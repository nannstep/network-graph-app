/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/graphology-utils/is-graph.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */

/**
 * Checking the value is a graphology instance.
 *
 * @param  {any}     value - Target value.
 * @return {boolean}
 */
module.exports = function isGraph(value) {
  return (
    value !== null &&
    typeof value === 'object' &&
    typeof value.addUndirectedEdgeWithKey === 'function' &&
    typeof value.dropNode === 'function' &&
    typeof value.multi === 'boolean'
  );
};


/***/ }),

/***/ "./node_modules/graphology/dist/graphology.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirectedGraph: () => (/* binding */ DirectedGraph),
/* harmony export */   Graph: () => (/* binding */ Graph),
/* harmony export */   InvalidArgumentsGraphError: () => (/* binding */ InvalidArgumentsGraphError),
/* harmony export */   MultiDirectedGraph: () => (/* binding */ MultiDirectedGraph),
/* harmony export */   MultiGraph: () => (/* binding */ MultiGraph),
/* harmony export */   MultiUndirectedGraph: () => (/* binding */ MultiUndirectedGraph),
/* harmony export */   NotFoundGraphError: () => (/* binding */ NotFoundGraphError),
/* harmony export */   UndirectedGraph: () => (/* binding */ UndirectedGraph),
/* harmony export */   UsageGraphError: () => (/* binding */ UsageGraphError),
/* harmony export */   "default": () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");


/**
 * Graphology Utilities
 * =====================
 *
 * Collection of helpful functions used by the implementation.
 */

/**
 * Object.assign-like polyfill.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
function assignPolyfill() {
  const target = arguments[0];

  for (let i = 1, l = arguments.length; i < l; i++) {
    if (!arguments[i]) continue;

    for (const k in arguments[i]) target[k] = arguments[i][k];
  }

  return target;
}

let assign = assignPolyfill;

if (typeof Object.assign === 'function') assign = Object.assign;

/**
 * Function returning the first matching edge for given path.
 * Note: this function does not check the existence of source & target. This
 * must be performed by the caller.
 *
 * @param  {Graph}  graph  - Target graph.
 * @param  {any}    source - Source node.
 * @param  {any}    target - Target node.
 * @param  {string} type   - Type of the edge (mixed, directed or undirected).
 * @return {string|null}
 */
function getMatchingEdge(graph, source, target, type) {
  const sourceData = graph._nodes.get(source);

  let edge = null;

  if (!sourceData) return edge;

  if (type === 'mixed') {
    edge =
      (sourceData.out && sourceData.out[target]) ||
      (sourceData.undirected && sourceData.undirected[target]);
  } else if (type === 'directed') {
    edge = sourceData.out && sourceData.out[target];
  } else {
    edge = sourceData.undirected && sourceData.undirected[target];
  }

  return edge;
}

/**
 * Checks whether the given value is a plain object.
 *
 * @param  {mixed}   value - Target value.
 * @return {boolean}
 */
function isPlainObject(value) {
  // NOTE: as per https://github.com/graphology/graphology/issues/149
  // this function has been loosened not to reject object instances
  // coming from other JavaScript contexts. It has also been chosen
  // not to improve it to avoid obvious false positives and avoid
  // taking a performance hit. People should really use TypeScript
  // if they want to avoid feeding subtly irrelvant attribute objects.
  return typeof value === 'object' && value !== null;
}

/**
 * Checks whether the given object is empty.
 *
 * @param  {object}  o - Target Object.
 * @return {boolean}
 */
function isEmpty(o) {
  let k;

  for (k in o) return false;

  return true;
}

/**
 * Creates a "private" property for the given member name by concealing it
 * using the `enumerable` option.
 *
 * @param {object} target - Target object.
 * @param {string} name   - Member name.
 */
function privateProperty(target, name, value) {
  Object.defineProperty(target, name, {
    enumerable: false,
    configurable: false,
    writable: true,
    value
  });
}

/**
 * Creates a read-only property for the given member name & the given getter.
 *
 * @param {object}   target - Target object.
 * @param {string}   name   - Member name.
 * @param {mixed}    value  - The attached getter or fixed value.
 */
function readOnlyProperty(target, name, value) {
  const descriptor = {
    enumerable: true,
    configurable: true
  };

  if (typeof value === 'function') {
    descriptor.get = value;
  } else {
    descriptor.value = value;
    descriptor.writable = false;
  }

  Object.defineProperty(target, name, descriptor);
}

/**
 * Returns whether the given object constitute valid hints.
 *
 * @param {object} hints - Target object.
 */
function validateHints(hints) {
  if (!isPlainObject(hints)) return false;

  if (hints.attributes && !Array.isArray(hints.attributes)) return false;

  return true;
}

/**
 * Creates a function generating incremental ids for edges.
 *
 * @return {function}
 */
function incrementalIdStartingFromRandomByte() {
  let i = Math.floor(Math.random() * 256) & 0xff;

  return () => {
    return i++;
  };
}

/**
 * Chains multiple iterators into a single iterator.
 *
 * @param {...Iterator} iterables
 * @returns {Iterator}
 */
function chain() {
  const iterables = arguments;
  let current = null;
  let i = -1;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step = null;

      do {
        if (current === null) {
          i++;
          if (i >= iterables.length) return {done: true};
          current = iterables[i][Symbol.iterator]();
        }
        step = current.next();
        if (step.done) {
          current = null;
          continue;
        }
        break;
        // eslint-disable-next-line no-constant-condition
      } while (true);

      return step;
    }
  };
}

function emptyIterator() {
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      return {done: true};
    }
  };
}

/**
 * Graphology Custom Errors
 * =========================
 *
 * Defining custom errors for ease of use & easy unit tests across
 * implementations (normalized typology rather than relying on error
 * messages to check whether the correct error was found).
 */
class GraphError extends Error {
  constructor(message) {
    super();
    this.name = 'GraphError';
    this.message = message;
  }
}

class InvalidArgumentsGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'InvalidArgumentsGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(
        this,
        InvalidArgumentsGraphError.prototype.constructor
      );
  }
}

class NotFoundGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'NotFoundGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
  }
}

class UsageGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'UsageGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
  }
}

/**
 * Graphology Internal Data Classes
 * =================================
 *
 * Internal classes hopefully reduced to structs by engines & storing
 * necessary information for nodes & edges.
 *
 * Note that those classes don't rely on the `class` keyword to avoid some
 * cruft introduced by most of ES2015 transpilers.
 */

/**
 * MixedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function MixedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

MixedNodeData.prototype.clear = function () {
  // Degrees
  this.inDegree = 0;
  this.outDegree = 0;
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;
  this.directedLoops = 0;

  // Indices
  this.in = {};
  this.out = {};
  this.undirected = {};
};

/**
 * DirectedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function DirectedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

DirectedNodeData.prototype.clear = function () {
  // Degrees
  this.inDegree = 0;
  this.outDegree = 0;
  this.directedLoops = 0;

  // Indices
  this.in = {};
  this.out = {};
};

/**
 * UndirectedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function UndirectedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

UndirectedNodeData.prototype.clear = function () {
  // Degrees
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;

  // Indices
  this.undirected = {};
};

/**
 * EdgeData class.
 *
 * @constructor
 * @param {boolean} undirected   - Whether the edge is undirected.
 * @param {string}  string       - The edge's key.
 * @param {string}  source       - Source of the edge.
 * @param {string}  target       - Target of the edge.
 * @param {object}  attributes   - Edge's attributes.
 */
function EdgeData(undirected, key, source, target, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;
  this.undirected = undirected;

  // Extremities
  this.source = source;
  this.target = target;
}

EdgeData.prototype.attach = function () {
  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  const source = this.source.key;
  const target = this.target.key;

  // Handling source
  this.source[outKey][target] = this;

  if (this.undirected && source === target) return;

  // Handling target
  this.target[inKey][source] = this;
};

EdgeData.prototype.attachMulti = function () {
  let outKey = 'out';
  let inKey = 'in';

  const source = this.source.key;
  const target = this.target.key;

  if (this.undirected) outKey = inKey = 'undirected';

  // Handling source
  const adj = this.source[outKey];
  const head = adj[target];

  if (typeof head === 'undefined') {
    adj[target] = this;

    // Self-loop optimization
    if (!(this.undirected && source === target)) {
      // Handling target
      this.target[inKey][source] = this;
    }

    return;
  }

  // Prepending to doubly-linked list
  head.previous = this;
  this.next = head;

  // Pointing to new head
  // NOTE: use mutating swap later to avoid lookup?
  adj[target] = this;
  this.target[inKey][source] = this;
};

EdgeData.prototype.detach = function () {
  const source = this.source.key;
  const target = this.target.key;

  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  delete this.source[outKey][target];

  // No-op delete in case of undirected self-loop
  delete this.target[inKey][source];
};

EdgeData.prototype.detachMulti = function () {
  const source = this.source.key;
  const target = this.target.key;

  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  // Deleting from doubly-linked list
  if (this.previous === undefined) {
    // We are dealing with the head

    // Should we delete the adjacency entry because it is now empty?
    if (this.next === undefined) {
      delete this.source[outKey][target];

      // No-op delete in case of undirected self-loop
      delete this.target[inKey][source];
    } else {
      // Detaching
      this.next.previous = undefined;

      // NOTE: could avoid the lookups by creating a #.become mutating method
      this.source[outKey][target] = this.next;

      // No-op delete in case of undirected self-loop
      this.target[inKey][source] = this.next;
    }
  } else {
    // We are dealing with another list node
    this.previous.next = this.next;

    // If not last
    if (this.next !== undefined) {
      this.next.previous = this.previous;
    }
  }
};

/**
 * Graphology Node Attributes methods
 * ===================================
 */

const NODE = 0;
const SOURCE = 1;
const TARGET = 2;
const OPPOSITE = 3;

function findRelevantNodeData(
  graph,
  method,
  mode,
  nodeOrEdge,
  nameOrEdge,
  add1,
  add2
) {
  let nodeData, edgeData, arg1, arg2;

  nodeOrEdge = '' + nodeOrEdge;

  if (mode === NODE) {
    nodeData = graph._nodes.get(nodeOrEdge);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nodeOrEdge}" node in the graph.`
      );

    arg1 = nameOrEdge;
    arg2 = add1;
  } else if (mode === OPPOSITE) {
    nameOrEdge = '' + nameOrEdge;

    edgeData = graph._edges.get(nameOrEdge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nameOrEdge}" edge in the graph.`
      );

    const source = edgeData.source.key;
    const target = edgeData.target.key;

    if (nodeOrEdge === source) {
      nodeData = edgeData.target;
    } else if (nodeOrEdge === target) {
      nodeData = edgeData.source;
    } else {
      throw new NotFoundGraphError(
        `Graph.${method}: the "${nodeOrEdge}" node is not attached to the "${nameOrEdge}" edge (${source}, ${target}).`
      );
    }

    arg1 = add1;
    arg2 = add2;
  } else {
    edgeData = graph._edges.get(nodeOrEdge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nodeOrEdge}" edge in the graph.`
      );

    if (mode === SOURCE) {
      nodeData = edgeData.source;
    } else {
      nodeData = edgeData.target;
    }

    arg1 = nameOrEdge;
    arg2 = add1;
  }

  return [nodeData, arg1, arg2];
}

function attachNodeAttributeGetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    return data.attributes[name];
  };
}

function attachNodeAttributesGetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {
    const [data] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge
    );

    return data.attributes;
  };
}

function attachNodeAttributeChecker(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    return data.attributes.hasOwnProperty(name);
  };
}

function attachNodeAttributeSetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, value] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1,
      add2
    );

    data.attributes[name] = value;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributeUpdater(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, updater] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1,
      add2
    );

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: updater should be a function.`
      );

    const attributes = data.attributes;
    const value = updater(attributes[name]);

    attributes[name] = value;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributeRemover(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    delete data.attributes[name];

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'remove',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributesReplacer(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    data.attributes = attributes;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'replace',
      attributes: data.attributes
    });

    return this;
  };
}

function attachNodeAttributesMerger(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    assign(data.attributes, attributes);

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'merge',
      attributes: data.attributes,
      data: attributes
    });

    return this;
  };
}

function attachNodeAttributesUpdater(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, updater] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided updater is not a function.`
      );

    data.attributes = updater(data.attributes);

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'update',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * List of methods to attach.
 */
const NODE_ATTRIBUTES_METHODS = [
  {
    name: element => `get${element}Attribute`,
    attacher: attachNodeAttributeGetter
  },
  {
    name: element => `get${element}Attributes`,
    attacher: attachNodeAttributesGetter
  },
  {
    name: element => `has${element}Attribute`,
    attacher: attachNodeAttributeChecker
  },
  {
    name: element => `set${element}Attribute`,
    attacher: attachNodeAttributeSetter
  },
  {
    name: element => `update${element}Attribute`,
    attacher: attachNodeAttributeUpdater
  },
  {
    name: element => `remove${element}Attribute`,
    attacher: attachNodeAttributeRemover
  },
  {
    name: element => `replace${element}Attributes`,
    attacher: attachNodeAttributesReplacer
  },
  {
    name: element => `merge${element}Attributes`,
    attacher: attachNodeAttributesMerger
  },
  {
    name: element => `update${element}Attributes`,
    attacher: attachNodeAttributesUpdater
  }
];

/**
 * Attach every attributes-related methods to a Graph class.
 *
 * @param {function} Graph - Target class.
 */
function attachNodeAttributesMethods(Graph) {
  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
    // For nodes
    attacher(Graph, name('Node'), NODE);

    // For sources
    attacher(Graph, name('Source'), SOURCE);

    // For targets
    attacher(Graph, name('Target'), TARGET);

    // For opposites
    attacher(Graph, name('Opposite'), OPPOSITE);
  });
}

/**
 * Graphology Edge Attributes methods
 * ===================================
 */

/**
 * Attach an attribute getter method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeGetter(Class, method, type) {
  /**
   * Get the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {mixed}          - The attribute's value.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes[name];
  };
}

/**
 * Attach an attributes getter method onto the provided class.
 *
 * @param {function} Class       - Target class.
 * @param {string}   method      - Method name.
 * @param {string}   type        - Type of the edge to find.
 */
function attachEdgeAttributesGetter(Class, method, type) {
  /**
   * Retrieves all the target element's attributes.
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   *
   * @return {object}          - The element's attributes.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 1) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + arguments[1];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes;
  };
}

/**
 * Attach an attribute checker method onto the provided class.
 *
 * @param {function} Class       - Target class.
 * @param {string}   method      - Method name.
 * @param {string}   type        - Type of the edge to find.
 */
function attachEdgeAttributeChecker(Class, method, type) {
  /**
   * Checks whether the desired attribute is set for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes.hasOwnProperty(name);
  };
}

/**
 * Attach an attribute setter method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeSetter(Class, method, type) {
  /**
   * Set the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   * @param  {mixed}  value   - New attribute value.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   * @param  {mixed}  value   - New attribute value.
   *
   * @return {Graph}          - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name, value) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];
      value = arguments[3];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    data.attributes[name] = value;

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute updater method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeUpdater(Class, method, type) {
  /**
   * Update the desired attribute for the given element (node or edge) using
   * the provided function.
   *
   * Arity 2:
   * @param  {any}      element - Target element.
   * @param  {string}   name    - Attribute's name.
   * @param  {function} updater - Updater function.
   *
   * Arity 3 (only for edges):
   * @param  {any}      source  - Source element.
   * @param  {any}      target  - Target element.
   * @param  {string}   name    - Attribute's name.
   * @param  {function} updater - Updater function.
   *
   * @return {Graph}            - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name, updater) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];
      updater = arguments[3];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: updater should be a function.`
      );

    data.attributes[name] = updater(data.attributes[name]);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute remover method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeRemover(Class, method, type) {
  /**
   * Remove the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {Graph}          - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    delete data.attributes[name];

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'remove',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute replacer method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesReplacer(Class, method, type) {
  /**
   * Replace the attributes for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element    - Target element.
   * @param  {object} attributes - New attributes.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source     - Source element.
   * @param  {any}     target     - Target element.
   * @param  {object}  attributes - New attributes.
   *
   * @return {Graph}              - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, attributes) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + attributes;

      attributes = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    data.attributes = attributes;

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'replace',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * Attach an attribute merger method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesMerger(Class, method, type) {
  /**
   * Merge the attributes for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element    - Target element.
   * @param  {object} attributes - Attributes to merge.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source     - Source element.
   * @param  {any}     target     - Target element.
   * @param  {object}  attributes - Attributes to merge.
   *
   * @return {Graph}              - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, attributes) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + attributes;

      attributes = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    assign(data.attributes, attributes);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'merge',
      attributes: data.attributes,
      data: attributes
    });

    return this;
  };
}

/**
 * Attach an attribute updater method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesUpdater(Class, method, type) {
  /**
   * Update the attributes of the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}      element - Target element.
   * @param  {function} updater - Updater function.
   *
   * Arity 3 (only for edges):
   * @param  {any}      source  - Source element.
   * @param  {any}      target  - Target element.
   * @param  {function} updater - Updater function.
   *
   * @return {Graph}            - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, updater) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + updater;

      updater = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided updater is not a function.`
      );

    data.attributes = updater(data.attributes);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'update',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * List of methods to attach.
 */
const EDGE_ATTRIBUTES_METHODS = [
  {
    name: element => `get${element}Attribute`,
    attacher: attachEdgeAttributeGetter
  },
  {
    name: element => `get${element}Attributes`,
    attacher: attachEdgeAttributesGetter
  },
  {
    name: element => `has${element}Attribute`,
    attacher: attachEdgeAttributeChecker
  },
  {
    name: element => `set${element}Attribute`,
    attacher: attachEdgeAttributeSetter
  },
  {
    name: element => `update${element}Attribute`,
    attacher: attachEdgeAttributeUpdater
  },
  {
    name: element => `remove${element}Attribute`,
    attacher: attachEdgeAttributeRemover
  },
  {
    name: element => `replace${element}Attributes`,
    attacher: attachEdgeAttributesReplacer
  },
  {
    name: element => `merge${element}Attributes`,
    attacher: attachEdgeAttributesMerger
  },
  {
    name: element => `update${element}Attributes`,
    attacher: attachEdgeAttributesUpdater
  }
];

/**
 * Attach every attributes-related methods to a Graph class.
 *
 * @param {function} Graph - Target class.
 */
function attachEdgeAttributesMethods(Graph) {
  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
    // For edges
    attacher(Graph, name('Edge'), 'mixed');

    // For directed edges
    attacher(Graph, name('DirectedEdge'), 'directed');

    // For undirected edges
    attacher(Graph, name('UndirectedEdge'), 'undirected');
  });
}

/**
 * Graphology Edge Iteration
 * ==========================
 *
 * Attaching some methods to the Graph class to be able to iterate over a
 * graph's edges.
 */

/**
 * Definitions.
 */
const EDGES_ITERATION = [
  {
    name: 'edges',
    type: 'mixed'
  },
  {
    name: 'inEdges',
    type: 'directed',
    direction: 'in'
  },
  {
    name: 'outEdges',
    type: 'directed',
    direction: 'out'
  },
  {
    name: 'inboundEdges',
    type: 'mixed',
    direction: 'in'
  },
  {
    name: 'outboundEdges',
    type: 'mixed',
    direction: 'out'
  },
  {
    name: 'directedEdges',
    type: 'directed'
  },
  {
    name: 'undirectedEdges',
    type: 'undirected'
  }
];

/**
 * Function iterating over edges from the given object to match one of them.
 *
 * @param {object}   object   - Target object.
 * @param {function} callback - Function to call.
 */
function forEachSimple(breakable, object, callback, avoid) {
  let shouldBreak = false;

  for (const k in object) {
    if (k === avoid) continue;

    const edgeData = object[k];

    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected
    );

    if (breakable && shouldBreak) return edgeData.key;
  }

  return;
}

function forEachMulti(breakable, object, callback, avoid) {
  let edgeData, source, target;

  let shouldBreak = false;

  for (const k in object) {
    if (k === avoid) continue;

    edgeData = object[k];

    do {
      source = edgeData.source;
      target = edgeData.target;

      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        source.key,
        target.key,
        source.attributes,
        target.attributes,
        edgeData.undirected
      );

      if (breakable && shouldBreak) return edgeData.key;

      edgeData = edgeData.next;
    } while (edgeData !== undefined);
  }

  return;
}

/**
 * Function returning an iterator over edges from the given object.
 *
 * @param  {object}   object - Target object.
 * @return {Iterator}
 */
function createIterator(object, avoid) {
  const keys = Object.keys(object);
  const l = keys.length;

  let edgeData;
  let i = 0;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      do {
        if (!edgeData) {
          if (i >= l) return {done: true};

          const k = keys[i++];

          if (k === avoid) {
            edgeData = undefined;
            continue;
          }

          edgeData = object[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);

      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}

/**
 * Function iterating over the egdes from the object at given key to match
 * one of them.
 *
 * @param {object}   object   - Target object.
 * @param {mixed}    k        - Neighbor key.
 * @param {function} callback - Callback to use.
 */
function forEachForKeySimple(breakable, object, k, callback) {
  const edgeData = object[k];

  if (!edgeData) return;

  const sourceData = edgeData.source;
  const targetData = edgeData.target;

  if (
    callback(
      edgeData.key,
      edgeData.attributes,
      sourceData.key,
      targetData.key,
      sourceData.attributes,
      targetData.attributes,
      edgeData.undirected
    ) &&
    breakable
  )
    return edgeData.key;
}

function forEachForKeyMulti(breakable, object, k, callback) {
  let edgeData = object[k];

  if (!edgeData) return;

  let shouldBreak = false;

  do {
    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected
    );

    if (breakable && shouldBreak) return edgeData.key;

    edgeData = edgeData.next;
  } while (edgeData !== undefined);

  return;
}

/**
 * Function returning an iterator over the egdes from the object at given key.
 *
 * @param  {object}   object   - Target object.
 * @param  {mixed}    k        - Neighbor key.
 * @return {Iterator}
 */
function createIteratorForKey(object, k) {
  let edgeData = object[k];

  if (edgeData.next !== undefined) {
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        if (!edgeData) return {done: true};

        const value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };

        edgeData = edgeData.next;

        return {
          done: false,
          value
        };
      }
    };
  }

  let done = false;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (done === true) return {done: true};
      done = true;
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}

/**
 * Function creating an array of edges for the given type.
 *
 * @param  {Graph}   graph - Target Graph instance.
 * @param  {string}  type  - Type of edges to retrieve.
 * @return {array}         - Array of edges.
 */
function createEdgeArray(graph, type) {
  if (graph.size === 0) return [];

  if (type === 'mixed' || type === graph.type) {
    return Array.from(graph._edges.keys());
  }

  const size =
    type === 'undirected' ? graph.undirectedSize : graph.directedSize;

  const list = new Array(size),
    mask = type === 'undirected';

  const iterator = graph._edges.values();

  let i = 0;
  let step, data;

  while (((step = iterator.next()), step.done !== true)) {
    data = step.value;

    if (data.undirected === mask) list[i++] = data.key;
  }

  return list;
}

/**
 * Function iterating over a graph's edges using a callback to match one of
 * them.
 *
 * @param  {Graph}    graph    - Target Graph instance.
 * @param  {string}   type     - Type of edges to retrieve.
 * @param  {function} callback - Function to call.
 */
function forEachEdge(breakable, graph, type, callback) {
  if (graph.size === 0) return;

  const shouldFilter = type !== 'mixed' && type !== graph.type;
  const mask = type === 'undirected';

  let step, data;
  let shouldBreak = false;
  const iterator = graph._edges.values();

  while (((step = iterator.next()), step.done !== true)) {
    data = step.value;

    if (shouldFilter && data.undirected !== mask) continue;

    const {key, attributes, source, target} = data;

    shouldBreak = callback(
      key,
      attributes,
      source.key,
      target.key,
      source.attributes,
      target.attributes,
      data.undirected
    );

    if (breakable && shouldBreak) return key;
  }

  return;
}

/**
 * Function creating an iterator of edges for the given type.
 *
 * @param  {Graph}    graph - Target Graph instance.
 * @param  {string}   type  - Type of edges to retrieve.
 * @return {Iterator}
 */
function createEdgeIterator(graph, type) {
  if (graph.size === 0) return emptyIterator();

  const shouldFilter = type !== 'mixed' && type !== graph.type;
  const mask = type === 'undirected';

  const iterator = graph._edges.values();

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step, data;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        step = iterator.next();

        if (step.done) return step;

        data = step.value;

        if (shouldFilter && data.undirected !== mask) continue;

        break;
      }

      const value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };

      return {value, done: false};
    }
  };
}

/**
 * Function iterating over a node's edges using a callback to match one of them.
 *
 * @param  {boolean}  multi     - Whether the graph is multi or not.
 * @param  {string}   type      - Type of edges to retrieve.
 * @param  {string}   direction - In or out?
 * @param  {any}      nodeData  - Target node's data.
 * @param  {function} callback  - Function to call.
 */
function forEachEdgeForNode(
  breakable,
  multi,
  type,
  direction,
  nodeData,
  callback
) {
  const fn = multi ? forEachMulti : forEachSimple;

  let found;

  if (type !== 'undirected') {
    if (direction !== 'out') {
      found = fn(breakable, nodeData.in, callback);

      if (breakable && found) return found;
    }
    if (direction !== 'in') {
      found = fn(
        breakable,
        nodeData.out,
        callback,
        !direction ? nodeData.key : undefined
      );

      if (breakable && found) return found;
    }
  }

  if (type !== 'directed') {
    found = fn(breakable, nodeData.undirected, callback);

    if (breakable && found) return found;
  }

  return;
}

/**
 * Function creating an array of edges for the given type & the given node.
 *
 * @param  {boolean} multi     - Whether the graph is multi or not.
 * @param  {string}  type      - Type of edges to retrieve.
 * @param  {string}  direction - In or out?
 * @param  {any}     nodeData  - Target node's data.
 * @return {array}             - Array of edges.
 */
function createEdgeArrayForNode(multi, type, direction, nodeData) {
  const edges = []; // TODO: possibility to know size beforehand or factorize with map

  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {
    edges.push(key);
  });

  return edges;
}

/**
 * Function iterating over a node's edges using a callback.
 *
 * @param  {string}   type      - Type of edges to retrieve.
 * @param  {string}   direction - In or out?
 * @param  {any}      nodeData  - Target node's data.
 * @return {Iterator}
 */
function createEdgeIteratorForNode(type, direction, nodeData) {
  let iterator = emptyIterator();

  if (type !== 'undirected') {
    if (direction !== 'out' && typeof nodeData.in !== 'undefined')
      iterator = chain(iterator, createIterator(nodeData.in));
    if (direction !== 'in' && typeof nodeData.out !== 'undefined')
      iterator = chain(
        iterator,
        createIterator(nodeData.out, !direction ? nodeData.key : undefined)
      );
  }

  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
    iterator = chain(iterator, createIterator(nodeData.undirected));
  }

  return iterator;
}

/**
 * Function iterating over edges for the given path using a callback to match
 * one of them.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {boolean}  multi      - Whether the graph is multi.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {string}   target     - Target node.
 * @param  {function} callback   - Function to call.
 */
function forEachEdgeForPath(
  breakable,
  type,
  multi,
  direction,
  sourceData,
  target,
  callback
) {
  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;

  let found;

  if (type !== 'undirected') {
    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {
      found = fn(breakable, sourceData.in, target, callback);

      if (breakable && found) return found;
    }

    if (
      typeof sourceData.out !== 'undefined' &&
      direction !== 'in' &&
      (direction || sourceData.key !== target)
    ) {
      found = fn(breakable, sourceData.out, target, callback);

      if (breakable && found) return found;
    }
  }

  if (type !== 'directed') {
    if (typeof sourceData.undirected !== 'undefined') {
      found = fn(breakable, sourceData.undirected, target, callback);

      if (breakable && found) return found;
    }
  }

  return;
}

/**
 * Function creating an array of edges for the given path.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {boolean}  multi      - Whether the graph is multi.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {any}      target     - Target node.
 * @return {array}               - Array of edges.
 */
function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
  const edges = []; // TODO: possibility to know size beforehand or factorize with map

  forEachEdgeForPath(
    false,
    type,
    multi,
    direction,
    sourceData,
    target,
    function (key) {
      edges.push(key);
    }
  );

  return edges;
}

/**
 * Function returning an iterator over edges for the given path.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {string}   target     - Target node.
 * @param  {function} callback   - Function to call.
 */
function createEdgeIteratorForPath(type, direction, sourceData, target) {
  let iterator = emptyIterator();

  if (type !== 'undirected') {
    if (
      typeof sourceData.in !== 'undefined' &&
      direction !== 'out' &&
      target in sourceData.in
    )
      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));

    if (
      typeof sourceData.out !== 'undefined' &&
      direction !== 'in' &&
      target in sourceData.out &&
      (direction || sourceData.key !== target)
    )
      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));
  }

  if (type !== 'directed') {
    if (
      typeof sourceData.undirected !== 'undefined' &&
      target in sourceData.undirected
    )
      iterator = chain(
        iterator,
        createIteratorForKey(sourceData.undirected, target)
      );
  }

  return iterator;
}

/**
 * Function attaching an edge array creator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeArrayCreator(Class, description) {
  const {name, type, direction} = description;

  /**
   * Function returning an array of certain edges.
   *
   * Arity 0: Return all the relevant edges.
   *
   * Arity 1: Return all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 2: Return the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[name] = function (source, target) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return [];

    if (!arguments.length) return createEdgeArray(this, type);

    if (arguments.length === 1) {
      source = '' + source;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${name}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      return createEdgeArrayForNode(
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData
      );
    }

    if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return createEdgeArrayForPath(
        type,
        this.multi,
        direction,
        sourceData,
        target
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
    );
  };
}

/**
 * Function attaching a edge callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachForEachEdge(Class, description) {
  const {name, type, direction} = description;

  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over the graph's relevant edges by applying the given
   * callback.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[forEachName] = function (source, target, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(false, this, type, callback);
    }

    if (arguments.length === 2) {
      source = '' + source;
      callback = target;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${forEachName}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      // TODO: maybe attach the sub method to the instance dynamically?
      return forEachEdgeForNode(
        false,
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }

    if (arguments.length === 3) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${forEachName}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${forEachName}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return forEachEdgeForPath(
        false,
        type,
        this.multi,
        direction,
        sourceData,
        target,
        callback
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
    );
  };

  /**
   * Function mapping the graph's relevant edges by applying the given
   * callback.
   *
   * Arity 1: Map all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Map all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Map the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[mapName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    let result;

    // We know the result length beforehand
    if (args.length === 0) {
      let length = 0;

      if (type !== 'directed') length += this.undirectedSize;
      if (type !== 'undirected') length += this.directedSize;

      result = new Array(length);

      let i = 0;

      args.push((e, ea, s, t, sa, ta, u) => {
        result[i++] = callback(e, ea, s, t, sa, ta, u);
      });
    }

    // We don't know the result length beforehand
    // TODO: we can in some instances of simple graphs, knowing degree
    else {
      result = [];

      args.push((e, ea, s, t, sa, ta, u) => {
        result.push(callback(e, ea, s, t, sa, ta, u));
      });
    }

    this[forEachName].apply(this, args);

    return result;
  };

  /**
   * Function filtering the graph's relevant edges using the provided predicate
   * function.
   *
   * Arity 1: Filter all the relevant edges.
   * @param  {function} predicate - Predicate to use.
   *
   * Arity 2: Filter all of a node's relevant edges.
   * @param  {any}      node      - Target node.
   * @param  {function} predicate - Predicate to use.
   *
   * Arity 3: Filter the relevant edges across the given path.
   * @param  {any}      source    - Source node.
   * @param  {any}      target    - Target node.
   * @param  {function} predicate - Predicate to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[filterName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    const result = [];

    args.push((e, ea, s, t, sa, ta, u) => {
      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);
    });

    this[forEachName].apply(this, args);

    return result;
  };

  /**
   * Function reducing the graph's relevant edges using the provided accumulator
   * function.
   *
   * Arity 1: Reduce all the relevant edges.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * Arity 2: Reduce all of a node's relevant edges.
   * @param  {any}      node         - Target node.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * Arity 3: Reduce the relevant edges across the given path.
   * @param  {any}      source       - Source node.
   * @param  {any}      target       - Target node.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[reduceName] = function () {
    let args = Array.prototype.slice.call(arguments);

    if (args.length < 2 || args.length > 4) {
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`
      );
    }

    if (
      typeof args[args.length - 1] === 'function' &&
      typeof args[args.length - 2] !== 'function'
    ) {
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
      );
    }

    let callback;
    let initialValue;

    if (args.length === 2) {
      callback = args[0];
      initialValue = args[1];
      args = [];
    } else if (args.length === 3) {
      callback = args[1];
      initialValue = args[2];
      args = [args[0]];
    } else if (args.length === 4) {
      callback = args[2];
      initialValue = args[3];
      args = [args[0], args[1]];
    }

    let accumulator = initialValue;

    args.push((e, ea, s, t, sa, ta, u) => {
      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);
    });

    this[forEachName].apply(this, args);

    return accumulator;
  };
}

/**
 * Function attaching a breakable edge callback iterator method to the Graph
 * prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachFindEdge(Class, description) {
  const {name, type, direction} = description;

  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over the graph's relevant edges in order to match
   * one of them using the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[findEdgeName] = function (source, target, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return false;

    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(true, this, type, callback);
    }

    if (arguments.length === 2) {
      source = '' + source;
      callback = target;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      // TODO: maybe attach the sub method to the instance dynamically?
      return forEachEdgeForNode(
        true,
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }

    if (arguments.length === 3) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return forEachEdgeForPath(
        true,
        type,
        this.multi,
        direction,
        sourceData,
        target,
        callback
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
    );
  };

  /**
   * Function iterating over the graph's relevant edges in order to assert
   * whether any one of them matches the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);

  Class.prototype[someName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    args.push((e, ea, s, t, sa, ta, u) => {
      return callback(e, ea, s, t, sa, ta, u);
    });

    const found = this[findEdgeName].apply(this, args);

    if (found) return true;

    return false;
  };

  /**
   * Function iterating over the graph's relevant edges in order to assert
   * whether all of them matche the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);

  Class.prototype[everyName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    args.push((e, ea, s, t, sa, ta, u) => {
      return !callback(e, ea, s, t, sa, ta, u);
    });

    const found = this[findEdgeName].apply(this, args);

    if (found) return false;

    return true;
  };
}

/**
 * Function attaching an edge iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeIteratorCreator(Class, description) {
  const {name: originalName, type, direction} = description;

  const name = originalName.slice(0, -1) + 'Entries';

  /**
   * Function returning an iterator over the graph's edges.
   *
   * Arity 0: Iterate over all the relevant edges.
   *
   * Arity 1: Iterate over all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 2: Iterate over the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[name] = function (source, target) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return emptyIterator();

    if (!arguments.length) return createEdgeIterator(this, type);

    if (arguments.length === 1) {
      source = '' + source;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      return createEdgeIteratorForNode(type, direction, sourceData);
    }

    if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return createEdgeIteratorForPath(type, direction, sourceData, target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
    );
  };
}

/**
 * Function attaching every edge iteration method to the Graph class.
 *
 * @param {function} Graph - Graph class.
 */
function attachEdgeIterationMethods(Graph) {
  EDGES_ITERATION.forEach(description => {
    attachEdgeArrayCreator(Graph, description);
    attachForEachEdge(Graph, description);
    attachFindEdge(Graph, description);
    attachEdgeIteratorCreator(Graph, description);
  });
}

/**
 * Graphology Neighbor Iteration
 * ==============================
 *
 * Attaching some methods to the Graph class to be able to iterate over
 * neighbors.
 */

/**
 * Definitions.
 */
const NEIGHBORS_ITERATION = [
  {
    name: 'neighbors',
    type: 'mixed'
  },
  {
    name: 'inNeighbors',
    type: 'directed',
    direction: 'in'
  },
  {
    name: 'outNeighbors',
    type: 'directed',
    direction: 'out'
  },
  {
    name: 'inboundNeighbors',
    type: 'mixed',
    direction: 'in'
  },
  {
    name: 'outboundNeighbors',
    type: 'mixed',
    direction: 'out'
  },
  {
    name: 'directedNeighbors',
    type: 'directed'
  },
  {
    name: 'undirectedNeighbors',
    type: 'undirected'
  }
];

/**
 * Helpers.
 */
function CompositeSetWrapper() {
  this.A = null;
  this.B = null;
}

CompositeSetWrapper.prototype.wrap = function (set) {
  if (this.A === null) this.A = set;
  else if (this.B === null) this.B = set;
};

CompositeSetWrapper.prototype.has = function (key) {
  if (this.A !== null && key in this.A) return true;
  if (this.B !== null && key in this.B) return true;
  return false;
};

/**
 * Function iterating over the given node's relevant neighbors to match
 * one of them using a predicated function.
 *
 * @param  {string}   type      - Type of neighbors.
 * @param  {string}   direction - Direction.
 * @param  {any}      nodeData  - Target node's data.
 * @param  {function} callback  - Callback to use.
 */
function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
  for (const k in object) {
    const edgeData = object[k];

    const sourceData = edgeData.source;
    const targetData = edgeData.target;

    const neighborData = sourceData === nodeData ? targetData : sourceData;

    if (visited && visited.has(neighborData.key)) continue;

    const shouldBreak = callback(neighborData.key, neighborData.attributes);

    if (breakable && shouldBreak) return neighborData.key;
  }

  return;
}

function forEachNeighbor(breakable, type, direction, nodeData, callback) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected')
      return forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData.undirected,
        callback
      );

    if (typeof direction === 'string')
      return forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData[direction],
        callback
      );
  }

  // Else we need to keep a set of neighbors not to return duplicates
  // We cheat by querying the other adjacencies
  const visited = new CompositeSetWrapper();

  let found;

  if (type !== 'undirected') {
    if (direction !== 'out') {
      found = forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData.in,
        callback
      );

      if (breakable && found) return found;

      visited.wrap(nodeData.in);
    }
    if (direction !== 'in') {
      found = forEachInObjectOnce(
        breakable,
        visited,
        nodeData,
        nodeData.out,
        callback
      );

      if (breakable && found) return found;

      visited.wrap(nodeData.out);
    }
  }

  if (type !== 'directed') {
    found = forEachInObjectOnce(
      breakable,
      visited,
      nodeData,
      nodeData.undirected,
      callback
    );

    if (breakable && found) return found;
  }

  return;
}

/**
 * Function creating an array of relevant neighbors for the given node.
 *
 * @param  {string}       type      - Type of neighbors.
 * @param  {string}       direction - Direction.
 * @param  {any}          nodeData  - Target node's data.
 * @return {Array}                  - The list of neighbors.
 */
function createNeighborArrayForNode(type, direction, nodeData) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected') return Object.keys(nodeData.undirected);

    if (typeof direction === 'string') return Object.keys(nodeData[direction]);
  }

  const neighbors = [];

  forEachNeighbor(false, type, direction, nodeData, function (key) {
    neighbors.push(key);
  });

  return neighbors;
}

/**
 * Function returning an iterator over the given node's relevant neighbors.
 *
 * @param  {string}   type      - Type of neighbors.
 * @param  {string}   direction - Direction.
 * @param  {any}      nodeData  - Target node's data.
 * @return {Iterator}
 */
function createDedupedObjectIterator(visited, nodeData, object) {
  const keys = Object.keys(object);
  const l = keys.length;

  let i = 0;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let neighborData = null;

      do {
        if (i >= l) {
          if (visited) visited.wrap(object);
          return {done: true};
        }

        const edgeData = object[keys[i++]];

        const sourceData = edgeData.source;
        const targetData = edgeData.target;

        neighborData = sourceData === nodeData ? targetData : sourceData;

        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);

      return {
        done: false,
        value: {neighbor: neighborData.key, attributes: neighborData.attributes}
      };
    }
  };
}

function createNeighborIterator(type, direction, nodeData) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected')
      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);

    if (typeof direction === 'string')
      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
  }

  let iterator = emptyIterator();

  // Else we need to keep a set of neighbors not to return duplicates
  // We cheat by querying the other adjacencies
  const visited = new CompositeSetWrapper();

  if (type !== 'undirected') {
    if (direction !== 'out') {
      iterator = chain(
        iterator,
        createDedupedObjectIterator(visited, nodeData, nodeData.in)
      );
    }
    if (direction !== 'in') {
      iterator = chain(
        iterator,
        createDedupedObjectIterator(visited, nodeData, nodeData.out)
      );
    }
  }

  if (type !== 'directed') {
    iterator = chain(
      iterator,
      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)
    );
  }

  return iterator;
}

/**
 * Function attaching a neighbors array creator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachNeighborArrayCreator(Class, description) {
  const {name, type, direction} = description;

  /**
   * Function returning an array of certain neighbors.
   *
   * @param  {any}   node   - Target node.
   * @return {array} - The neighbors of neighbors.
   *
   * @throws {Error} - Will throw if node is not found in the graph.
   */
  Class.prototype[name] = function (node) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return [];

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${name}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return createNeighborArrayForNode(
      type === 'mixed' ? this.type : type,
      direction,
      nodeData
    );
  };
}

/**
 * Function attaching a neighbors callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachForEachNeighbor(Class, description) {
  const {name, type, direction} = description;

  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over all the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[forEachName] = function (node, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${forEachName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    forEachNeighbor(
      false,
      type === 'mixed' ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };

  /**
   * Function mapping the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[mapName] = function (node, callback) {
    // TODO: optimize when size is known beforehand
    const result = [];

    this[forEachName](node, (n, a) => {
      result.push(callback(n, a));
    });

    return result;
  };

  /**
   * Function filtering the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[filterName] = function (node, callback) {
    const result = [];

    this[forEachName](node, (n, a) => {
      if (callback(n, a)) result.push(n);
    });

    return result;
  };

  /**
   * Function reducing the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[reduceName] = function (node, callback, initialValue) {
    if (arguments.length < 3)
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
      );

    let accumulator = initialValue;

    this[forEachName](node, (n, a) => {
      accumulator = callback(accumulator, n, a);
    });

    return accumulator;
  };
}

/**
 * Function attaching a breakable neighbors callback iterator method to the
 * Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachFindNeighbor(Class, description) {
  const {name, type, direction} = description;

  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);

  const findName = 'find' + capitalizedSingular;

  /**
   * Function iterating over all the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[findName] = function (node, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${findName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return forEachNeighbor(
      true,
      type === 'mixed' ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };

  /**
   * Function iterating over all the relevant neighbors to find if any of them
   * matches the given predicate.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const someName = 'some' + capitalizedSingular;

  Class.prototype[someName] = function (node, callback) {
    const found = this[findName](node, callback);

    if (found) return true;

    return false;
  };

  /**
   * Function iterating over all the relevant neighbors to find if all of them
   * matche the given predicate.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const everyName = 'every' + capitalizedSingular;

  Class.prototype[everyName] = function (node, callback) {
    const found = this[findName](node, (n, a) => {
      return !callback(n, a);
    });

    if (found) return false;

    return true;
  };
}

/**
 * Function attaching a neighbors callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachNeighborIteratorCreator(Class, description) {
  const {name, type, direction} = description;

  const iteratorName = name.slice(0, -1) + 'Entries';

  /**
   * Function returning an iterator over all the relevant neighbors.
   *
   * @param  {any}      node     - Target node.
   * @return {Iterator}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[iteratorName] = function (node) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return emptyIterator();

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${iteratorName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return createNeighborIterator(
      type === 'mixed' ? this.type : type,
      direction,
      nodeData
    );
  };
}

/**
 * Function attaching every neighbor iteration method to the Graph class.
 *
 * @param {function} Graph - Graph class.
 */
function attachNeighborIterationMethods(Graph) {
  NEIGHBORS_ITERATION.forEach(description => {
    attachNeighborArrayCreator(Graph, description);
    attachForEachNeighbor(Graph, description);
    attachFindNeighbor(Graph, description);
    attachNeighborIteratorCreator(Graph, description);
  });
}

/**
 * Graphology Adjacency Iteration
 * ===============================
 *
 * Attaching some methods to the Graph class to be able to iterate over a
 * graph's adjacency.
 */

/**
 * Function iterating over a simple graph's adjacency using a callback.
 *
 * @param {boolean}  breakable         - Can we break?
 * @param {boolean}  assymetric        - Whether to emit undirected edges only once.
 * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.
 * @param {Graph}    graph             - Target Graph instance.
 * @param {callback} function          - Iteration callback.
 */
function forEachAdjacency(
  breakable,
  assymetric,
  disconnectedNodes,
  graph,
  callback
) {
  const iterator = graph._nodes.values();

  const type = graph.type;

  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;

  while (((step = iterator.next()), step.done !== true)) {
    let hasEdges = false;

    sourceData = step.value;

    if (type !== 'undirected') {
      adj = sourceData.out;

      for (neighbor in adj) {
        edgeData = adj[neighbor];

        do {
          targetData = edgeData.target;

          hasEdges = true;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected
          );

          if (breakable && shouldBreak) return edgeData;

          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (type !== 'directed') {
      adj = sourceData.undirected;

      for (neighbor in adj) {
        if (assymetric && sourceData.key > neighbor) continue;

        edgeData = adj[neighbor];

        do {
          targetData = edgeData.target;

          if (targetData.key !== neighbor) targetData = edgeData.source;

          hasEdges = true;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected
          );

          if (breakable && shouldBreak) return edgeData;

          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (disconnectedNodes && !hasEdges) {
      shouldBreak = callback(
        sourceData.key,
        null,
        sourceData.attributes,
        null,
        null,
        null,
        null
      );

      if (breakable && shouldBreak) return null;
    }
  }

  return;
}

/**
 * Graphology Serialization Utilities
 * ===================================
 *
 * Collection of functions used by the graph serialization schemes.
 */

/**
 * Formats internal node data into a serialized node.
 *
 * @param  {any}    key  - The node's key.
 * @param  {object} data - Internal node's data.
 * @return {array}       - The serialized node.
 */
function serializeNode(key, data) {
  const serialized = {key};

  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);

  return serialized;
}

/**
 * Formats internal edge data into a serialized edge.
 *
 * @param  {string} type - The graph's type.
 * @param  {any}    key  - The edge's key.
 * @param  {object} data - Internal edge's data.
 * @return {array}       - The serialized edge.
 */
function serializeEdge(type, key, data) {
  const serialized = {
    key,
    source: data.source.key,
    target: data.target.key
  };

  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);

  if (type === 'mixed' && data.undirected) serialized.undirected = true;

  return serialized;
}

/**
 * Checks whether the given value is a serialized node.
 *
 * @param  {mixed} value - Target value.
 * @return {string|null}
 */
function validateSerializedNode(value) {
  if (!isPlainObject(value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'
    );

  if (!('key' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized node is missing its key.'
    );

  if (
    'attributes' in value &&
    (!isPlainObject(value.attributes) || value.attributes === null)
  )
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
    );
}

/**
 * Checks whether the given value is a serialized edge.
 *
 * @param  {mixed} value - Target value.
 * @return {string|null}
 */
function validateSerializedEdge(value) {
  if (!isPlainObject(value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'
    );

  if (!('source' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized edge is missing its source.'
    );

  if (!('target' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized edge is missing its target.'
    );

  if (
    'attributes' in value &&
    (!isPlainObject(value.attributes) || value.attributes === null)
  )
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
    );

  if ('undirected' in value && typeof value.undirected !== 'boolean')
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'
    );
}

/* eslint no-nested-ternary: 0 */

/**
 * Constants.
 */
const INSTANCE_ID = incrementalIdStartingFromRandomByte();

/**
 * Enums.
 */
const TYPES = new Set(['directed', 'undirected', 'mixed']);

const EMITTER_PROPS = new Set([
  'domain',
  '_events',
  '_eventsCount',
  '_maxListeners'
]);

const EDGE_ADD_METHODS = [
  {
    name: verb => `${verb}Edge`,
    generateKey: true
  },
  {
    name: verb => `${verb}DirectedEdge`,
    generateKey: true,
    type: 'directed'
  },
  {
    name: verb => `${verb}UndirectedEdge`,
    generateKey: true,
    type: 'undirected'
  },
  {
    name: verb => `${verb}EdgeWithKey`
  },
  {
    name: verb => `${verb}DirectedEdgeWithKey`,
    type: 'directed'
  },
  {
    name: verb => `${verb}UndirectedEdgeWithKey`,
    type: 'undirected'
  }
];

/**
 * Default options.
 */
const DEFAULTS = {
  allowSelfLoops: true,
  multi: false,
  type: 'mixed'
};

/**
 * Abstract functions used by the Graph class for various methods.
 */

/**
 * Internal method used to add a node to the given graph
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {any}     node            - The node's key.
 * @param  {object}  [attributes]    - Optional attributes.
 * @return {NodeData}                - Created node data.
 */
function addNode(graph, node, attributes) {
  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(
      `Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`
    );

  // String coercion
  node = '' + node;
  attributes = attributes || {};

  if (graph._nodes.has(node))
    throw new UsageGraphError(
      `Graph.addNode: the "${node}" node already exist in the graph.`
    );

  const data = new graph.NodeDataClass(node, attributes);

  // Adding the node to internal register
  graph._nodes.set(node, data);

  // Emitting
  graph.emit('nodeAdded', {
    key: node,
    attributes
  });

  return data;
}

/**
 * Same as the above but without sanity checks because we call this in contexts
 * where necessary checks were already done.
 */
function unsafeAddNode(graph, node, attributes) {
  const data = new graph.NodeDataClass(node, attributes);

  graph._nodes.set(node, data);

  graph.emit('nodeAdded', {
    key: node,
    attributes
  });

  return data;
}

/**
 * Internal method used to add an arbitrary edge to the given graph.
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {string}  name            - Name of the child method for errors.
 * @param  {boolean} mustGenerateKey - Should the graph generate an id?
 * @param  {boolean} undirected      - Whether the edge is undirected.
 * @param  {any}     edge            - The edge's key.
 * @param  {any}     source          - The source node.
 * @param  {any}     target          - The target node.
 * @param  {object}  [attributes]    - Optional attributes.
 * @return {any}                     - The edge.
 *
 * @throws {Error} - Will throw if the graph is of the wrong type.
 * @throws {Error} - Will throw if the given attributes are not an object.
 * @throws {Error} - Will throw if source or target doesn't exist.
 * @throws {Error} - Will throw if the edge already exist.
 */
function addEdge(
  graph,
  name,
  mustGenerateKey,
  undirected,
  edge,
  source,
  target,
  attributes
) {
  // Checking validity of operation
  if (!undirected && graph.type === 'undirected')
    throw new UsageGraphError(
      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`
    );

  if (undirected && graph.type === 'directed')
    throw new UsageGraphError(
      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`
    );

  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(
      `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
    );

  // Coercion of source & target:
  source = '' + source;
  target = '' + target;
  attributes = attributes || {};

  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(
      `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
    );

  const sourceData = graph._nodes.get(source),
    targetData = graph._nodes.get(target);

  if (!sourceData)
    throw new NotFoundGraphError(
      `Graph.${name}: source node "${source}" not found.`
    );

  if (!targetData)
    throw new NotFoundGraphError(
      `Graph.${name}: target node "${target}" not found.`
    );

  // Must the graph generate an id for this edge?
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };

  if (mustGenerateKey) {
    // NOTE: in this case we can guarantee that the key does not already
    // exist and is already correctly casted as a string
    edge = graph._edgeKeyGenerator();
  } else {
    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(
        `Graph.${name}: the "${edge}" edge already exists in the graph.`
      );
  }

  // Here, we might have a source / target collision
  if (
    !graph.multi &&
    (undirected
      ? typeof sourceData.undirected[target] !== 'undefined'
      : typeof sourceData.out[target] !== 'undefined')
  ) {
    throw new UsageGraphError(
      `Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`
    );
  }

  // Storing some data
  const edgeData = new EdgeData(
    undirected,
    edge,
    sourceData,
    targetData,
    attributes
  );

  // Adding the edge to the internal register
  graph._edges.set(edge, edgeData);

  // Incrementing node degree counters
  const isSelfLoop = source === target;

  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;

    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;

    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }

  // Updating relevant index
  if (graph.multi) edgeData.attachMulti();
  else edgeData.attach();

  if (undirected) graph._undirectedSize++;
  else graph._directedSize++;

  // Emitting
  eventData.key = edge;

  graph.emit('edgeAdded', eventData);

  return edge;
}

/**
 * Internal method used to add an arbitrary edge to the given graph.
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {string}  name            - Name of the child method for errors.
 * @param  {boolean} mustGenerateKey - Should the graph generate an id?
 * @param  {boolean} undirected      - Whether the edge is undirected.
 * @param  {any}     edge            - The edge's key.
 * @param  {any}     source          - The source node.
 * @param  {any}     target          - The target node.
 * @param  {object}  [attributes]    - Optional attributes.
 * @param  {boolean} [asUpdater]       - Are we updating or merging?
 * @return {any}                     - The edge.
 *
 * @throws {Error} - Will throw if the graph is of the wrong type.
 * @throws {Error} - Will throw if the given attributes are not an object.
 * @throws {Error} - Will throw if source or target doesn't exist.
 * @throws {Error} - Will throw if the edge already exist.
 */
function mergeEdge(
  graph,
  name,
  mustGenerateKey,
  undirected,
  edge,
  source,
  target,
  attributes,
  asUpdater
) {
  // Checking validity of operation
  if (!undirected && graph.type === 'undirected')
    throw new UsageGraphError(
      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`
    );

  if (undirected && graph.type === 'directed')
    throw new UsageGraphError(
      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`
    );

  if (attributes) {
    if (asUpdater) {
      if (typeof attributes !== 'function')
        throw new InvalidArgumentsGraphError(
          `Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`
        );
    } else {
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
        );
    }
  }

  // Coercion of source & target:
  source = '' + source;
  target = '' + target;

  let updater;

  if (asUpdater) {
    updater = attributes;
    attributes = undefined;
  }

  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(
      `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
    );

  let sourceData = graph._nodes.get(source);
  let targetData = graph._nodes.get(target);
  let edgeData;

  // Do we need to handle duplicate?
  let alreadyExistingEdgeData;

  if (!mustGenerateKey) {
    edgeData = graph._edges.get(edge);

    if (edgeData) {
      // Here, we need to ensure, if the user gave a key, that source & target
      // are consistent
      if (edgeData.source.key !== source || edgeData.target.key !== target) {
        // If source or target inconsistent
        if (
          !undirected ||
          edgeData.source.key !== target ||
          edgeData.target.key !== source
        ) {
          // If directed, or source/target aren't flipped
          throw new UsageGraphError(
            `Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`
          );
        }
      }

      alreadyExistingEdgeData = edgeData;
    }
  }

  // Here, we might have a source / target collision
  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
    alreadyExistingEdgeData = undirected
      ? sourceData.undirected[target]
      : sourceData.out[target];
  }

  // Handling duplicates
  if (alreadyExistingEdgeData) {
    const info = [alreadyExistingEdgeData.key, false, false, false];

    // We can skip the attribute merging part if the user did not provide them
    if (asUpdater ? !updater : !attributes) return info;

    // Updating the attributes
    if (asUpdater) {
      const oldAttributes = alreadyExistingEdgeData.attributes;
      alreadyExistingEdgeData.attributes = updater(oldAttributes);

      graph.emit('edgeAttributesUpdated', {
        type: 'replace',
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes
      });
    }

    // Merging the attributes
    else {
      assign(alreadyExistingEdgeData.attributes, attributes);

      graph.emit('edgeAttributesUpdated', {
        type: 'merge',
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes,
        data: attributes
      });
    }

    return info;
  }

  attributes = attributes || {};

  if (asUpdater && updater) attributes = updater(attributes);

  // Must the graph generate an id for this edge?
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };

  if (mustGenerateKey) {
    // NOTE: in this case we can guarantee that the key does not already
    // exist and is already correctly casted as a string
    edge = graph._edgeKeyGenerator();
  } else {
    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(
        `Graph.${name}: the "${edge}" edge already exists in the graph.`
      );
  }

  let sourceWasAdded = false;
  let targetWasAdded = false;

  if (!sourceData) {
    sourceData = unsafeAddNode(graph, source, {});
    sourceWasAdded = true;

    if (source === target) {
      targetData = sourceData;
      targetWasAdded = true;
    }
  }
  if (!targetData) {
    targetData = unsafeAddNode(graph, target, {});
    targetWasAdded = true;
  }

  // Storing some data
  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);

  // Adding the edge to the internal register
  graph._edges.set(edge, edgeData);

  // Incrementing node degree counters
  const isSelfLoop = source === target;

  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;

    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;

    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }

  // Updating relevant index
  if (graph.multi) edgeData.attachMulti();
  else edgeData.attach();

  if (undirected) graph._undirectedSize++;
  else graph._directedSize++;

  // Emitting
  eventData.key = edge;

  graph.emit('edgeAdded', eventData);

  return [edge, true, sourceWasAdded, targetWasAdded];
}

/**
 * Internal method used to drop an edge.
 *
 * @param  {Graph}    graph    - Target graph.
 * @param  {EdgeData} edgeData - Data of the edge to drop.
 */
function dropEdgeFromData(graph, edgeData) {
  // Dropping the edge from the register
  graph._edges.delete(edgeData.key);

  // Updating related degrees
  const {source: sourceData, target: targetData, attributes} = edgeData;

  const undirected = edgeData.undirected;

  const isSelfLoop = sourceData === targetData;

  if (undirected) {
    sourceData.undirectedDegree--;
    targetData.undirectedDegree--;

    if (isSelfLoop) {
      sourceData.undirectedLoops--;
      graph._undirectedSelfLoopCount--;
    }
  } else {
    sourceData.outDegree--;
    targetData.inDegree--;

    if (isSelfLoop) {
      sourceData.directedLoops--;
      graph._directedSelfLoopCount--;
    }
  }

  // Clearing index
  if (graph.multi) edgeData.detachMulti();
  else edgeData.detach();

  if (undirected) graph._undirectedSize--;
  else graph._directedSize--;

  // Emitting
  graph.emit('edgeDropped', {
    key: edgeData.key,
    attributes,
    source: sourceData.key,
    target: targetData.key,
    undirected
  });
}

/**
 * Graph class
 *
 * @constructor
 * @param  {object}  [options] - Options:
 * @param  {boolean}   [allowSelfLoops] - Allow self loops?
 * @param  {string}    [type]           - Type of the graph.
 * @param  {boolean}   [map]            - Allow references as keys?
 * @param  {boolean}   [multi]          - Allow parallel edges?
 *
 * @throws {Error} - Will throw if the arguments are not valid.
 */
class Graph extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor(options) {
    super();

    //-- Solving options
    options = assign({}, DEFAULTS, options);

    // Enforcing options validity
    if (typeof options.multi !== 'boolean')
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`
      );

    if (!TYPES.has(options.type))
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`
      );

    if (typeof options.allowSelfLoops !== 'boolean')
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`
      );

    //-- Private properties

    // Utilities
    const NodeDataClass =
      options.type === 'mixed'
        ? MixedNodeData
        : options.type === 'directed'
        ? DirectedNodeData
        : UndirectedNodeData;

    privateProperty(this, 'NodeDataClass', NodeDataClass);

    // Internal edge key generator

    // NOTE: this internal generator produce keys that are strings
    // composed of a weird prefix, an incremental instance id starting from
    // a random byte and finally an internal instance incremental id.
    // All this to avoid intra-frame and cross-frame adversarial inputs
    // that can force a single #.addEdge call to degenerate into a O(n)
    // available key search loop.

    // It also ensures that automatically generated edge keys are unlikely
    // to produce collisions with arbitrary keys given by users.
    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';
    let edgeId = 0;

    const edgeKeyGenerator = () => {
      let availableEdgeKey;

      do {
        availableEdgeKey = instancePrefix + edgeId++;
      } while (this._edges.has(availableEdgeKey));

      return availableEdgeKey;
    };

    // Indexes
    privateProperty(this, '_attributes', {});
    privateProperty(this, '_nodes', new Map());
    privateProperty(this, '_edges', new Map());
    privateProperty(this, '_directedSize', 0);
    privateProperty(this, '_undirectedSize', 0);
    privateProperty(this, '_directedSelfLoopCount', 0);
    privateProperty(this, '_undirectedSelfLoopCount', 0);
    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);

    // Options
    privateProperty(this, '_options', options);

    // Emitter properties
    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));

    //-- Properties readers
    readOnlyProperty(this, 'order', () => this._nodes.size);
    readOnlyProperty(this, 'size', () => this._edges.size);
    readOnlyProperty(this, 'directedSize', () => this._directedSize);
    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);
    readOnlyProperty(
      this,
      'selfLoopCount',
      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount
    );
    readOnlyProperty(
      this,
      'directedSelfLoopCount',
      () => this._directedSelfLoopCount
    );
    readOnlyProperty(
      this,
      'undirectedSelfLoopCount',
      () => this._undirectedSelfLoopCount
    );
    readOnlyProperty(this, 'multi', this._options.multi);
    readOnlyProperty(this, 'type', this._options.type);
    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);
    readOnlyProperty(this, 'implementation', () => 'graphology');
  }

  _resetInstanceCounters() {
    this._directedSize = 0;
    this._undirectedSize = 0;
    this._directedSelfLoopCount = 0;
    this._undirectedSelfLoopCount = 0;
  }

  /**---------------------------------------------------------------------------
   * Read
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning whether the given node is found in the graph.
   *
   * @param  {any}     node - The node.
   * @return {boolean}
   */
  hasNode(node) {
    return this._nodes.has('' + node);
  }

  /**
   * Method returning whether the given directed edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasDirectedEdge(source, target) {
    // Early termination
    if (this.type === 'undirected') return false;

    if (arguments.length === 1) {
      const edge = '' + source;

      const edgeData = this._edges.get(edge);

      return !!edgeData && !edgeData.undirected;
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return nodeData.out.hasOwnProperty(target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning whether the given undirected edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasUndirectedEdge(source, target) {
    // Early termination
    if (this.type === 'directed') return false;

    if (arguments.length === 1) {
      const edge = '' + source;

      const edgeData = this._edges.get(edge);

      return !!edgeData && edgeData.undirected;
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return nodeData.undirected.hasOwnProperty(target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning whether the given edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasEdge(source, target) {
    if (arguments.length === 1) {
      const edge = '' + source;

      return this._edges.has(edge);
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return (
        (typeof nodeData.out !== 'undefined' &&
          nodeData.out.hasOwnProperty(target)) ||
        (typeof nodeData.undirected !== 'undefined' &&
          nodeData.undirected.hasOwnProperty(target))
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning the edge matching source & target in a directed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  directedEdge(source, target) {
    if (this.type === 'undirected') return;

    source = '' + source;
    target = '' + target;

    if (this.multi)
      throw new UsageGraphError(
        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'
      );

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.directedEdge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.directedEdge: could not find the "${target}" target node in the graph.`
      );

    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning the edge matching source & target in a undirected fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  undirectedEdge(source, target) {
    if (this.type === 'directed') return;

    source = '' + source;
    target = '' + target;

    if (this.multi)
      throw new UsageGraphError(
        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'
      );

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.undirectedEdge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.undirectedEdge: could not find the "${target}" target node in the graph.`
      );

    const edgeData =
      (sourceData.undirected && sourceData.undirected[target]) || undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning the edge matching source & target in a mixed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  edge(source, target) {
    if (this.multi)
      throw new UsageGraphError(
        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'
      );

    source = '' + source;
    target = '' + target;

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.edge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.edge: could not find the "${target}" target node in the graph.`
      );

    const edgeData =
      (sourceData.out && sourceData.out[target]) ||
      (sourceData.undirected && sourceData.undirected[target]) ||
      undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning whether two nodes are directed neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areDirectedNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.in || neighbor in nodeData.out;
  }

  /**
   * Method returning whether two nodes are out neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areOutNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areOutNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.out;
  }

  /**
   * Method returning whether two nodes are in neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areInNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areInNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.in;
  }

  /**
   * Method returning whether two nodes are undirected neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areUndirectedNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return false;

    return neighbor in nodeData.undirected;
  }

  /**
   * Method returning whether two nodes are neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning whether two nodes are inbound neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areInboundNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.in) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning whether two nodes are outbound neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areOutboundNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.out) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning the given node's in degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree;
  }

  /**
   * Method returning the given node's out degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.outDegree;
  }

  /**
   * Method returning the given node's directed degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  directedDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.directedDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree + nodeData.outDegree;
  }

  /**
   * Method returning the given node's undirected degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  undirectedDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.undirectedDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return 0;

    return nodeData.undirectedDegree;
  }

  /**
   * Method returning the given node's inbound degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's inbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inboundDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inboundDegree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's outbound degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's outbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outboundDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outboundDegree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.outDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's directed degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  degree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.degree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree + nodeData.outDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's in degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree - nodeData.directedLoops;
  }

  /**
   * Method returning the given node's out degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.outDegree - nodeData.directedLoops;
  }

  /**
   * Method returning the given node's directed degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  directedDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
  }

  /**
   * Method returning the given node's undirected degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  undirectedDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return 0;

    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
  }

  /**
   * Method returning the given node's inbound degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's inbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inboundDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree;
      loops += nodeData.directedLoops;
    }

    return degree - loops;
  }

  /**
   * Method returning the given node's outbound degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's outbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outboundDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.outDegree;
      loops += nodeData.directedLoops;
    }

    return degree - loops;
  }

  /**
   * Method returning the given node's directed degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  degreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.degreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree + nodeData.outDegree;
      loops += nodeData.directedLoops * 2;
    }

    return degree - loops;
  }

  /**
   * Method returning the given edge's source.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's source.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  source(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.source: could not find the "${edge}" edge in the graph.`
      );

    return data.source.key;
  }

  /**
   * Method returning the given edge's target.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's target.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  target(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.target: could not find the "${edge}" edge in the graph.`
      );

    return data.target.key;
  }

  /**
   * Method returning the given edge's extremities.
   *
   * @param  {any}   edge - The edge's key.
   * @return {array}      - The edge's extremities.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  extremities(edge) {
    edge = '' + edge;

    const edgeData = this._edges.get(edge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.extremities: could not find the "${edge}" edge in the graph.`
      );

    return [edgeData.source.key, edgeData.target.key];
  }

  /**
   * Given a node & an edge, returns the other extremity of the edge.
   *
   * @param  {any}   node - The node's key.
   * @param  {any}   edge - The edge's key.
   * @return {any}        - The related node.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph or if the
   *                   edge & node are not related.
   */
  opposite(node, edge) {
    node = '' + node;
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.opposite: could not find the "${edge}" edge in the graph.`
      );

    const source = data.source.key;
    const target = data.target.key;

    if (node === source) return target;
    if (node === target) return source;

    throw new NotFoundGraphError(
      `Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`
    );
  }

  /**
   * Returns whether the given edge has the given node as extremity.
   *
   * @param  {any}     edge - The edge's key.
   * @param  {any}     node - The node's key.
   * @return {boolean}      - The related node.
   *
   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
   */
  hasExtremity(edge, node) {
    edge = '' + edge;
    node = '' + node;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.hasExtremity: could not find the "${edge}" edge in the graph.`
      );

    return data.source.key === node || data.target.key === node;
  }

  /**
   * Method returning whether the given edge is undirected.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isUndirected(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isUndirected: could not find the "${edge}" edge in the graph.`
      );

    return data.undirected;
  }

  /**
   * Method returning whether the given edge is directed.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isDirected(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isDirected: could not find the "${edge}" edge in the graph.`
      );

    return !data.undirected;
  }

  /**
   * Method returning whether the given edge is a self loop.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isSelfLoop(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`
      );

    return data.source === data.target;
  }

  /**---------------------------------------------------------------------------
   * Mutation
   **---------------------------------------------------------------------------
   */

  /**
   * Method used to add a node to the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   *
   * @throws {Error} - Will throw if the given node already exist.
   * @throws {Error} - Will throw if the given attributes are not an object.
   */
  addNode(node, attributes) {
    const nodeData = addNode(this, node, attributes);

    return nodeData.key;
  }

  /**
   * Method used to merge a node into the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   */
  mergeNode(node, attributes) {
    if (attributes && !isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`
      );

    // String coercion
    node = '' + node;
    attributes = attributes || {};

    // If the node already exists, we merge the attributes
    let data = this._nodes.get(node);

    if (data) {
      if (attributes) {
        assign(data.attributes, attributes);

        this.emit('nodeAttributesUpdated', {
          type: 'merge',
          key: node,
          attributes: data.attributes,
          data: attributes
        });
      }
      return [node, false];
    }

    data = new this.NodeDataClass(node, attributes);

    // Adding the node to internal register
    this._nodes.set(node, data);

    // Emitting
    this.emit('nodeAdded', {
      key: node,
      attributes
    });

    return [node, true];
  }

  /**
   * Method used to add a node if it does not exist in the graph or else to
   * update its attributes using a function.
   *
   * @param  {any}      node      - The node.
   * @param  {function} [updater] - Optional updater function.
   * @return {any}                - The node.
   */
  updateNode(node, updater) {
    if (updater && typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`
      );

    // String coercion
    node = '' + node;

    // If the node already exists, we update the attributes
    let data = this._nodes.get(node);

    if (data) {
      if (updater) {
        const oldAttributes = data.attributes;
        data.attributes = updater(oldAttributes);

        this.emit('nodeAttributesUpdated', {
          type: 'replace',
          key: node,
          attributes: data.attributes
        });
      }
      return [node, false];
    }

    const attributes = updater ? updater({}) : {};

    data = new this.NodeDataClass(node, attributes);

    // Adding the node to internal register
    this._nodes.set(node, data);

    // Emitting
    this.emit('nodeAdded', {
      key: node,
      attributes
    });

    return [node, true];
  }

  /**
   * Method used to drop a single node & all its attached edges from the graph.
   *
   * @param  {any}    node - The node.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node doesn't exist.
   */
  dropNode(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.dropNode: could not find the "${node}" node in the graph.`
      );

    let edgeData;

    // Removing attached edges
    // NOTE: we could be faster here, but this is such a pain to maintain
    if (this.type !== 'undirected') {
      for (const neighbor in nodeData.out) {
        edgeData = nodeData.out[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }

      for (const neighbor in nodeData.in) {
        edgeData = nodeData.in[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (this.type !== 'directed') {
      for (const neighbor in nodeData.undirected) {
        edgeData = nodeData.undirected[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    // Dropping the node from the register
    this._nodes.delete(node);

    // Emitting
    this.emit('nodeDropped', {
      key: node,
      attributes: nodeData.attributes
    });
  }

  /**
   * Method used to drop a single edge from the graph.
   *
   * Arity 1:
   * @param  {any}    edge - The edge.
   *
   * Arity 2:
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropEdge(edge) {
    let edgeData;

    if (arguments.length > 1) {
      const source = '' + arguments[0];
      const target = '' + arguments[1];

      edgeData = getMatchingEdge(this, source, target, this.type);

      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`
        );
    } else {
      edge = '' + edge;

      edgeData = this._edges.get(edge);

      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropEdge: could not find the "${edge}" edge in the graph.`
        );
    }

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to drop a single directed edge from the graph.
   *
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropDirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError(
        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
      );

    if (this.multi)
      throw new UsageGraphError(
        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
      );

    source = '' + source;
    target = '' + target;

    const edgeData = getMatchingEdge(this, source, target, 'directed');

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.dropDirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
      );

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to drop a single undirected edge from the graph.
   *
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropUndirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError(
        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
      );

    if (this.multi)
      throw new UsageGraphError(
        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
      );

    const edgeData = getMatchingEdge(this, source, target, 'undirected');

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.dropUndirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
      );

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to remove every edge & every node from the graph.
   *
   * @return {Graph}
   */
  clear() {
    // Clearing edges
    this._edges.clear();

    // Clearing nodes
    this._nodes.clear();

    // Reset counters
    this._resetInstanceCounters();

    // Emitting
    this.emit('cleared');
  }

  /**
   * Method used to remove every edge from the graph.
   *
   * @return {Graph}
   */
  clearEdges() {
    // Clearing structure index
    const iterator = this._nodes.values();

    let step;

    while (((step = iterator.next()), step.done !== true)) {
      step.value.clear();
    }

    // Clearing edges
    this._edges.clear();

    // Reset counters
    this._resetInstanceCounters();

    // Emitting
    this.emit('edgesCleared');
  }

  /**---------------------------------------------------------------------------
   * Attributes-related methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning the desired graph's attribute.
   *
   * @param  {string} name - Name of the attribute.
   * @return {any}
   */
  getAttribute(name) {
    return this._attributes[name];
  }

  /**
   * Method returning the graph's attributes.
   *
   * @return {object}
   */
  getAttributes() {
    return this._attributes;
  }

  /**
   * Method returning whether the graph has the desired attribute.
   *
   * @param  {string}  name - Name of the attribute.
   * @return {boolean}
   */
  hasAttribute(name) {
    return this._attributes.hasOwnProperty(name);
  }

  /**
   * Method setting a value for the desired graph's attribute.
   *
   * @param  {string}  name  - Name of the attribute.
   * @param  {any}     value - Value for the attribute.
   * @return {Graph}
   */
  setAttribute(name, value) {
    this._attributes[name] = value;

    // Emitting
    this.emit('attributesUpdated', {
      type: 'set',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method using a function to update the desired graph's attribute's value.
   *
   * @param  {string}   name    - Name of the attribute.
   * @param  {function} updater - Function use to update the attribute's value.
   * @return {Graph}
   */
  updateAttribute(name, updater) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateAttribute: updater should be a function.'
      );

    const value = this._attributes[name];

    this._attributes[name] = updater(value);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'set',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method removing the desired graph's attribute.
   *
   * @param  {string} name  - Name of the attribute.
   * @return {Graph}
   */
  removeAttribute(name) {
    delete this._attributes[name];

    // Emitting
    this.emit('attributesUpdated', {
      type: 'remove',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method replacing the graph's attributes.
   *
   * @param  {object} attributes - New attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  replaceAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        'Graph.replaceAttributes: provided attributes are not a plain object.'
      );

    this._attributes = attributes;

    // Emitting
    this.emit('attributesUpdated', {
      type: 'replace',
      attributes: this._attributes
    });

    return this;
  }

  /**
   * Method merging the graph's attributes.
   *
   * @param  {object} attributes - Attributes to merge.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  mergeAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        'Graph.mergeAttributes: provided attributes are not a plain object.'
      );

    assign(this._attributes, attributes);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'merge',
      attributes: this._attributes,
      data: attributes
    });

    return this;
  }

  /**
   * Method updating the graph's attributes.
   *
   * @param  {function} updater - Function used to update the attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given updater is not a function.
   */
  updateAttributes(updater) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateAttributes: provided updater is not a function.'
      );

    this._attributes = updater(this._attributes);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'update',
      attributes: this._attributes
    });

    return this;
  }

  /**
   * Method used to update each node's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachNodeAttributes(updater, hints) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachNodeAttributes: expecting an updater function.'
      );

    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      nodeData.attributes = updater(nodeData.key, nodeData.attributes);
    }

    this.emit('eachNodeAttributesUpdated', {
      hints: hints ? hints : null
    });
  }

  /**
   * Method used to update each edge's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachEdgeAttributes(updater, hints) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachEdgeAttributes: expecting an updater function.'
      );

    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
      );

    const iterator = this._edges.values();

    let step, edgeData, sourceData, targetData;

    while (((step = iterator.next()), step.done !== true)) {
      edgeData = step.value;
      sourceData = edgeData.source;
      targetData = edgeData.target;

      edgeData.attributes = updater(
        edgeData.key,
        edgeData.attributes,
        sourceData.key,
        targetData.key,
        sourceData.attributes,
        targetData.attributes,
        edgeData.undirected
      );
    }

    this.emit('eachEdgeAttributesUpdated', {
      hints: hints ? hints : null
    });
  }

  /**---------------------------------------------------------------------------
   * Iteration-related methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method iterating over the graph's adjacency using the given callback.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEachAdjacencyEntry(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAdjacencyEntry: expecting a callback.'
      );

    forEachAdjacency(false, false, false, this, callback);
  }
  forEachAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'
      );

    forEachAdjacency(false, false, true, this, callback);
  }

  /**
   * Method iterating over the graph's assymetric adjacency using the given callback.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEachAssymetricAdjacencyEntry(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'
      );

    forEachAdjacency(false, true, false, this, callback);
  }
  forEachAssymetricAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'
      );

    forEachAdjacency(false, true, true, this, callback);
  }

  /**
   * Method returning the list of the graph's nodes.
   *
   * @return {array} - The nodes.
   */
  nodes() {
    return Array.from(this._nodes.keys());
  }

  /**
   * Method iterating over the graph's nodes using the given callback.
   *
   * @param  {function}  callback - Callback (key, attributes, index).
   */
  forEachNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      callback(nodeData.key, nodeData.attributes);
    }
  }

  /**
   * Method iterating attempting to find a node matching the given predicate
   * function.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  findNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.findNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;
    }

    return;
  }

  /**
   * Method mapping nodes.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  mapNodes(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.mapNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    const result = new Array(this.order);
    let i = 0;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      result[i++] = callback(nodeData.key, nodeData.attributes);
    }

    return result;
  }

  /**
   * Method returning whether some node verify the given predicate.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  someNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.someNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes)) return true;
    }

    return false;
  }

  /**
   * Method returning whether all node verify the given predicate.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  everyNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.everyNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (!callback(nodeData.key, nodeData.attributes)) return false;
    }

    return true;
  }

  /**
   * Method filtering nodes.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  filterNodes(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.filterNodes: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    const result = [];

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes))
        result.push(nodeData.key);
    }

    return result;
  }

  /**
   * Method reducing nodes.
   *
   * @param  {function}  callback - Callback (accumulator, key, attributes).
   */
  reduceNodes(callback, initialValue) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.reduceNodes: expecting a callback.'
      );

    if (arguments.length < 2)
      throw new InvalidArgumentsGraphError(
        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'
      );

    let accumulator = initialValue;

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
    }

    return accumulator;
  }

  /**
   * Method returning an iterator over the graph's node entries.
   *
   * @return {Iterator}
   */
  nodeEntries() {
    const iterator = this._nodes.values();

    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const step = iterator.next();
        if (step.done) return step;
        const data = step.value;
        return {
          value: {node: data.key, attributes: data.attributes},
          done: false
        };
      }
    };
  }

  /**---------------------------------------------------------------------------
   * Serialization
   **---------------------------------------------------------------------------
   */

  /**
   * Method used to export the whole graph.
   *
   * @return {object} - The serialized graph.
   */
  export() {
    const nodes = new Array(this._nodes.size);

    let i = 0;

    this._nodes.forEach((data, key) => {
      nodes[i++] = serializeNode(key, data);
    });

    const edges = new Array(this._edges.size);

    i = 0;

    this._edges.forEach((data, key) => {
      edges[i++] = serializeEdge(this.type, key, data);
    });

    return {
      options: {
        type: this.type,
        multi: this.multi,
        allowSelfLoops: this.allowSelfLoops
      },
      attributes: this.getAttributes(),
      nodes,
      edges
    };
  }

  /**
   * Method used to import a serialized graph.
   *
   * @param  {object|Graph} data  - The serialized graph.
   * @param  {boolean}      merge - Whether to merge data.
   * @return {Graph}              - Returns itself for chaining.
   */
  import(data, merge = false) {
    // Importing a Graph instance directly
    if (data instanceof Graph) {
      // Nodes
      data.forEachNode((n, a) => {
        if (merge) this.mergeNode(n, a);
        else this.addNode(n, a);
      });

      // Edges
      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {
        if (merge) {
          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);
          else this.mergeDirectedEdgeWithKey(e, s, t, a);
        } else {
          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);
          else this.addDirectedEdgeWithKey(e, s, t, a);
        }
      });

      return this;
    }

    // Importing a serialized graph
    if (!isPlainObject(data))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'
      );

    if (data.attributes) {
      if (!isPlainObject(data.attributes))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid attributes. Expecting a plain object.'
        );

      if (merge) this.mergeAttributes(data.attributes);
      else this.replaceAttributes(data.attributes);
    }

    let i, l, list, node, edge;

    if (data.nodes) {
      list = data.nodes;

      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid nodes. Expecting an array.'
        );

      for (i = 0, l = list.length; i < l; i++) {
        node = list[i];

        // Validating
        validateSerializedNode(node);

        // Adding the node
        const {key, attributes} = node;

        if (merge) this.mergeNode(key, attributes);
        else this.addNode(key, attributes);
      }
    }

    if (data.edges) {
      let undirectedByDefault = false;

      if (this.type === 'undirected') {
        undirectedByDefault = true;
      }

      list = data.edges;

      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid edges. Expecting an array.'
        );

      for (i = 0, l = list.length; i < l; i++) {
        edge = list[i];

        // Validating
        validateSerializedEdge(edge);

        // Adding the edge
        const {
          source,
          target,
          attributes,
          undirected = undirectedByDefault
        } = edge;

        let method;

        if ('key' in edge) {
          method = merge
            ? undirected
              ? this.mergeUndirectedEdgeWithKey
              : this.mergeDirectedEdgeWithKey
            : undirected
            ? this.addUndirectedEdgeWithKey
            : this.addDirectedEdgeWithKey;

          method.call(this, edge.key, source, target, attributes);
        } else {
          method = merge
            ? undirected
              ? this.mergeUndirectedEdge
              : this.mergeDirectedEdge
            : undirected
            ? this.addUndirectedEdge
            : this.addDirectedEdge;

          method.call(this, source, target, attributes);
        }
      }
    }

    return this;
  }

  /**---------------------------------------------------------------------------
   * Utils
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning a null copy of the graph, i.e. a graph without nodes
   * & edges but with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The null copy.
   */
  nullCopy(options) {
    const graph = new Graph(assign({}, this._options, options));
    graph.replaceAttributes(assign({}, this.getAttributes()));
    return graph;
  }

  /**
   * Method returning an empty copy of the graph, i.e. a graph without edges but
   * with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The empty copy.
   */
  emptyCopy(options) {
    const graph = this.nullCopy(options);

    this._nodes.forEach((nodeData, key) => {
      const attributes = assign({}, nodeData.attributes);

      // NOTE: no need to emit events since user cannot access the instance yet
      nodeData = new graph.NodeDataClass(key, attributes);
      graph._nodes.set(key, nodeData);
    });

    return graph;
  }

  /**
   * Method returning an exact copy of the graph.
   *
   * @param  {object} options - Upgrade options.
   * @return {Graph}          - The copy.
   */
  copy(options) {
    options = options || {};

    if (
      typeof options.type === 'string' &&
      options.type !== this.type &&
      options.type !== 'mixed'
    )
      throw new UsageGraphError(
        `Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options.type}" because this would mean losing information about the current graph.`
      );

    if (
      typeof options.multi === 'boolean' &&
      options.multi !== this.multi &&
      options.multi !== true
    )
      throw new UsageGraphError(
        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'
      );

    if (
      typeof options.allowSelfLoops === 'boolean' &&
      options.allowSelfLoops !== this.allowSelfLoops &&
      options.allowSelfLoops !== true
    )
      throw new UsageGraphError(
        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'
      );

    const graph = this.emptyCopy(options);

    const iterator = this._edges.values();

    let step, edgeData;

    while (((step = iterator.next()), step.done !== true)) {
      edgeData = step.value;

      // NOTE: no need to emit events since user cannot access the instance yet
      addEdge(
        graph,
        'copy',
        false,
        edgeData.undirected,
        edgeData.key,
        edgeData.source.key,
        edgeData.target.key,
        assign({}, edgeData.attributes)
      );
    }

    return graph;
  }

  /**---------------------------------------------------------------------------
   * Known methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method used by JavaScript to perform JSON serialization.
   *
   * @return {object} - The serialized graph.
   */
  toJSON() {
    return this.export();
  }

  /**
   * Method returning [object Graph].
   */
  toString() {
    return '[object Graph]';
  }

  /**
   * Method used internally by node's console to display a custom object.
   *
   * @return {object} - Formatted object representation of the graph.
   */
  inspect() {
    const nodes = {};
    this._nodes.forEach((data, key) => {
      nodes[key] = data.attributes;
    });

    const edges = {},
      multiIndex = {};

    this._edges.forEach((data, key) => {
      const direction = data.undirected ? '--' : '->';

      let label = '';

      let source = data.source.key;
      let target = data.target.key;
      let tmp;

      if (data.undirected && source > target) {
        tmp = source;
        source = target;
        target = tmp;
      }

      const desc = `(${source})${direction}(${target})`;

      if (!key.startsWith('geid_')) {
        label += `[${key}]: `;
      } else if (this.multi) {
        if (typeof multiIndex[desc] === 'undefined') {
          multiIndex[desc] = 0;
        } else {
          multiIndex[desc]++;
        }

        label += `${multiIndex[desc]}. `;
      }

      label += desc;

      edges[label] = data.attributes;
    });

    const dummy = {};

    for (const k in this) {
      if (
        this.hasOwnProperty(k) &&
        !EMITTER_PROPS.has(k) &&
        typeof this[k] !== 'function' &&
        typeof k !== 'symbol'
      )
        dummy[k] = this[k];
    }

    dummy.attributes = this._attributes;
    dummy.nodes = nodes;
    dummy.edges = edges;

    privateProperty(dummy, 'constructor', this.constructor);

    return dummy;
  }
}

/**
 * Attaching methods to the prototype.
 *
 * Here, we are attaching a wide variety of methods to the Graph class'
 * prototype when those are very numerous and when their creation is
 * abstracted.
 */

/**
 * Attaching custom inspect method for node >= 10.
 */
if (typeof Symbol !== 'undefined')
  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =
    Graph.prototype.inspect;

/**
 * Related to edge addition.
 */
EDGE_ADD_METHODS.forEach(method => {
  ['add', 'merge', 'update'].forEach(verb => {
    const name = method.name(verb);
    const fn = verb === 'add' ? addEdge : mergeEdge;

    if (method.generateKey) {
      Graph.prototype[name] = function (source, target, attributes) {
        return fn(
          this,
          name,
          true,
          (method.type || this.type) === 'undirected',
          null,
          source,
          target,
          attributes,
          verb === 'update'
        );
      };
    } else {
      Graph.prototype[name] = function (edge, source, target, attributes) {
        return fn(
          this,
          name,
          false,
          (method.type || this.type) === 'undirected',
          edge,
          source,
          target,
          attributes,
          verb === 'update'
        );
      };
    }
  });
});

/**
 * Attributes-related.
 */
attachNodeAttributesMethods(Graph);
attachEdgeAttributesMethods(Graph);

/**
 * Edge iteration-related.
 */
attachEdgeIterationMethods(Graph);

/**
 * Neighbor iteration-related.
 */
attachNeighborIterationMethods(Graph);

/**
 * Graphology Helper Classes
 * ==========================
 *
 * Building some higher-order classes instantiating the graph with
 * predefinite options.
 */

/**
 * Alternative constructors.
 */
class DirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'directed'}, options);

    if ('multi' in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError(
        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
      );

    if (finalOptions.type !== 'directed')
      throw new InvalidArgumentsGraphError(
        'DirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class UndirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'undirected'}, options);

    if ('multi' in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError(
        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
      );

    if (finalOptions.type !== 'undirected')
      throw new InvalidArgumentsGraphError(
        'UndirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class MultiGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    super(finalOptions);
  }
}
class MultiDirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'directed', multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    if (finalOptions.type !== 'directed')
      throw new InvalidArgumentsGraphError(
        'MultiDirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class MultiUndirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'undirected', multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    if (finalOptions.type !== 'undirected')
      throw new InvalidArgumentsGraphError(
        'MultiUndirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}

/**
 * Attaching static #.from method to each of the constructors.
 */
function attachStaticFromMethod(Class) {
  /**
   * Builds a graph from serialized data or another graph's data.
   *
   * @param  {Graph|SerializedGraph} data      - Hydratation data.
   * @param  {object}                [options] - Options.
   * @return {Class}
   */
  Class.from = function (data, options) {
    // Merging given options with serialized ones
    const finalOptions = assign({}, data.options, options);

    const instance = new Class(finalOptions);
    instance.import(data);

    return instance;
  };
}

attachStaticFromMethod(Graph);
attachStaticFromMethod(DirectedGraph);
attachStaticFromMethod(UndirectedGraph);
attachStaticFromMethod(MultiGraph);
attachStaticFromMethod(MultiDirectedGraph);
attachStaticFromMethod(MultiUndirectedGraph);

Graph.Graph = Graph;
Graph.DirectedGraph = DirectedGraph;
Graph.UndirectedGraph = UndirectedGraph;
Graph.MultiGraph = MultiGraph;
Graph.MultiDirectedGraph = MultiDirectedGraph;
Graph.MultiUndirectedGraph = MultiUndirectedGraph;

Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
Graph.NotFoundGraphError = NotFoundGraphError;
Graph.UsageGraphError = UsageGraphError;

/**
 * Graphology ESM Endoint
 * =======================
 *
 * Endpoint for ESM modules consumers.
 */


//# sourceMappingURL=graphology.mjs.map


/***/ }),

/***/ "./node_modules/papaparse/papaparse.min.js":
/*!*************************************************!*\
  !*** ./node_modules/papaparse/papaparse.min.js ***!
  \*************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
((e,t)=>{ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})(this,function r(){var n="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==n?n:{};var d,s=!n.document&&!!n.postMessage,a=n.IS_PAPA_WORKER||!1,o={},h=0,v={};function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=b(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(t,e){var i=parseInt(this._config.skipFirstNLines)||0;if(this.isFirstChunk&&0<i){let e=this._config.newline;e||(r=this._config.quoteChar||'"',e=this._handle.guessLineEndings(t,r)),t=[...t.split(e).slice(i)].join(e)}this.isFirstChunk&&U(this._config.beforeFirstChunk)&&void 0!==(r=this._config.beforeFirstChunk(t))&&(t=r),this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+t,r=(this._partialLine="",this._handle.parse(i,this._baseIndex,!this._finished));if(!this._handle.paused()&&!this._handle.aborted()){t=r.meta.cursor,i=(this._finished||(this._partialLine=i.substring(t-this._baseIndex),this._baseIndex=t),r&&r.data&&(this._rowCount+=r.data.length),this._finished||this._config.preview&&this._rowCount>=this._config.preview);if(a)n.postMessage({results:r,workerId:v.WORKER_ID,finished:i});else if(U(this._config.chunk)&&!e){if(this._config.chunk(r,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);this._completeResults=r=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(r.data),this._completeResults.errors=this._completeResults.errors.concat(r.errors),this._completeResults.meta=r.meta),this._completed||!i||!U(this._config.complete)||r&&r.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),i||r&&r.meta.paused||this._nextChunk(),r}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):a&&this._config.error&&n.postMessage({workerId:v.WORKER_ID,error:e,finished:!1})}}function f(e){var r;(e=e||{}).chunkSize||(e.chunkSize=v.RemoteChunkSize),u.call(this,e),this._nextChunk=s?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),s||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?"POST":"GET",this._input,!s),this._config.downloadRequestHeaders){var e,t=this._config.downloadRequestHeaders;for(e in t)r.setRequestHeader(e,t[e])}var i;this._config.chunkSize&&(i=this._start+this._config.chunkSize-1,r.setRequestHeader("Range","bytes="+this._start+"-"+i));try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}s&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize||r.responseText.length,this._finished=!this._config.chunkSize||this._start>=(e=>null!==(e=e.getResponseHeader("Content-Range"))?parseInt(e.substring(e.lastIndexOf("/")+1)):-1)(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){e=r.statusText||e;this._sendError(new Error(e))}}function l(e){(e=e||{}).chunkSize||(e.chunkSize=v.LocalChunkSize),u.call(this,e);var i,r,n="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,r=e.slice||e.webkitSlice||e.mozSlice,n?((i=new FileReader).onload=y(this._chunkLoaded,this),i.onerror=y(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input,t=(this._config.chunkSize&&(t=Math.min(this._start+this._config.chunkSize,this._input.size),e=r.call(e,this._start,t)),i.readAsText(e,this._config.encoding));n||this._chunkLoaded({target:{result:t}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function c(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){var e,t;if(!this._finished)return e=this._config.chunkSize,i=e?(t=i.substring(0,e),i.substring(e)):(t=i,""),this._finished=!i,this.parseChunk(t)}}function p(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData("")},this),this._streamCleanUp=y(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function i(m){var n,s,a,t,o=Math.pow(2,53),h=-o,u=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,d=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,i=this,r=0,f=0,l=!1,e=!1,c=[],p={data:[],errors:[],meta:{}};function y(e){return"greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){if(p&&a&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+v.DefaultDelimiter+"'"),a=!1),m.skipEmptyLines&&(p.data=p.data.filter(function(e){return!y(e)})),_()){if(p)if(Array.isArray(p.data[0])){for(var e=0;_()&&e<p.data.length;e++)p.data[e].forEach(t);p.data.splice(0,1)}else p.data.forEach(t);function t(e,t){U(m.transformHeader)&&(e=m.transformHeader(e,t)),c.push(e)}}function i(e,t){for(var i=m.header?{}:[],r=0;r<e.length;r++){var n=r,s=e[r],s=((e,t)=>(e=>(m.dynamicTypingFunction&&void 0===m.dynamicTyping[e]&&(m.dynamicTyping[e]=m.dynamicTypingFunction(e)),!0===(m.dynamicTyping[e]||m.dynamicTyping)))(e)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&((e=>{if(u.test(e)){e=parseFloat(e);if(h<e&&e<o)return 1}})(t)?parseFloat(t):d.test(t)?new Date(t):""===t?null:t):t)(n=m.header?r>=c.length?"__parsed_extra":c[r]:n,s=m.transform?m.transform(s,n):s);"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>c.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+c.length+" fields but parsed "+r,f+t):r<c.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+c.length+" fields but parsed "+r,f+t)),i}var r;p&&(m.header||m.dynamicTyping||m.transform)&&(r=1,!p.data.length||Array.isArray(p.data[0])?(p.data=p.data.map(i),r=p.data.length):p.data=i(p.data,0),m.header&&p.meta&&(p.meta.fields=c),f+=r)}function _(){return m.header&&0===c.length}function k(e,t,i,r){e={type:e,code:t,message:i};void 0!==r&&(e.row=r),p.errors.push(e)}U(m.step)&&(t=m.step,m.step=function(e){p=e,_()?g():(g(),0!==p.data.length&&(r+=e.data.length,m.preview&&r>m.preview?s.abort():(p.data=p.data[0],t(p,i))))}),this.parse=function(e,t,i){var r=m.quoteChar||'"',r=(m.newline||(m.newline=this.guessLineEndings(e,r)),a=!1,m.delimiter?U(m.delimiter)&&(m.delimiter=m.delimiter(e),p.meta.delimiter=m.delimiter):((r=((e,t,i,r,n)=>{var s,a,o,h;n=n||[",","\t","|",";",v.RECORD_SEP,v.UNIT_SEP];for(var u=0;u<n.length;u++){for(var d,f=n[u],l=0,c=0,p=0,g=(o=void 0,new E({comments:r,delimiter:f,newline:t,preview:10}).parse(e)),_=0;_<g.data.length;_++)i&&y(g.data[_])?p++:(d=g.data[_].length,c+=d,void 0===o?o=d:0<d&&(l+=Math.abs(d-o),o=d));0<g.data.length&&(c/=g.data.length-p),(void 0===a||l<=a)&&(void 0===h||h<c)&&1.99<c&&(a=l,s=f,h=c)}return{successful:!!(m.delimiter=s),bestDelimiter:s}})(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess)).successful?m.delimiter=r.bestDelimiter:(a=!0,m.delimiter=v.DefaultDelimiter),p.meta.delimiter=m.delimiter),b(m));return m.preview&&m.header&&r.preview++,n=e,s=new E(r),p=s.parse(n,t,i),g(),l?{meta:{paused:!0}}:p||{meta:{paused:!1}}},this.paused=function(){return l},this.pause=function(){l=!0,s.abort(),n=U(m.chunk)?"":n.substring(s.getCharIndex())},this.resume=function(){i.streamer._halted?(l=!1,i.streamer.parseChunk(n,!0)):setTimeout(i.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,s.abort(),p.meta.aborted=!0,U(m.complete)&&m.complete(p),n=""},this.guessLineEndings=function(e,t){e=e.substring(0,1048576);var t=new RegExp(P(t)+"([^]*?)"+P(t),"gm"),i=(e=e.replace(t,"")).split("\r"),t=e.split("\n"),e=1<t.length&&t[0].length<i[0].length;if(1===i.length||e)return"\n";for(var r=0,n=0;n<i.length;n++)"\n"===i[n][0]&&r++;return r>=i.length/2?"\r\n":"\r"}}function P(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(C){var S=(C=C||{}).delimiter,O=C.newline,x=C.comments,I=C.step,A=C.preview,T=C.fastMode,D=null,L=!1,F=null==C.quoteChar?'"':C.quoteChar,j=F;if(void 0!==C.escapeChar&&(j=C.escapeChar),("string"!=typeof S||-1<v.BAD_DELIMITERS.indexOf(S))&&(S=","),x===S)throw new Error("Comment character same as delimiter");!0===x?x="#":("string"!=typeof x||-1<v.BAD_DELIMITERS.indexOf(x))&&(x=!1),"\n"!==O&&"\r"!==O&&"\r\n"!==O&&(O="\n");var z=0,M=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=S.length,s=O.length,a=x.length,o=U(I),h=[],u=[],d=[],f=z=0;if(!i)return w();if(T||!1!==T&&-1===i.indexOf(F)){for(var l=i.split(O),c=0;c<l.length;c++){if(d=l[c],z+=d.length,c!==l.length-1)z+=O.length;else if(r)return w();if(!x||d.substring(0,a)!==x){if(o){if(h=[],k(d.split(S)),R(),M)return w()}else k(d.split(S));if(A&&A<=c)return h=h.slice(0,A),w(!0)}}return w()}for(var p=i.indexOf(S,z),g=i.indexOf(O,z),_=new RegExp(P(j)+P(F),"g"),m=i.indexOf(F,z);;)if(i[z]===F)for(m=z,z++;;){if(-1===(m=i.indexOf(F,m+1)))return r||u.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:h.length,index:z}),E();if(m===n-1)return E(i.substring(z,m).replace(_,F));if(F===j&&i[m+1]===j)m++;else if(F===j||0===m||i[m-1]!==j){-1!==p&&p<m+1&&(p=i.indexOf(S,m+1));var y=v(-1===(g=-1!==g&&g<m+1?i.indexOf(O,m+1):g)?p:Math.min(p,g));if(i.substr(m+1+y,e)===S){d.push(i.substring(z,m).replace(_,F)),i[z=m+1+y+e]!==F&&(m=i.indexOf(F,z)),p=i.indexOf(S,z),g=i.indexOf(O,z);break}y=v(g);if(i.substring(m+1+y,m+1+y+s)===O){if(d.push(i.substring(z,m).replace(_,F)),b(m+1+y+s),p=i.indexOf(S,z),m=i.indexOf(F,z),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0);break}u.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:h.length,index:z}),m++}}else if(x&&0===d.length&&i.substring(z,z+a)===x){if(-1===g)return w();z=g+s,g=i.indexOf(O,z),p=i.indexOf(S,z)}else if(-1!==p&&(p<g||-1===g))d.push(i.substring(z,p)),z=p+e,p=i.indexOf(S,z);else{if(-1===g)break;if(d.push(i.substring(z,g)),b(g+s),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0)}return E();function k(e){h.push(e),f=z}function v(e){var t=0;return t=-1!==e&&(e=i.substring(m+1,e))&&""===e.trim()?e.length:t}function E(e){return r||(void 0===e&&(e=i.substring(z)),d.push(e),z=n,k(d),o&&R()),w()}function b(e){z=e,k(d),d=[],g=i.indexOf(O,z)}function w(e){if(C.header&&!t&&h.length&&!L){var s=h[0],a=Object.create(null),o=new Set(s);let n=!1;for(let r=0;r<s.length;r++){let i=s[r];if(a[i=U(C.transformHeader)?C.transformHeader(i,r):i]){let e,t=a[i];for(;e=i+"_"+t,t++,o.has(e););o.add(e),s[r]=e,a[i]++,n=!0,(D=null===D?{}:D)[e]=i}else a[i]=1,s[r]=i;o.add(i)}n&&console.warn("Duplicate headers found and renamed."),L=!0}return{data:h,errors:u,meta:{delimiter:S,linebreak:O,aborted:M,truncated:!!e,cursor:f+(t||0),renamedHeaders:D}}}function R(){I(w()),h=[],u=[]}},this.abort=function(){M=!0},this.getCharIndex=function(){return z}}function g(e){var t=e.data,i=o[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,_(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:m,resume:m};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&_(t.workerId,t.results)}function _(e,t){var i=o[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete o[e]}function m(){throw new Error("Not implemented.")}function b(e){if("object"!=typeof e||null===e)return e;var t,i=Array.isArray(e)?[]:{};for(t in e)i[t]=b(e[t]);return i}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return"function"==typeof e}return v.parse=function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,!t.worker||!v.WORKERS_SUPPORTED)return i=null,v.NODE_STREAM_INPUT,"string"==typeof e?(e=(e=>65279!==e.charCodeAt(0)?e:e.slice(1))(e),i=new(t.download?f:c)(t)):!0===e.readable&&U(e.read)&&U(e.on)?i=new p(t):(n.File&&e instanceof File||e instanceof Object)&&(i=new l(t)),i.stream(e);(i=(()=>{var e;return!!v.WORKERS_SUPPORTED&&(e=(()=>{var e=n.URL||n.webkitURL||null,t=r.toString();return v.BLOB_URL||(v.BLOB_URL=e.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",t,")();"],{type:"text/javascript"})))})(),(e=new n.Worker(e)).onmessage=g,e.id=h++,o[e.id]=e)})()).userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,i.postMessage({input:e,config:t,workerId:i.id})},v.unparse=function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,i=!1,r=null,o=!1,h=((()=>{if("object"==typeof t){if("string"!=typeof t.delimiter||v.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter),"boolean"!=typeof t.quotes&&"function"!=typeof t.quotes&&!Array.isArray(t.quotes)||(n=t.quotes),"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines),"string"==typeof t.newline&&(y=t.newline),"string"==typeof t.quoteChar&&(s=t.quoteChar),"boolean"==typeof t.header&&(_=t.header),Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s),t.escapeFormulae instanceof RegExp?o=t.escapeFormulae:"boolean"==typeof t.escapeFormulae&&t.escapeFormulae&&(o=/^[=+\-@\t\r].*$/)}})(),new RegExp(P(s),"g"));"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if("object"==typeof e[0])return u(r||Object.keys(e[0]),e,i)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||r),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error("Unable to serialize unrecognized input");function u(e,t,i){var r="",n=("string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t)),Array.isArray(e)&&0<e.length),s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=k(e[a],a);0<t.length&&(r+=y)}for(var o=0;o<t.length;o++){var h=(n?e:t[o]).length,u=!1,d=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u="greedy"===i?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===i&&n){for(var f=[],l=0;l<h;l++){var c=s?e[l]:l;f.push(t[o][c])}u=""===f.join("").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!d&&(r+=m);var g=n&&s?e[p]:p;r+=k(t[o][g],p)}o<t.length-1&&(!i||0<h&&!d)&&(r+=y)}}return r}function k(e,t){var i,r;return null==e?"":e.constructor===Date?JSON.stringify(e).slice(1,25):(r=!1,o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0),i=e.toString().replace(h,a),(r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||((e,t)=>{for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1})(i,v.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i)}},v.RECORD_SEP=String.fromCharCode(30),v.UNIT_SEP=String.fromCharCode(31),v.BYTE_ORDER_MARK="\ufeff",v.BAD_DELIMITERS=["\r","\n",'"',v.BYTE_ORDER_MARK],v.WORKERS_SUPPORTED=!s&&!!n.Worker,v.NODE_STREAM_INPUT=1,v.LocalChunkSize=10485760,v.RemoteChunkSize=5242880,v.DefaultDelimiter=",",v.Parser=E,v.ParserHandle=i,v.NetworkStreamer=f,v.FileStreamer=l,v.StringStreamer=c,v.ReadableStreamStreamer=p,n.jQuery&&((d=n.jQuery).fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&n.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0===h.length)U(o.complete)&&o.complete();else{var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if("skip"===s.action)return void u();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if("skip"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},v.parse(n.file,n.instanceConfig)}}function u(){h.splice(0,1),e()}}),a&&(n.onmessage=function(e){e=e.data;void 0===v.WORKER_ID&&e&&(v.WORKER_ID=e.workerId);"string"==typeof e.input?n.postMessage({workerId:v.WORKER_ID,results:v.parse(e.input,e.config),finished:!0}):(n.File&&e.input instanceof File||e.input instanceof Object)&&(e=v.parse(e.input,e.config))&&n.postMessage({workerId:v.WORKER_ID,results:e,finished:!0})}),(f.prototype=Object.create(u.prototype)).constructor=f,(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(c.prototype)).constructor=c,(p.prototype=Object.create(u.prototype)).constructor=p,v});

/***/ }),

/***/ "./node_modules/sigma/dist/colors-beb06eb2.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/dist/colors-beb06eb2.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ HTML_COLORS),
/* harmony export */   _: () => (/* binding */ _slicedToArray),
/* harmony export */   a: () => (/* binding */ _arrayLikeToArray),
/* harmony export */   b: () => (/* binding */ _unsupportedIterableToArray),
/* harmony export */   c: () => (/* binding */ colorToIndex),
/* harmony export */   d: () => (/* binding */ colorToArray),
/* harmony export */   e: () => (/* binding */ extractPixel),
/* harmony export */   f: () => (/* binding */ floatColor),
/* harmony export */   g: () => (/* binding */ getPixelColor),
/* harmony export */   i: () => (/* binding */ indexToColor),
/* harmony export */   p: () => (/* binding */ parseColor),
/* harmony export */   r: () => (/* binding */ rgbaToFloat)
/* harmony export */ });
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

var HTML_COLORS = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
};

/**
 * Function extracting the color at the given pixel.
 */
function extractPixel(gl, x, y, array) {
  var data = array || new Uint8Array(4);
  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
  return data;
}

/**
 * Memoized function returning a float-encoded color from various string
 * formats describing colors.
 */
var INT8 = new Int8Array(4);
var INT32 = new Int32Array(INT8.buffer, 0, 1);
var FLOAT32 = new Float32Array(INT8.buffer, 0, 1);
var RGBA_TEST_REGEX = /^\s*rgba?\s*\(/;
var RGBA_EXTRACT_REGEX = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;
function parseColor(val) {
  var r = 0; // byte
  var g = 0; // byte
  var b = 0; // byte
  var a = 1; // float

  // Handling hexadecimal notation
  if (val[0] === "#") {
    if (val.length === 4) {
      r = parseInt(val.charAt(1) + val.charAt(1), 16);
      g = parseInt(val.charAt(2) + val.charAt(2), 16);
      b = parseInt(val.charAt(3) + val.charAt(3), 16);
    } else {
      r = parseInt(val.charAt(1) + val.charAt(2), 16);
      g = parseInt(val.charAt(3) + val.charAt(4), 16);
      b = parseInt(val.charAt(5) + val.charAt(6), 16);
    }
    if (val.length === 9) {
      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;
    }
  }

  // Handling rgb notation
  else if (RGBA_TEST_REGEX.test(val)) {
    var match = val.match(RGBA_EXTRACT_REGEX);
    if (match) {
      r = +match[1];
      g = +match[2];
      b = +match[3];
      if (match[4]) a = +match[4];
    }
  }
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
var FLOAT_COLOR_CACHE = {};
for (var htmlColor in HTML_COLORS) {
  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);
  // Replicating cache for hex values for free
  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];
}
function rgbaToFloat(r, g, b, a, masking) {
  INT32[0] = a << 24 | b << 16 | g << 8 | r;
  if (masking) INT32[0] = INT32[0] & 0xfeffffff;
  return FLOAT32[0];
}
function floatColor(val) {
  // The html color names are case-insensitive
  val = val.toLowerCase();

  // If the color is already computed, we yield it
  if (typeof FLOAT_COLOR_CACHE[val] !== "undefined") return FLOAT_COLOR_CACHE[val];
  var parsed = parseColor(val);
  var r = parsed.r,
    g = parsed.g,
    b = parsed.b;
  var a = parsed.a;
  a = a * 255 | 0;
  var color = rgbaToFloat(r, g, b, a, true);
  FLOAT_COLOR_CACHE[val] = color;
  return color;
}
function colorToArray(val, masking) {
  FLOAT32[0] = floatColor(val);
  var intValue = INT32[0];
  if (masking) {
    intValue = intValue | 0x01000000;
  }
  var r = intValue & 0xff;
  var g = intValue >> 8 & 0xff;
  var b = intValue >> 16 & 0xff;
  var a = intValue >> 24 & 0xff;
  return [r, g, b, a];
}
var FLOAT_INDEX_CACHE = {};
function indexToColor(index) {
  // If the index is already computed, we yield it
  if (typeof FLOAT_INDEX_CACHE[index] !== "undefined") return FLOAT_INDEX_CACHE[index];

  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,
  // but with alpha hard-set to 1.0 (or 255):
  var r = (index & 0x00ff0000) >>> 16;
  var g = (index & 0x0000ff00) >>> 8;
  var b = index & 0x000000ff;
  var a = 0x000000ff;

  // The original 4 bytes color encoding was the following:
  // const r = (index & 0xff000000) >>> 24;
  // const g = (index & 0x00ff0000) >>> 16;
  // const b = (index & 0x0000ff00) >>> 8;
  // const a = index & 0x000000ff;

  var color = rgbaToFloat(r, g, b, a, true);
  FLOAT_INDEX_CACHE[index] = color;
  return color;
}
function colorToIndex(r, g, b, _a) {
  // As for the function indexToColor, because of #1397 and the "alpha is always
  // 1.0" strategy, we need to fix this function as well:
  return b + (g << 8) + (r << 16);

  // The original 4 bytes color decoding is the following:
  // return a + (b << 8) + (g << 16) + (r << 24);
}
function getPixelColor(gl, frameBuffer, x, y, pixelRatio, downSizingRatio) {
  var bufferX = Math.floor(x / downSizingRatio * pixelRatio);
  var bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y / downSizingRatio * pixelRatio);
  var pixel = new Uint8Array(4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  var _pixel = _slicedToArray(pixel, 4),
    r = _pixel[0],
    g = _pixel[1],
    b = _pixel[2],
    a = _pixel[3];
  return [r, g, b, a];
}




/***/ }),

/***/ "./node_modules/sigma/dist/data-11df7124.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/dist/data-11df7124.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ _typeof),
/* harmony export */   a: () => (/* binding */ assign),
/* harmony export */   b: () => (/* binding */ assignDeep),
/* harmony export */   e: () => (/* binding */ extend),
/* harmony export */   i: () => (/* binding */ isPlainObject)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

/**
 * Extends the target array with the given values.
 */
function extend(array, values) {
  var l2 = values.size;
  if (l2 === 0) return;
  var l1 = array.length;
  array.length += l2;
  var i = 0;
  values.forEach(function (value) {
    array[l1 + i] = value;
    i++;
  });
}

/**
 * Checks whether the given value is a plain object.
 */
function isPlainObject(value) {
  return _typeof(value) === "object" && value !== null && value.constructor === Object;
}

/**
 * Helper to use `Object.assign` with more than two objects.
 */
function assign(target) {
  target = target || {};
  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    if (!o) continue;
    Object.assign(target, o);
  }
  return target;
}

/**
 * Very simple recursive `Object.assign` like function.
 */
function assignDeep(target) {
  target = target || {};
  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    if (!o) continue;
    for (var k in o) {
      if (isPlainObject(o[k])) {
        target[k] = assignDeep(target[k], o[k]);
      } else {
        target[k] = o[k];
      }
    }
  }
  return target;
}




/***/ }),

/***/ "./node_modules/sigma/dist/index-236c62ad.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/sigma/dist/index-236c62ad.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AbstractNodeProgram),
/* harmony export */   D: () => (/* binding */ DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS),
/* harmony export */   E: () => (/* binding */ EdgeArrowProgram$1),
/* harmony export */   F: () => (/* binding */ FRAGMENT_SHADER_SOURCE),
/* harmony export */   N: () => (/* binding */ NodeCircleProgram),
/* harmony export */   P: () => (/* binding */ Program),
/* harmony export */   _: () => (/* binding */ _objectSpread2),
/* harmony export */   a: () => (/* binding */ _defineProperty),
/* harmony export */   b: () => (/* binding */ drawDiscNodeLabel),
/* harmony export */   c: () => (/* binding */ drawDiscNodeHover),
/* harmony export */   d: () => (/* binding */ drawStraightEdgeLabel),
/* harmony export */   e: () => (/* binding */ EdgeRectangleProgram),
/* harmony export */   f: () => (/* binding */ NodeProgram),
/* harmony export */   g: () => (/* binding */ EdgeProgram),
/* harmony export */   h: () => (/* binding */ createEdgeCompoundProgram),
/* harmony export */   i: () => (/* binding */ createEdgeArrowHeadProgram),
/* harmony export */   j: () => (/* binding */ createNodeCompoundProgram),
/* harmony export */   k: () => (/* binding */ AbstractEdgeProgram),
/* harmony export */   l: () => (/* binding */ AbstractProgram),
/* harmony export */   m: () => (/* binding */ EdgeArrowHeadProgram$1),
/* harmony export */   n: () => (/* binding */ EdgeClampedProgram$1),
/* harmony export */   o: () => (/* binding */ createEdgeClampedProgram),
/* harmony export */   p: () => (/* binding */ DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS),
/* harmony export */   q: () => (/* binding */ createEdgeArrowProgram),
/* harmony export */   r: () => (/* binding */ getAttributeItemsCount),
/* harmony export */   s: () => (/* binding */ getAttributesItemsCount),
/* harmony export */   t: () => (/* binding */ loadVertexShader),
/* harmony export */   u: () => (/* binding */ loadFragmentShader),
/* harmony export */   v: () => (/* binding */ loadProgram),
/* harmony export */   w: () => (/* binding */ killProgram),
/* harmony export */   x: () => (/* binding */ numberToGLSLFloat)
/* harmony export */ });
/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");



function _defineProperty(e, r, t) {
  return (r = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(t)););
  return t;
}

function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

function _superPropGet(t, o, e, r) {
  var p = _get((0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function (t) {
    return p.apply(e, t);
  } : p;
}

function getAttributeItemsCount(attr) {
  return attr.normalized ? 1 : attr.size;
}
function getAttributesItemsCount(attrs) {
  var res = 0;
  attrs.forEach(function (attr) {
    return res += getAttributeItemsCount(attr);
  });
  return res;
}
function loadShader(type, gl, source) {
  var glType = type === "VERTEX" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;

  // Creating the shader
  var shader = gl.createShader(glType);
  if (shader === null) {
    throw new Error("loadShader: error while creating the shader");
  }

  // Loading source
  gl.shaderSource(shader, source);

  // Compiling the shader
  gl.compileShader(shader);

  // Retrieving compilation status
  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  // Throwing if something went awry
  if (!successfullyCompiled) {
    var infoLog = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error("loadShader: error while compiling the shader:\n".concat(infoLog, "\n").concat(source));
  }
  return shader;
}
function loadVertexShader(gl, source) {
  return loadShader("VERTEX", gl, source);
}
function loadFragmentShader(gl, source) {
  return loadShader("FRAGMENT", gl, source);
}

/**
 * Function used to load a program.
 */
function loadProgram(gl, shaders) {
  var program = gl.createProgram();
  if (program === null) {
    throw new Error("loadProgram: error while creating the program.");
  }
  var i, l;

  // Attaching the shaders
  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);
  gl.linkProgram(program);

  // Checking status
  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!successfullyLinked) {
    gl.deleteProgram(program);
    throw new Error("loadProgram: error while linking the program.");
  }
  return program;
}
function killProgram(_ref) {
  var gl = _ref.gl,
    buffer = _ref.buffer,
    program = _ref.program,
    vertexShader = _ref.vertexShader,
    fragmentShader = _ref.fragmentShader;
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  gl.deleteBuffer(buffer);
}

/**
 * Function use to print a float for inserting in a GLSL program.
 */
function numberToGLSLFloat(n) {
  return n % 1 === 0 ? n.toFixed(1) : n.toString();
}

var PICKING_PREFIX = "#define PICKING_MODE\n";
var SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);
var AbstractProgram = /*#__PURE__*/(0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(function AbstractProgram(_gl, _pickGl, _renderer) {
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractProgram);
});
var Program = /*#__PURE__*/function () {
  function Program(gl, pickingBuffer, renderer) {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, Program);
    // GLenum
    _defineProperty(this, "array", new Float32Array());
    _defineProperty(this, "constantArray", new Float32Array());
    _defineProperty(this, "capacity", 0);
    _defineProperty(this, "verticesCount", 0);
    // Reading and caching program definition
    var def = this.getDefinition();
    this.VERTICES = def.VERTICES;
    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;
    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;
    this.UNIFORMS = def.UNIFORMS;
    this.ATTRIBUTES = def.ATTRIBUTES;
    this.METHOD = def.METHOD;
    this.CONSTANT_ATTRIBUTES = "CONSTANT_ATTRIBUTES" in def ? def.CONSTANT_ATTRIBUTES : [];
    this.CONSTANT_DATA = "CONSTANT_DATA" in def ? def.CONSTANT_DATA : [];
    this.isInstanced = "CONSTANT_ATTRIBUTES" in def;

    // Computing stride
    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);
    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;

    // Members
    this.renderer = renderer;
    this.normalProgram = this.getProgramInfo("normal", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);
    this.pickProgram = pickingBuffer ? this.getProgramInfo("pick", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;

    // For instanced programs:
    if (this.isInstanced) {
      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);
      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error("Program: error while getting constant data (expected ".concat(this.VERTICES, " items, received ").concat(this.CONSTANT_DATA.length, " instead)"));
      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);
      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {
        var vector = this.CONSTANT_DATA[i];
        if (vector.length !== constantAttributesItemsCount) throw new Error("Program: error while getting constant data (one vector has ".concat(vector.length, " items instead of ").concat(constantAttributesItemsCount, ")"));
        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];
      }
      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;
    }
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(Program, [{
    key: "kill",
    value: function kill() {
      killProgram(this.normalProgram);
      if (this.pickProgram) {
        killProgram(this.pickProgram);
        this.pickProgram = null;
      }
    }
  }, {
    key: "getProgramInfo",
    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {
      var def = this.getDefinition();

      // WebGL buffers
      var buffer = gl.createBuffer();
      if (buffer === null) throw new Error("Program: error while creating the WebGL buffer.");

      // Shaders and program
      var vertexShader = loadVertexShader(gl, vertexShaderSource);
      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);
      var program = loadProgram(gl, [vertexShader, fragmentShader]);

      // Initializing locations
      var uniformLocations = {};
      def.UNIFORMS.forEach(function (uniformName) {
        var location = gl.getUniformLocation(program, uniformName);
        if (location) uniformLocations[uniformName] = location;
      });
      var attributeLocations = {};
      def.ATTRIBUTES.forEach(function (attr) {
        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
      });

      // For instanced programs:
      var constantBuffer;
      if ("CONSTANT_ATTRIBUTES" in def) {
        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
        });
        constantBuffer = gl.createBuffer();
        if (constantBuffer === null) throw new Error("Program: error while creating the WebGL constant buffer.");
      }
      return {
        name: name,
        program: program,
        gl: gl,
        frameBuffer: frameBuffer,
        buffer: buffer,
        constantBuffer: constantBuffer || {},
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        isPicking: name === "pick",
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      };
    }
  }, {
    key: "bindProgram",
    value: function bindProgram(program) {
      var _this = this;
      var offset = 0;
      var gl = program.gl,
        buffer = program.buffer;
      if (!this.isInstanced) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        offset = 0;
        this.ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      } else {
        // Handle constant data (things that remain unchanged for all items):
        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);
        offset = 0;
        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset, false);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);

        // Handle "instance specific" data (things that vary for each item):
        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);
        offset = 0;
        this.ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset, true);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
  }, {
    key: "unbindProgram",
    value: function unbindProgram(program) {
      var _this2 = this;
      if (!this.isInstanced) {
        this.ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program);
        });
      } else {
        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program, false);
        });
        this.ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program, true);
        });
      }
    }
  }, {
    key: "bindAttribute",
    value: function bindAttribute(attr, program, offset, setDivisor) {
      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];
      if (typeof sizeFactor !== "number") throw new Error("Program.bind: yet unsupported attribute type \"".concat(attr.type, "\""));
      var location = program.attributeLocations[attr.name];
      var gl = program.gl;
      if (location !== -1) {
        gl.enableVertexAttribArray(location);
        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);
        if (this.isInstanced && setDivisor) {
          if (gl instanceof WebGL2RenderingContext) {
            gl.vertexAttribDivisor(location, 1);
          } else {
            var ext = gl.getExtension("ANGLE_instanced_arrays");
            if (ext) ext.vertexAttribDivisorANGLE(location, 1);
          }
        }
      }
      return attr.size * sizeFactor;
    }
  }, {
    key: "unbindAttribute",
    value: function unbindAttribute(attr, program, unsetDivisor) {
      var location = program.attributeLocations[attr.name];
      var gl = program.gl;
      if (location !== -1) {
        gl.disableVertexAttribArray(location);
        if (this.isInstanced && unsetDivisor) {
          if (gl instanceof WebGL2RenderingContext) {
            gl.vertexAttribDivisor(location, 0);
          } else {
            var ext = gl.getExtension("ANGLE_instanced_arrays");
            if (ext) ext.vertexAttribDivisorANGLE(location, 0);
          }
        }
      }
    }
  }, {
    key: "reallocate",
    value: function reallocate(capacity) {
      // If desired capacity has not changed we do nothing
      // NOTE: it's possible here to implement more subtle reallocation schemes
      // when the number of rendered items increase or decrease
      if (capacity === this.capacity) return;
      this.capacity = capacity;
      this.verticesCount = this.VERTICES * capacity;
      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);
    }
  }, {
    key: "hasNothingToRender",
    value: function hasNothingToRender() {
      return this.verticesCount === 0;
    }
  }, {
    key: "renderProgram",
    value: function renderProgram(params, programInfo) {
      var gl = programInfo.gl,
        program = programInfo.program;

      // With the current fix for #1397, the alpha blending is enabled for the
      // picking layer:
      gl.enable(gl.BLEND);

      // Original code:
      // if (!isPicking) gl.enable(gl.BLEND);
      // else gl.disable(gl.BLEND);

      gl.useProgram(program);
      this.setUniforms(params, programInfo);
      this.drawWebGL(this.METHOD, programInfo);
    }
  }, {
    key: "render",
    value: function render(params) {
      if (this.hasNothingToRender()) return;
      if (this.pickProgram) {
        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);
        this.bindProgram(this.pickProgram);
        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {
          pixelRatio: params.pixelRatio / params.downSizingRatio
        }), this.pickProgram);
        this.unbindProgram(this.pickProgram);
      }
      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);
      this.bindProgram(this.normalProgram);
      this.renderProgram(params, this.normalProgram);
      this.unbindProgram(this.normalProgram);
    }
  }, {
    key: "drawWebGL",
    value: function drawWebGL(method, _ref) {
      var gl = _ref.gl,
        frameBuffer = _ref.frameBuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      if (!this.isInstanced) {
        gl.drawArrays(method, 0, this.verticesCount);
      } else {
        if (gl instanceof WebGL2RenderingContext) {
          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);
        } else {
          var ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);
        }
      }
    }
  }]);
}();

var AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {
  function AbstractNodeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractNodeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractNodeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractNodeProgram, _AbstractProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractNodeProgram);
}(AbstractProgram);
var NodeProgram = /*#__PURE__*/function (_ref) {
  function NodeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeProgram, _ref);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeProgram, [{
    key: "kill",
    value: function kill() {
      _superPropGet(NodeProgram, "kill", this, 3)([]);
    }
  }, {
    key: "process",
    value: function process(nodeIndex, offset, data) {
      var i = offset * this.STRIDE;
      // NOTE: dealing with hidden items automatically
      if (data.hidden) {
        for (var l = i + this.STRIDE; i < l; i++) {
          this.array[i] = 0;
        }
        return;
      }
      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(nodeIndex), i, data);
    }
  }]);
}(Program);
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @param  {function} drawLabel - An optional node "draw label" function.
 * @param  {function} drawHover - An optional node "draw hover" function.
 * @return {function}
 */
function createNodeCompoundProgram(programClasses, drawLabel, drawHover) {
  return /*#__PURE__*/function () {
    function NodeCompoundProgram(gl, pickingBuffer, renderer) {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCompoundProgram);
      _defineProperty(this, "drawLabel", drawLabel);
      _defineProperty(this, "drawHover", drawHover);
      this.programs = programClasses.map(function (Program) {
        return new Program(gl, pickingBuffer, renderer);
      });
    }
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCompoundProgram, [{
      key: "reallocate",
      value: function reallocate(capacity) {
        this.programs.forEach(function (program) {
          return program.reallocate(capacity);
        });
      }
    }, {
      key: "process",
      value: function process(nodeIndex, offset, data) {
        this.programs.forEach(function (program) {
          return program.process(nodeIndex, offset, data);
        });
      }
    }, {
      key: "render",
      value: function render(params) {
        this.programs.forEach(function (program) {
          return program.render(params);
        });
      }
    }, {
      key: "kill",
      value: function kill() {
        this.programs.forEach(function (program) {
          return program.kill();
        });
      }
    }]);
  }();
}

var AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {
  function AbstractEdgeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractEdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractEdgeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractEdgeProgram, _AbstractProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractEdgeProgram);
}(AbstractProgram);
var EdgeProgram = /*#__PURE__*/function (_ref) {
  function EdgeProgram() {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeProgram);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeProgram, [].concat(args));
    _defineProperty(_this, "drawLabel", undefined);
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeProgram, _ref);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeProgram, [{
    key: "kill",
    value: function kill() {
      _superPropGet(EdgeProgram, "kill", this, 3)([]);
    }
  }, {
    key: "process",
    value: function process(edgeIndex, offset, sourceData, targetData, data) {
      var i = offset * this.STRIDE;
      // NOTE: dealing with hidden items automatically
      if (data.hidden || sourceData.hidden || targetData.hidden) {
        for (var l = i + this.STRIDE; i < l; i++) {
          this.array[i] = 0;
        }
        return;
      }
      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(edgeIndex), i, sourceData, targetData, data);
    }
  }]);
}(Program);
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @param  {function} drawLabel - An optional edge "draw label" function.
 * @return {function}
 */
function createEdgeCompoundProgram(programClasses, drawLabel) {
  return /*#__PURE__*/function () {
    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeCompoundProgram);
      _defineProperty(this, "drawLabel", drawLabel);
      this.programs = programClasses.map(function (Program) {
        return new Program(gl, pickingBuffer, renderer);
      });
    }
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeCompoundProgram, [{
      key: "reallocate",
      value: function reallocate(capacity) {
        this.programs.forEach(function (program) {
          return program.reallocate(capacity);
        });
      }
    }, {
      key: "process",
      value: function process(edgeIndex, offset, sourceData, targetData, data) {
        this.programs.forEach(function (program) {
          return program.process(edgeIndex, offset, sourceData, targetData, data);
        });
      }
    }, {
      key: "render",
      value: function render(params) {
        this.programs.forEach(function (program) {
          return program.render(params);
        });
      }
    }, {
      key: "kill",
      value: function kill() {
        this.programs.forEach(function (program) {
          return program.kill();
        });
      }
    }]);
  }();
}

function drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {
  var size = settings.edgeLabelSize,
    font = settings.edgeLabelFont,
    weight = settings.edgeLabelWeight,
    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || "#000" : settings.edgeLabelColor.color;
  var label = edgeData.label;
  if (!label) return;
  context.fillStyle = color;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);

  // Computing positions without considering nodes sizes:
  var sSize = sourceData.size;
  var tSize = targetData.size;
  var sx = sourceData.x;
  var sy = sourceData.y;
  var tx = targetData.x;
  var ty = targetData.y;
  var cx = (sx + tx) / 2;
  var cy = (sy + ty) / 2;
  var dx = tx - sx;
  var dy = ty - sy;
  var d = Math.sqrt(dx * dx + dy * dy);
  if (d < sSize + tSize) return;

  // Adding nodes sizes:
  sx += dx * sSize / d;
  sy += dy * sSize / d;
  tx -= dx * tSize / d;
  ty -= dy * tSize / d;
  cx = (sx + tx) / 2;
  cy = (sy + ty) / 2;
  dx = tx - sx;
  dy = ty - sy;
  d = Math.sqrt(dx * dx + dy * dy);

  // Handling ellipsis
  var textLength = context.measureText(label).width;
  if (textLength > d) {
    var ellipsis = "…";
    label = label + ellipsis;
    textLength = context.measureText(label).width;
    while (textLength > d && label.length > 1) {
      label = label.slice(0, -2) + ellipsis;
      textLength = context.measureText(label).width;
    }
    if (label.length < 4) return;
  }
  var angle;
  if (dx > 0) {
    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);
  } else {
    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;
  }
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);
  context.restore();
}

function drawDiscNodeLabel(context, data, settings) {
  if (!data.label) return;
  var size = settings.labelSize,
    font = settings.labelFont,
    weight = settings.labelWeight,
    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || "#000" : settings.labelColor.color;
  context.fillStyle = color;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);
}

/**
 * Draw an hovered node.
 * - if there is no label => display a shadow on the node
 * - if the label box is bigger than node size => display a label box that contains the node with a shadow
 * - else node with shadow and the label box
 */
function drawDiscNodeHover(context, data, settings) {
  var size = settings.labelSize,
    font = settings.labelFont,
    weight = settings.labelWeight;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);

  // Then we draw the label background
  context.fillStyle = "#FFF";
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 8;
  context.shadowColor = "#000";
  var PADDING = 2;
  if (typeof data.label === "string") {
    var textWidth = context.measureText(data.label).width,
      boxWidth = Math.round(textWidth + 5),
      boxHeight = Math.round(size + 2 * PADDING),
      radius = Math.max(data.size, size / 2) + PADDING;
    var angleRadian = Math.asin(boxHeight / 2 / radius);
    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));
    context.beginPath();
    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);
    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);
    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);
    context.closePath();
    context.fill();
  } else {
    context.beginPath();
    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);
    context.closePath();
    context.fill();
  }
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 0;

  // And finally we draw the label
  drawDiscNodeLabel(context, data, settings);
}

// language=GLSL
var SHADER_SOURCE$6 = /*glsl*/"\nprecision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\n\nuniform float u_correctionRatio;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float border = u_correctionRatio * 2.0;\n  float dist = length(v_diffVector) - v_radius + border;\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > border)\n    gl_FragColor = transparent;\n  else\n    gl_FragColor = v_color;\n\n  #else\n  float t = 0.0;\n  if (dist > border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / border;\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n";
var FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;

// language=GLSL
var SHADER_SOURCE$5 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_diffVector = diffVector;\n  v_radius = size / 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;

var _WebGLRenderingContex$3 = WebGLRenderingContext,
  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,
  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;
var UNIFORMS$3 = ["u_sizeRatio", "u_correctionRatio", "u_matrix"];
var NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {
  function NodeCircleProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCircleProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeCircleProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeCircleProgram, _NodeProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCircleProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 3,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS$3,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$3
        }, {
          name: "a_size",
          size: 1,
          type: FLOAT$3
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [{
          name: "a_angle",
          size: 1,
          type: FLOAT$3
        }],
        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(nodeIndex, startIndex, data) {
      var array = this.array;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);
      array[startIndex++] = data.x;
      array[startIndex++] = data.y;
      array[startIndex++] = data.size;
      array[startIndex++] = color;
      array[startIndex++] = nodeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_sizeRatio = uniformLocations.u_sizeRatio,
        u_correctionRatio = uniformLocations.u_correctionRatio,
        u_matrix = uniformLocations.u_matrix;
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
    }
  }]);
}(NodeProgram);
_defineProperty(NodeCircleProgram, "ANGLE_1", 0);
_defineProperty(NodeCircleProgram, "ANGLE_2", 2 * Math.PI / 3);
_defineProperty(NodeCircleProgram, "ANGLE_3", 4 * Math.PI / 3);

// language=GLSL
var SHADER_SOURCE$4 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";
var FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;

// language=GLSL
var SHADER_SOURCE$3 = /*glsl*/"\nattribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec3 a_barycentric;\n\n#ifdef PICKING_MODE\nattribute vec4 a_id;\n#else\nattribute vec4 a_color;\n#endif\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_widenessToThicknessRatio;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (webGLNodeRadius * unitNormal.y)\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),\n\n      da * (-webGLNodeRadius * unitNormal.x)\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;

var _WebGLRenderingContex$2 = WebGLRenderingContext,
  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,
  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;
var UNIFORMS$2 = ["u_matrix", "u_sizeRatio", "u_correctionRatio", "u_minEdgeThickness", "u_lengthToThicknessRatio", "u_widenessToThicknessRatio"];
var DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS = {
  extremity: "target",
  lengthToThicknessRatio: 2.5,
  widenessToThicknessRatio: 2
};
function createEdgeArrowHeadProgram(inputOptions) {
  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), inputOptions || {});
  return /*#__PURE__*/function (_EdgeProgram) {
    function EdgeArrowHeadProgram() {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeArrowHeadProgram);
      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeArrowHeadProgram, arguments);
    }
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeArrowHeadProgram, _EdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeArrowHeadProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 3,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,
          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS$2,
          ATTRIBUTES: [{
            name: "a_position",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_normal",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_radius",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }],
          CONSTANT_ATTRIBUTES: [{
            name: "a_barycentric",
            size: 3,
            type: FLOAT$2
          }],
          CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        if (options.extremity === "source") {
          var _ref = [targetData, sourceData];
          sourceData = _ref[0];
          targetData = _ref[1];
        }
        var thickness = data.size || 1;
        var radius = targetData.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len * thickness;
          n2 = dx * len * thickness;
        }
        var array = this.array;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        array[startIndex++] = -n1;
        array[startIndex++] = -n2;
        array[startIndex++] = radius;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref2) {
        var gl = _ref2.gl,
          uniformLocations = _ref2.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_correctionRatio = uniformLocations.u_correctionRatio,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,
          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,
          u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
        gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);
      }
    }]);
  }(EdgeProgram);
}
var EdgeArrowHeadProgram = createEdgeArrowHeadProgram();
var EdgeArrowHeadProgram$1 = EdgeArrowHeadProgram;

// language=GLSL
var SHADER_SOURCE$2 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  // We only handle antialiasing for normal mode:\n  #ifdef PICKING_MODE\n  gl_FragColor = v_color;\n  #else\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - v_feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n";
var FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;

// language=GLSL
var SHADER_SOURCE$1 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_radius;\nattribute float a_radiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float radius = a_radius * a_radiusCoef;\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(radius);\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;

var _WebGLRenderingContex$1 = WebGLRenderingContext,
  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,
  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;
var UNIFORMS$1 = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio", "u_pixelRatio", "u_feather", "u_minEdgeThickness", "u_lengthToThicknessRatio"];
var DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS = {
  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio
};
function createEdgeClampedProgram(inputOptions) {
  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});
  return /*#__PURE__*/function (_EdgeProgram) {
    function EdgeClampedProgram() {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeClampedProgram);
      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeClampedProgram, arguments);
    }
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeClampedProgram, _EdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeClampedProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 6,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,
          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS$1,
          ATTRIBUTES: [{
            name: "a_positionStart",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_positionEnd",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_normal",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE$1,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE$1,
            normalized: true
          }, {
            name: "a_radius",
            size: 1,
            type: FLOAT$1
          }],
          CONSTANT_ATTRIBUTES: [
          // If 0, then position will be a_positionStart
          // If 1, then position will be a_positionEnd
          {
            name: "a_positionCoef",
            size: 1,
            type: FLOAT$1
          }, {
            name: "a_normalCoef",
            size: 1,
            type: FLOAT$1
          }, {
            name: "a_radiusCoef",
            size: 1,
            type: FLOAT$1
          }],
          CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var radius = targetData.size || 1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len * thickness;
          n2 = dx * len * thickness;
        }
        var array = this.array;
        array[startIndex++] = x1;
        array[startIndex++] = y1;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        array[startIndex++] = n1;
        array[startIndex++] = n2;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
        array[startIndex++] = radius;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref) {
        var gl = _ref.gl,
          uniformLocations = _ref.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_zoomRatio = uniformLocations.u_zoomRatio,
          u_feather = uniformLocations.u_feather,
          u_pixelRatio = uniformLocations.u_pixelRatio,
          u_correctionRatio = uniformLocations.u_correctionRatio,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,
          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_zoomRatio, params.zoomRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_feather, params.antiAliasingFeather);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
      }
    }]);
  }(EdgeProgram);
}
var EdgeClampedProgram = createEdgeClampedProgram();
var EdgeClampedProgram$1 = EdgeClampedProgram;

function createEdgeArrowProgram(inputOptions) {
  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);
}
var EdgeArrowProgram = createEdgeArrowProgram();
var EdgeArrowProgram$1 = EdgeArrowProgram;

// language=GLSL
var SHADER_SOURCE = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_zoomRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // We require edges to be at least \"minThickness\" pixels thick *on screen*\n  // (so we need to compensate the size ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasing effect does not depend on the zoom level. So here's yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE = SHADER_SOURCE;

var _WebGLRenderingContex = WebGLRenderingContext,
  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,
  FLOAT = _WebGLRenderingContex.FLOAT;
var UNIFORMS = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio", "u_pixelRatio", "u_feather", "u_minEdgeThickness"];
var EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {
  function EdgeRectangleProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeRectangleProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeRectangleProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeRectangleProgram, _EdgeProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeRectangleProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 6,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS,
        ATTRIBUTES: [{
          name: "a_positionStart",
          size: 2,
          type: FLOAT
        }, {
          name: "a_positionEnd",
          size: 2,
          type: FLOAT
        }, {
          name: "a_normal",
          size: 2,
          type: FLOAT
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 2, then position will be a_positionEnd
        {
          name: "a_positionCoef",
          size: 1,
          type: FLOAT
        }, {
          name: "a_normalCoef",
          size: 1,
          type: FLOAT
        }],
        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var thickness = data.size || 1;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

      // Computing normals
      var dx = x2 - x1;
      var dy = y2 - y1;
      var len = dx * dx + dy * dy;
      var n1 = 0;
      var n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      var array = this.array;
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = n1;
      array[startIndex++] = n2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix,
        u_zoomRatio = uniformLocations.u_zoomRatio,
        u_feather = uniformLocations.u_feather,
        u_pixelRatio = uniformLocations.u_pixelRatio,
        u_correctionRatio = uniformLocations.u_correctionRatio,
        u_sizeRatio = uniformLocations.u_sizeRatio,
        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_zoomRatio, params.zoomRatio);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_pixelRatio, params.pixelRatio);
      gl.uniform1f(u_feather, params.antiAliasingFeather);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
    }
  }]);
}(EdgeProgram);




/***/ }),

/***/ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/dist/inherits-d1a1e29b.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ _inherits),
/* harmony export */   a: () => (/* binding */ _createClass),
/* harmony export */   b: () => (/* binding */ _classCallCheck),
/* harmony export */   c: () => (/* binding */ _callSuper),
/* harmony export */   d: () => (/* binding */ _toPropertyKey),
/* harmony export */   e: () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}




/***/ }),

/***/ "./node_modules/sigma/dist/normalization-be445518.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/sigma/dist/normalization-be445518.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ANIMATE_DEFAULTS),
/* harmony export */   a: () => (/* binding */ getMatrixImpact),
/* harmony export */   b: () => (/* binding */ createElement),
/* harmony export */   c: () => (/* binding */ createNormalizationFunction),
/* harmony export */   d: () => (/* binding */ getPixelRatio),
/* harmony export */   e: () => (/* binding */ easings),
/* harmony export */   f: () => (/* binding */ multiplyVec2),
/* harmony export */   g: () => (/* binding */ graphExtent),
/* harmony export */   h: () => (/* binding */ animateNodes),
/* harmony export */   i: () => (/* binding */ identity),
/* harmony export */   j: () => (/* binding */ getCorrectionRatio),
/* harmony export */   k: () => (/* binding */ quadraticOut),
/* harmony export */   l: () => (/* binding */ linear),
/* harmony export */   m: () => (/* binding */ matrixFromCamera),
/* harmony export */   n: () => (/* binding */ quadraticInOut),
/* harmony export */   o: () => (/* binding */ cubicIn),
/* harmony export */   p: () => (/* binding */ cubicOut),
/* harmony export */   q: () => (/* binding */ quadraticIn),
/* harmony export */   r: () => (/* binding */ cubicInOut),
/* harmony export */   s: () => (/* binding */ scale),
/* harmony export */   t: () => (/* binding */ rotate),
/* harmony export */   u: () => (/* binding */ translate),
/* harmony export */   v: () => (/* binding */ validateGraph),
/* harmony export */   w: () => (/* binding */ multiply),
/* harmony export */   z: () => (/* binding */ zIndexOrdering)
/* harmony export */ });
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");



var linear = function linear(k) {
  return k;
};
var quadraticIn = function quadraticIn(k) {
  return k * k;
};
var quadraticOut = function quadraticOut(k) {
  return k * (2 - k);
};
var quadraticInOut = function quadraticInOut(k) {
  if ((k *= 2) < 1) return 0.5 * k * k;
  return -0.5 * (--k * (k - 2) - 1);
};
var cubicIn = function cubicIn(k) {
  return k * k * k;
};
var cubicOut = function cubicOut(k) {
  return --k * k * k + 1;
};
var cubicInOut = function cubicInOut(k) {
  if ((k *= 2) < 1) return 0.5 * k * k * k;
  return 0.5 * ((k -= 2) * k * k + 2);
};
var easings = {
  linear: linear,
  quadraticIn: quadraticIn,
  quadraticOut: quadraticOut,
  quadraticInOut: quadraticInOut,
  cubicIn: cubicIn,
  cubicOut: cubicOut,
  cubicInOut: cubicInOut
};

/**
 * Defaults.
 */

var ANIMATE_DEFAULTS = {
  easing: "quadraticInOut",
  duration: 150
};

/**
 * Function used to animate the nodes.
 */
function animateNodes(graph, targets, opts, callback) {
  var options = Object.assign({}, ANIMATE_DEFAULTS, opts);
  var easing = typeof options.easing === "function" ? options.easing : easings[options.easing];
  var start = Date.now();
  var startPositions = {};
  for (var node in targets) {
    var attrs = targets[node];
    startPositions[node] = {};
    for (var _k in attrs) startPositions[node][_k] = graph.getNodeAttribute(node, _k);
  }
  var frame = null;
  var _step = function step() {
    frame = null;
    var p = (Date.now() - start) / options.duration;
    if (p >= 1) {
      // Animation is done
      for (var _node in targets) {
        var _attrs = targets[_node];

        // We use given values to avoid precision issues and for convenience
        for (var _k2 in _attrs) graph.setNodeAttribute(_node, _k2, _attrs[_k2]);
      }
      if (typeof callback === "function") callback();
      return;
    }
    p = easing(p);
    for (var _node2 in targets) {
      var _attrs2 = targets[_node2];
      var s = startPositions[_node2];
      for (var _k3 in _attrs2) graph.setNodeAttribute(_node2, _k3, _attrs2[_k3] * p + s[_k3] * (1 - p));
    }
    frame = requestAnimationFrame(_step);
  };
  _step();
  return function () {
    if (frame) cancelAnimationFrame(frame);
  };
}

function identity() {
  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

// TODO: optimize
function scale(m, x, y) {
  m[0] = x;
  m[4] = typeof y === "number" ? y : x;
  return m;
}
function rotate(m, r) {
  var s = Math.sin(r),
    c = Math.cos(r);
  m[0] = c;
  m[1] = s;
  m[3] = -s;
  m[4] = c;
  return m;
}
function translate(m, x, y) {
  m[6] = x;
  m[7] = y;
  return m;
}
function multiply(a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  a[0] = b00 * a00 + b01 * a10 + b02 * a20;
  a[1] = b00 * a01 + b01 * a11 + b02 * a21;
  a[2] = b00 * a02 + b01 * a12 + b02 * a22;
  a[3] = b10 * a00 + b11 * a10 + b12 * a20;
  a[4] = b10 * a01 + b11 * a11 + b12 * a21;
  a[5] = b10 * a02 + b11 * a12 + b12 * a22;
  a[6] = b20 * a00 + b21 * a10 + b22 * a20;
  a[7] = b20 * a01 + b21 * a11 + b22 * a21;
  a[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return a;
}
function multiplyVec2(a, b) {
  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var a00 = a[0];
  var a01 = a[1];
  var a10 = a[3];
  var a11 = a[4];
  var a20 = a[6];
  var a21 = a[7];
  var b0 = b.x;
  var b1 = b.y;
  return {
    x: b0 * a00 + b1 * a10 + a20 * z,
    y: b0 * a01 + b1 * a11 + a21 * z
  };
}

/**
 * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This
 * helps to deal with quadtree in particular.
 * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two
 * nodes "touching" opposite sides of the graph, with the camera being at its default state.
 *
 * This function determines this ratio.
 */
function getCorrectionRatio(viewportDimensions, graphDimensions) {
  var viewportRatio = viewportDimensions.height / viewportDimensions.width;
  var graphRatio = graphDimensions.height / graphDimensions.width;

  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage
  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:
  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {
    return 1;
  }

  // Else, we need to fit the graph inside the stage:
  // 1. If the graph is "squarer" (i.e. with a ratio closer to 1), we need to make the largest sides touch;
  // 2. If the stage is "squarer", we need to make the smallest sides touch.
  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));
}

/**
 * Function returning a matrix from the current state of the camera.
 */
function matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {
  // TODO: it's possible to optimize this drastically!
  var angle = state.angle,
    ratio = state.ratio,
    x = state.x,
    y = state.y;
  var width = viewportDimensions.width,
    height = viewportDimensions.height;
  var matrix = identity();
  var smallestDimension = Math.min(width, height) - 2 * padding;
  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);
  if (!inverse) {
    multiply(matrix, scale(identity(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));
    multiply(matrix, rotate(identity(), -angle));
    multiply(matrix, scale(identity(), 1 / ratio));
    multiply(matrix, translate(identity(), -x, -y));
  } else {
    multiply(matrix, translate(identity(), x, y));
    multiply(matrix, scale(identity(), ratio));
    multiply(matrix, rotate(identity(), angle));
    multiply(matrix, scale(identity(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));
  }
  return matrix;
}

/**
 * All these transformations we apply on the matrix to get it rescale the graph
 * as we want make it very hard to get pixel-perfect distances in WebGL. This
 * function returns a factor that properly cancels the matrix effect on lengths.
 *
 * [jacomyal]
 * To be fully honest, I can't really explain happens here... I notice that the
 * following ratio works (i.e. it correctly compensates the matrix impact on all
 * camera states I could try):
 * > `R = size(V) / size(M * V) / W`
 * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works
 * as well with H and a vector that transforms into something parallel to (Oy).
 *
 * Also, note that we use `angle` and not `-angle` (that would seem logical,
 * since we want to anticipate the rotation), because the image is vertically
 * swapped in WebGL.
 */
function getMatrixImpact(matrix, cameraState, viewportDimensions) {
  var _multiplyVec = multiplyVec2(matrix, {
      x: Math.cos(cameraState.angle),
      y: Math.sin(cameraState.angle)
    }, 0),
    x = _multiplyVec.x,
    y = _multiplyVec.y;
  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;
}

/**
 * Function returning the graph's node extent in x & y.
 */
function graphExtent(graph) {
  if (!graph.order) return {
    x: [0, 1],
    y: [0, 1]
  };
  var xMin = Infinity;
  var xMax = -Infinity;
  var yMin = Infinity;
  var yMax = -Infinity;
  graph.forEachNode(function (_, attr) {
    var x = attr.x,
      y = attr.y;
    if (x < xMin) xMin = x;
    if (x > xMax) xMax = x;
    if (y < yMin) yMin = y;
    if (y > yMax) yMax = y;
  });
  return {
    x: [xMin, xMax],
    y: [yMin, yMax]
  };
}

/**
 * Check if the graph variable is a valid graph, and if sigma can render it.
 */
function validateGraph(graph) {
  // check if it's a valid graphology instance
  if (!graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default()(graph)) throw new Error("Sigma: invalid graph instance.");

  // check if nodes have x/y attributes
  graph.forEachNode(function (key, attributes) {
    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {
      throw new Error("Sigma: Coordinates of node ".concat(key, " are invalid. A node must have a numeric 'x' and 'y' attribute."));
    }
  });
}

/**
 * Function used to create DOM elements easily.
 */
function createElement(tag, style, attributes) {
  var element = document.createElement(tag);
  if (style) {
    for (var k in style) {
      element.style[k] = style[k];
    }
  }
  if (attributes) {
    for (var _k in attributes) {
      element.setAttribute(_k, attributes[_k]);
    }
  }
  return element;
}

/**
 * Function returning the browser's pixel ratio.
 */
function getPixelRatio() {
  if (typeof window.devicePixelRatio !== "undefined") return window.devicePixelRatio;
  return 1;
}

/**
 * Function ordering the given elements in reverse z-order so they drawn
 * the correct way.
 */
function zIndexOrdering(_extent, getter, elements) {
  // If k is > n, we'll use a standard sort
  return elements.sort(function (a, b) {
    var zA = getter(a) || 0,
      zB = getter(b) || 0;
    if (zA < zB) return -1;
    if (zA > zB) return 1;
    return 0;
  });

  // TODO: counting sort optimization
}

/**
 * Factory returning a function normalizing the given node's position & size.
 */

function createNormalizationFunction(extent) {
  var _extent$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.x, 2),
    minX = _extent$x[0],
    maxX = _extent$x[1],
    _extent$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.y, 2),
    minY = _extent$y[0],
    maxY = _extent$y[1];
  var ratio = Math.max(maxX - minX, maxY - minY),
    dX = (maxX + minX) / 2,
    dY = (maxY + minY) / 2;
  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;
  if (isNaN(dX)) dX = 0;
  if (isNaN(dY)) dY = 0;
  var fn = function fn(data) {
    return {
      x: 0.5 + (data.x - dX) / ratio,
      y: 0.5 + (data.y - dY) / ratio
    };
  };

  // TODO: possibility to apply this in batch over array of indices
  fn.applyTo = function (data) {
    data.x = 0.5 + (data.x - dX) / ratio;
    data.y = 0.5 + (data.y - dY) / ratio;
  };
  fn.inverse = function (data) {
    return {
      x: dX + ratio * (data.x - 0.5),
      y: dY + ratio * (data.y - 0.5)
    };
  };
  fn.ratio = ratio;
  return fn;
}




/***/ }),

/***/ "./node_modules/sigma/dist/sigma.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/dist/sigma.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   MouseCaptor: () => (/* binding */ MouseCaptor),
/* harmony export */   Sigma: () => (/* binding */ Sigma$1),
/* harmony export */   TouchCaptor: () => (/* binding */ TouchCaptor),
/* harmony export */   "default": () => (/* binding */ Sigma)
/* harmony export */ });
/* harmony import */ var _index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-236c62ad.esm.js */ "./node_modules/sigma/dist/index-236c62ad.esm.js");
/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var _types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/dist/sigma-types.esm.js */ "./node_modules/sigma/types/dist/sigma-types.esm.js");
/* harmony import */ var _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalization-be445518.esm.js */ "./node_modules/sigma/dist/normalization-be445518.esm.js");
/* harmony import */ var _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings/dist/sigma-settings.esm.js */ "./node_modules/sigma/settings/dist/sigma-settings.esm.js");
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");
/* harmony import */ var _data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-11df7124.esm.js */ "./node_modules/sigma/dist/data-11df7124.esm.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);










/**
 * Defaults.
 */
var DEFAULT_ZOOMING_RATIO = 1.5;

/**
 * Event types.
 */
/**
 * Camera class
 */
var Camera = /*#__PURE__*/function (_TypedEventEmitter) {
  function Camera() {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Camera);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Camera);

    // State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "x", 0.5);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "y", 0.5);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "angle", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "ratio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "minRatio", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "maxRatio", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledZooming", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledPanning", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledRotation", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "clean", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nextFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "previousState", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    _this.previousState = _this.getState();
    return _this;
  }

  /**
   * Static method used to create a Camera object with a given state.
   */
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Camera, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Camera, [{
    key: "enable",
    value:
    /**
     * Method used to enable the camera.
     */
    function enable() {
      this.enabled = true;
      return this;
    }

    /**
     * Method used to disable the camera.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.enabled = false;
      return this;
    }

    /**
     * Method used to retrieve the camera's current state.
     */
  }, {
    key: "getState",
    value: function getState() {
      return {
        x: this.x,
        y: this.y,
        angle: this.angle,
        ratio: this.ratio
      };
    }

    /**
     * Method used to check whether the camera has the given state.
     */
  }, {
    key: "hasState",
    value: function hasState(state) {
      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;
    }

    /**
     * Method used to retrieve the camera's previous state.
     */
  }, {
    key: "getPreviousState",
    value: function getPreviousState() {
      var state = this.previousState;
      if (!state) return null;
      return {
        x: state.x,
        y: state.y,
        angle: state.angle,
        ratio: state.ratio
      };
    }

    /**
     * Method used to check minRatio and maxRatio values.
     */
  }, {
    key: "getBoundedRatio",
    value: function getBoundedRatio(ratio) {
      var r = ratio;
      if (typeof this.minRatio === "number") r = Math.max(r, this.minRatio);
      if (typeof this.maxRatio === "number") r = Math.min(r, this.maxRatio);
      return r;
    }

    /**
     * Method used to check various things to return a legit state candidate.
     */
  }, {
    key: "validateState",
    value: function validateState(state) {
      var validatedState = {};
      if (this.enabledPanning && typeof state.x === "number") validatedState.x = state.x;
      if (this.enabledPanning && typeof state.y === "number") validatedState.y = state.y;
      if (this.enabledZooming && typeof state.ratio === "number") validatedState.ratio = this.getBoundedRatio(state.ratio);
      if (this.enabledRotation && typeof state.angle === "number") validatedState.angle = state.angle;
      return this.clean ? this.clean((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.getState()), validatedState)) : validatedState;
    }

    /**
     * Method used to check whether the camera is currently being animated.
     */
  }, {
    key: "isAnimated",
    value: function isAnimated() {
      return !!this.nextFrame;
    }

    /**
     * Method used to set the camera's state.
     */
  }, {
    key: "setState",
    value: function setState(state) {
      if (!this.enabled) return this;

      // Keeping track of last state
      this.previousState = this.getState();
      var validState = this.validateState(state);
      if (typeof validState.x === "number") this.x = validState.x;
      if (typeof validState.y === "number") this.y = validState.y;
      if (typeof validState.ratio === "number") this.ratio = validState.ratio;
      if (typeof validState.angle === "number") this.angle = validState.angle;

      // Emitting
      if (!this.hasState(this.previousState)) this.emit("updated", this.getState());
      return this;
    }

    /**
     * Method used to update the camera's state using a function.
     */
  }, {
    key: "updateState",
    value: function updateState(updater) {
      this.setState(updater(this.getState()));
      return this;
    }

    /**
     * Method used to animate the camera.
     */
  }, {
    key: "animate",
    value: function animate(state) {
      var _this2 = this;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 ? arguments[2] : undefined;
      if (!callback) return new Promise(function (resolve) {
        return _this2.animate(state, opts, resolve);
      });
      if (!this.enabled) return;
      var options = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.A), opts);
      var validState = this.validateState(state);
      var easing = typeof options.easing === "function" ? options.easing : _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.e[options.easing];

      // State
      var start = Date.now(),
        initialState = this.getState();

      // Function performing the animation
      var _fn = function fn() {
        var t = (Date.now() - start) / options.duration;

        // The animation is over:
        if (t >= 1) {
          _this2.nextFrame = null;
          _this2.setState(validState);
          if (_this2.animationCallback) {
            _this2.animationCallback.call(null);
            _this2.animationCallback = undefined;
          }
          return;
        }
        var coefficient = easing(t);
        var newState = {};
        if (typeof validState.x === "number") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;
        if (typeof validState.y === "number") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;
        if (_this2.enabledRotation && typeof validState.angle === "number") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;
        if (typeof validState.ratio === "number") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;
        _this2.setState(newState);
        _this2.nextFrame = requestAnimationFrame(_fn);
      };
      if (this.nextFrame) {
        cancelAnimationFrame(this.nextFrame);
        if (this.animationCallback) this.animationCallback.call(null);
        this.nextFrame = requestAnimationFrame(_fn);
      } else {
        _fn();
      }
      this.animationCallback = callback;
    }

    /**
     * Method used to zoom the camera.
     */
  }, {
    key: "animatedZoom",
    value: function animatedZoom(factorOrOptions) {
      if (!factorOrOptions) return this.animate({
        ratio: this.ratio / DEFAULT_ZOOMING_RATIO
      });
      if (typeof factorOrOptions === "number") return this.animate({
        ratio: this.ratio / factorOrOptions
      });
      return this.animate({
        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      }, factorOrOptions);
    }

    /**
     * Method used to unzoom the camera.
     */
  }, {
    key: "animatedUnzoom",
    value: function animatedUnzoom(factorOrOptions) {
      if (!factorOrOptions) return this.animate({
        ratio: this.ratio * DEFAULT_ZOOMING_RATIO
      });
      if (typeof factorOrOptions === "number") return this.animate({
        ratio: this.ratio * factorOrOptions
      });
      return this.animate({
        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      }, factorOrOptions);
    }

    /**
     * Method used to reset the camera.
     */
  }, {
    key: "animatedReset",
    value: function animatedReset(options) {
      return this.animate({
        x: 0.5,
        y: 0.5,
        ratio: 1,
        angle: 0
      }, options);
    }

    /**
     * Returns a new Camera instance, with the same state as the current camera.
     */
  }, {
    key: "copy",
    value: function copy() {
      return Camera.from(this.getState());
    }
  }], [{
    key: "from",
    value: function from(state) {
      var camera = new Camera();
      return camera.setState(state);
    }
  }]);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

/**
 * Captor utils functions
 * ======================
 */

/**
 * Extract the local X and Y coordinates from a mouse event or touch object. If
 * a DOM element is given, it uses this element's offset to compute the position
 * (this allows using events that are not bound to the container itself and
 * still have a proper position).
 *
 * @param  {event}       e - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {number}      The local Y value of the mouse.
 */
function getPosition(e, dom) {
  var bbox = dom.getBoundingClientRect();
  return {
    x: e.clientX - bbox.left,
    y: e.clientY - bbox.top
  };
}

/**
 * Convert mouse coords to sigma coords.
 *
 * @param  {event}       e   - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getMouseCoords(e, dom) {
  var res = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getPosition(e, dom)), {}, {
    sigmaDefaultPrevented: false,
    preventSigmaDefault: function preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e
  });
  return res;
}

/**
 * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.
 */
function cleanMouseCoords(e) {
  var res = "x" in e ? e : (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, e.touches[0] || e.previousTouches[0]), {}, {
    original: e.original,
    sigmaDefaultPrevented: e.sigmaDefaultPrevented,
    preventSigmaDefault: function preventSigmaDefault() {
      e.sigmaDefaultPrevented = true;
      res.sigmaDefaultPrevented = true;
    }
  });
  return res;
}

/**
 * Convert mouse wheel event coords to sigma coords.
 *
 * @param  {event}       e   - A wheel mouse event.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getWheelCoords(e, dom) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getMouseCoords(e, dom)), {}, {
    delta: getWheelDelta(e)
  });
}
var MAX_TOUCHES = 2;
function getTouchesArray(touches) {
  var arr = [];
  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);
  return arr;
}

/**
 * Convert touch coords to sigma coords.
 *
 * @param  {event}       e               - A touch event.
 * @param  {Touch[]}     previousTouches - An array of the previously stored touches.
 * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getTouchCoords(e, previousTouches, dom) {
  var res = {
    touches: getTouchesArray(e.touches).map(function (touch) {
      return getPosition(touch, dom);
    }),
    previousTouches: previousTouches.map(function (touch) {
      return getPosition(touch, dom);
    }),
    sigmaDefaultPrevented: false,
    preventSigmaDefault: function preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e
  };
  return res;
}

/**
 * Extract the wheel delta from a mouse event or touch object.
 *
 * @param  {event}  e - A mouse event or touch object.
 * @return {number}     The wheel delta of the mouse.
 */
function getWheelDelta(e) {
  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat
  if (typeof e.deltaY !== "undefined") return e.deltaY * -3 / 360;
  if (typeof e.detail !== "undefined") return e.detail / -9;
  throw new Error("Captor: could not extract delta from event.");
}

/**
 * Abstract class representing a captor like the user's mouse or touch controls.
 */
var Captor = /*#__PURE__*/function (_TypedEventEmitter) {
  function Captor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Captor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Captor);
    // Properties
    _this.container = container;
    _this.renderer = renderer;
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Captor, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Captor);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

var MOUSE_SETTINGS_KEYS = ["doubleClickTimeout", "doubleClickZoomingDuration", "doubleClickZoomingRatio", "dragTimeout", "draggedEventsTolerance", "inertiaDuration", "inertiaRatio", "zoomDuration", "zoomingRatio"];
var DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));
}, {});

/**
 * Event types.
 */
/**
 * Mouse captor class.
 *
 * @constructor
 */
var MouseCaptor = /*#__PURE__*/function (_Captor) {
  function MouseCaptor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, MouseCaptor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, MouseCaptor, [container, renderer]);

    // Binding methods
    // State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "draggedEvents", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "downStartTime", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastMouseX", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastMouseY", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMouseDown", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMoving", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "movingTimeout", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "startCameraState", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "clicks", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "doubleClickTimeout", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "currentWheelDirection", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "settings", DEFAULT_MOUSE_SETTINGS);
    _this.handleClick = _this.handleClick.bind(_this);
    _this.handleRightClick = _this.handleRightClick.bind(_this);
    _this.handleDown = _this.handleDown.bind(_this);
    _this.handleUp = _this.handleUp.bind(_this);
    _this.handleMove = _this.handleMove.bind(_this);
    _this.handleWheel = _this.handleWheel.bind(_this);
    _this.handleLeave = _this.handleLeave.bind(_this);
    _this.handleEnter = _this.handleEnter.bind(_this);

    // Binding events
    container.addEventListener("click", _this.handleClick, {
      capture: false
    });
    container.addEventListener("contextmenu", _this.handleRightClick, {
      capture: false
    });
    container.addEventListener("mousedown", _this.handleDown, {
      capture: false
    });
    container.addEventListener("wheel", _this.handleWheel, {
      capture: false
    });
    container.addEventListener("mouseleave", _this.handleLeave, {
      capture: false
    });
    container.addEventListener("mouseenter", _this.handleEnter, {
      capture: false
    });
    document.addEventListener("mousemove", _this.handleMove, {
      capture: false
    });
    document.addEventListener("mouseup", _this.handleUp, {
      capture: false
    });
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(MouseCaptor, _Captor);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(MouseCaptor, [{
    key: "kill",
    value: function kill() {
      var container = this.container;
      container.removeEventListener("click", this.handleClick);
      container.removeEventListener("contextmenu", this.handleRightClick);
      container.removeEventListener("mousedown", this.handleDown);
      container.removeEventListener("wheel", this.handleWheel);
      container.removeEventListener("mouseleave", this.handleLeave);
      container.removeEventListener("mouseenter", this.handleEnter);
      document.removeEventListener("mousemove", this.handleMove);
      document.removeEventListener("mouseup", this.handleUp);
    }
  }, {
    key: "handleClick",
    value: function handleClick(e) {
      var _this2 = this;
      if (!this.enabled) return;
      this.clicks++;
      if (this.clicks === 2) {
        this.clicks = 0;
        if (typeof this.doubleClickTimeout === "number") {
          clearTimeout(this.doubleClickTimeout);
          this.doubleClickTimeout = null;
        }
        return this.handleDoubleClick(e);
      }
      setTimeout(function () {
        _this2.clicks = 0;
        _this2.doubleClickTimeout = null;
      }, this.settings.doubleClickTimeout);

      // NOTE: this is here to prevent click events on drag
      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit("click", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleRightClick",
    value: function handleRightClick(e) {
      if (!this.enabled) return;
      this.emit("rightClick", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleDoubleClick",
    value: function handleDoubleClick(e) {
      if (!this.enabled) return;
      e.preventDefault();
      e.stopPropagation();
      var mouseCoords = getMouseCoords(e, this.container);
      this.emit("doubleClick", mouseCoords);
      if (mouseCoords.sigmaDefaultPrevented) return;

      // default behavior
      var camera = this.renderer.getCamera();
      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);
      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {
        easing: "quadraticInOut",
        duration: this.settings.doubleClickZoomingDuration
      });
    }
  }, {
    key: "handleDown",
    value: function handleDown(e) {
      if (!this.enabled) return;

      // We only start dragging on left button
      if (e.button === 0) {
        this.startCameraState = this.renderer.getCamera().getState();
        var _getPosition = getPosition(e, this.container),
          x = _getPosition.x,
          y = _getPosition.y;
        this.lastMouseX = x;
        this.lastMouseY = y;
        this.draggedEvents = 0;
        this.downStartTime = Date.now();
        this.isMouseDown = true;
      }
      this.emit("mousedown", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleUp",
    value: function handleUp(e) {
      var _this3 = this;
      if (!this.enabled || !this.isMouseDown) return;
      var camera = this.renderer.getCamera();
      this.isMouseDown = false;
      if (typeof this.movingTimeout === "number") {
        clearTimeout(this.movingTimeout);
        this.movingTimeout = null;
      }
      var _getPosition2 = getPosition(e, this.container),
        x = _getPosition2.x,
        y = _getPosition2.y;
      var cameraState = camera.getState(),
        previousCameraState = camera.getPreviousState() || {
          x: 0,
          y: 0
        };
      if (this.isMoving) {
        camera.animate({
          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
        }, {
          duration: this.settings.inertiaDuration,
          easing: "quadraticOut"
        });
      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {
        camera.setState({
          x: cameraState.x,
          y: cameraState.y
        });
      }
      this.isMoving = false;
      setTimeout(function () {
        var shouldRefresh = _this3.draggedEvents > 0;
        _this3.draggedEvents = 0;

        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work
        // when someone releases camera pan drag after having stopped moving.
        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2
        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290
        // It could be possible to render instead of scheduling a refresh but for
        // now it seems good enough.
        if (shouldRefresh && _this3.renderer.getSetting("hideEdgesOnMove")) _this3.renderer.refresh();
      }, 0);
      this.emit("mouseup", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleMove",
    value: function handleMove(e) {
      var _this4 = this;
      if (!this.enabled) return;
      var mouseCoords = getMouseCoords(e, this.container);

      // Always trigger a "mousemovebody" event, so that it is possible to develop
      // a drag-and-drop effect that works even when the mouse is out of the
      // container:
      this.emit("mousemovebody", mouseCoords);

      // Only trigger the "mousemove" event when the mouse is actually hovering
      // the container, to avoid weirdly hovering nodes and/or edges when the
      // mouse is not hover the container:
      if (e.target === this.container || e.composedPath()[0] === this.container) {
        this.emit("mousemove", mouseCoords);
      }
      if (mouseCoords.sigmaDefaultPrevented) return;

      // Handle the case when "isMouseDown" all the time, to allow dragging the
      // stage while the mouse is not hover the container:
      if (this.isMouseDown) {
        this.isMoving = true;
        this.draggedEvents++;
        if (typeof this.movingTimeout === "number") {
          clearTimeout(this.movingTimeout);
        }
        this.movingTimeout = window.setTimeout(function () {
          _this4.movingTimeout = null;
          _this4.isMoving = false;
        }, this.settings.dragTimeout);
        var camera = this.renderer.getCamera();
        var _getPosition3 = getPosition(e, this.container),
          eX = _getPosition3.x,
          eY = _getPosition3.y;
        var lastMouse = this.renderer.viewportToFramedGraph({
          x: this.lastMouseX,
          y: this.lastMouseY
        });
        var mouse = this.renderer.viewportToFramedGraph({
          x: eX,
          y: eY
        });
        var offsetX = lastMouse.x - mouse.x,
          offsetY = lastMouse.y - mouse.y;
        var cameraState = camera.getState();
        var x = cameraState.x + offsetX,
          y = cameraState.y + offsetY;
        camera.setState({
          x: x,
          y: y
        });
        this.lastMouseX = eX;
        this.lastMouseY = eY;
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: "handleLeave",
    value: function handleLeave(e) {
      this.emit("mouseleave", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleEnter",
    value: function handleEnter(e) {
      this.emit("mouseenter", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleWheel",
    value: function handleWheel(e) {
      var _this5 = this;
      var camera = this.renderer.getCamera();
      if (!this.enabled || !camera.enabledZooming) return;
      var delta = getWheelDelta(e);
      if (!delta) return;
      var wheelCoords = getWheelCoords(e, this.container);
      this.emit("wheel", wheelCoords);
      if (wheelCoords.sigmaDefaultPrevented) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      // Default behavior
      var currentRatio = camera.getState().ratio;
      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;
      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);
      var wheelDirection = delta > 0 ? 1 : -1;
      var now = Date.now();

      // Exit early without preventing default behavior when ratio doesn't change:
      if (currentRatio === newRatio) return;
      e.preventDefault();
      e.stopPropagation();

      // Cancel events that are too close each other and in the same direction:
      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {
        return;
      }
      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {
        easing: "quadraticOut",
        duration: this.settings.zoomDuration
      }, function () {
        _this5.currentWheelDirection = 0;
      });
      this.currentWheelDirection = wheelDirection;
      this.lastWheelTriggerTime = now;
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
  }]);
}(Captor);

var TOUCH_SETTINGS_KEYS = ["dragTimeout", "inertiaDuration", "inertiaRatio", "doubleClickTimeout", "doubleClickZoomingRatio", "doubleClickZoomingDuration", "tapMoveTolerance"];
var DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));
}, {});

/**
 * Event types.
 */
/**
 * Touch captor class.
 *
 * @constructor
 */
var TouchCaptor = /*#__PURE__*/function (_Captor) {
  function TouchCaptor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, TouchCaptor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, TouchCaptor, [container, renderer]);

    // Binding methods:
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMoving", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hasMoved", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "touchMode", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "startTouchesPositions", []);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastTouches", []);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastTap", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "settings", DEFAULT_TOUCH_SETTINGS);
    _this.handleStart = _this.handleStart.bind(_this);
    _this.handleLeave = _this.handleLeave.bind(_this);
    _this.handleMove = _this.handleMove.bind(_this);

    // Binding events
    container.addEventListener("touchstart", _this.handleStart, {
      capture: false
    });
    container.addEventListener("touchcancel", _this.handleLeave, {
      capture: false
    });
    document.addEventListener("touchend", _this.handleLeave, {
      capture: false,
      passive: false
    });
    document.addEventListener("touchmove", _this.handleMove, {
      capture: false,
      passive: false
    });
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(TouchCaptor, _Captor);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(TouchCaptor, [{
    key: "kill",
    value: function kill() {
      var container = this.container;
      container.removeEventListener("touchstart", this.handleStart);
      container.removeEventListener("touchcancel", this.handleLeave);
      document.removeEventListener("touchend", this.handleLeave);
      document.removeEventListener("touchmove", this.handleMove);
    }
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return {
        width: this.container.offsetWidth,
        height: this.container.offsetHeight
      };
    }
  }, {
    key: "handleStart",
    value: function handleStart(e) {
      var _this2 = this;
      if (!this.enabled) return;
      e.preventDefault();
      var touches = getTouchesArray(e.touches);
      this.touchMode = touches.length;
      this.startCameraState = this.renderer.getCamera().getState();
      this.startTouchesPositions = touches.map(function (touch) {
        return getPosition(touch, _this2.container);
      });

      // When there are two touches down, let's record distance and angle as well:
      if (this.touchMode === 2) {
        var _this$startTouchesPos = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this.startTouchesPositions, 2),
          _this$startTouchesPos2 = _this$startTouchesPos[0],
          x0 = _this$startTouchesPos2.x,
          y0 = _this$startTouchesPos2.y,
          _this$startTouchesPos3 = _this$startTouchesPos[1],
          x1 = _this$startTouchesPos3.x,
          y1 = _this$startTouchesPos3.y;
        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);
        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
      }
      this.emit("touchdown", getTouchCoords(e, this.lastTouches, this.container));
      this.lastTouches = touches;
      this.lastTouchesPositions = this.startTouchesPositions;
    }
  }, {
    key: "handleLeave",
    value: function handleLeave(e) {
      if (!this.enabled || !this.startTouchesPositions.length) return;
      if (e.cancelable) e.preventDefault();
      if (this.movingTimeout) {
        this.isMoving = false;
        clearTimeout(this.movingTimeout);
      }
      switch (this.touchMode) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        case 2:
          if (e.touches.length === 1) {
            this.handleStart(e);
            e.preventDefault();
            break;
          }
        /* falls through */
        case 1:
          if (this.isMoving) {
            var camera = this.renderer.getCamera();
            var cameraState = camera.getState(),
              previousCameraState = camera.getPreviousState() || {
                x: 0,
                y: 0
              };
            camera.animate({
              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
            }, {
              duration: this.settings.inertiaDuration,
              easing: "quadraticOut"
            });
          }
          this.hasMoved = false;
          this.isMoving = false;
          this.touchMode = 0;
          break;
      }
      this.emit("touchup", getTouchCoords(e, this.lastTouches, this.container));

      // When the last touch ends and there hasn't been too much movement, trigger a "tap" or "doubletap" event:
      if (!e.touches.length) {
        var position = getPosition(this.lastTouches[0], this.container);
        var downPosition = this.startTouchesPositions[0];
        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);
        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {
          // Only trigger "doubletap" when the last tap is recent enough:
          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {
            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);
            this.emit("doubletap", touchCoords);
            this.lastTap = null;
            if (!touchCoords.sigmaDefaultPrevented) {
              var _camera = this.renderer.getCamera();
              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);
              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {
                easing: "quadraticInOut",
                duration: this.settings.doubleClickZoomingDuration
              });
            }
          }
          // Else, trigger a normal "tap" event:
          else {
            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);
            this.emit("tap", _touchCoords);
            this.lastTap = {
              time: Date.now(),
              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]
            };
          }
        }
      }
      this.lastTouches = getTouchesArray(e.touches);
      this.startTouchesPositions = [];
    }
  }, {
    key: "handleMove",
    value: function handleMove(e) {
      var _this3 = this;
      if (!this.enabled || !this.startTouchesPositions.length) return;
      e.preventDefault();
      var touches = getTouchesArray(e.touches);
      var touchesPositions = touches.map(function (touch) {
        return getPosition(touch, _this3.container);
      });
      var lastTouches = this.lastTouches;
      this.lastTouches = touches;
      this.lastTouchesPositions = touchesPositions;
      var touchCoords = getTouchCoords(e, lastTouches, this.container);
      this.emit("touchmove", touchCoords);
      if (touchCoords.sigmaDefaultPrevented) return;

      // If a move was initiated at some point, and we get back to start point,
      // we should still consider that we did move (which also happens after a
      // multiple touch when only one touch remains in which case handleStart
      // is recalled within handleLeave).
      // Now, some mobile browsers report zero-distance moves so we also check that
      // one of the touches did actually move from the origin position.
      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {
        var startPosition = _this3.startTouchesPositions[idx];
        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);
      }));

      // If there was no move, do not trigger touch moves behavior
      if (!this.hasMoved) {
        return;
      }
      this.isMoving = true;
      if (this.movingTimeout) clearTimeout(this.movingTimeout);
      this.movingTimeout = window.setTimeout(function () {
        _this3.isMoving = false;
      }, this.settings.dragTimeout);
      var camera = this.renderer.getCamera();
      var startCameraState = this.startCameraState;
      var padding = this.renderer.getSetting("stagePadding");
      switch (this.touchMode) {
        case 1:
          {
            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),
              xStart = _this$renderer$viewpo.x,
              yStart = _this$renderer$viewpo.y;
            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),
              x = _this$renderer$viewpo2.x,
              y = _this$renderer$viewpo2.y;
            camera.setState({
              x: startCameraState.x + xStart - x,
              y: startCameraState.y + yStart - y
            });
            break;
          }
        case 2:
          {
            /**
             * Here is the thinking here:
             *
             * 1. We can find the new angle and ratio, by comparing the vector from "touch one" to "touch two" at the start
             *    of the d'n'd and now
             *
             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph
             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport
             *    position of this same touch now
             */
            var newCameraState = {
              x: 0.5,
              y: 0.5,
              angle: 0,
              ratio: 1
            };
            var _touchesPositions$ = touchesPositions[0],
              x0 = _touchesPositions$.x,
              y0 = _touchesPositions$.y;
            var _touchesPositions$2 = touchesPositions[1],
              x1 = _touchesPositions$2.x,
              y1 = _touchesPositions$2.y;
            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;
            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;

            // 1.
            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);
            newCameraState.ratio = newRatio;
            newCameraState.angle = startCameraState.angle + angleDiff;

            // 2.
            var dimensions = this.getDimensions();
            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {
              cameraState: startCameraState
            });
            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;
            var dx = smallestDimension / dimensions.width;
            var dy = smallestDimension / dimensions.height;
            var ratio = newRatio / smallestDimension;

            // Align with center of the graph:
            var _x = x0 - smallestDimension / 2 / dx;
            var _y = y0 - smallestDimension / 2 / dy;

            // Rotate:
            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];
            _x = _ref[0];
            _y = _ref[1];
            newCameraState.x = touchGraphPosition.x - _x * ratio;
            newCameraState.y = touchGraphPosition.y + _y * ratio;
            camera.setState(newCameraState);
            break;
          }
      }
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
  }]);
}(Captor);

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(r) || _nonIterableSpread();
}

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

/**
 * Sigma.js Labels Heuristics
 * ===========================
 *
 * Miscellaneous heuristics related to label display.
 * @module
 */
/**
 * Class representing a single candidate for the label grid selection.
 *
 * It also describes a deterministic way to compare two candidates to assess
 * which one is better.
 */
var LabelCandidate = /*#__PURE__*/function () {
  function LabelCandidate(key, size) {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelCandidate);
    this.key = key;
    this.size = size;
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelCandidate, null, [{
    key: "compare",
    value: function compare(first, second) {
      // First we compare by size
      if (first.size > second.size) return -1;
      if (first.size < second.size) return 1;

      // Then since no two nodes can have the same key, we use it to
      // deterministically tie-break by key
      if (first.key > second.key) return 1;

      // NOTE: this comparator cannot return 0
      return -1;
    }
  }]);
}();
/**
 * Class representing a 2D spatial grid divided into constant-size cells.
 */
var LabelGrid = /*#__PURE__*/function () {
  function LabelGrid() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelGrid);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "width", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "height", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "cellSize", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "columns", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "rows", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "cells", {});
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelGrid, [{
    key: "resizeAndClear",
    value: function resizeAndClear(dimensions, cellSize) {
      this.width = dimensions.width;
      this.height = dimensions.height;
      this.cellSize = cellSize;
      this.columns = Math.ceil(dimensions.width / cellSize);
      this.rows = Math.ceil(dimensions.height / cellSize);
      this.cells = {};
    }
  }, {
    key: "getIndex",
    value: function getIndex(pos) {
      var xIndex = Math.floor(pos.x / this.cellSize);
      var yIndex = Math.floor(pos.y / this.cellSize);
      return yIndex * this.columns + xIndex;
    }
  }, {
    key: "add",
    value: function add(key, size, pos) {
      var candidate = new LabelCandidate(key, size);
      var index = this.getIndex(pos);
      var cell = this.cells[index];
      if (!cell) {
        cell = [];
        this.cells[index] = cell;
      }
      cell.push(candidate);
    }
  }, {
    key: "organize",
    value: function organize() {
      for (var k in this.cells) {
        var cell = this.cells[k];
        cell.sort(LabelCandidate.compare);
      }
    }
  }, {
    key: "getLabelsToDisplay",
    value: function getLabelsToDisplay(ratio, density) {
      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?
      // TODO: adjust threshold lower, but increase cells a bit?
      // TODO: hunt for geom issue in disguise
      // TODO: memoize while ratio does not move. method to force recompute
      var cellArea = this.cellSize * this.cellSize;
      var scaledCellArea = cellArea / ratio / ratio;
      var scaledDensity = scaledCellArea * density / cellArea;
      var labelsToDisplayPerCell = Math.ceil(scaledDensity);
      var labels = [];
      for (var k in this.cells) {
        var cell = this.cells[k];
        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {
          labels.push(cell[i].key);
        }
      }
      return labels;
    }
  }]);
}();

/**
 * Label heuristic selecting edge labels to display, based on displayed node
 * labels
 *
 * @param  {object} params                 - Parameters:
 * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.
 * @param  {Set}      highlightedNodes     - Highlighted nodes.
 * @param  {Graph}    graph                - The rendered graph.
 * @param  {string}   hoveredNode          - Hovered node (optional)
 * @return {Array}                         - The selected labels.
 */
function edgeLabelsToDisplayFromNodes(params) {
  var graph = params.graph,
    hoveredNode = params.hoveredNode,
    highlightedNodes = params.highlightedNodes,
    displayedNodeLabels = params.displayedNodeLabels;
  var worthyEdges = [];

  // TODO: the code below can be optimized using #.forEach and batching the code per adj

  // We should display an edge's label if:
  //   - Any of its extremities is highlighted or hovered
  //   - Both of its extremities has its label shown
  graph.forEachEdge(function (edge, _, source, target) {
    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {
      worthyEdges.push(edge);
    }
  });
  return worthyEdges;
}

/**
 * Constants.
 */
var X_LABEL_MARGIN = 150;
var Y_LABEL_MARGIN = 50;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Important functions.
 */
function applyNodeDefaults(settings, key, data) {
  if (!hasOwnProperty.call(data, "x") || !hasOwnProperty.call(data, "y")) throw new Error("Sigma: could not find a valid position (x, y) for node \"".concat(key, "\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?"));
  if (!data.color) data.color = settings.defaultNodeColor;
  if (!data.label && data.label !== "") data.label = null;
  if (data.label !== undefined && data.label !== null) data.label = "" + data.label;else data.label = null;
  if (!data.size) data.size = 2;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "highlighted")) data.highlighted = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultNodeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}
function applyEdgeDefaults(settings, _key, data) {
  if (!data.color) data.color = settings.defaultEdgeColor;
  if (!data.label) data.label = "";
  if (!data.size) data.size = 0.5;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultEdgeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}

/**
 * Main class.
 *
 * @constructor
 * @param {Graph}       graph     - Graph to render.
 * @param {HTMLElement} container - DOM container in which to render.
 * @param {object}      settings  - Optional settings.
 */
var Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {
  function Sigma(graph, container) {
    var _this;
    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Sigma);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Sigma);

    // Resolving settings
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "elements", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "canvasContexts", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "webGLContexts", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pickingLayers", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "textures", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "frameBuffers", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "activeListeners", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "labelGrid", new LabelGrid());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeDataCache", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeDataCache", {});
    // Indices to keep track of the index of the item inside programs
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeProgramIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeProgramIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodesWithForcedLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgesWithForcedLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeExtent", {
      x: [0, 1],
      y: [0, 1]
    });
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeZExtent", [Infinity, -Infinity]);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeZExtent", [Infinity, -Infinity]);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "matrix", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "invMatrix", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "correctionRatio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "customBBox", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "normalizationFunction", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)({
      x: [0, 1],
      y: [0, 1]
    }));
    // Cache:
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "graphToViewportRatio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "itemIDsIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeIndices", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeIndices", {});
    // Starting dimensions and pixel ratio
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "width", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "height", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pixelRatio", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pickingDownSizingRatio", 2 * _this.pixelRatio);
    // Graph State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "displayedNodeLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "displayedEdgeLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "highlightedNodes", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hoveredNode", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hoveredEdge", null);
    // Internal states
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "renderFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "renderHighlightedNodesFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "needToProcess", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "checkEdgesEventsFrame", null);
    // Programs
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodePrograms", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeHoverPrograms", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgePrograms", {});
    _this.settings = (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.resolveSettings)(settings);

    // Validating
    (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(_this.settings);
    (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.v)(graph);
    if (!(container instanceof HTMLElement)) throw new Error("Sigma: container should be an html element.");

    // Properties
    _this.graph = graph;
    _this.container = container;

    // Initializing contexts
    _this.createWebGLContext("edges", {
      picking: settings.enableEdgeEvents
    });
    _this.createCanvasContext("edgeLabels");
    _this.createWebGLContext("nodes", {
      picking: true
    });
    _this.createCanvasContext("labels");
    _this.createCanvasContext("hovers");
    _this.createWebGLContext("hoverNodes");
    _this.createCanvasContext("mouse", {
      style: {
        touchAction: "none",
        userSelect: "none"
      }
    });

    // Initial resize
    _this.resize();

    // Loading programs
    for (var type in _this.settings.nodeProgramClasses) {
      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);
    }
    for (var _type in _this.settings.edgeProgramClasses) {
      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);
    }

    // Initializing the camera
    _this.camera = new Camera();

    // Binding camera events
    _this.bindCameraHandlers();

    // Initializing captors
    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);
    _this.mouseCaptor.setSettings(_this.settings);
    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);
    _this.touchCaptor.setSettings(_this.settings);

    // Binding event handlers
    _this.bindEventHandlers();

    // Binding graph handlers
    _this.bindGraphHandlers();

    // Trigger eventual settings-related things
    _this.handleSettingsUpdate();

    // Processing data for the first time & render
    _this.refresh();
    return _this;
  }

  /**---------------------------------------------------------------------------
   * Internal methods.
   **---------------------------------------------------------------------------
   */

  /**
   * Internal function used to register a node program
   *
   * @param  {string}           key              - The program's key, matching the related nodes "type" values.
   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.
   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).
   * @return {Sigma}
   */
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Sigma, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Sigma, [{
    key: "registerNodeProgram",
    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {
      if (this.nodePrograms[key]) this.nodePrograms[key].kill();
      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();
      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);
      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);
      return this;
    }

    /**
     * Internal function used to register an edge program
     *
     * @param  {string}          key              - The program's key, matching the related edges "type" values.
     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.
     * @return {Sigma}
     */
  }, {
    key: "registerEdgeProgram",
    value: function registerEdgeProgram(key, EdgeProgramClass) {
      if (this.edgePrograms[key]) this.edgePrograms[key].kill();
      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);
      return this;
    }

    /**
     * Internal function used to unregister a node program
     *
     * @param  {string} key - The program's key, matching the related nodes "type" values.
     * @return {Sigma}
     */
  }, {
    key: "unregisterNodeProgram",
    value: function unregisterNodeProgram(key) {
      if (this.nodePrograms[key]) {
        var _this$nodePrograms = this.nodePrograms,
          program = _this$nodePrograms[key],
          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        program.kill();
        this.nodePrograms = programs;
      }
      if (this.nodeHoverPrograms[key]) {
        var _this$nodeHoverProgra = this.nodeHoverPrograms,
          _program = _this$nodeHoverProgra[key],
          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        _program.kill();
        this.nodePrograms = _programs;
      }
      return this;
    }

    /**
     * Internal function used to unregister an edge program
     *
     * @param  {string} key - The program's key, matching the related edges "type" values.
     * @return {Sigma}
     */
  }, {
    key: "unregisterEdgeProgram",
    value: function unregisterEdgeProgram(key) {
      if (this.edgePrograms[key]) {
        var _this$edgePrograms = this.edgePrograms,
          program = _this$edgePrograms[key],
          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        program.kill();
        this.edgePrograms = programs;
      }
      return this;
    }

    /**
     * Method (re)binding WebGL texture (for picking).
     *
     * @return {Sigma}
     */
  }, {
    key: "resetWebGLTexture",
    value: function resetWebGLTexture(id) {
      var gl = this.webGLContexts[id];
      var frameBuffer = this.frameBuffers[id];
      var currentTexture = this.textures[id];
      if (currentTexture) gl.deleteTexture(currentTexture);
      var pickingTexture = gl.createTexture();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);
      this.textures[id] = pickingTexture;
      return this;
    }

    /**
     * Method binding camera handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "bindCameraHandlers",
    value: function bindCameraHandlers() {
      var _this2 = this;
      this.activeListeners.camera = function () {
        _this2.scheduleRender();
      };
      this.camera.on("updated", this.activeListeners.camera);
      return this;
    }

    /**
     * Method unbinding camera handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "unbindCameraHandlers",
    value: function unbindCameraHandlers() {
      this.camera.removeListener("updated", this.activeListeners.camera);
      return this;
    }

    /**
     * Method that returns the closest node to a given position.
     */
  }, {
    key: "getNodeAtPosition",
    value: function getNodeAtPosition(position) {
      var x = position.x,
        y = position.y;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);
      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));
      var itemAt = this.itemIDsIndex[index];
      return itemAt && itemAt.type === "node" ? itemAt.id : null;
    }

    /**
     * Method binding event handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "bindEventHandlers",
    value: function bindEventHandlers() {
      var _this3 = this;
      // Handling window resize
      this.activeListeners.handleResize = function () {
        // need to call a refresh to rebuild the labelgrid
        _this3.scheduleRefresh();
      };
      window.addEventListener("resize", this.activeListeners.handleResize);

      // Handling mouse move
      this.activeListeners.handleMove = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        var nodeToHover = _this3.getNodeAtPosition(event);
        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {
          // Handling passing from one node to the other directly
          if (_this3.hoveredNode) _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: _this3.hoveredNode
          }));
          _this3.hoveredNode = nodeToHover;
          _this3.emit("enterNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: nodeToHover
          }));
          _this3.scheduleHighlightedNodesRender();
          return;
        }

        // Checking if the hovered node is still hovered
        if (_this3.hoveredNode) {
          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {
            var node = _this3.hoveredNode;
            _this3.hoveredNode = null;
            _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              node: node
            }));
            _this3.scheduleHighlightedNodesRender();
            return;
          }
        }
        if (_this3.settings.enableEdgeEvents) {
          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);
          if (edgeToHover !== _this3.hoveredEdge) {
            if (_this3.hoveredEdge) _this3.emit("leaveEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: _this3.hoveredEdge
            }));
            if (edgeToHover) _this3.emit("enterEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: edgeToHover
            }));
            _this3.hoveredEdge = edgeToHover;
          }
        }
      };

      // Handling mouse move over body (only to dispatch the proper event):
      this.activeListeners.handleMoveBody = function (e) {
        var event = cleanMouseCoords(e);
        _this3.emit("moveBody", {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        });
      };

      // Handling mouse leave stage:
      this.activeListeners.handleLeave = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        if (_this3.hoveredNode) {
          _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: _this3.hoveredNode
          }));
          _this3.scheduleHighlightedNodesRender();
        }
        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {
          _this3.emit("leaveEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            edge: _this3.hoveredEdge
          }));
          _this3.scheduleHighlightedNodesRender();
        }
        _this3.emit("leaveStage", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));
      };

      // Handling mouse enter stage:
      this.activeListeners.handleEnter = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        _this3.emit("enterStage", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));
      };

      // Handling click
      var createInteractionListener = function createInteractionListener(eventType) {
        return function (e) {
          var event = cleanMouseCoords(e);
          var baseEvent = {
            event: event,
            preventSigmaDefault: function preventSigmaDefault() {
              event.preventSigmaDefault();
            }
          };
          var nodeAtPosition = _this3.getNodeAtPosition(event);
          if (nodeAtPosition) return _this3.emit("".concat(eventType, "Node"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: nodeAtPosition
          }));
          if (_this3.settings.enableEdgeEvents) {
            var edge = _this3.getEdgeAtPoint(event.x, event.y);
            if (edge) return _this3.emit("".concat(eventType, "Edge"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: edge
            }));
          }
          return _this3.emit("".concat(eventType, "Stage"), baseEvent);
        };
      };
      this.activeListeners.handleClick = createInteractionListener("click");
      this.activeListeners.handleRightClick = createInteractionListener("rightClick");
      this.activeListeners.handleDoubleClick = createInteractionListener("doubleClick");
      this.activeListeners.handleWheel = createInteractionListener("wheel");
      this.activeListeners.handleDown = createInteractionListener("down");
      this.activeListeners.handleUp = createInteractionListener("up");
      this.mouseCaptor.on("mousemove", this.activeListeners.handleMove);
      this.mouseCaptor.on("mousemovebody", this.activeListeners.handleMoveBody);
      this.mouseCaptor.on("click", this.activeListeners.handleClick);
      this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick);
      this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick);
      this.mouseCaptor.on("wheel", this.activeListeners.handleWheel);
      this.mouseCaptor.on("mousedown", this.activeListeners.handleDown);
      this.mouseCaptor.on("mouseup", this.activeListeners.handleUp);
      this.mouseCaptor.on("mouseleave", this.activeListeners.handleLeave);
      this.mouseCaptor.on("mouseenter", this.activeListeners.handleEnter);
      this.touchCaptor.on("touchdown", this.activeListeners.handleDown);
      this.touchCaptor.on("touchdown", this.activeListeners.handleMove);
      this.touchCaptor.on("touchup", this.activeListeners.handleUp);
      this.touchCaptor.on("touchmove", this.activeListeners.handleMove);
      this.touchCaptor.on("tap", this.activeListeners.handleClick);
      this.touchCaptor.on("doubletap", this.activeListeners.handleDoubleClick);
      this.touchCaptor.on("touchmove", this.activeListeners.handleMoveBody);
      return this;
    }

    /**
     * Method binding graph handlers
     *
     * @return {Sigma}
     */
  }, {
    key: "bindGraphHandlers",
    value: function bindGraphHandlers() {
      var _this4 = this;
      var graph = this.graph;
      var LAYOUT_IMPACTING_FIELDS = new Set(["x", "y", "zIndex", "type"]);
      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {
        var _e$hints;
        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;
        // we process all nodes
        _this4.graph.forEachNode(function (node) {
          return _this4.updateNode(node);
        });

        // if coord, type or zIndex have changed, we need to schedule a render
        // (zIndex for the programIndex)
        var layoutChanged = !updatedFields || updatedFields.some(function (f) {
          return LAYOUT_IMPACTING_FIELDS.has(f);
        });
        _this4.refresh({
          partialGraph: {
            nodes: graph.nodes()
          },
          skipIndexation: !layoutChanged,
          schedule: true
        });
      };
      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {
        var _e$hints2;
        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;
        // we process all edges
        _this4.graph.forEachEdge(function (edge) {
          return _this4.updateEdge(edge);
        });
        var layoutChanged = updatedFields && ["zIndex", "type"].some(function (f) {
          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);
        });
        _this4.refresh({
          partialGraph: {
            edges: graph.edges()
          },
          skipIndexation: !layoutChanged,
          schedule: true
        });
      };

      // On add node, we add the node in indices and then call for a render
      this.activeListeners.addNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // we process the node
        _this4.addNode(node);
        // schedule a render for the node
        _this4.refresh({
          partialGraph: {
            nodes: [node]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On update node, we update indices and then call for a render
      this.activeListeners.updateNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // schedule a render for the node
        _this4.refresh({
          partialGraph: {
            nodes: [node]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On drop node, we remove the node from indices and then call for a refresh
      this.activeListeners.dropNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // we process the node
        _this4.removeNode(node);
        // schedule a render for everything
        _this4.refresh({
          schedule: true
        });
      };

      // On add edge, we remove the edge from indices and then call for a refresh
      this.activeListeners.addEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // we process the edge
        _this4.addEdge(edge);
        // schedule a render for the edge
        _this4.refresh({
          partialGraph: {
            edges: [edge]
          },
          schedule: true
        });
      };

      // On update edge, we update indices and then call for a refresh
      this.activeListeners.updateEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // schedule a repaint for the edge
        _this4.refresh({
          partialGraph: {
            edges: [edge]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On drop edge, we remove the edge from indices and then call for a refresh
      this.activeListeners.dropEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // we process the edge
        _this4.removeEdge(edge);
        // schedule a render for all edges
        _this4.refresh({
          schedule: true
        });
      };

      // On clear edges, we clear the edge indices and then call for a refresh
      this.activeListeners.clearEdgesGraphUpdate = function () {
        // we clear the edge data structures
        _this4.clearEdgeState();
        _this4.clearEdgeIndices();
        // schedule a render for all edges
        _this4.refresh({
          schedule: true
        });
      };

      // On graph clear, we clear indices and then call for a refresh
      this.activeListeners.clearGraphUpdate = function () {
        // clear graph state
        _this4.clearEdgeState();
        _this4.clearNodeState();

        // clear graph indices
        _this4.clearEdgeIndices();
        _this4.clearNodeIndices();

        // schedule a render for all
        _this4.refresh({
          schedule: true
        });
      };
      graph.on("nodeAdded", this.activeListeners.addNodeGraphUpdate);
      graph.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
      graph.on("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
      graph.on("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
      graph.on("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
      graph.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
      graph.on("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
      graph.on("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
      graph.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
      graph.on("cleared", this.activeListeners.clearGraphUpdate);
      return this;
    }

    /**
     * Method used to unbind handlers from the graph.
     *
     * @return {undefined}
     */
  }, {
    key: "unbindGraphHandlers",
    value: function unbindGraphHandlers() {
      var graph = this.graph;
      graph.removeListener("nodeAdded", this.activeListeners.addNodeGraphUpdate);
      graph.removeListener("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
      graph.removeListener("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
      graph.removeListener("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
      graph.removeListener("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
      graph.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
      graph.removeListener("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
      graph.removeListener("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
      graph.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
      graph.removeListener("cleared", this.activeListeners.clearGraphUpdate);
    }

    /**
     * Method looking for an edge colliding with a given point at (x, y). Returns
     * the key of the edge if any, or null else.
     */
  }, {
    key: "getEdgeAtPoint",
    value: function getEdgeAtPoint(x, y) {
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);
      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));
      var itemAt = this.itemIDsIndex[index];
      return itemAt && itemAt.type === "edge" ? itemAt.id : null;
    }

    /**
     * Method used to process the whole graph's data.
     *  - extent
     *  - normalizationFunction
     *  - compute node's coordinate
     *  - labelgrid
     *  - program data allocation
     * @return {Sigma}
     */
  }, {
    key: "process",
    value: function process() {
      var _this5 = this;
      this.emit("beforeProcess");
      var graph = this.graph;
      var settings = this.settings;
      var dimensions = this.getDimensions();

      //
      // NODES
      //
      this.nodeExtent = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.graph);
      if (!this.settings.autoRescale) {
        var width = dimensions.width,
          height = dimensions.height;
        var _this$nodeExtent = this.nodeExtent,
          x = _this$nodeExtent.x,
          y = _this$nodeExtent.y;
        this.nodeExtent = {
          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],
          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]
        };
      }
      this.normalizationFunction = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(this.customBBox || this.nodeExtent);

      // NOTE: it is important to compute this matrix after computing the node's extent
      // because #.getGraphDimensions relies on it
      var nullCamera = new Camera();
      var nullCameraMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());
      // Resetting the label grid
      // TODO: it's probably better to do this explicitly or on resizes for layout and anims
      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);
      var nodesPerPrograms = {};
      var nodeIndices = {};
      var edgeIndices = {};
      var itemIDsIndex = {};
      var incrID = 1;
      var nodes = graph.nodes();

      // Do some indexation on the whole graph
      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        var data = this.nodeDataCache[node];

        // Get initial coordinates
        var attrs = graph.getNodeAttributes(node);
        data.x = attrs.x;
        data.y = attrs.y;
        this.normalizationFunction.applyTo(data);

        // labelgrid
        if (typeof data.label === "string" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {
          matrix: nullCameraMatrix
        }));

        // update count per program
        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;
      }
      this.labelGrid.organize();

      // Allocate memory to programs
      for (var type in this.nodePrograms) {
        if (!hasOwnProperty.call(this.nodePrograms, type)) {
          throw new Error("Sigma: could not find a suitable program for node type \"".concat(type, "\"!"));
        }
        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);
        // We reset that count here, so that we can reuse it while calling the Program#process methods:
        nodesPerPrograms[type] = 0;
      }

      // Order nodes by zIndex before to add them to program
      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.nodeZExtent, function (node) {
        return _this5.nodeDataCache[node].zIndex;
      }, nodes);

      // Add data to programs
      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {
        var _node = nodes[_i];
        nodeIndices[_node] = incrID;
        itemIDsIndex[nodeIndices[_node]] = {
          type: "node",
          id: _node
        };
        incrID++;
        var _data = this.nodeDataCache[_node];
        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);
      }

      //
      // EDGES
      //

      var edgesPerPrograms = {};
      var edges = graph.edges();

      // Allocate memory to programs
      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {
        var edge = edges[_i2];
        var _data2 = this.edgeDataCache[edge];
        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;
      }

      // Order edges by zIndex before to add them to program
      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.edgeZExtent, function (edge) {
        return _this5.edgeDataCache[edge].zIndex;
      }, edges);
      for (var _type2 in this.edgePrograms) {
        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {
          throw new Error("Sigma: could not find a suitable program for edge type \"".concat(_type2, "\"!"));
        }
        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);
        // We reset that count here, so that we can reuse it while calling the Program#process methods:
        edgesPerPrograms[_type2] = 0;
      }

      // Add data to programs
      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {
        var _edge = edges[_i3];
        edgeIndices[_edge] = incrID;
        itemIDsIndex[edgeIndices[_edge]] = {
          type: "edge",
          id: _edge
        };
        incrID++;
        var _data3 = this.edgeDataCache[_edge];
        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);
      }
      this.itemIDsIndex = itemIDsIndex;
      this.nodeIndices = nodeIndices;
      this.edgeIndices = edgeIndices;
      this.emit("afterProcess");
      return this;
    }

    /**
     * Method that backports potential settings updates where it's needed.
     * @private
     */
  }, {
    key: "handleSettingsUpdate",
    value: function handleSettingsUpdate(oldSettings) {
      var _this6 = this;
      var settings = this.settings;
      this.camera.minRatio = settings.minCameraRatio;
      this.camera.maxRatio = settings.maxCameraRatio;
      this.camera.enabledZooming = settings.enableCameraZooming;
      this.camera.enabledPanning = settings.enableCameraPanning;
      this.camera.enabledRotation = settings.enableCameraRotation;
      if (settings.cameraPanBoundaries) {
        this.camera.clean = function (state) {
          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__._)(settings.cameraPanBoundaries) === "object" ? settings.cameraPanBoundaries : {});
        };
      } else {
        this.camera.clean = null;
      }
      this.camera.setState(this.camera.validateState(this.camera.getState()));
      if (oldSettings) {
        // Check edge programs:
        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {
          for (var type in settings.edgeProgramClasses) {
            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {
              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);
            }
          }
          for (var _type3 in oldSettings.edgeProgramClasses) {
            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);
          }
        }

        // Check node programs:
        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {
          for (var _type4 in settings.nodeProgramClasses) {
            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {
              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);
            }
          }
          for (var _type5 in oldSettings.nodeProgramClasses) {
            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);
          }
        }
      }

      // Update captors settings:
      this.mouseCaptor.setSettings(this.settings);
      this.touchCaptor.setSettings(this.settings);
      return this;
    }
  }, {
    key: "cleanCameraState",
    value: function cleanCameraState(state) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$tolerance = _ref.tolerance,
        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,
        boundaries = _ref.boundaries;
      var newState = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, state);

      // Extract necessary properties
      var _ref2 = boundaries || this.nodeExtent,
        _ref2$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.x, 2),
        xMinGraph = _ref2$x[0],
        xMaxGraph = _ref2$x[1],
        _ref2$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.y, 2),
        yMinGraph = _ref2$y[0],
        yMaxGraph = _ref2$y[1];

      // Transform the four corners of the graph rectangle using the provided camera state
      var corners = [this.graphToViewport({
        x: xMinGraph,
        y: yMinGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMaxGraph,
        y: yMinGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMinGraph,
        y: yMaxGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMaxGraph,
        y: yMaxGraph
      }, {
        cameraState: state
      })];

      // Look for new extents, based on these four corners
      var xMin = Infinity,
        xMax = -Infinity,
        yMin = Infinity,
        yMax = -Infinity;
      corners.forEach(function (_ref3) {
        var x = _ref3.x,
          y = _ref3.y;
        xMin = Math.min(xMin, x);
        xMax = Math.max(xMax, x);
        yMin = Math.min(yMin, y);
        yMax = Math.max(yMax, y);
      });

      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:
      var graphWidth = xMax - xMin;
      var graphHeight = yMax - yMin;
      var _this$getDimensions = this.getDimensions(),
        width = _this$getDimensions.width,
        height = _this$getDimensions.height;
      var dx = 0;
      var dy = 0;
      if (graphWidth >= width) {
        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;
      } else {
        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;
      }
      if (graphHeight >= height) {
        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;
      } else {
        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;
      }
      if (dx || dy) {
        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):
        var origin = this.viewportToFramedGraph({
          x: 0,
          y: 0
        }, {
          cameraState: state
        });
        var delta = this.viewportToFramedGraph({
          x: dx,
          y: dy
        }, {
          cameraState: state
        });
        dx = delta.x - origin.x;
        dy = delta.y - origin.y;
        newState.x += dx;
        newState.y += dy;
      }
      return newState;
    }

    /**
     * Method used to render labels.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderLabels",
    value: function renderLabels() {
      if (!this.settings.renderLabels) return this;
      var cameraState = this.camera.getState();

      // Selecting labels to draw
      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);
      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(labelsToDisplay, this.nodesWithForcedLabels);
      this.displayedNodeLabels = new Set();

      // Drawing labels
      var context = this.canvasContexts.labels;
      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {
        var node = labelsToDisplay[i];
        var data = this.nodeDataCache[node];

        // If the node was already drawn (like if it is eligible AND has
        // `forceLabel`), we don't want to draw it again
        // NOTE: we can do better probably
        if (this.displayedNodeLabels.has(node)) continue;

        // If the node is hidden, we don't need to display its label obviously
        if (data.hidden) continue;
        var _this$framedGraphToVi = this.framedGraphToViewport(data),
          x = _this$framedGraphToVi.x,
          y = _this$framedGraphToVi.y;

        // NOTE: we can cache the labels we need to render until the camera's ratio changes
        var size = this.scaleSize(data.size);

        // Is node big enough?
        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;

        // Is node actually on screen (with some margin)
        // NOTE: we used to rely on the quadtree for this, but the coordinates
        // conversion make it unreliable and at that point we already converted
        // to viewport coordinates and since the label grid already culls the
        // number of potential labels to display this looks like a good
        // performance compromise.
        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not
        // considering cells obviously outside of the range of the current
        // view rectangle.
        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;

        // Because displayed edge labels depend directly on actually rendered node
        // labels, we need to only add to this.displayedNodeLabels nodes whose label
        // is rendered.
        // This makes this.displayedNodeLabels depend on viewport, which might become
        // an issue once we start memoizing getLabelsToDisplay.
        this.displayedNodeLabels.add(node);
        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;
        var nodeProgram = this.nodePrograms[data.type];
        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;
        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: node
        }, data), {}, {
          size: size,
          x: x,
          y: y
        }), this.settings);
      }
      return this;
    }

    /**
     * Method used to render edge labels, based on which node labels were
     * rendered.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderEdgeLabels",
    value: function renderEdgeLabels() {
      if (!this.settings.renderEdgeLabels) return this;
      var context = this.canvasContexts.edgeLabels;

      // Clearing
      context.clearRect(0, 0, this.width, this.height);
      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({
        graph: this.graph,
        hoveredNode: this.hoveredNode,
        displayedNodeLabels: this.displayedNodeLabels,
        highlightedNodes: this.highlightedNodes
      });
      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(edgeLabelsToDisplay, this.edgesWithForcedLabels);
      var displayedLabels = new Set();
      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {
        var edge = edgeLabelsToDisplay[i],
          extremities = this.graph.extremities(edge),
          sourceData = this.nodeDataCache[extremities[0]],
          targetData = this.nodeDataCache[extremities[1]],
          edgeData = this.edgeDataCache[edge];

        // If the edge was already drawn (like if it is eligible AND has
        // `forceLabel`), we don't want to draw it again
        if (displayedLabels.has(edge)) continue;

        // If the edge is hidden we don't need to display its label
        // NOTE: the test on sourceData & targetData is probably paranoid at this point?
        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {
          continue;
        }
        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;
        var edgeProgram = this.edgePrograms[edgeData.type];
        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;
        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: edge
        }, edgeData), {}, {
          size: this.scaleSize(edgeData.size)
        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: extremities[0]
        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {
          size: this.scaleSize(sourceData.size)
        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: extremities[1]
        }, targetData), this.framedGraphToViewport(targetData)), {}, {
          size: this.scaleSize(targetData.size)
        }), this.settings);
        displayedLabels.add(edge);
      }
      this.displayedEdgeLabels = displayedLabels;
      return this;
    }

    /**
     * Method used to render the highlighted nodes.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderHighlightedNodes",
    value: function renderHighlightedNodes() {
      var _this7 = this;
      var context = this.canvasContexts.hovers;

      // Clearing
      context.clearRect(0, 0, this.width, this.height);

      // Rendering
      var render = function render(node) {
        var data = _this7.nodeDataCache[node];
        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),
          x = _this7$framedGraphToV.x,
          y = _this7$framedGraphToV.y;
        var size = _this7.scaleSize(data.size);
        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;
        var nodeProgram = _this7.nodePrograms[data.type];
        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;
        drawHover(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: node
        }, data), {}, {
          size: size,
          x: x,
          y: y
        }), _this7.settings);
      };
      var nodesToRender = [];
      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {
        nodesToRender.push(this.hoveredNode);
      }
      this.highlightedNodes.forEach(function (node) {
        // The hovered node has already been highlighted
        if (node !== _this7.hoveredNode) nodesToRender.push(node);
      });

      // Draw labels:
      nodesToRender.forEach(function (node) {
        return render(node);
      });

      // Draw WebGL nodes on top of the labels:
      var nodesPerPrograms = {};

      // 1. Count nodes per type:
      nodesToRender.forEach(function (node) {
        var type = _this7.nodeDataCache[node].type;
        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;
      });
      // 2. Allocate for each type for the proper number of nodes
      for (var type in this.nodeHoverPrograms) {
        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);
        // Also reset count, to use when rendering:
        nodesPerPrograms[type] = 0;
      }
      // 3. Process all nodes to render:
      nodesToRender.forEach(function (node) {
        var data = _this7.nodeDataCache[node];
        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);
      });
      // 4. Clear hovered nodes layer:
      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
      // 5. Render:
      var renderParams = this.getRenderParams();
      for (var _type6 in this.nodeHoverPrograms) {
        var program = this.nodeHoverPrograms[_type6];
        program.render(renderParams);
      }
    }

    /**
     * Method used to schedule a hover render.
     *
     */
  }, {
    key: "scheduleHighlightedNodesRender",
    value: function scheduleHighlightedNodesRender() {
      var _this8 = this;
      if (this.renderHighlightedNodesFrame || this.renderFrame) return;
      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {
        // Resetting state
        _this8.renderHighlightedNodesFrame = null;

        // Rendering
        _this8.renderHighlightedNodes();
        _this8.renderEdgeLabels();
      });
    }

    /**
     * Method used to render.
     *
     * @return {Sigma}
     */
  }, {
    key: "render",
    value: function render() {
      var _this9 = this;
      this.emit("beforeRender");
      var exitRender = function exitRender() {
        _this9.emit("afterRender");
        return _this9;
      };

      // If a render was scheduled, we cancel it
      if (this.renderFrame) {
        cancelAnimationFrame(this.renderFrame);
        this.renderFrame = null;
      }

      // First we need to resize
      this.resize();

      // Do we need to reprocess data?
      if (this.needToProcess) this.process();
      this.needToProcess = false;

      // Clearing the canvases
      this.clear();

      // Prepare the textures
      this.pickingLayers.forEach(function (layer) {
        return _this9.resetWebGLTexture(layer);
      });

      // If we have no nodes we can stop right there
      if (!this.graph.order) return exitRender();

      // TODO: improve this heuristic or move to the captor itself?
      // TODO: deal with the touch captor here as well
      var mouseCaptor = this.mouseCaptor;
      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;

      // Then we need to extract a matrix from the camera
      var cameraState = this.camera.getState();
      var viewportDimensions = this.getDimensions();
      var graphDimensions = this.getGraphDimensions();
      var padding = this.getStagePadding();
      this.matrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding);
      this.invMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding, true);
      this.correctionRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.a)(this.matrix, cameraState, viewportDimensions);
      this.graphToViewportRatio = this.getGraphToViewportRatio();

      // [jacomyal]
      // This comment is related to the one above the `getMatrixImpact` definition:
      // - `this.correctionRatio` is somehow not completely explained
      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the
      //   graph
      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`
      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even
      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:
      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);

      var params = this.getRenderParams();

      // Drawing nodes
      for (var type in this.nodePrograms) {
        var program = this.nodePrograms[type];
        program.render(params);
      }

      // Drawing edges
      if (!this.settings.hideEdgesOnMove || !moving) {
        for (var _type7 in this.edgePrograms) {
          var _program2 = this.edgePrograms[_type7];
          _program2.render(params);
        }
      }

      // Do not display labels on move per setting
      if (this.settings.hideLabelsOnMove && moving) return exitRender();
      this.renderLabels();
      this.renderEdgeLabels();
      this.renderHighlightedNodes();
      return exitRender();
    }

    /**
     * Add a node in the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "addNode",
    value: function addNode(key) {
      // Node display data resolution:
      //  1. First we get the node's attributes
      //  2. We optionally reduce them using the function provided by the user
      //     Note that this function must return a total object and won't be merged
      //  3. We apply our defaults, while running some vital checks
      //  4. We apply the normalization function
      // We shallow copy node data to avoid dangerous behaviors from reducers
      var attr = Object.assign({}, this.graph.getNodeAttributes(key));
      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);
      var data = applyNodeDefaults(this.settings, key, attr);
      this.nodeDataCache[key] = data;

      // Label:
      // We delete and add if needed because this function is also used from
      // update
      this.nodesWithForcedLabels["delete"](key);
      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);

      // Highlighted:
      // We remove and re add if needed because this function is also used from
      // update
      this.highlightedNodes["delete"](key);
      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);

      // zIndex
      if (this.settings.zIndex) {
        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;
        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;
      }
    }

    /**
     * Update a node the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "updateNode",
    value: function updateNode(key) {
      this.addNode(key);

      // Re-apply normalization on the node
      var data = this.nodeDataCache[key];
      this.normalizationFunction.applyTo(data);
    }

    /**
     * Remove a node from the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "removeNode",
    value: function removeNode(key) {
      // Remove from node cache
      delete this.nodeDataCache[key];
      // Remove from node program index
      delete this.nodeProgramIndex[key];
      // Remove from higlighted nodes
      this.highlightedNodes["delete"](key);
      // Remove from hovered
      if (this.hoveredNode === key) this.hoveredNode = null;
      // Remove from forced label
      this.nodesWithForcedLabels["delete"](key);
    }

    /**
     * Add an edge into the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "addEdge",
    value: function addEdge(key) {
      // Edge display data resolution:
      //  1. First we get the edge's attributes
      //  2. We optionally reduce them using the function provided by the user
      //  3. Note that this function must return a total object and won't be merged
      //  4. We apply our defaults, while running some vital checks
      // We shallow copy edge data to avoid dangerous behaviors from reducers
      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));
      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);
      var data = applyEdgeDefaults(this.settings, key, attr);
      this.edgeDataCache[key] = data;

      // Forced label
      // we filter and re push if needed because this function is also used from
      // update
      this.edgesWithForcedLabels["delete"](key);
      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);

      // Check zIndex
      if (this.settings.zIndex) {
        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;
        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;
      }
    }

    /**
     * Update an edge in the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "updateEdge",
    value: function updateEdge(key) {
      this.addEdge(key);
    }

    /**
     * Remove an edge from the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "removeEdge",
    value: function removeEdge(key) {
      // Remove from edge cache
      delete this.edgeDataCache[key];
      // Remove from programId index
      delete this.edgeProgramIndex[key];
      // Remove from hovered
      if (this.hoveredEdge === key) this.hoveredEdge = null;
      // Remove from forced label
      this.edgesWithForcedLabels["delete"](key);
    }

    /**
     * Clear all indices related to nodes.
     * @private
     */
  }, {
    key: "clearNodeIndices",
    value: function clearNodeIndices() {
      // LabelGrid & nodeExtent are only manage/populated in the process function
      this.labelGrid = new LabelGrid();
      this.nodeExtent = {
        x: [0, 1],
        y: [0, 1]
      };
      this.nodeDataCache = {};
      this.edgeProgramIndex = {};
      this.nodesWithForcedLabels = new Set();
      this.nodeZExtent = [Infinity, -Infinity];
      this.highlightedNodes = new Set();
    }

    /**
     * Clear all indices related to edges.
     * @private
     */
  }, {
    key: "clearEdgeIndices",
    value: function clearEdgeIndices() {
      this.edgeDataCache = {};
      this.edgeProgramIndex = {};
      this.edgesWithForcedLabels = new Set();
      this.edgeZExtent = [Infinity, -Infinity];
    }

    /**
     * Clear all indices.
     * @private
     */
  }, {
    key: "clearIndices",
    value: function clearIndices() {
      this.clearEdgeIndices();
      this.clearNodeIndices();
    }

    /**
     * Clear all graph state related to nodes.
     * @private
     */
  }, {
    key: "clearNodeState",
    value: function clearNodeState() {
      this.displayedNodeLabels = new Set();
      this.highlightedNodes = new Set();
      this.hoveredNode = null;
    }

    /**
     * Clear all graph state related to edges.
     * @private
     */
  }, {
    key: "clearEdgeState",
    value: function clearEdgeState() {
      this.displayedEdgeLabels = new Set();
      this.highlightedNodes = new Set();
      this.hoveredEdge = null;
    }

    /**
     * Clear all graph state.
     * @private
     */
  }, {
    key: "clearState",
    value: function clearState() {
      this.clearEdgeState();
      this.clearNodeState();
    }

    /**
     * Add the node data to its program.
     * @private
     * @param node The node's graphology ID
     * @param fingerprint A fingerprint used to identity the node with picking
     * @param position The index where to place the node in the program
     */
  }, {
    key: "addNodeToProgram",
    value: function addNodeToProgram(node, fingerprint, position) {
      var data = this.nodeDataCache[node];
      var nodeProgram = this.nodePrograms[data.type];
      if (!nodeProgram) throw new Error("Sigma: could not find a suitable program for node type \"".concat(data.type, "\"!"));
      nodeProgram.process(fingerprint, position, data);
      // Saving program index
      this.nodeProgramIndex[node] = position;
    }

    /**
     * Add the edge data to its program.
     * @private
     * @param edge The edge's graphology ID
     * @param fingerprint A fingerprint used to identity the edge with picking
     * @param position The index where to place the edge in the program
     */
  }, {
    key: "addEdgeToProgram",
    value: function addEdgeToProgram(edge, fingerprint, position) {
      var data = this.edgeDataCache[edge];
      var edgeProgram = this.edgePrograms[data.type];
      if (!edgeProgram) throw new Error("Sigma: could not find a suitable program for edge type \"".concat(data.type, "\"!"));
      var extremities = this.graph.extremities(edge),
        sourceData = this.nodeDataCache[extremities[0]],
        targetData = this.nodeDataCache[extremities[1]];
      edgeProgram.process(fingerprint, position, sourceData, targetData, data);
      // Saving program index
      this.edgeProgramIndex[edge] = position;
    }

    /**---------------------------------------------------------------------------
     * Public API.
     **---------------------------------------------------------------------------
     */

    /**
     * Function used to get the render params.
     *
     * @return {RenderParams}
     */
  }, {
    key: "getRenderParams",
    value: function getRenderParams() {
      return {
        matrix: this.matrix,
        invMatrix: this.invMatrix,
        width: this.width,
        height: this.height,
        pixelRatio: this.pixelRatio,
        zoomRatio: this.camera.ratio,
        cameraAngle: this.camera.angle,
        sizeRatio: 1 / this.scaleSize(),
        correctionRatio: this.correctionRatio,
        downSizingRatio: this.pickingDownSizingRatio,
        minEdgeThickness: this.settings.minEdgeThickness,
        antiAliasingFeather: this.settings.antiAliasingFeather
      };
    }

    /**
     * Function used to retrieve the actual stage padding value.
     *
     * @return {number}
     */
  }, {
    key: "getStagePadding",
    value: function getStagePadding() {
      var _this$settings = this.settings,
        stagePadding = _this$settings.stagePadding,
        autoRescale = _this$settings.autoRescale;
      return autoRescale ? stagePadding || 0 : 0;
    }

    /**
     * Function used to create a layer element.
     *
     * @param {string} id - Context's id.
     * @param {string} tag - The HTML tag to use.
     * @param options
     * @return {Sigma}
     */
  }, {
    key: "createLayer",
    value: function createLayer(id, tag) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (this.elements[id]) throw new Error("Sigma: a layer named \"".concat(id, "\" already exists"));
      var element = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.b)(tag, {
        position: "absolute"
      }, {
        "class": "sigma-".concat(id)
      });
      if (options.style) Object.assign(element.style, options.style);
      this.elements[id] = element;
      if ("beforeLayer" in options && options.beforeLayer) {
        this.elements[options.beforeLayer].before(element);
      } else if ("afterLayer" in options && options.afterLayer) {
        this.elements[options.afterLayer].after(element);
      } else {
        this.container.appendChild(element);
      }
      return element;
    }

    /**
     * Function used to create a canvas element.
     *
     * @param {string} id - Context's id.
     * @param options
     * @return {Sigma}
     */
  }, {
    key: "createCanvas",
    value: function createCanvas(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.createLayer(id, "canvas", options);
    }

    /**
     * Function used to create a canvas context and add the relevant DOM elements.
     *
     * @param  {string} id - Context's id.
     * @param  options
     * @return {Sigma}
     */
  }, {
    key: "createCanvasContext",
    value: function createCanvasContext(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var canvas = this.createCanvas(id, options);
      var contextOptions = {
        preserveDrawingBuffer: false,
        antialias: false
      };
      this.canvasContexts[id] = canvas.getContext("2d", contextOptions);
      return this;
    }

    /**
     * Function used to create a WebGL context and add the relevant DOM
     * elements.
     *
     * @param  {string}  id      - Context's id.
     * @param  {object?} options - #getContext params to override (optional)
     * @return {WebGLRenderingContext}
     */
  }, {
    key: "createWebGLContext",
    value: function createWebGLContext(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);
      if (options.hidden) canvas.remove();
      var contextOptions = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
        preserveDrawingBuffer: false,
        antialias: false
      }, options);
      var context;

      // First we try webgl2 for an easy performance boost
      context = canvas.getContext("webgl2", contextOptions);

      // Else we fall back to webgl
      if (!context) context = canvas.getContext("webgl", contextOptions);

      // Edge, I am looking right at you...
      if (!context) context = canvas.getContext("experimental-webgl", contextOptions);
      var gl = context;
      this.webGLContexts[id] = gl;

      // Blending:
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      // Prepare frame buffer for picking layers:
      if (options.picking) {
        this.pickingLayers.add(id);
        var newFrameBuffer = gl.createFramebuffer();
        if (!newFrameBuffer) throw new Error("Sigma: cannot create a new frame buffer for layer ".concat(id));
        this.frameBuffers[id] = newFrameBuffer;
      }
      return gl;
    }

    /**
     * Function used to properly kill a layer.
     *
     * @param  {string} id - Layer id.
     * @return {Sigma}
     */
  }, {
    key: "killLayer",
    value: function killLayer(id) {
      var element = this.elements[id];
      if (!element) throw new Error("Sigma: cannot kill layer ".concat(id, ", which does not exist"));
      if (this.webGLContexts[id]) {
        var _gl$getExtension;
        var gl = this.webGLContexts[id];
        (_gl$getExtension = gl.getExtension("WEBGL_lose_context")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();
        delete this.webGLContexts[id];
      } else if (this.canvasContexts[id]) {
        delete this.canvasContexts[id];
      }

      // Delete layer element
      element.remove();
      delete this.elements[id];
      return this;
    }

    /**
     * Method returning the renderer's camera.
     *
     * @return {Camera}
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.camera;
    }

    /**
     * Method setting the renderer's camera.
     *
     * @param  {Camera} camera - New camera.
     * @return {Sigma}
     */
  }, {
    key: "setCamera",
    value: function setCamera(camera) {
      this.unbindCameraHandlers();
      this.camera = camera;
      this.bindCameraHandlers();
    }

    /**
     * Method returning the container DOM element.
     *
     * @return {HTMLElement}
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    /**
     * Method returning the renderer's graph.
     *
     * @return {Graph}
     */
  }, {
    key: "getGraph",
    value: function getGraph() {
      return this.graph;
    }

    /**
     * Method used to set the renderer's graph.
     *
     * @return {Graph}
     */
  }, {
    key: "setGraph",
    value: function setGraph(graph) {
      if (graph === this.graph) return;

      // Check hoveredNode and hoveredEdge
      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;
      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;

      // Unbinding handlers on the current graph
      this.unbindGraphHandlers();
      if (this.checkEdgesEventsFrame !== null) {
        cancelAnimationFrame(this.checkEdgesEventsFrame);
        this.checkEdgesEventsFrame = null;
      }

      // Installing new graph
      this.graph = graph;

      // Binding new handlers
      this.bindGraphHandlers();

      // Re-rendering now to avoid discrepancies from now to next frame
      this.refresh();
    }

    /**
     * Method returning the mouse captor.
     *
     * @return {MouseCaptor}
     */
  }, {
    key: "getMouseCaptor",
    value: function getMouseCaptor() {
      return this.mouseCaptor;
    }

    /**
     * Method returning the touch captor.
     *
     * @return {TouchCaptor}
     */
  }, {
    key: "getTouchCaptor",
    value: function getTouchCaptor() {
      return this.touchCaptor;
    }

    /**
     * Method returning the current renderer's dimensions.
     *
     * @return {Dimensions}
     */
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return {
        width: this.width,
        height: this.height
      };
    }

    /**
     * Method returning the current graph's dimensions.
     *
     * @return {Dimensions}
     */
  }, {
    key: "getGraphDimensions",
    value: function getGraphDimensions() {
      var extent = this.customBBox || this.nodeExtent;
      return {
        width: extent.x[1] - extent.x[0] || 1,
        height: extent.y[1] - extent.y[0] || 1
      };
    }

    /**
     * Method used to get all the sigma node attributes.
     * It's useful for example to get the position of a node
     * and to get values that are set by the nodeReducer
     *
     * @param  {string} key - The node's key.
     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
     */
  }, {
    key: "getNodeDisplayData",
    value: function getNodeDisplayData(key) {
      var node = this.nodeDataCache[key];
      return node ? Object.assign({}, node) : undefined;
    }

    /**
     * Method used to get all the sigma edge attributes.
     * It's useful for example to get values that are set by the edgeReducer.
     *
     * @param  {string} key - The edge's key.
     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
     */
  }, {
    key: "getEdgeDisplayData",
    value: function getEdgeDisplayData(key) {
      var edge = this.edgeDataCache[key];
      return edge ? Object.assign({}, edge) : undefined;
    }

    /**
     * Method used to get the set of currently displayed node labels.
     *
     * @return {Set<string>} A set of node keys whose label is displayed.
     */
  }, {
    key: "getNodeDisplayedLabels",
    value: function getNodeDisplayedLabels() {
      return new Set(this.displayedNodeLabels);
    }

    /**
     * Method used to get the set of currently displayed edge labels.
     *
     * @return {Set<string>} A set of edge keys whose label is displayed.
     */
  }, {
    key: "getEdgeDisplayedLabels",
    value: function getEdgeDisplayedLabels() {
      return new Set(this.displayedEdgeLabels);
    }

    /**
     * Method returning a copy of the settings collection.
     *
     * @return {Settings} A copy of the settings collection.
     */
  }, {
    key: "getSettings",
    value: function getSettings() {
      return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
    }

    /**
     * Method returning the current value for a given setting key.
     *
     * @param  {string} key - The setting key to get.
     * @return {any} The value attached to this setting key or undefined if not found
     */
  }, {
    key: "getSetting",
    value: function getSetting(key) {
      return this.settings[key];
    }

    /**
     * Method setting the value of a given setting key. Note that this will schedule
     * a new render next frame.
     *
     * @param  {string} key - The setting key to set.
     * @param  {any}    value - The value to set.
     * @return {Sigma}
     */
  }, {
    key: "setSetting",
    value: function setSetting(key, value) {
      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
      this.settings[key] = value;
      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);
      this.handleSettingsUpdate(oldValues);
      this.scheduleRefresh();
      return this;
    }

    /**
     * Method updating the value of a given setting key using the provided function.
     * Note that this will schedule a new render next frame.
     *
     * @param  {string}   key     - The setting key to set.
     * @param  {function} updater - The update function.
     * @return {Sigma}
     */
  }, {
    key: "updateSetting",
    value: function updateSetting(key, updater) {
      this.setSetting(key, updater(this.settings[key]));
      return this;
    }

    /**
     * Method setting multiple settings at once.
     *
     * @param  {Partial<Settings>} settings - The settings to set.
     * @return {Sigma}
     */
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
      this.settings = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings), settings);
      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);
      this.handleSettingsUpdate(oldValues);
      this.scheduleRefresh();
      return this;
    }

    /**
     * Method used to resize the renderer.
     *
     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).
     * @return {Sigma}
     */
  }, {
    key: "resize",
    value: function resize(force) {
      var previousWidth = this.width,
        previousHeight = this.height;
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;
      this.pixelRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)();
      if (this.width === 0) {
        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error("Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.");
      }
      if (this.height === 0) {
        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error("Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.");
      }

      // If nothing has changed, we can stop right here
      if (!force && previousWidth === this.width && previousHeight === this.height) return this;

      // Sizing dom elements
      for (var id in this.elements) {
        var element = this.elements[id];
        element.style.width = this.width + "px";
        element.style.height = this.height + "px";
      }

      // Sizing canvas contexts
      for (var _id in this.canvasContexts) {
        this.elements[_id].setAttribute("width", this.width * this.pixelRatio + "px");
        this.elements[_id].setAttribute("height", this.height * this.pixelRatio + "px");
        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);
      }

      // Sizing WebGL contexts
      for (var _id2 in this.webGLContexts) {
        this.elements[_id2].setAttribute("width", this.width * this.pixelRatio + "px");
        this.elements[_id2].setAttribute("height", this.height * this.pixelRatio + "px");
        var gl = this.webGLContexts[_id2];
        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);

        // Clear picking texture if needed
        if (this.pickingLayers.has(_id2)) {
          var currentTexture = this.textures[_id2];
          if (currentTexture) gl.deleteTexture(currentTexture);
        }
      }
      this.emit("resize");
      return this;
    }

    /**
     * Method used to clear all the canvases.
     *
     * @return {Sigma}
     */
  }, {
    key: "clear",
    value: function clear() {
      this.emit("beforeClear");
      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);
      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);
      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);
      this.emit("afterClear");
      return this;
    }

    /**
     * Method used to refresh, i.e. force the renderer to reprocess graph
     * data and render, but keep the state.
     * - if a partialGraph is provided, we only reprocess those nodes & edges.
     * - if schedule is TRUE, we schedule a render instead of sync render
     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)
     *
     * @return {Sigma}
     */
  }, {
    key: "refresh",
    value: function refresh(opts) {
      var _this10 = this;
      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;
      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;
      var fullRefresh = !opts || !opts.partialGraph;
      if (fullRefresh) {
        // Re-index graph data
        this.clearEdgeIndices();
        this.clearNodeIndices();
        this.graph.forEachNode(function (node) {
          return _this10.addNode(node);
        });
        this.graph.forEachEdge(function (edge) {
          return _this10.addEdge(edge);
        });
      } else {
        var _opts$partialGraph, _opts$partialGraph2;
        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];
        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {
          var node = nodes[i];
          // Recompute node's data (ie. apply reducer)
          this.updateNode(node);
          // Add node to the program if layout is unchanged.
          // otherwise it will be done in the process function
          if (skipIndexation) {
            var programIndex = this.nodeProgramIndex[node];
            if (programIndex === undefined) throw new Error("Sigma: node \"".concat(node, "\" can't be repaint"));
            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);
          }
        }
        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];
        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {
          var edge = edges[_i4];
          // Recompute edge's data (ie. apply reducer)
          this.updateEdge(edge);
          // Add edge to the program
          // otherwise it will be done in the process function
          if (skipIndexation) {
            var _programIndex = this.edgeProgramIndex[edge];
            if (_programIndex === undefined) throw new Error("Sigma: edge \"".concat(edge, "\" can't be repaint"));
            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);
          }
        }
      }

      // Do we need to call the process function ?
      if (fullRefresh || !skipIndexation) this.needToProcess = true;
      if (schedule) this.scheduleRender();else this.render();
      return this;
    }

    /**
     * Method used to schedule a render at the next available frame.
     * This method can be safely called on a same frame because it basically
     * debounces refresh to the next frame.
     *
     * @return {Sigma}
     */
  }, {
    key: "scheduleRender",
    value: function scheduleRender() {
      var _this11 = this;
      if (!this.renderFrame) {
        this.renderFrame = requestAnimationFrame(function () {
          _this11.render();
        });
      }
      return this;
    }

    /**
     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)
     * at the next available frame.
     * This method can be safely called on a same frame because it basically
     * debounces refresh to the next frame.
     *
     * @return {Sigma}
     */
  }, {
    key: "scheduleRefresh",
    value: function scheduleRefresh(opts) {
      return this.refresh((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, opts), {}, {
        schedule: true
      }));
    }

    /**
     * Method used to (un)zoom, while preserving the position of a viewport point.
     * Used for instance to zoom "on the mouse cursor".
     *
     * @param viewportTarget
     * @param newRatio
     * @return {CameraState}
     */
  }, {
    key: "getViewportZoomedState",
    value: function getViewportZoomedState(viewportTarget, newRatio) {
      var _this$camera$getState = this.camera.getState(),
        ratio = _this$camera$getState.ratio,
        angle = _this$camera$getState.angle,
        x = _this$camera$getState.x,
        y = _this$camera$getState.y;
      var _this$settings2 = this.settings,
        minCameraRatio = _this$settings2.minCameraRatio,
        maxCameraRatio = _this$settings2.maxCameraRatio;
      if (typeof maxCameraRatio === "number") newRatio = Math.min(newRatio, maxCameraRatio);
      if (typeof minCameraRatio === "number") newRatio = Math.max(newRatio, minCameraRatio);
      var ratioDiff = newRatio / ratio;
      var center = {
        x: this.width / 2,
        y: this.height / 2
      };
      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);
      var graphCenterPosition = this.viewportToFramedGraph(center);
      return {
        angle: angle,
        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,
        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,
        ratio: newRatio
      };
    }

    /**
     * Method returning the abstract rectangle containing the graph according
     * to the camera's state.
     *
     * @return {object} - The view's rectangle.
     */
  }, {
    key: "viewRectangle",
    value: function viewRectangle() {
      var p1 = this.viewportToFramedGraph({
          x: 0,
          y: 0
        }),
        p2 = this.viewportToFramedGraph({
          x: this.width,
          y: 0
        }),
        h = this.viewportToFramedGraph({
          x: 0,
          y: this.height
        });
      return {
        x1: p1.x,
        y1: p1.y,
        x2: p2.x,
        y2: p2.y,
        height: p2.y - h.y
      };
    }

    /**
     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
  }, {
    key: "framedGraphToViewport",
    value: function framedGraphToViewport(coordinates) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;
      var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;
      var viewportPos = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(matrix, coordinates);
      return {
        x: (1 + viewportPos.x) * this.width / 2,
        y: (1 - viewportPos.y) * this.height / 2
      };
    }

    /**
     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
  }, {
    key: "viewportToFramedGraph",
    value: function viewportToFramedGraph(coordinates) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;
      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;
      var res = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(invMatrix, {
        x: coordinates.x / this.width * 2 - 1,
        y: 1 - coordinates.y / this.height * 2
      });
      if (isNaN(res.x)) res.x = 0;
      if (isNaN(res.y)) res.y = 0;
      return res;
    }

    /**
     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
     * stage) to the graph system (the reference system of data as they are in the given graph instance).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  viewportPoint
     * @param {CoordinateConversionOverride} override
     */
  }, {
    key: "viewportToGraph",
    value: function viewportToGraph(viewportPoint) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));
    }

    /**
     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  graphPoint
     * @param {CoordinateConversionOverride} override
     */
  }, {
    key: "graphToViewport",
    value: function graphToViewport(graphPoint) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);
    }

    /**
     * Method returning the distance multiplier between the graph system and the
     * viewport system.
     */
  }, {
    key: "getGraphToViewportRatio",
    value: function getGraphToViewportRatio() {
      var graphP1 = {
        x: 0,
        y: 0
      };
      var graphP2 = {
        x: 1,
        y: 1
      };
      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));
      var viewportP1 = this.graphToViewport(graphP1);
      var viewportP2 = this.graphToViewport(graphP2);
      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));
      return viewportD / graphD;
    }

    /**
     * Method returning the graph's bounding box.
     *
     * @return {{ x: Extent, y: Extent }}
     */
  }, {
    key: "getBBox",
    value: function getBBox() {
      return this.nodeExtent;
    }

    /**
     * Method returning the graph's custom bounding box, if any.
     *
     * @return {{ x: Extent, y: Extent } | null}
     */
  }, {
    key: "getCustomBBox",
    value: function getCustomBBox() {
      return this.customBBox;
    }

    /**
     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
     *
     * @return {Sigma}
     */
  }, {
    key: "setCustomBBox",
    value: function setCustomBBox(customBBox) {
      this.customBBox = customBBox;
      this.scheduleRender();
      return this;
    }

    /**
     * Method used to shut the container & release event listeners.
     *
     * @return {undefined}
     */
  }, {
    key: "kill",
    value: function kill() {
      // Emitting "kill" events so that plugins and such can cleanup
      this.emit("kill");

      // Releasing events
      this.removeAllListeners();

      // Releasing camera handlers
      this.unbindCameraHandlers();

      // Releasing DOM events & captors
      window.removeEventListener("resize", this.activeListeners.handleResize);
      this.mouseCaptor.kill();
      this.touchCaptor.kill();

      // Releasing graph handlers
      this.unbindGraphHandlers();

      // Releasing cache & state
      this.clearIndices();
      this.clearState();
      this.nodeDataCache = {};
      this.edgeDataCache = {};
      this.highlightedNodes.clear();

      // Clearing frames
      if (this.renderFrame) {
        cancelAnimationFrame(this.renderFrame);
        this.renderFrame = null;
      }
      if (this.renderHighlightedNodesFrame) {
        cancelAnimationFrame(this.renderHighlightedNodesFrame);
        this.renderHighlightedNodesFrame = null;
      }

      // Destroying canvases
      var container = this.container;
      while (container.firstChild) container.removeChild(container.firstChild);

      // Kill programs:
      for (var type in this.nodePrograms) {
        this.nodePrograms[type].kill();
      }
      for (var _type8 in this.nodeHoverPrograms) {
        this.nodeHoverPrograms[_type8].kill();
      }
      for (var _type9 in this.edgePrograms) {
        this.edgePrograms[_type9].kill();
      }
      this.nodePrograms = {};
      this.nodeHoverPrograms = {};
      this.edgePrograms = {};

      // Kill all canvas/WebGL contexts
      for (var id in this.elements) {
        this.killLayer(id);
      }

      // Destroying remaining collections
      this.canvasContexts = {};
      this.webGLContexts = {};
      this.elements = {};
    }

    /**
     * Method used to scale the given size according to the camera's ratio, i.e.
     * zooming state.
     *
     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).
     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).
     * @return {number}              - The scaled size.
     */
  }, {
    key: "scaleSize",
    value: function scaleSize() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;
      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting("itemSizesReference") === "positions" ? cameraRatio * this.graphToViewportRatio : 1);
    }

    /**
     * Method that returns the collection of all used canvases.
     * At the moment, the instantiated canvases are the following, and in the
     * following order in the DOM:
     * - `edges`
     * - `nodes`
     * - `edgeLabels`
     * - `labels`
     * - `hovers`
     * - `hoverNodes`
     * - `mouse`
     *
     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.
     */
  }, {
    key: "getCanvases",
    value: function getCanvases() {
      var res = {};
      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];
      return res;
    }
  }]);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

/**
 * Sigma.js Library Endpoint
 * =========================
 *
 * The library endpoint.
 * @module
 */
var Sigma = Sigma$1;




/***/ }),

/***/ "./node_modules/sigma/settings/dist/sigma-settings.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/settings/dist/sigma-settings.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_EDGE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_EDGE_PROGRAM_CLASSES),
/* harmony export */   DEFAULT_NODE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_NODE_PROGRAM_CLASSES),
/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),
/* harmony export */   resolveSettings: () => (/* binding */ resolveSettings),
/* harmony export */   validateSettings: () => (/* binding */ validateSettings)
/* harmony export */ });
/* harmony import */ var _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-236c62ad.esm.js */ "./node_modules/sigma/dist/index-236c62ad.esm.js");
/* harmony import */ var _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/data-11df7124.esm.js */ "./node_modules/sigma/dist/data-11df7124.esm.js");





/**
 * Sigma.js Settings
 * =================================
 *
 * The list of settings and some handy functions.
 * @module
 */

/**
 * Sigma.js settings
 * =================================
 */

var DEFAULT_SETTINGS = {
  // Performance
  hideEdgesOnMove: false,
  hideLabelsOnMove: false,
  renderLabels: true,
  renderEdgeLabels: false,
  enableEdgeEvents: false,
  // Component rendering
  defaultNodeColor: "#999",
  defaultNodeType: "circle",
  defaultEdgeColor: "#ccc",
  defaultEdgeType: "line",
  labelFont: "Arial",
  labelSize: 14,
  labelWeight: "normal",
  labelColor: {
    color: "#000"
  },
  edgeLabelFont: "Arial",
  edgeLabelSize: 14,
  edgeLabelWeight: "normal",
  edgeLabelColor: {
    attribute: "color"
  },
  stagePadding: 30,
  defaultDrawEdgeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.d,
  defaultDrawNodeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.b,
  defaultDrawNodeHover: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.c,
  minEdgeThickness: 1.7,
  antiAliasingFeather: 1,
  // Mouse and touch settings
  dragTimeout: 100,
  draggedEventsTolerance: 3,
  inertiaDuration: 200,
  inertiaRatio: 3,
  zoomDuration: 250,
  zoomingRatio: 1.7,
  doubleClickTimeout: 300,
  doubleClickZoomingRatio: 2.2,
  doubleClickZoomingDuration: 200,
  tapMoveTolerance: 10,
  // Size and scaling
  zoomToSizeRatioFunction: Math.sqrt,
  itemSizesReference: "screen",
  autoRescale: true,
  autoCenter: true,
  // Labels
  labelDensity: 1,
  labelGridCellSize: 100,
  labelRenderedSizeThreshold: 6,
  // Reducers
  nodeReducer: null,
  edgeReducer: null,
  // Features
  zIndex: false,
  minCameraRatio: null,
  maxCameraRatio: null,
  enableCameraZooming: true,
  enableCameraPanning: true,
  enableCameraRotation: true,
  cameraPanBoundaries: null,
  // Lifecycle
  allowInvalidContainer: false,
  // Program classes
  nodeProgramClasses: {},
  nodeHoverProgramClasses: {},
  edgeProgramClasses: {}
};
var DEFAULT_NODE_PROGRAM_CLASSES = {
  circle: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.N
};
var DEFAULT_EDGE_PROGRAM_CLASSES = {
  arrow: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.E,
  line: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.e
};
function validateSettings(settings) {
  if (typeof settings.labelDensity !== "number" || settings.labelDensity < 0) {
    throw new Error("Settings: invalid `labelDensity`. Expecting a positive number.");
  }
  var minCameraRatio = settings.minCameraRatio,
    maxCameraRatio = settings.maxCameraRatio;
  if (typeof minCameraRatio === "number" && typeof maxCameraRatio === "number" && maxCameraRatio < minCameraRatio) {
    throw new Error("Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.");
  }
}
function resolveSettings(settings) {
  var resolvedSettings = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_SETTINGS, settings);
  resolvedSettings.nodeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);
  resolvedSettings.edgeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);
  return resolvedSettings;
}




/***/ }),

/***/ "./node_modules/sigma/types/dist/sigma-types.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/types/dist/sigma-types.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var _dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);



/**
 * Util type to represent maps of typed elements, but implemented with
 * JavaScript objects.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

/**
 * Returns a type similar to T, but with the K set of properties of the type
 * T *required*, and the rest optional.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

/**
 * Returns a type similar to Partial<T>, but with at least one key set.
 */

/**
 * Custom event emitter types.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

var TypedEventEmitter = /*#__PURE__*/function (_ref) {
  function TypedEventEmitter() {
    var _this;
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, TypedEventEmitter);
    _this = (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, TypedEventEmitter);
    _this.rawEmitter = _this;
    return _this;
  }
  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(TypedEventEmitter, _ref);
  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(TypedEventEmitter);
}(events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter);

/**
 * Event types.
 */

/**
 * Export various other types:
 */




/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sigma__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! sigma */ "./node_modules/sigma/dist/sigma.esm.js");
/* harmony import */ var graphology__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology */ "./node_modules/graphology/dist/graphology.mjs");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_1__);




window.onload = function () {
    // const graph = new graphology.Graph();
    // graph.addNode("1", { label: "Node 1", x: 0, y: 0, size: 10, color: "blue" });
    // graph.addNode("2", { label: "Node 2", x: 1, y: 1, size: 20, color: "red" });
    // graph.addEdge("1", "2", { size: 5, color: "purple" });

    // // Instantiate sigma.js and render the graph
    // const sigmaInstance = new Sigma(graph, document.getElementById("container"));
    // }
    console.log("Hello");

    var results = papaparse__WEBPACK_IMPORTED_MODULE_1___default().parse("./jon_sample_data.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
            console.log("CSV Data Parsed:", results.data);
            // Process the parsed data here
            // For example, you can create nodes and edges based on the CSV data
            const graph = new graphology__WEBPACK_IMPORTED_MODULE_0__["default"].Graph();
            results.data.forEach(row => {

                if (!graph.hasNode(row.source)) {
                    graph.addNode(row.source, {
                        label: row.source,
                        x: Math.random(),
                        y: Math.random(),
                        size: 10,
                        color: "blue"
                    });
                }
            });

            results.data.forEach(row => {
                if (row.source && row.target && graph.hasNode (row.source) && graph.hasNode(row.target) && !graph.hasEdge(row.source, row.target)) {
                    graph.addEdge(row.source, row.target, { 
                        size: 2, 
                        label: row.label,
                        type: 'arrow',
                        forceLabel: true
                    });
                }
            });

            // Render the graph using Sigma.js
            const sigmaInstance = new sigma__WEBPACK_IMPORTED_MODULE_2__["default"](graph, document.getElementById("container"), {
                renderEdgeLabels: true
            });
        },
        error: function (error) {
            console.error("Error parsing CSV:", error);
        }
    });

};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7O0FDaGZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDdEJzQzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPLHdCQUF3QixXQUFXO0FBQzNEOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixPQUFPLHdCQUF3QixXQUFXO0FBQzNEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxlQUFlO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLGlDQUFpQzs7QUFFNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFB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O0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTtBQUNiLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Ozs7Ozs7Ozs7QUMvb0MzekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRStIOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakYvRTtBQUNlOztBQUUvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxnRUFBTzs7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QUNYO0FBQ0E7QUFDQSx1RUFBdUUseURBQWMsQ0FBQyx5REFBYyxHQUFHLGdCQUFnQjtBQUN2SDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRSIsInNvdXJjZXMiOlsid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaC5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5L2Rpc3QvZ3JhcGhvbG9neS5tanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvcGFwYXBhcnNlL3BhcGFwYXJzZS5taW4uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9jb2xvcnMtYmViMDZlYjIuZXNtLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvZGF0YS0xMWRmNzEyNC5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmRleC0yMzZjNjJhZC5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9ub3JtYWxpemF0aW9uLWJlNDQ1NTE4LmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L3NpZ21hLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS9zZXR0aW5ncy9kaXN0L3NpZ21hLXNldHRpbmdzLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS90eXBlcy9kaXN0L3NpZ21hLXR5cGVzLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgaXNHcmFwaFxuICogPT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFZlcnkgc2ltcGxlIGZ1bmN0aW9uIGFpbWluZyBhdCBlbnN1cmluZyB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYVxuICogZ3JhcGhvbG9neSBpbnN0YW5jZS5cbiAqL1xuXG4vKipcbiAqIENoZWNraW5nIHRoZSB2YWx1ZSBpcyBhIGdyYXBob2xvZ3kgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtICB7YW55fSAgICAgdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzR3JhcGgodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB2YWx1ZSAhPT0gbnVsbCAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYWRkVW5kaXJlY3RlZEVkZ2VXaXRoS2V5ID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLmRyb3BOb2RlID09PSAnZnVuY3Rpb24nICYmXG4gICAgdHlwZW9mIHZhbHVlLm11bHRpID09PSAnYm9vbGVhbidcbiAgKTtcbn07XG4iLCJpbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgVXRpbGl0aWVzXG4gKiA9PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBDb2xsZWN0aW9uIG9mIGhlbHBmdWwgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLlxuICovXG5cbi8qKlxuICogT2JqZWN0LmFzc2lnbi1saWtlIHBvbHlmaWxsLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gdGFyZ2V0ICAgICAgIC0gRmlyc3Qgb2JqZWN0LlxuICogQHBhcmFtICB7b2JqZWN0fSBbLi4ub2JqZWN0c10gLSBPYmplY3RzIHRvIG1lcmdlLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBhc3NpZ25Qb2x5ZmlsbCgpIHtcbiAgY29uc3QgdGFyZ2V0ID0gYXJndW1lbnRzWzBdO1xuXG4gIGZvciAobGV0IGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICghYXJndW1lbnRzW2ldKSBjb250aW51ZTtcblxuICAgIGZvciAoY29uc3QgayBpbiBhcmd1bWVudHNbaV0pIHRhcmdldFtrXSA9IGFyZ3VtZW50c1tpXVtrXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmxldCBhc3NpZ24gPSBhc3NpZ25Qb2x5ZmlsbDtcblxuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduID09PSAnZnVuY3Rpb24nKSBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgZmlyc3QgbWF0Y2hpbmcgZWRnZSBmb3IgZ2l2ZW4gcGF0aC5cbiAqIE5vdGU6IHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgY2hlY2sgdGhlIGV4aXN0ZW5jZSBvZiBzb3VyY2UgJiB0YXJnZXQuIFRoaXNcbiAqIG11c3QgYmUgcGVyZm9ybWVkIGJ5IHRoZSBjYWxsZXIuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICBncmFwaCAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHthbnl9ICAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICogQHBhcmFtICB7YW55fSAgICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSAgIC0gVHlwZSBvZiB0aGUgZWRnZSAobWl4ZWQsIGRpcmVjdGVkIG9yIHVuZGlyZWN0ZWQpLlxuICogQHJldHVybiB7c3RyaW5nfG51bGx9XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoaW5nRWRnZShncmFwaCwgc291cmNlLCB0YXJnZXQsIHR5cGUpIHtcbiAgY29uc3Qgc291cmNlRGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICBsZXQgZWRnZSA9IG51bGw7XG5cbiAgaWYgKCFzb3VyY2VEYXRhKSByZXR1cm4gZWRnZTtcblxuICBpZiAodHlwZSA9PT0gJ21peGVkJykge1xuICAgIGVkZ2UgPVxuICAgICAgKHNvdXJjZURhdGEub3V0ICYmIHNvdXJjZURhdGEub3V0W3RhcmdldF0pIHx8XG4gICAgICAoc291cmNlRGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnZGlyZWN0ZWQnKSB7XG4gICAgZWRnZSA9IHNvdXJjZURhdGEub3V0ICYmIHNvdXJjZURhdGEub3V0W3RhcmdldF07XG4gIH0gZWxzZSB7XG4gICAgZWRnZSA9IHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XTtcbiAgfVxuXG4gIHJldHVybiBlZGdlO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gICB2YWx1ZSAtIFRhcmdldCB2YWx1ZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgLy8gTk9URTogYXMgcGVyIGh0dHBzOi8vZ2l0aHViLmNvbS9ncmFwaG9sb2d5L2dyYXBob2xvZ3kvaXNzdWVzLzE0OVxuICAvLyB0aGlzIGZ1bmN0aW9uIGhhcyBiZWVuIGxvb3NlbmVkIG5vdCB0byByZWplY3Qgb2JqZWN0IGluc3RhbmNlc1xuICAvLyBjb21pbmcgZnJvbSBvdGhlciBKYXZhU2NyaXB0IGNvbnRleHRzLiBJdCBoYXMgYWxzbyBiZWVuIGNob3NlblxuICAvLyBub3QgdG8gaW1wcm92ZSBpdCB0byBhdm9pZCBvYnZpb3VzIGZhbHNlIHBvc2l0aXZlcyBhbmQgYXZvaWRcbiAgLy8gdGFraW5nIGEgcGVyZm9ybWFuY2UgaGl0LiBQZW9wbGUgc2hvdWxkIHJlYWxseSB1c2UgVHlwZVNjcmlwdFxuICAvLyBpZiB0aGV5IHdhbnQgdG8gYXZvaWQgZmVlZGluZyBzdWJ0bHkgaXJyZWx2YW50IGF0dHJpYnV0ZSBvYmplY3RzLlxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGVtcHR5LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gIG8gLSBUYXJnZXQgT2JqZWN0LlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNFbXB0eShvKSB7XG4gIGxldCBrO1xuXG4gIGZvciAoayBpbiBvKSByZXR1cm4gZmFsc2U7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIFwicHJpdmF0ZVwiIHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gbWVtYmVyIG5hbWUgYnkgY29uY2VhbGluZyBpdFxuICogdXNpbmcgdGhlIGBlbnVtZXJhYmxlYCBvcHRpb24uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHRhcmdldCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAgIC0gTWVtYmVyIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByaXZhdGVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlXG4gIH0pO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSByZWFkLW9ubHkgcHJvcGVydHkgZm9yIHRoZSBnaXZlbiBtZW1iZXIgbmFtZSAmIHRoZSBnaXZlbiBnZXR0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9ICAgdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG5hbWUgICAtIE1lbWJlciBuYW1lLlxuICogQHBhcmFtIHttaXhlZH0gICAgdmFsdWUgIC0gVGhlIGF0dGFjaGVkIGdldHRlciBvciBmaXhlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcmVhZE9ubHlQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHZhbHVlKSB7XG4gIGNvbnN0IGRlc2NyaXB0b3IgPSB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfTtcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZGVzY3JpcHRvci5nZXQgPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gdmFsdWU7XG4gICAgZGVzY3JpcHRvci53cml0YWJsZSA9IGZhbHNlO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwgZGVzY3JpcHRvcik7XG59XG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIHRoZSBnaXZlbiBvYmplY3QgY29uc3RpdHV0ZSB2YWxpZCBoaW50cy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaGludHMgLSBUYXJnZXQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUhpbnRzKGhpbnRzKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdChoaW50cykpIHJldHVybiBmYWxzZTtcblxuICBpZiAoaGludHMuYXR0cmlidXRlcyAmJiAhQXJyYXkuaXNBcnJheShoaW50cy5hdHRyaWJ1dGVzKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBnZW5lcmF0aW5nIGluY3JlbWVudGFsIGlkcyBmb3IgZWRnZXMuXG4gKlxuICogQHJldHVybiB7ZnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGluY3JlbWVudGFsSWRTdGFydGluZ0Zyb21SYW5kb21CeXRlKCkge1xuICBsZXQgaSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NikgJiAweGZmO1xuXG4gIHJldHVybiAoKSA9PiB7XG4gICAgcmV0dXJuIGkrKztcbiAgfTtcbn1cblxuLyoqXG4gKiBDaGFpbnMgbXVsdGlwbGUgaXRlcmF0b3JzIGludG8gYSBzaW5nbGUgaXRlcmF0b3IuXG4gKlxuICogQHBhcmFtIHsuLi5JdGVyYXRvcn0gaXRlcmFibGVzXG4gKiBAcmV0dXJucyB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNoYWluKCkge1xuICBjb25zdCBpdGVyYWJsZXMgPSBhcmd1bWVudHM7XG4gIGxldCBjdXJyZW50ID0gbnVsbDtcbiAgbGV0IGkgPSAtMTtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgbGV0IHN0ZXAgPSBudWxsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgaSsrO1xuICAgICAgICAgIGlmIChpID49IGl0ZXJhYmxlcy5sZW5ndGgpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG4gICAgICAgICAgY3VycmVudCA9IGl0ZXJhYmxlc1tpXVtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RlcCA9IGN1cnJlbnQubmV4dCgpO1xuICAgICAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAgICAgY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zdGFudC1jb25kaXRpb25cbiAgICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgICByZXR1cm4gc3RlcDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVtcHR5SXRlcmF0b3IoKSB7XG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IEN1c3RvbSBFcnJvcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBEZWZpbmluZyBjdXN0b20gZXJyb3JzIGZvciBlYXNlIG9mIHVzZSAmIGVhc3kgdW5pdCB0ZXN0cyBhY3Jvc3NcbiAqIGltcGxlbWVudGF0aW9ucyAobm9ybWFsaXplZCB0eXBvbG9neSByYXRoZXIgdGhhbiByZWx5aW5nIG9uIGVycm9yXG4gKiBtZXNzYWdlcyB0byBjaGVjayB3aGV0aGVyIHRoZSBjb3JyZWN0IGVycm9yIHdhcyBmb3VuZCkuXG4gKi9cbmNsYXNzIEdyYXBoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubmFtZSA9ICdHcmFwaEVycm9yJztcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG59XG5cbmNsYXNzIEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yIGV4dGVuZHMgR3JhcGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3InO1xuXG4gICAgLy8gVGhpcyBpcyBWOCBzcGVjaWZpYyB0byBlbmhhbmNlIHN0YWNrIHJlYWRhYmlsaXR5XG4gICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKFxuICAgICAgICB0aGlzLFxuICAgICAgICBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3JcbiAgICAgICk7XG4gIH1cbn1cblxuY2xhc3MgTm90Rm91bmRHcmFwaEVycm9yIGV4dGVuZHMgR3JhcGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnTm90Rm91bmRHcmFwaEVycm9yJztcblxuICAgIC8vIFRoaXMgaXMgVjggc3BlY2lmaWMgdG8gZW5oYW5jZSBzdGFjayByZWFkYWJpbGl0eVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBOb3RGb3VuZEdyYXBoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuXG5jbGFzcyBVc2FnZUdyYXBoRXJyb3IgZXh0ZW5kcyBHcmFwaEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdVc2FnZUdyYXBoRXJyb3InO1xuXG4gICAgLy8gVGhpcyBpcyBWOCBzcGVjaWZpYyB0byBlbmhhbmNlIHN0YWNrIHJlYWRhYmlsaXR5XG4gICAgaWYgKHR5cGVvZiBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFVzYWdlR3JhcGhFcnJvci5wcm90b3R5cGUuY29uc3RydWN0b3IpO1xuICB9XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBJbnRlcm5hbCBEYXRhIENsYXNzZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEludGVybmFsIGNsYXNzZXMgaG9wZWZ1bGx5IHJlZHVjZWQgdG8gc3RydWN0cyBieSBlbmdpbmVzICYgc3RvcmluZ1xuICogbmVjZXNzYXJ5IGluZm9ybWF0aW9uIGZvciBub2RlcyAmIGVkZ2VzLlxuICpcbiAqIE5vdGUgdGhhdCB0aG9zZSBjbGFzc2VzIGRvbid0IHJlbHkgb24gdGhlIGBjbGFzc2Aga2V5d29yZCB0byBhdm9pZCBzb21lXG4gKiBjcnVmdCBpbnRyb2R1Y2VkIGJ5IG1vc3Qgb2YgRVMyMDE1IHRyYW5zcGlsZXJzLlxuICovXG5cbi8qKlxuICogTWl4ZWROb2RlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE5vZGUncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBNaXhlZE5vZGVEYXRhKGtleSwgYXR0cmlidXRlcykge1xuICAvLyBBdHRyaWJ1dGVzXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gIHRoaXMuY2xlYXIoKTtcbn1cblxuTWl4ZWROb2RlRGF0YS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIERlZ3JlZXNcbiAgdGhpcy5pbkRlZ3JlZSA9IDA7XG4gIHRoaXMub3V0RGVncmVlID0gMDtcbiAgdGhpcy51bmRpcmVjdGVkRGVncmVlID0gMDtcbiAgdGhpcy51bmRpcmVjdGVkTG9vcHMgPSAwO1xuICB0aGlzLmRpcmVjdGVkTG9vcHMgPSAwO1xuXG4gIC8vIEluZGljZXNcbiAgdGhpcy5pbiA9IHt9O1xuICB0aGlzLm91dCA9IHt9O1xuICB0aGlzLnVuZGlyZWN0ZWQgPSB7fTtcbn07XG5cbi8qKlxuICogRGlyZWN0ZWROb2RlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE5vZGUncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBEaXJlY3RlZE5vZGVEYXRhKGtleSwgYXR0cmlidXRlcykge1xuICAvLyBBdHRyaWJ1dGVzXG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gIHRoaXMuY2xlYXIoKTtcbn1cblxuRGlyZWN0ZWROb2RlRGF0YS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIERlZ3JlZXNcbiAgdGhpcy5pbkRlZ3JlZSA9IDA7XG4gIHRoaXMub3V0RGVncmVlID0gMDtcbiAgdGhpcy5kaXJlY3RlZExvb3BzID0gMDtcblxuICAvLyBJbmRpY2VzXG4gIHRoaXMuaW4gPSB7fTtcbiAgdGhpcy5vdXQgPSB7fTtcbn07XG5cbi8qKlxuICogVW5kaXJlY3RlZE5vZGVEYXRhIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gTm9kZSdzIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIFVuZGlyZWN0ZWROb2RlRGF0YShrZXksIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICB0aGlzLmNsZWFyKCk7XG59XG5cblVuZGlyZWN0ZWROb2RlRGF0YS5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIERlZ3JlZXNcbiAgdGhpcy51bmRpcmVjdGVkRGVncmVlID0gMDtcbiAgdGhpcy51bmRpcmVjdGVkTG9vcHMgPSAwO1xuXG4gIC8vIEluZGljZXNcbiAgdGhpcy51bmRpcmVjdGVkID0ge307XG59O1xuXG4vKipcbiAqIEVkZ2VEYXRhIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtib29sZWFufSB1bmRpcmVjdGVkICAgLSBXaGV0aGVyIHRoZSBlZGdlIGlzIHVuZGlyZWN0ZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gIHN0cmluZyAgICAgICAtIFRoZSBlZGdlJ3Mga2V5LlxuICogQHBhcmFtIHtzdHJpbmd9ICBzb3VyY2UgICAgICAgLSBTb3VyY2Ugb2YgdGhlIGVkZ2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gIHRhcmdldCAgICAgICAtIFRhcmdldCBvZiB0aGUgZWRnZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgYXR0cmlidXRlcyAgIC0gRWRnZSdzIGF0dHJpYnV0ZXMuXG4gKi9cbmZ1bmN0aW9uIEVkZ2VEYXRhKHVuZGlyZWN0ZWQsIGtleSwgc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcbiAgdGhpcy51bmRpcmVjdGVkID0gdW5kaXJlY3RlZDtcblxuICAvLyBFeHRyZW1pdGllc1xuICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG59XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5rZXk7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LmtleTtcblxuICAvLyBIYW5kbGluZyBzb3VyY2VcbiAgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdID0gdGhpcztcblxuICBpZiAodGhpcy51bmRpcmVjdGVkICYmIHNvdXJjZSA9PT0gdGFyZ2V0KSByZXR1cm47XG5cbiAgLy8gSGFuZGxpbmcgdGFyZ2V0XG4gIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcztcbn07XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5hdHRhY2hNdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IG91dEtleSA9ICdvdXQnO1xuICBsZXQgaW5LZXkgPSAnaW4nO1xuXG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLmtleTtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQua2V5O1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQpIG91dEtleSA9IGluS2V5ID0gJ3VuZGlyZWN0ZWQnO1xuXG4gIC8vIEhhbmRsaW5nIHNvdXJjZVxuICBjb25zdCBhZGogPSB0aGlzLnNvdXJjZVtvdXRLZXldO1xuICBjb25zdCBoZWFkID0gYWRqW3RhcmdldF07XG5cbiAgaWYgKHR5cGVvZiBoZWFkID09PSAndW5kZWZpbmVkJykge1xuICAgIGFkalt0YXJnZXRdID0gdGhpcztcblxuICAgIC8vIFNlbGYtbG9vcCBvcHRpbWl6YXRpb25cbiAgICBpZiAoISh0aGlzLnVuZGlyZWN0ZWQgJiYgc291cmNlID09PSB0YXJnZXQpKSB7XG4gICAgICAvLyBIYW5kbGluZyB0YXJnZXRcbiAgICAgIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBQcmVwZW5kaW5nIHRvIGRvdWJseS1saW5rZWQgbGlzdFxuICBoZWFkLnByZXZpb3VzID0gdGhpcztcbiAgdGhpcy5uZXh0ID0gaGVhZDtcblxuICAvLyBQb2ludGluZyB0byBuZXcgaGVhZFxuICAvLyBOT1RFOiB1c2UgbXV0YXRpbmcgc3dhcCBsYXRlciB0byBhdm9pZCBsb29rdXA/XG4gIGFkalt0YXJnZXRdID0gdGhpcztcbiAgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV0gPSB0aGlzO1xufTtcblxuRWRnZURhdGEucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgbGV0IG91dEtleSA9ICdvdXQnO1xuICBsZXQgaW5LZXkgPSAnaW4nO1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQpIG91dEtleSA9IGluS2V5ID0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGRlbGV0ZSB0aGlzLnNvdXJjZVtvdXRLZXldW3RhcmdldF07XG5cbiAgLy8gTm8tb3AgZGVsZXRlIGluIGNhc2Ugb2YgdW5kaXJlY3RlZCBzZWxmLWxvb3BcbiAgZGVsZXRlIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdO1xufTtcblxuRWRnZURhdGEucHJvdG90eXBlLmRldGFjaE11bHRpID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5rZXk7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LmtleTtcblxuICBsZXQgb3V0S2V5ID0gJ291dCc7XG4gIGxldCBpbktleSA9ICdpbic7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCkgb3V0S2V5ID0gaW5LZXkgPSAndW5kaXJlY3RlZCc7XG5cbiAgLy8gRGVsZXRpbmcgZnJvbSBkb3VibHktbGlua2VkIGxpc3RcbiAgaWYgKHRoaXMucHJldmlvdXMgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggdGhlIGhlYWRcblxuICAgIC8vIFNob3VsZCB3ZSBkZWxldGUgdGhlIGFkamFjZW5jeSBlbnRyeSBiZWNhdXNlIGl0IGlzIG5vdyBlbXB0eT9cbiAgICBpZiAodGhpcy5uZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlbGV0ZSB0aGlzLnNvdXJjZVtvdXRLZXldW3RhcmdldF07XG5cbiAgICAgIC8vIE5vLW9wIGRlbGV0ZSBpbiBjYXNlIG9mIHVuZGlyZWN0ZWQgc2VsZi1sb29wXG4gICAgICBkZWxldGUgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERldGFjaGluZ1xuICAgICAgdGhpcy5uZXh0LnByZXZpb3VzID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBOT1RFOiBjb3VsZCBhdm9pZCB0aGUgbG9va3VwcyBieSBjcmVhdGluZyBhICMuYmVjb21lIG11dGF0aW5nIG1ldGhvZFxuICAgICAgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdID0gdGhpcy5uZXh0O1xuXG4gICAgICAvLyBOby1vcCBkZWxldGUgaW4gY2FzZSBvZiB1bmRpcmVjdGVkIHNlbGYtbG9vcFxuICAgICAgdGhpcy50YXJnZXRbaW5LZXldW3NvdXJjZV0gPSB0aGlzLm5leHQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFdlIGFyZSBkZWFsaW5nIHdpdGggYW5vdGhlciBsaXN0IG5vZGVcbiAgICB0aGlzLnByZXZpb3VzLm5leHQgPSB0aGlzLm5leHQ7XG5cbiAgICAvLyBJZiBub3QgbGFzdFxuICAgIGlmICh0aGlzLm5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5uZXh0LnByZXZpb3VzID0gdGhpcy5wcmV2aW91cztcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogR3JhcGhvbG9neSBOb2RlIEF0dHJpYnV0ZXMgbWV0aG9kc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5jb25zdCBOT0RFID0gMDtcbmNvbnN0IFNPVVJDRSA9IDE7XG5jb25zdCBUQVJHRVQgPSAyO1xuY29uc3QgT1BQT1NJVEUgPSAzO1xuXG5mdW5jdGlvbiBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgZ3JhcGgsXG4gIG1ldGhvZCxcbiAgbW9kZSxcbiAgbm9kZU9yRWRnZSxcbiAgbmFtZU9yRWRnZSxcbiAgYWRkMSxcbiAgYWRkMlxuKSB7XG4gIGxldCBub2RlRGF0YSwgZWRnZURhdGEsIGFyZzEsIGFyZzI7XG5cbiAgbm9kZU9yRWRnZSA9ICcnICsgbm9kZU9yRWRnZTtcblxuICBpZiAobW9kZSA9PT0gTk9ERSkge1xuICAgIG5vZGVEYXRhID0gZ3JhcGguX25vZGVzLmdldChub2RlT3JFZGdlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGVPckVkZ2V9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGFyZzEgPSBuYW1lT3JFZGdlO1xuICAgIGFyZzIgPSBhZGQxO1xuICB9IGVsc2UgaWYgKG1vZGUgPT09IE9QUE9TSVRFKSB7XG4gICAgbmFtZU9yRWRnZSA9ICcnICsgbmFtZU9yRWRnZTtcblxuICAgIGVkZ2VEYXRhID0gZ3JhcGguX2VkZ2VzLmdldChuYW1lT3JFZGdlKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25hbWVPckVkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IGVkZ2VEYXRhLnNvdXJjZS5rZXk7XG4gICAgY29uc3QgdGFyZ2V0ID0gZWRnZURhdGEudGFyZ2V0LmtleTtcblxuICAgIGlmIChub2RlT3JFZGdlID09PSBzb3VyY2UpIHtcbiAgICAgIG5vZGVEYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuICAgIH0gZWxzZSBpZiAobm9kZU9yRWRnZSA9PT0gdGFyZ2V0KSB7XG4gICAgICBub2RlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogdGhlIFwiJHtub2RlT3JFZGdlfVwiIG5vZGUgaXMgbm90IGF0dGFjaGVkIHRvIHRoZSBcIiR7bmFtZU9yRWRnZX1cIiBlZGdlICgke3NvdXJjZX0sICR7dGFyZ2V0fSkuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBhcmcxID0gYWRkMTtcbiAgICBhcmcyID0gYWRkMjtcbiAgfSBlbHNlIHtcbiAgICBlZGdlRGF0YSA9IGdyYXBoLl9lZGdlcy5nZXQobm9kZU9yRWRnZSk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlT3JFZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAobW9kZSA9PT0gU09VUkNFKSB7XG4gICAgICBub2RlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgYXJnMSA9IG5hbWVPckVkZ2U7XG4gICAgYXJnMiA9IGFkZDE7XG4gIH1cblxuICByZXR1cm4gW25vZGVEYXRhLCBhcmcxLCBhcmcyXTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZUdldHRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgbmFtZV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzR2V0dGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSkge1xuICAgIGNvbnN0IFtkYXRhXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZVxuICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlQ2hlY2tlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgbmFtZV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVTZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxLCBhZGQyKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWUsIHZhbHVlXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDEsXG4gICAgICBhZGQyXG4gICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlVXBkYXRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEsIGFkZDIpIHtcbiAgICBjb25zdCBbZGF0YSwgbmFtZSwgdXBkYXRlcl0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxLFxuICAgICAgYWRkMlxuICAgICk7XG5cbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHVwZGF0ZXIgc2hvdWxkIGJlIGEgZnVuY3Rpb24uYFxuICAgICAgKTtcblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBkYXRhLmF0dHJpYnV0ZXM7XG4gICAgY29uc3QgdmFsdWUgPSB1cGRhdGVyKGF0dHJpYnV0ZXNbbmFtZV0pO1xuXG4gICAgYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlUmVtb3ZlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgbmFtZV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIGRlbGV0ZSBkYXRhLmF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzUmVwbGFjZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIGF0dHJpYnV0ZXNdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNNZXJnZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIGF0dHJpYnV0ZXNdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgYXNzaWduKGRhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCB1cGRhdGVyXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIG1ldGhvZHMgdG8gYXR0YWNoLlxuICovXG5jb25zdCBOT0RFX0FUVFJJQlVURVNfTUVUSE9EUyA9IFtcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGdldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVzR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBoYXMke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZUNoZWNrZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHNldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlU2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZVVwZGF0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlbW92ZSR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlUmVtb3ZlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgcmVwbGFjZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZXNSZXBsYWNlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgbWVyZ2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVzTWVyZ2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlclxuICB9XG5dO1xuXG4vKipcbiAqIEF0dGFjaCBldmVyeSBhdHRyaWJ1dGVzLXJlbGF0ZWQgbWV0aG9kcyB0byBhIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gVGFyZ2V0IGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpIHtcbiAgTk9ERV9BVFRSSUJVVEVTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAoe25hbWUsIGF0dGFjaGVyfSkge1xuICAgIC8vIEZvciBub2Rlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdOb2RlJyksIE5PREUpO1xuXG4gICAgLy8gRm9yIHNvdXJjZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnU291cmNlJyksIFNPVVJDRSk7XG5cbiAgICAvLyBGb3IgdGFyZ2V0c1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdUYXJnZXQnKSwgVEFSR0VUKTtcblxuICAgIC8vIEZvciBvcHBvc2l0ZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnT3Bwb3NpdGUnKSwgT1BQT1NJVEUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IEVkZ2UgQXR0cmlidXRlcyBtZXRob2RzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBnZXR0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlR2V0dGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIEdldCB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge21peGVkfSAgICAgICAgICAtIFRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXNbbmFtZV07XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZXMgZ2V0dGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZXNHZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogUmV0cmlldmVzIGFsbCB0aGUgdGFyZ2V0IGVsZW1lbnQncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgLSBUaGUgZWxlbWVudCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQsXG4gICAgICAgIHRhcmdldCA9ICcnICsgYXJndW1lbnRzWzFdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIGNoZWNrZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlQ2hlY2tlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgaXMgc2V0IGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHNldHRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVTZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogU2V0IHRoZSBkZXNpcmVkIGF0dHJpYnV0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHttaXhlZH0gIHZhbHVlICAgLSBOZXcgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtICB7bWl4ZWR9ICB2YWx1ZSAgIC0gTmV3IGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAzKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgIHZhbHVlID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZGF0YS5hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSB1cGRhdGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZVVwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBkZXNpcmVkIGF0dHJpYnV0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkgdXNpbmdcbiAgICogdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUsIHVwZGF0ZXIpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG4gICAgICB1cGRhdGVyID0gYXJndW1lbnRzWzNdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiB1cGRhdGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXNbbmFtZV0gPSB1cGRhdGVyKGRhdGEuYXR0cmlidXRlc1tuYW1lXSk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSByZW1vdmVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZVJlbW92ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogUmVtb3ZlIHRoZSBkZXNpcmVkIGF0dHJpYnV0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZGVsZXRlIGRhdGEuYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHJlcGxhY2VyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZXNSZXBsYWNlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBSZXBsYWNlIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50ICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIE5ldyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAgICAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0ICAgICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICBhdHRyaWJ1dGVzIC0gTmV3IGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQsXG4gICAgICAgIHRhcmdldCA9ICcnICsgYXR0cmlidXRlcztcblxuICAgICAgYXR0cmlidXRlcyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgbWVyZ2VyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZXNNZXJnZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogTWVyZ2UgdGhlIGF0dHJpYnV0ZXMgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgICAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gQXR0cmlidXRlcyB0byBtZXJnZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgdG8gbWVyZ2UuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgICAgLSBSZXR1cm5zIGl0c2VsZiBmb3IgY2hhaW5pbmcuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIGF0dHJpYnV0ZXMpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQsXG4gICAgICAgIHRhcmdldCA9ICcnICsgYXR0cmlidXRlcztcblxuICAgICAgYXR0cmlidXRlcyA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LmBcbiAgICAgICk7XG5cbiAgICBhc3NpZ24oZGF0YS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgdXBkYXRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGF0dHJpYnV0ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCB1cGRhdGVyKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIHVwZGF0ZXI7XG5cbiAgICAgIHVwZGF0ZXIgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIoZGF0YS5hdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3VwZGF0ZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIExpc3Qgb2YgbWV0aG9kcyB0byBhdHRhY2guXG4gKi9cbmNvbnN0IEVER0VfQVRUUklCVVRFU19NRVRIT0RTID0gW1xuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgZ2V0JHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVHZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGdldCR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZXNHZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGhhcyR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlQ2hlY2tlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgc2V0JHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVTZXR0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHVwZGF0ZSR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlVXBkYXRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgcmVtb3ZlJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVSZW1vdmVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGByZXBsYWNlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlc1JlcGxhY2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBtZXJnZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZXNNZXJnZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHVwZGF0ZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVyXG4gIH1cbl07XG5cbi8qKlxuICogQXR0YWNoIGV2ZXJ5IGF0dHJpYnV0ZXMtcmVsYXRlZCBtZXRob2RzIHRvIGEgR3JhcGggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gR3JhcGggLSBUYXJnZXQgY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWV0aG9kcyhHcmFwaCkge1xuICBFREdFX0FUVFJJQlVURVNfTUVUSE9EUy5mb3JFYWNoKGZ1bmN0aW9uICh7bmFtZSwgYXR0YWNoZXJ9KSB7XG4gICAgLy8gRm9yIGVkZ2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ0VkZ2UnKSwgJ21peGVkJyk7XG5cbiAgICAvLyBGb3IgZGlyZWN0ZWQgZWRnZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnRGlyZWN0ZWRFZGdlJyksICdkaXJlY3RlZCcpO1xuXG4gICAgLy8gRm9yIHVuZGlyZWN0ZWQgZWRnZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnVW5kaXJlY3RlZEVkZ2UnKSwgJ3VuZGlyZWN0ZWQnKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBFZGdlIEl0ZXJhdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBBdHRhY2hpbmcgc29tZSBtZXRob2RzIHRvIHRoZSBHcmFwaCBjbGFzcyB0byBiZSBhYmxlIHRvIGl0ZXJhdGUgb3ZlciBhXG4gKiBncmFwaCdzIGVkZ2VzLlxuICovXG5cbi8qKlxuICogRGVmaW5pdGlvbnMuXG4gKi9cbmNvbnN0IEVER0VTX0lURVJBVElPTiA9IFtcbiAge1xuICAgIG5hbWU6ICdlZGdlcycsXG4gICAgdHlwZTogJ21peGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2luRWRnZXMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0RWRnZXMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCcsXG4gICAgZGlyZWN0aW9uOiAnb3V0J1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2luYm91bmRFZGdlcycsXG4gICAgdHlwZTogJ21peGVkJyxcbiAgICBkaXJlY3Rpb246ICdpbidcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdvdXRib3VuZEVkZ2VzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdkaXJlY3RlZEVkZ2VzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAndW5kaXJlY3RlZEVkZ2VzJyxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfVxuXTtcblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBlZGdlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3QgdG8gbWF0Y2ggb25lIG9mIHRoZW0uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9ICAgb2JqZWN0ICAgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoU2ltcGxlKGJyZWFrYWJsZSwgb2JqZWN0LCBjYWxsYmFjaywgYXZvaWQpIHtcbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG5cbiAgZm9yIChjb25zdCBrIGluIG9iamVjdCkge1xuICAgIGlmIChrID09PSBhdm9pZCkgY29udGludWU7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICBlZGdlRGF0YS5rZXksXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoTXVsdGkoYnJlYWthYmxlLCBvYmplY3QsIGNhbGxiYWNrLCBhdm9pZCkge1xuICBsZXQgZWRnZURhdGEsIHNvdXJjZSwgdGFyZ2V0O1xuXG4gIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgayBpbiBvYmplY3QpIHtcbiAgICBpZiAoayA9PT0gYXZvaWQpIGNvbnRpbnVlO1xuXG4gICAgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgICBkbyB7XG4gICAgICBzb3VyY2UgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgICB0YXJnZXQgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgc291cmNlLmtleSxcbiAgICAgICAgdGFyZ2V0LmtleSxcbiAgICAgICAgc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgIHRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGEua2V5O1xuXG4gICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgfSB3aGlsZSAoZWRnZURhdGEgIT09IHVuZGVmaW5lZCk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgZWRnZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICBvYmplY3QgLSBUYXJnZXQgb2JqZWN0LlxuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yKG9iamVjdCwgYXZvaWQpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGNvbnN0IGwgPSBrZXlzLmxlbmd0aDtcblxuICBsZXQgZWRnZURhdGE7XG4gIGxldCBpID0gMDtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoIWVkZ2VEYXRhKSB7XG4gICAgICAgICAgaWYgKGkgPj0gbCkgcmV0dXJuIHtkb25lOiB0cnVlfTtcblxuICAgICAgICAgIGNvbnN0IGsgPSBrZXlzW2krK107XG5cbiAgICAgICAgICBpZiAoayA9PT0gYXZvaWQpIHtcbiAgICAgICAgICAgIGVkZ2VEYXRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZWRnZURhdGEgPSBvYmplY3Rba107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlICghZWRnZURhdGEpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBlZGdlOiBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgYXR0cmlidXRlczogZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICBzb3VyY2U6IGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHVuZGlyZWN0ZWQ6IGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGVnZGVzIGZyb20gdGhlIG9iamVjdCBhdCBnaXZlbiBrZXkgdG8gbWF0Y2hcbiAqIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iamVjdCAgIC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7bWl4ZWR9ICAgIGsgICAgICAgIC0gTmVpZ2hib3Iga2V5LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hGb3JLZXlTaW1wbGUoYnJlYWthYmxlLCBvYmplY3QsIGssIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gIGlmICghZWRnZURhdGEpIHJldHVybjtcblxuICBjb25zdCBzb3VyY2VEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICBjb25zdCB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gIGlmIChcbiAgICBjYWxsYmFjayhcbiAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgIHRhcmdldERhdGEua2V5LFxuICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICkgJiZcbiAgICBicmVha2FibGVcbiAgKVxuICAgIHJldHVybiBlZGdlRGF0YS5rZXk7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hGb3JLZXlNdWx0aShicmVha2FibGUsIG9iamVjdCwgaywgY2FsbGJhY2spIHtcbiAgbGV0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gIGlmICghZWRnZURhdGEpIHJldHVybjtcblxuICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcblxuICBkbyB7XG4gICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgIGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBlZGdlRGF0YS5rZXk7XG5cbiAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gIH0gd2hpbGUgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpO1xuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZWdkZXMgZnJvbSB0aGUgb2JqZWN0IGF0IGdpdmVuIGtleS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgb2JqZWN0ICAgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtICB7bWl4ZWR9ICAgIGsgICAgICAgIC0gTmVpZ2hib3Iga2V5LlxuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJhdG9yRm9yS2V5KG9iamVjdCwgaykge1xuICBsZXQgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgaWYgKGVkZ2VEYXRhLm5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgaWYgKCFlZGdlRGF0YSkgcmV0dXJuIHtkb25lOiB0cnVlfTtcblxuICAgICAgICBjb25zdCB2YWx1ZSA9IHtcbiAgICAgICAgICBlZGdlOiBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgYXR0cmlidXRlczogZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICBzb3VyY2U6IGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHVuZGlyZWN0ZWQ6IGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgfTtcblxuICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBsZXQgZG9uZSA9IGZhbHNlO1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgaWYgKGRvbmUgPT09IHRydWUpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGVkZ2U6IGVkZ2VEYXRhLmtleSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHNvdXJjZTogZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgICAgICB0YXJnZXQ6IGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICAgICAgc291cmNlQXR0cmlidXRlczogZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdGFyZ2V0QXR0cmlidXRlczogZWRnZURhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgICAgdW5kaXJlY3RlZDogZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgZ3JhcGggLSBUYXJnZXQgR3JhcGggaW5zdGFuY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAtIEFycmF5IG9mIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyYXkoZ3JhcGgsIHR5cGUpIHtcbiAgaWYgKGdyYXBoLnNpemUgPT09IDApIHJldHVybiBbXTtcblxuICBpZiAodHlwZSA9PT0gJ21peGVkJyB8fCB0eXBlID09PSBncmFwaC50eXBlKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oZ3JhcGguX2VkZ2VzLmtleXMoKSk7XG4gIH1cblxuICBjb25zdCBzaXplID1cbiAgICB0eXBlID09PSAndW5kaXJlY3RlZCcgPyBncmFwaC51bmRpcmVjdGVkU2l6ZSA6IGdyYXBoLmRpcmVjdGVkU2l6ZTtcblxuICBjb25zdCBsaXN0ID0gbmV3IEFycmF5KHNpemUpLFxuICAgIG1hc2sgPSB0eXBlID09PSAndW5kaXJlY3RlZCc7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBncmFwaC5fZWRnZXMudmFsdWVzKCk7XG5cbiAgbGV0IGkgPSAwO1xuICBsZXQgc3RlcCwgZGF0YTtcblxuICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgIGRhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgaWYgKGRhdGEudW5kaXJlY3RlZCA9PT0gbWFzaykgbGlzdFtpKytdID0gZGF0YS5rZXk7XG4gIH1cblxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIGdyYXBoJ3MgZWRnZXMgdXNpbmcgYSBjYWxsYmFjayB0byBtYXRjaCBvbmUgb2ZcbiAqIHRoZW0uXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFZGdlKGJyZWFrYWJsZSwgZ3JhcGgsIHR5cGUsIGNhbGxiYWNrKSB7XG4gIGlmIChncmFwaC5zaXplID09PSAwKSByZXR1cm47XG5cbiAgY29uc3Qgc2hvdWxkRmlsdGVyID0gdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSBncmFwaC50eXBlO1xuICBjb25zdCBtYXNrID0gdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGxldCBzdGVwLCBkYXRhO1xuICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcbiAgY29uc3QgaXRlcmF0b3IgPSBncmFwaC5fZWRnZXMudmFsdWVzKCk7XG5cbiAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICBkYXRhID0gc3RlcC52YWx1ZTtcblxuICAgIGlmIChzaG91bGRGaWx0ZXIgJiYgZGF0YS51bmRpcmVjdGVkICE9PSBtYXNrKSBjb250aW51ZTtcblxuICAgIGNvbnN0IHtrZXksIGF0dHJpYnV0ZXMsIHNvdXJjZSwgdGFyZ2V0fSA9IGRhdGE7XG5cbiAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAga2V5LFxuICAgICAgYXR0cmlidXRlcyxcbiAgICAgIHNvdXJjZS5rZXksXG4gICAgICB0YXJnZXQua2V5LFxuICAgICAgc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICB0YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgIGRhdGEudW5kaXJlY3RlZFxuICAgICk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4ga2V5O1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGNyZWF0aW5nIGFuIGl0ZXJhdG9yIG9mIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICAgZ3JhcGggLSBUYXJnZXQgR3JhcGggaW5zdGFuY2UuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHJldHVybiB7SXRlcmF0b3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VJdGVyYXRvcihncmFwaCwgdHlwZSkge1xuICBpZiAoZ3JhcGguc2l6ZSA9PT0gMCkgcmV0dXJuIGVtcHR5SXRlcmF0b3IoKTtcblxuICBjb25zdCBzaG91bGRGaWx0ZXIgPSB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IGdyYXBoLnR5cGU7XG4gIGNvbnN0IG1hc2sgPSB0eXBlID09PSAndW5kaXJlY3RlZCc7XG5cbiAgY29uc3QgaXRlcmF0b3IgPSBncmFwaC5fZWRnZXMudmFsdWVzKCk7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGxldCBzdGVwLCBkYXRhO1xuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGVwID0gaXRlcmF0b3IubmV4dCgpO1xuXG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHJldHVybiBzdGVwO1xuXG4gICAgICAgIGRhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICAgIGlmIChzaG91bGRGaWx0ZXIgJiYgZGF0YS51bmRpcmVjdGVkICE9PSBtYXNrKSBjb250aW51ZTtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgIGVkZ2U6IGRhdGEua2V5LFxuICAgICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNvdXJjZTogZGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICB0YXJnZXQ6IGRhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgc291cmNlQXR0cmlidXRlczogZGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgdGFyZ2V0QXR0cmlidXRlczogZGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgdW5kaXJlY3RlZDogZGF0YS51bmRpcmVjdGVkXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge3ZhbHVlLCBkb25lOiBmYWxzZX07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzIHVzaW5nIGEgY2FsbGJhY2sgdG8gbWF0Y2ggb25lIG9mIHRoZW0uXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gIG11bHRpICAgICAtIFdoZXRoZXIgdGhlIGdyYXBoIGlzIG11bHRpIG9yIG5vdC5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEVkZ2VGb3JOb2RlKFxuICBicmVha2FibGUsXG4gIG11bHRpLFxuICB0eXBlLFxuICBkaXJlY3Rpb24sXG4gIG5vZGVEYXRhLFxuICBjYWxsYmFja1xuKSB7XG4gIGNvbnN0IGZuID0gbXVsdGkgPyBmb3JFYWNoTXVsdGkgOiBmb3JFYWNoU2ltcGxlO1xuXG4gIGxldCBmb3VuZDtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ291dCcpIHtcbiAgICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBub2RlRGF0YS5pbiwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gIT09ICdpbicpIHtcbiAgICAgIGZvdW5kID0gZm4oXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbm9kZURhdGEub3V0LFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgIWRpcmVjdGlvbiA/IG5vZGVEYXRhLmtleSA6IHVuZGVmaW5lZFxuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgZm91bmQgPSBmbihicmVha2FibGUsIG5vZGVEYXRhLnVuZGlyZWN0ZWQsIGNhbGxiYWNrKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHR5cGUgJiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHtib29sZWFufSBtdWx0aSAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aSBvciBub3QuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICB0eXBlICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgZGlyZWN0aW9uIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7YW55fSAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgIC0gQXJyYXkgb2YgZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJheUZvck5vZGUobXVsdGksIHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEpIHtcbiAgY29uc3QgZWRnZXMgPSBbXTsgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8ga25vdyBzaXplIGJlZm9yZWhhbmQgb3IgZmFjdG9yaXplIHdpdGggbWFwXG5cbiAgZm9yRWFjaEVkZ2VGb3JOb2RlKGZhbHNlLCBtdWx0aSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSwgZnVuY3Rpb24gKGtleSkge1xuICAgIGVkZ2VzLnB1c2goa2V5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzIHVzaW5nIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7YW55fSAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlSXRlcmF0b3JGb3JOb2RlKHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEpIHtcbiAgbGV0IGl0ZXJhdG9yID0gZW1wdHlJdGVyYXRvcigpO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0JyAmJiB0eXBlb2Ygbm9kZURhdGEuaW4gIT09ICd1bmRlZmluZWQnKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3Iobm9kZURhdGEuaW4pKTtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nICYmIHR5cGVvZiBub2RlRGF0YS5vdXQgIT09ICd1bmRlZmluZWQnKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZUl0ZXJhdG9yKG5vZGVEYXRhLm91dCwgIWRpcmVjdGlvbiA/IG5vZGVEYXRhLmtleSA6IHVuZGVmaW5lZClcbiAgICAgICk7XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJyAmJiB0eXBlb2Ygbm9kZURhdGEudW5kaXJlY3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpdGVyYXRvciA9IGNoYWluKGl0ZXJhdG9yLCBjcmVhdGVJdGVyYXRvcihub2RlRGF0YS51bmRpcmVjdGVkKSk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgZWRnZXMgZm9yIHRoZSBnaXZlbiBwYXRoIHVzaW5nIGEgY2FsbGJhY2sgdG8gbWF0Y2hcbiAqIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBtdWx0aSAgICAgIC0gV2hldGhlciB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uICAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge05vZGVEYXRhfSBzb3VyY2VEYXRhIC0gU291cmNlIG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHRhcmdldCAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICBicmVha2FibGUsXG4gIHR5cGUsXG4gIG11bHRpLFxuICBkaXJlY3Rpb24sXG4gIHNvdXJjZURhdGEsXG4gIHRhcmdldCxcbiAgY2FsbGJhY2tcbikge1xuICBjb25zdCBmbiA9IG11bHRpID8gZm9yRWFjaEZvcktleU11bHRpIDogZm9yRWFjaEZvcktleVNpbXBsZTtcblxuICBsZXQgZm91bmQ7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlRGF0YS5pbiAhPT0gJ3VuZGVmaW5lZCcgJiYgZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgZm91bmQgPSBmbihicmVha2FibGUsIHNvdXJjZURhdGEuaW4sIHRhcmdldCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHNvdXJjZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGlyZWN0aW9uICE9PSAnaW4nICYmXG4gICAgICAoZGlyZWN0aW9uIHx8IHNvdXJjZURhdGEua2V5ICE9PSB0YXJnZXQpXG4gICAgKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgc291cmNlRGF0YS5vdXQsIHRhcmdldCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEudW5kaXJlY3RlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQsIHRhcmdldCwgY2FsbGJhY2spO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGNyZWF0aW5nIGFuIGFycmF5IG9mIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgbXVsdGkgICAgICAtIFdoZXRoZXIgdGhlIGdyYXBoIGlzIG11bHRpLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAgLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHtOb2RlRGF0YX0gc291cmNlRGF0YSAtIFNvdXJjZSBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAgIC0gVGFyZ2V0IG5vZGUuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgICAgICAgICAtIEFycmF5IG9mIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyYXlGb3JQYXRoKHR5cGUsIG11bHRpLCBkaXJlY3Rpb24sIHNvdXJjZURhdGEsIHRhcmdldCkge1xuICBjb25zdCBlZGdlcyA9IFtdOyAvLyBUT0RPOiBwb3NzaWJpbGl0eSB0byBrbm93IHNpemUgYmVmb3JlaGFuZCBvciBmYWN0b3JpemUgd2l0aCBtYXBcblxuICBmb3JFYWNoRWRnZUZvclBhdGgoXG4gICAgZmFsc2UsXG4gICAgdHlwZSxcbiAgICBtdWx0aSxcbiAgICBkaXJlY3Rpb24sXG4gICAgc291cmNlRGF0YSxcbiAgICB0YXJnZXQsXG4gICAgZnVuY3Rpb24gKGtleSkge1xuICAgICAgZWRnZXMucHVzaChrZXkpO1xuICAgIH1cbiAgKTtcblxuICByZXR1cm4gZWRnZXM7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgZWRnZXMgZm9yIHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7Tm9kZURhdGF9IHNvdXJjZURhdGEgLSBTb3VyY2Ugbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdGFyZ2V0ICAgICAtIFRhcmdldCBub2RlLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrICAgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlSXRlcmF0b3JGb3JQYXRoKHR5cGUsIGRpcmVjdGlvbiwgc291cmNlRGF0YSwgdGFyZ2V0KSB7XG4gIGxldCBpdGVyYXRvciA9IGVtcHR5SXRlcmF0b3IoKTtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHNvdXJjZURhdGEuaW4gIT09ICd1bmRlZmluZWQnICYmXG4gICAgICBkaXJlY3Rpb24gIT09ICdvdXQnICYmXG4gICAgICB0YXJnZXQgaW4gc291cmNlRGF0YS5pblxuICAgIClcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oaXRlcmF0b3IsIGNyZWF0ZUl0ZXJhdG9yRm9yS2V5KHNvdXJjZURhdGEuaW4sIHRhcmdldCkpO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHNvdXJjZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGlyZWN0aW9uICE9PSAnaW4nICYmXG4gICAgICB0YXJnZXQgaW4gc291cmNlRGF0YS5vdXQgJiZcbiAgICAgIChkaXJlY3Rpb24gfHwgc291cmNlRGF0YS5rZXkgIT09IHRhcmdldClcbiAgICApXG4gICAgICBpdGVyYXRvciA9IGNoYWluKGl0ZXJhdG9yLCBjcmVhdGVJdGVyYXRvckZvcktleShzb3VyY2VEYXRhLm91dCwgdGFyZ2V0KSk7XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICB0YXJnZXQgaW4gc291cmNlRGF0YS51bmRpcmVjdGVkXG4gICAgKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZUl0ZXJhdG9yRm9yS2V5KHNvdXJjZURhdGEudW5kaXJlY3RlZCwgdGFyZ2V0KVxuICAgICAgKTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYW4gZWRnZSBhcnJheSBjcmVhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBcnJheUNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheSBvZiBjZXJ0YWluIGVkZ2VzLlxuICAgKlxuICAgKiBBcml0eSAwOiBSZXR1cm4gYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMTogUmV0dXJuIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgICAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBBcml0eSAyOiBSZXR1cm4gdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fG51bWJlcn0gLSBUaGUgZWRnZXMgb3IgdGhlIG51bWJlciBvZiBlZGdlcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY3JlYXRlRWRnZUFycmF5KHRoaXMsIHR5cGUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlc1xuICAgICAgcmV0dXJuIGNyZWF0ZUVkZ2VBcnJheUZvck5vZGUoXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIG5vZGVEYXRhXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciB0aGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlQXJyYXlGb3JQYXRoKFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNvdXJjZURhdGEsXG4gICAgICAgIHRhcmdldFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMCwgMSBvciAyIGFuZCBnb3QgJHthcmd1bWVudHMubGVuZ3RofSkuYFxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgZWRnZSBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hGb3JFYWNoRWRnZShDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBmb3JFYWNoTmFtZSA9ICdmb3JFYWNoJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyBieSBhcHBseWluZyB0aGUgZ2l2ZW5cbiAgICogY2FsbGJhY2suXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZm9yRWFjaE5hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSkgcmV0dXJuO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNhbGxiYWNrID0gc291cmNlO1xuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlKGZhbHNlLCB0aGlzLCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgY2FsbGJhY2sgPSB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlc1xuICAgICAgLy8gVE9ETzogbWF5YmUgYXR0YWNoIHRoZSBzdWIgbWV0aG9kIHRvIHRoZSBpbnN0YW5jZSBkeW5hbWljYWxseT9cbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZUZvck5vZGUoXG4gICAgICAgIGZhbHNlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzb3VyY2VEYXRhLFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMSwgMiBvciAzIGFuZCBnb3QgJHthcmd1bWVudHMubGVuZ3RofSkuYFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIG1hcHBpbmcgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgYnkgYXBwbHlpbmcgdGhlIGdpdmVuXG4gICAqIGNhbGxiYWNrLlxuICAgKlxuICAgKiBBcml0eSAxOiBNYXAgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBNYXAgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBNYXAgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgbWFwTmFtZSA9ICdtYXAnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbbWFwTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgbGV0IHJlc3VsdDtcblxuICAgIC8vIFdlIGtub3cgdGhlIHJlc3VsdCBsZW5ndGggYmVmb3JlaGFuZFxuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGV0IGxlbmd0aCA9IDA7XG5cbiAgICAgIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSBsZW5ndGggKz0gdGhpcy51bmRpcmVjdGVkU2l6ZTtcbiAgICAgIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIGxlbmd0aCArPSB0aGlzLmRpcmVjdGVkU2l6ZTtcblxuICAgICAgcmVzdWx0ID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIGxldCBpID0gMDtcblxuICAgICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICAgIHJlc3VsdFtpKytdID0gY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBXZSBkb24ndCBrbm93IHRoZSByZXN1bHQgbGVuZ3RoIGJlZm9yZWhhbmRcbiAgICAvLyBUT0RPOiB3ZSBjYW4gaW4gc29tZSBpbnN0YW5jZXMgb2Ygc2ltcGxlIGdyYXBocywga25vd2luZyBkZWdyZWVcbiAgICBlbHNlIHtcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmaWx0ZXJpbmcgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgdXNpbmcgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMTogRmlsdGVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBQcmVkaWNhdGUgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBGaWx0ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBQcmVkaWNhdGUgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBGaWx0ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBwcmVkaWNhdGUgLSBQcmVkaWNhdGUgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IGZpbHRlck5hbWUgPSAnZmlsdGVyJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW2ZpbHRlck5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICBpZiAoY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkpIHJlc3VsdC5wdXNoKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZWR1Y2luZyB0aGUgZ3JhcGgncyByZWxldmFudCBlZGdlcyB1c2luZyB0aGUgcHJvdmlkZWQgYWNjdW11bGF0b3JcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IFJlZHVjZSBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gYWNjdW11bGF0b3IgIC0gQWNjdW11bGF0b3IgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgaW5pdGlhbFZhbHVlIC0gSW5pdGlhbCB2YWx1ZS5cbiAgICpcbiAgICogQXJpdHkgMjogUmVkdWNlIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gYWNjdW11bGF0b3IgIC0gQWNjdW11bGF0b3IgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgaW5pdGlhbFZhbHVlIC0gSW5pdGlhbCB2YWx1ZS5cbiAgICpcbiAgICogQXJpdHkgMzogUmVkdWNlIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAgICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gYWNjdW11bGF0b3IgIC0gQWNjdW11bGF0b3IgdG8gdXNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgaW5pdGlhbFZhbHVlIC0gSW5pdGlhbCB2YWx1ZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCByZWR1Y2VOYW1lID0gJ3JlZHVjZScgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtyZWR1Y2VOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPCAyIHx8IGFyZ3MubGVuZ3RoID4gNCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtyZWR1Y2VOYW1lfTogaW52YWxpZCBudW1iZXIgb2YgYXJndW1lbnRzIChleHBlY3RpbmcgMiwgMyBvciA0IGFuZCBnb3QgJHthcmdzLmxlbmd0aH0pLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAyXSAhPT0gJ2Z1bmN0aW9uJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtyZWR1Y2VOYW1lfTogbWlzc2luZyBpbml0aWFsIHZhbHVlLiBZb3UgbXVzdCBwcm92aWRlIGl0IGJlY2F1c2UgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgYW5kIHdlIGNhbm5vdCBpbmZlciB0aGUgaW5pdGlhbCB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVyYXRpb24sIGFzIHlvdSBjb3VsZCB3aXRoIGEgc2ltcGxlIGFycmF5LmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGNhbGxiYWNrO1xuICAgIGxldCBpbml0aWFsVmFsdWU7XG5cbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJnc1swXTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZ3NbMV07XG4gICAgICBhcmdzID0gW107XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gMykge1xuICAgICAgY2FsbGJhY2sgPSBhcmdzWzFdO1xuICAgICAgaW5pdGlhbFZhbHVlID0gYXJnc1syXTtcbiAgICAgIGFyZ3MgPSBbYXJnc1swXV07XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PT0gNCkge1xuICAgICAgY2FsbGJhY2sgPSBhcmdzWzJdO1xuICAgICAgaW5pdGlhbFZhbHVlID0gYXJnc1szXTtcbiAgICAgIGFyZ3MgPSBbYXJnc1swXSwgYXJnc1sxXV07XG4gICAgfVxuXG4gICAgbGV0IGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBlLCBlYSwgcywgdCwgc2EsIHRhLCB1KTtcbiAgICB9KTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIGJyZWFrYWJsZSBlZGdlIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGhcbiAqIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hGaW5kRWRnZShDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBmaW5kRWRnZU5hbWUgPSAnZmluZCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgaW4gb3JkZXIgdG8gbWF0Y2hcbiAgICogb25lIG9mIHRoZW0gdXNpbmcgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogSXRlcmF0ZSBvdmVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtmaW5kRWRnZU5hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjYWxsYmFjayA9IHNvdXJjZTtcbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZSh0cnVlLCB0aGlzLCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgY2FsbGJhY2sgPSB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZpbmRFZGdlTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIC8vIFRPRE86IG1heWJlIGF0dGFjaCB0aGUgc3ViIG1ldGhvZCB0byB0aGUgaW5zdGFuY2UgZHluYW1pY2FsbHk/XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JOb2RlKFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDMpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZpbmRFZGdlTmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZpbmRFZGdlTmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciB0aGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZUZvclBhdGgoXG4gICAgICAgIHRydWUsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc291cmNlRGF0YSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAxLCAyIG9yIDMgYW5kIGdvdCAke2FyZ3VtZW50cy5sZW5ndGh9KS5gXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgaW4gb3JkZXIgdG8gYXNzZXJ0XG4gICAqIHdoZXRoZXIgYW55IG9uZSBvZiB0aGVtIG1hdGNoZXMgdGhlIHByb3ZpZGVkIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogSXRlcmF0ZSBvdmVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IHNvbWVOYW1lID0gJ3NvbWUnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3NvbWVOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICBhcmdzLnB1c2goKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kRWRnZU5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgaW4gb3JkZXIgdG8gYXNzZXJ0XG4gICAqIHdoZXRoZXIgYWxsIG9mIHRoZW0gbWF0Y2hlIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBldmVyeU5hbWUgPSAnZXZlcnknICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW2V2ZXJ5TmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZm91bmQgPSB0aGlzW2ZpbmRFZGdlTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG5cbiAgICBpZiAoZm91bmQpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhbiBlZGdlIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VJdGVyYXRvckNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lOiBvcmlnaW5hbE5hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBuYW1lID0gb3JpZ2luYWxOYW1lLnNsaWNlKDAsIC0xKSArICdFbnRyaWVzJztcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdyYXBoJ3MgZWRnZXMuXG4gICAqXG4gICAqIEFyaXR5IDA6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgbm9kZSAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7YXJyYXl8bnVtYmVyfSAtIFRoZSBlZGdlcyBvciB0aGUgbnVtYmVyIG9mIGVkZ2VzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoc291cmNlLCB0YXJnZXQpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gZW1wdHlJdGVyYXRvcigpO1xuXG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gY3JlYXRlRWRnZUl0ZXJhdG9yKHRoaXMsIHR5cGUpO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICAvLyBJdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlc1xuICAgICAgcmV0dXJuIGNyZWF0ZUVkZ2VJdGVyYXRvckZvck5vZGUodHlwZSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yUGF0aCh0eXBlLCBkaXJlY3Rpb24sIHNvdXJjZURhdGEsIHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDAsIDEgb3IgMiBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBldmVyeSBlZGdlIGl0ZXJhdGlvbiBtZXRob2QgdG8gdGhlIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gR3JhcGggY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VJdGVyYXRpb25NZXRob2RzKEdyYXBoKSB7XG4gIEVER0VTX0lURVJBVElPTi5mb3JFYWNoKGRlc2NyaXB0aW9uID0+IHtcbiAgICBhdHRhY2hFZGdlQXJyYXlDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRm9yRWFjaEVkZ2UoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hGaW5kRWRnZShHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEVkZ2VJdGVyYXRvckNyZWF0b3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBOZWlnaGJvciBJdGVyYXRpb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEF0dGFjaGluZyBzb21lIG1ldGhvZHMgdG8gdGhlIEdyYXBoIGNsYXNzIHRvIGJlIGFibGUgdG8gaXRlcmF0ZSBvdmVyXG4gKiBuZWlnaGJvcnMuXG4gKi9cblxuLyoqXG4gKiBEZWZpbml0aW9ucy5cbiAqL1xuY29uc3QgTkVJR0hCT1JTX0lURVJBVElPTiA9IFtcbiAge1xuICAgIG5hbWU6ICduZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdtaXhlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbk5laWdoYm9ycycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJyxcbiAgICBkaXJlY3Rpb246ICdpbidcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdvdXROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCcsXG4gICAgZGlyZWN0aW9uOiAnb3V0J1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2luYm91bmROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0Ym91bmROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgZGlyZWN0aW9uOiAnb3V0J1xuICB9LFxuICB7XG4gICAgbmFtZTogJ2RpcmVjdGVkTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAndW5kaXJlY3RlZE5laWdoYm9ycycsXG4gICAgdHlwZTogJ3VuZGlyZWN0ZWQnXG4gIH1cbl07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuZnVuY3Rpb24gQ29tcG9zaXRlU2V0V3JhcHBlcigpIHtcbiAgdGhpcy5BID0gbnVsbDtcbiAgdGhpcy5CID0gbnVsbDtcbn1cblxuQ29tcG9zaXRlU2V0V3JhcHBlci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgaWYgKHRoaXMuQSA9PT0gbnVsbCkgdGhpcy5BID0gc2V0O1xuICBlbHNlIGlmICh0aGlzLkIgPT09IG51bGwpIHRoaXMuQiA9IHNldDtcbn07XG5cbkNvbXBvc2l0ZVNldFdyYXBwZXIucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgaWYgKHRoaXMuQSAhPT0gbnVsbCAmJiBrZXkgaW4gdGhpcy5BKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKHRoaXMuQiAhPT0gbnVsbCAmJiBrZXkgaW4gdGhpcy5CKSByZXR1cm4gdHJ1ZTtcbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciB0aGUgZ2l2ZW4gbm9kZSdzIHJlbGV2YW50IG5laWdoYm9ycyB0byBtYXRjaFxuICogb25lIG9mIHRoZW0gdXNpbmcgYSBwcmVkaWNhdGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgLSBUeXBlIG9mIG5laWdoYm9ycy5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gLSBEaXJlY3Rpb24uXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrICAtIENhbGxiYWNrIHRvIHVzZS5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaEluT2JqZWN0T25jZShicmVha2FibGUsIHZpc2l0ZWQsIG5vZGVEYXRhLCBvYmplY3QsIGNhbGxiYWNrKSB7XG4gIGZvciAoY29uc3QgayBpbiBvYmplY3QpIHtcbiAgICBjb25zdCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgY29uc3QgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgIGNvbnN0IG5laWdoYm9yRGF0YSA9IHNvdXJjZURhdGEgPT09IG5vZGVEYXRhID8gdGFyZ2V0RGF0YSA6IHNvdXJjZURhdGE7XG5cbiAgICBpZiAodmlzaXRlZCAmJiB2aXNpdGVkLmhhcyhuZWlnaGJvckRhdGEua2V5KSkgY29udGludWU7XG5cbiAgICBjb25zdCBzaG91bGRCcmVhayA9IGNhbGxiYWNrKG5laWdoYm9yRGF0YS5rZXksIG5laWdoYm9yRGF0YS5hdHRyaWJ1dGVzKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBuZWlnaGJvckRhdGEua2V5O1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoTmVpZ2hib3IoYnJlYWthYmxlLCB0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhLCBjYWxsYmFjaykge1xuICAvLyBJZiB3ZSB3YW50IG9ubHkgdW5kaXJlY3RlZCBvciBpbiBvciBvdXQsIHdlIGNhbiByb2xsIHNvbWUgb3B0aW1pemF0aW9uc1xuICBpZiAodHlwZSAhPT0gJ21peGVkJykge1xuICAgIGlmICh0eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgICByZXR1cm4gZm9yRWFjaEluT2JqZWN0T25jZShcbiAgICAgICAgYnJlYWthYmxlLFxuICAgICAgICBudWxsLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgbm9kZURhdGEudW5kaXJlY3RlZCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PT0gJ3N0cmluZycpXG4gICAgICByZXR1cm4gZm9yRWFjaEluT2JqZWN0T25jZShcbiAgICAgICAgYnJlYWthYmxlLFxuICAgICAgICBudWxsLFxuICAgICAgICBub2RlRGF0YSxcbiAgICAgICAgbm9kZURhdGFbZGlyZWN0aW9uXSxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gIH1cblxuICAvLyBFbHNlIHdlIG5lZWQgdG8ga2VlcCBhIHNldCBvZiBuZWlnaGJvcnMgbm90IHRvIHJldHVybiBkdXBsaWNhdGVzXG4gIC8vIFdlIGNoZWF0IGJ5IHF1ZXJ5aW5nIHRoZSBvdGhlciBhZGphY2VuY2llc1xuICBjb25zdCB2aXNpdGVkID0gbmV3IENvbXBvc2l0ZVNldFdyYXBwZXIoKTtcblxuICBsZXQgZm91bmQ7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdvdXQnKSB7XG4gICAgICBmb3VuZCA9IGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhLmluLFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuXG4gICAgICB2aXNpdGVkLndyYXAobm9kZURhdGEuaW4pO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nKSB7XG4gICAgICBmb3VuZCA9IGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgdmlzaXRlZCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhLm91dCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcblxuICAgICAgdmlzaXRlZC53cmFwKG5vZGVEYXRhLm91dCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBmb3VuZCA9IGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICBicmVha2FibGUsXG4gICAgICB2aXNpdGVkLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBub2RlRGF0YS51bmRpcmVjdGVkLFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGNyZWF0aW5nIGFuIGFycmF5IG9mIHJlbGV2YW50IG5laWdoYm9ycyBmb3IgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgICAgICB0eXBlICAgICAgLSBUeXBlIG9mIG5laWdoYm9ycy5cbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgZGlyZWN0aW9uIC0gRGlyZWN0aW9uLlxuICogQHBhcmFtICB7YW55fSAgICAgICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgICAtIFRoZSBsaXN0IG9mIG5laWdoYm9ycy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTmVpZ2hib3JBcnJheUZvck5vZGUodHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSkge1xuICAvLyBJZiB3ZSB3YW50IG9ubHkgdW5kaXJlY3RlZCBvciBpbiBvciBvdXQsIHdlIGNhbiByb2xsIHNvbWUgb3B0aW1pemF0aW9uc1xuICBpZiAodHlwZSAhPT0gJ21peGVkJykge1xuICAgIGlmICh0eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBPYmplY3Qua2V5cyhub2RlRGF0YS51bmRpcmVjdGVkKTtcblxuICAgIGlmICh0eXBlb2YgZGlyZWN0aW9uID09PSAnc3RyaW5nJykgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGVEYXRhW2RpcmVjdGlvbl0pO1xuICB9XG5cbiAgY29uc3QgbmVpZ2hib3JzID0gW107XG5cbiAgZm9yRWFjaE5laWdoYm9yKGZhbHNlLCB0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgbmVpZ2hib3JzLnB1c2goa2V5KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG5laWdoYm9ycztcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZ2l2ZW4gbm9kZSdzIHJlbGV2YW50IG5laWdoYm9ycy5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBuZWlnaGJvcnMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uIC0gRGlyZWN0aW9uLlxuICogQHBhcmFtICB7YW55fSAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IodmlzaXRlZCwgbm9kZURhdGEsIG9iamVjdCkge1xuICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcbiAgY29uc3QgbCA9IGtleXMubGVuZ3RoO1xuXG4gIGxldCBpID0gMDtcblxuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgbGV0IG5laWdoYm9yRGF0YSA9IG51bGw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKGkgPj0gbCkge1xuICAgICAgICAgIGlmICh2aXNpdGVkKSB2aXNpdGVkLndyYXAob2JqZWN0KTtcbiAgICAgICAgICByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba2V5c1tpKytdXTtcblxuICAgICAgICBjb25zdCBzb3VyY2VEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgICAgICBjb25zdCB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICAgIG5laWdoYm9yRGF0YSA9IHNvdXJjZURhdGEgPT09IG5vZGVEYXRhID8gdGFyZ2V0RGF0YSA6IHNvdXJjZURhdGE7XG5cbiAgICAgICAgaWYgKHZpc2l0ZWQgJiYgdmlzaXRlZC5oYXMobmVpZ2hib3JEYXRhLmtleSkpIHtcbiAgICAgICAgICBuZWlnaGJvckRhdGEgPSBudWxsO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuZWlnaGJvckRhdGEgPT09IG51bGwpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtuZWlnaGJvcjogbmVpZ2hib3JEYXRhLmtleSwgYXR0cmlidXRlczogbmVpZ2hib3JEYXRhLmF0dHJpYnV0ZXN9XG4gICAgICB9O1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmVpZ2hib3JJdGVyYXRvcih0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIC8vIElmIHdlIHdhbnQgb25seSB1bmRpcmVjdGVkIG9yIGluIG9yIG91dCwgd2UgY2FuIHJvbGwgc29tZSBvcHRpbWl6YXRpb25zXG4gIGlmICh0eXBlICE9PSAnbWl4ZWQnKSB7XG4gICAgaWYgKHR5cGUgPT09ICd1bmRpcmVjdGVkJylcbiAgICAgIHJldHVybiBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IobnVsbCwgbm9kZURhdGEsIG5vZGVEYXRhLnVuZGlyZWN0ZWQpO1xuXG4gICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcihudWxsLCBub2RlRGF0YSwgbm9kZURhdGFbZGlyZWN0aW9uXSk7XG4gIH1cblxuICBsZXQgaXRlcmF0b3IgPSBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgLy8gRWxzZSB3ZSBuZWVkIHRvIGtlZXAgYSBzZXQgb2YgbmVpZ2hib3JzIG5vdCB0byByZXR1cm4gZHVwbGljYXRlc1xuICAvLyBXZSBjaGVhdCBieSBxdWVyeWluZyB0aGUgb3RoZXIgYWRqYWNlbmNpZXNcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBDb21wb3NpdGVTZXRXcmFwcGVyKCk7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdvdXQnKSB7XG4gICAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBub2RlRGF0YS5pbilcbiAgICAgICk7XG4gICAgfVxuICAgIGlmIChkaXJlY3Rpb24gIT09ICdpbicpIHtcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IodmlzaXRlZCwgbm9kZURhdGEsIG5vZGVEYXRhLm91dClcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgaXRlcmF0b3IsXG4gICAgICBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IodmlzaXRlZCwgbm9kZURhdGEsIG5vZGVEYXRhLnVuZGlyZWN0ZWQpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBpdGVyYXRvcjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBuZWlnaGJvcnMgYXJyYXkgY3JlYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hOZWlnaGJvckFycmF5Q3JlYXRvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGFycmF5IG9mIGNlcnRhaW4gbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgbm9kZSAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSBuZWlnaGJvcnMgb2YgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIG5vZGUgaXMgbm90IGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIFtdO1xuXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtuYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICAvLyBIZXJlLCB3ZSB3YW50IHRvIGl0ZXJhdGUgb3ZlciBhIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnNcbiAgICByZXR1cm4gY3JlYXRlTmVpZ2hib3JBcnJheUZvck5vZGUoXG4gICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIG5vZGVEYXRhXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBuZWlnaGJvcnMgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRm9yRWFjaE5laWdoYm9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIGNvbnN0IGZvckVhY2hOYW1lID0gJ2ZvckVhY2gnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2ZvckVhY2hOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSkgcmV0dXJuO1xuXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgLy8gSGVyZSwgd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgYSBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzXG4gICAgZm9yRWFjaE5laWdoYm9yKFxuICAgICAgZmFsc2UsXG4gICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgY2FsbGJhY2tcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBtYXBwaW5nIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgbWFwTmFtZSA9ICdtYXAnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbbWFwTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiBvcHRpbWl6ZSB3aGVuIHNpemUgaXMga25vd24gYmVmb3JlaGFuZFxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0obm9kZSwgKG4sIGEpID0+IHtcbiAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKG4sIGEpKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGZpbHRlcmluZyB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IGZpbHRlck5hbWUgPSAnZmlsdGVyJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW2ZpbHRlck5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXShub2RlLCAobiwgYSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKG4sIGEpKSByZXN1bHQucHVzaChuKTtcbiAgICB9KTtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJlZHVjaW5nIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgcmVkdWNlTmFtZSA9ICdyZWR1Y2UnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbcmVkdWNlTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7cmVkdWNlTmFtZX06IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS5gXG4gICAgICApO1xuXG4gICAgbGV0IGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0obm9kZSwgKG4sIGEpID0+IHtcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIG4sIGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIGJyZWFrYWJsZSBuZWlnaGJvcnMgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZVxuICogR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEZpbmROZWlnaGJvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBjYXBpdGFsaXplZFNpbmd1bGFyID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgY29uc3QgZmluZE5hbWUgPSAnZmluZCcgKyBjYXBpdGFsaXplZFNpbmd1bGFyO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtmaW5kTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpIHJldHVybjtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7ZmluZE5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIHJldHVybiBmb3JFYWNoTmVpZ2hib3IoXG4gICAgICB0cnVlLFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdG8gZmluZCBpZiBhbnkgb2YgdGhlbVxuICAgKiBtYXRjaGVzIHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IHNvbWVOYW1lID0gJ3NvbWUnICsgY2FwaXRhbGl6ZWRTaW5ndWxhcjtcblxuICBDbGFzcy5wcm90b3R5cGVbc29tZU5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZm91bmQgPSB0aGlzW2ZpbmROYW1lXShub2RlLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoZm91bmQpIHJldHVybiB0cnVlO1xuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB0byBmaW5kIGlmIGFsbCBvZiB0aGVtXG4gICAqIG1hdGNoZSB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBldmVyeU5hbWUgPSAnZXZlcnknICsgY2FwaXRhbGl6ZWRTaW5ndWxhcjtcblxuICBDbGFzcy5wcm90b3R5cGVbZXZlcnlOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kTmFtZV0obm9kZSwgKG4sIGEpID0+IHtcbiAgICAgIHJldHVybiAhY2FsbGJhY2sobiwgYSk7XG4gICAgfSk7XG5cbiAgICBpZiAoZm91bmQpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIG5laWdoYm9ycyBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hOZWlnaGJvckl0ZXJhdG9yQ3JlYXRvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBpdGVyYXRvck5hbWUgPSBuYW1lLnNsaWNlKDAsIC0xKSArICdFbnRyaWVzJztcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2l0ZXJhdG9yTmFtZV0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke2l0ZXJhdG9yTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgLy8gSGVyZSwgd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgYSBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzXG4gICAgcmV0dXJuIGNyZWF0ZU5laWdoYm9ySXRlcmF0b3IoXG4gICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgIGRpcmVjdGlvbixcbiAgICAgIG5vZGVEYXRhXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgZXZlcnkgbmVpZ2hib3IgaXRlcmF0aW9uIG1ldGhvZCB0byB0aGUgR3JhcGggY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gR3JhcGggLSBHcmFwaCBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTmVpZ2hib3JJdGVyYXRpb25NZXRob2RzKEdyYXBoKSB7XG4gIE5FSUdIQk9SU19JVEVSQVRJT04uZm9yRWFjaChkZXNjcmlwdGlvbiA9PiB7XG4gICAgYXR0YWNoTmVpZ2hib3JBcnJheUNyZWF0b3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hGb3JFYWNoTmVpZ2hib3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hGaW5kTmVpZ2hib3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hOZWlnaGJvckl0ZXJhdG9yQ3JlYXRvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFwaG9sb2d5IEFkamFjZW5jeSBJdGVyYXRpb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBBdHRhY2hpbmcgc29tZSBtZXRob2RzIHRvIHRoZSBHcmFwaCBjbGFzcyB0byBiZSBhYmxlIHRvIGl0ZXJhdGUgb3ZlciBhXG4gKiBncmFwaCdzIGFkamFjZW5jeS5cbiAqL1xuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGEgc2ltcGxlIGdyYXBoJ3MgYWRqYWNlbmN5IHVzaW5nIGEgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtib29sZWFufSAgYnJlYWthYmxlICAgICAgICAgLSBDYW4gd2UgYnJlYWs/XG4gKiBAcGFyYW0ge2Jvb2xlYW59ICBhc3N5bWV0cmljICAgICAgICAtIFdoZXRoZXIgdG8gZW1pdCB1bmRpcmVjdGVkIGVkZ2VzIG9ubHkgb25jZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gIGRpc2Nvbm5lY3RlZE5vZGVzIC0gV2hldGhlciB0byBlbWl0IGRpc2Nvbm5lY3RlZCBub2Rlcy5cbiAqIEBwYXJhbSB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgICAgIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtIHtjYWxsYmFja30gZnVuY3Rpb24gICAgICAgICAgLSBJdGVyYXRpb24gY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBZGphY2VuY3koXG4gIGJyZWFrYWJsZSxcbiAgYXNzeW1ldHJpYyxcbiAgZGlzY29ubmVjdGVkTm9kZXMsXG4gIGdyYXBoLFxuICBjYWxsYmFja1xuKSB7XG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX25vZGVzLnZhbHVlcygpO1xuXG4gIGNvbnN0IHR5cGUgPSBncmFwaC50eXBlO1xuXG4gIGxldCBzdGVwLCBzb3VyY2VEYXRhLCBuZWlnaGJvciwgYWRqLCBlZGdlRGF0YSwgdGFyZ2V0RGF0YSwgc2hvdWxkQnJlYWs7XG5cbiAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICBsZXQgaGFzRWRnZXMgPSBmYWxzZTtcblxuICAgIHNvdXJjZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgYWRqID0gc291cmNlRGF0YS5vdXQ7XG5cbiAgICAgIGZvciAobmVpZ2hib3IgaW4gYWRqKSB7XG4gICAgICAgIGVkZ2VEYXRhID0gYWRqW25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgICAgIGhhc0VkZ2VzID0gdHJ1ZTtcbiAgICAgICAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICAgICAgICB0YXJnZXREYXRhLmtleSxcbiAgICAgICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIHRhcmdldERhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIGlmIChicmVha2FibGUgJiYgc2hvdWxkQnJlYWspIHJldHVybiBlZGdlRGF0YTtcblxuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBhZGogPSBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQ7XG5cbiAgICAgIGZvciAobmVpZ2hib3IgaW4gYWRqKSB7XG4gICAgICAgIGlmIChhc3N5bWV0cmljICYmIHNvdXJjZURhdGEua2V5ID4gbmVpZ2hib3IpIGNvbnRpbnVlO1xuXG4gICAgICAgIGVkZ2VEYXRhID0gYWRqW25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgICAgIGlmICh0YXJnZXREYXRhLmtleSAhPT0gbmVpZ2hib3IpIHRhcmdldERhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG5cbiAgICAgICAgICBoYXNFZGdlcyA9IHRydWU7XG4gICAgICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB0YXJnZXREYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGE7XG5cbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlzY29ubmVjdGVkTm9kZXMgJiYgIWhhc0VkZ2VzKSB7XG4gICAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBTZXJpYWxpemF0aW9uIFV0aWxpdGllc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBDb2xsZWN0aW9uIG9mIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBncmFwaCBzZXJpYWxpemF0aW9uIHNjaGVtZXMuXG4gKi9cblxuLyoqXG4gKiBGb3JtYXRzIGludGVybmFsIG5vZGUgZGF0YSBpbnRvIGEgc2VyaWFsaXplZCBub2RlLlxuICpcbiAqIEBwYXJhbSAge2FueX0gICAga2V5ICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtICB7b2JqZWN0fSBkYXRhIC0gSW50ZXJuYWwgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgLSBUaGUgc2VyaWFsaXplZCBub2RlLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVOb2RlKGtleSwgZGF0YSkge1xuICBjb25zdCBzZXJpYWxpemVkID0ge2tleX07XG5cbiAgaWYgKCFpc0VtcHR5KGRhdGEuYXR0cmlidXRlcykpXG4gICAgc2VyaWFsaXplZC5hdHRyaWJ1dGVzID0gYXNzaWduKHt9LCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgaW50ZXJuYWwgZWRnZSBkYXRhIGludG8gYSBzZXJpYWxpemVkIGVkZ2UuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSB0eXBlIC0gVGhlIGdyYXBoJ3MgdHlwZS5cbiAqIEBwYXJhbSAge2FueX0gICAga2V5ICAtIFRoZSBlZGdlJ3Mga2V5LlxuICogQHBhcmFtICB7b2JqZWN0fSBkYXRhIC0gSW50ZXJuYWwgZWRnZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHthcnJheX0gICAgICAgLSBUaGUgc2VyaWFsaXplZCBlZGdlLlxuICovXG5mdW5jdGlvbiBzZXJpYWxpemVFZGdlKHR5cGUsIGtleSwgZGF0YSkge1xuICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgIGtleSxcbiAgICBzb3VyY2U6IGRhdGEuc291cmNlLmtleSxcbiAgICB0YXJnZXQ6IGRhdGEudGFyZ2V0LmtleVxuICB9O1xuXG4gIGlmICghaXNFbXB0eShkYXRhLmF0dHJpYnV0ZXMpKVxuICAgIHNlcmlhbGl6ZWQuYXR0cmlidXRlcyA9IGFzc2lnbih7fSwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICBpZiAodHlwZSA9PT0gJ21peGVkJyAmJiBkYXRhLnVuZGlyZWN0ZWQpIHNlcmlhbGl6ZWQudW5kaXJlY3RlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc2VyaWFsaXplZCBub2RlLlxuICpcbiAqIEBwYXJhbSAge21peGVkfSB2YWx1ZSAtIFRhcmdldCB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNlcmlhbGl6ZWROb2RlKHZhbHVlKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBzZXJpYWxpemVkIG5vZGUuIEEgc2VyaWFsaXplZCBub2RlIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgXCJrZXlcIiBwcm9wZXJ0eS4nXG4gICAgKTtcblxuICBpZiAoISgna2V5JyBpbiB2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogc2VyaWFsaXplZCBub2RlIGlzIG1pc3NpbmcgaXRzIGtleS4nXG4gICAgKTtcblxuICBpZiAoXG4gICAgJ2F0dHJpYnV0ZXMnIGluIHZhbHVlICYmXG4gICAgKCFpc1BsYWluT2JqZWN0KHZhbHVlLmF0dHJpYnV0ZXMpIHx8IHZhbHVlLmF0dHJpYnV0ZXMgPT09IG51bGwpXG4gIClcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEF0dHJpYnV0ZXMgc2hvdWxkIGJlIGEgcGxhaW4gb2JqZWN0LCBudWxsIG9yIG9taXR0ZWQuJ1xuICAgICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgc2VyaWFsaXplZCBlZGdlLlxuICpcbiAqIEBwYXJhbSAge21peGVkfSB2YWx1ZSAtIFRhcmdldCB2YWx1ZS5cbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNlcmlhbGl6ZWRFZGdlKHZhbHVlKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBzZXJpYWxpemVkIGVkZ2UuIEEgc2VyaWFsaXplZCBlZGdlIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCB3aXRoIGF0IGxlYXN0IGEgXCJzb3VyY2VcIiAmIFwidGFyZ2V0XCIgcHJvcGVydHkuJ1xuICAgICk7XG5cbiAgaWYgKCEoJ3NvdXJjZScgaW4gdmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IHNlcmlhbGl6ZWQgZWRnZSBpcyBtaXNzaW5nIGl0cyBzb3VyY2UuJ1xuICAgICk7XG5cbiAgaWYgKCEoJ3RhcmdldCcgaW4gdmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IHNlcmlhbGl6ZWQgZWRnZSBpcyBtaXNzaW5nIGl0cyB0YXJnZXQuJ1xuICAgICk7XG5cbiAgaWYgKFxuICAgICdhdHRyaWJ1dGVzJyBpbiB2YWx1ZSAmJlxuICAgICghaXNQbGFpbk9iamVjdCh2YWx1ZS5hdHRyaWJ1dGVzKSB8fCB2YWx1ZS5hdHRyaWJ1dGVzID09PSBudWxsKVxuICApXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBhdHRyaWJ1dGVzLiBBdHRyaWJ1dGVzIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCwgbnVsbCBvciBvbWl0dGVkLidcbiAgICApO1xuXG4gIGlmICgndW5kaXJlY3RlZCcgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLnVuZGlyZWN0ZWQgIT09ICdib29sZWFuJylcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIHVuZGlyZWN0ZWRuZXNzIGluZm9ybWF0aW9uLiBVbmRpcmVjdGVkIHNob3VsZCBiZSBib29sZWFuIG9yIG9taXR0ZWQuJ1xuICAgICk7XG59XG5cbi8qIGVzbGludCBuby1uZXN0ZWQtdGVybmFyeTogMCAqL1xuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xuY29uc3QgSU5TVEFOQ0VfSUQgPSBpbmNyZW1lbnRhbElkU3RhcnRpbmdGcm9tUmFuZG9tQnl0ZSgpO1xuXG4vKipcbiAqIEVudW1zLlxuICovXG5jb25zdCBUWVBFUyA9IG5ldyBTZXQoWydkaXJlY3RlZCcsICd1bmRpcmVjdGVkJywgJ21peGVkJ10pO1xuXG5jb25zdCBFTUlUVEVSX1BST1BTID0gbmV3IFNldChbXG4gICdkb21haW4nLFxuICAnX2V2ZW50cycsXG4gICdfZXZlbnRzQ291bnQnLFxuICAnX21heExpc3RlbmVycydcbl0pO1xuXG5jb25zdCBFREdFX0FERF9NRVRIT0RTID0gW1xuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifUVkZ2VgLFxuICAgIGdlbmVyYXRlS2V5OiB0cnVlXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9RGlyZWN0ZWRFZGdlYCxcbiAgICBnZW5lcmF0ZUtleTogdHJ1ZSxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9VW5kaXJlY3RlZEVkZ2VgLFxuICAgIGdlbmVyYXRlS2V5OiB0cnVlLFxuICAgIHR5cGU6ICd1bmRpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifUVkZ2VXaXRoS2V5YFxuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifURpcmVjdGVkRWRnZVdpdGhLZXlgLFxuICAgIHR5cGU6ICdkaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1VbmRpcmVjdGVkRWRnZVdpdGhLZXlgLFxuICAgIHR5cGU6ICd1bmRpcmVjdGVkJ1xuICB9XG5dO1xuXG4vKipcbiAqIERlZmF1bHQgb3B0aW9ucy5cbiAqL1xuY29uc3QgREVGQVVMVFMgPSB7XG4gIGFsbG93U2VsZkxvb3BzOiB0cnVlLFxuICBtdWx0aTogZmFsc2UsXG4gIHR5cGU6ICdtaXhlZCdcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgZnVuY3Rpb25zIHVzZWQgYnkgdGhlIEdyYXBoIGNsYXNzIGZvciB2YXJpb3VzIG1ldGhvZHMuXG4gKi9cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgdXNlZCB0byBhZGQgYSBub2RlIHRvIHRoZSBnaXZlbiBncmFwaFxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoICAgICAgICAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgICAgICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtICB7b2JqZWN0fSAgW2F0dHJpYnV0ZXNdICAgIC0gT3B0aW9uYWwgYXR0cmlidXRlcy5cbiAqIEByZXR1cm4ge05vZGVEYXRhfSAgICAgICAgICAgICAgICAtIENyZWF0ZWQgbm9kZSBkYXRhLlxuICovXG5mdW5jdGlvbiBhZGROb2RlKGdyYXBoLCBub2RlLCBhdHRyaWJ1dGVzKSB7XG4gIGlmIChhdHRyaWJ1dGVzICYmICFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5hZGROb2RlOiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICApO1xuXG4gIC8vIFN0cmluZyBjb2VyY2lvblxuICBub2RlID0gJycgKyBub2RlO1xuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAoZ3JhcGguX25vZGVzLmhhcyhub2RlKSlcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmFkZE5vZGU6IHRoZSBcIiR7bm9kZX1cIiBub2RlIGFscmVhZHkgZXhpc3QgaW4gdGhlIGdyYXBoLmBcbiAgICApO1xuXG4gIGNvbnN0IGRhdGEgPSBuZXcgZ3JhcGguTm9kZURhdGFDbGFzcyhub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAvLyBBZGRpbmcgdGhlIG5vZGUgdG8gaW50ZXJuYWwgcmVnaXN0ZXJcbiAgZ3JhcGguX25vZGVzLnNldChub2RlLCBkYXRhKTtcblxuICAvLyBFbWl0dGluZ1xuICBncmFwaC5lbWl0KCdub2RlQWRkZWQnLCB7XG4gICAga2V5OiBub2RlLFxuICAgIGF0dHJpYnV0ZXNcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2FtZSBhcyB0aGUgYWJvdmUgYnV0IHdpdGhvdXQgc2FuaXR5IGNoZWNrcyBiZWNhdXNlIHdlIGNhbGwgdGhpcyBpbiBjb250ZXh0c1xuICogd2hlcmUgbmVjZXNzYXJ5IGNoZWNrcyB3ZXJlIGFscmVhZHkgZG9uZS5cbiAqL1xuZnVuY3Rpb24gdW5zYWZlQWRkTm9kZShncmFwaCwgbm9kZSwgYXR0cmlidXRlcykge1xuICBjb25zdCBkYXRhID0gbmV3IGdyYXBoLk5vZGVEYXRhQ2xhc3Mobm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgZ3JhcGguX25vZGVzLnNldChub2RlLCBkYXRhKTtcblxuICBncmFwaC5lbWl0KCdub2RlQWRkZWQnLCB7XG4gICAga2V5OiBub2RlLFxuICAgIGF0dHJpYnV0ZXNcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gYWRkIGFuIGFyYml0cmFyeSBlZGdlIHRvIHRoZSBnaXZlbiBncmFwaC5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgICAgICAgICAgLSBOYW1lIG9mIHRoZSBjaGlsZCBtZXRob2QgZm9yIGVycm9ycy5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IG11c3RHZW5lcmF0ZUtleSAtIFNob3VsZCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQ/XG4gKiBAcGFyYW0gIHtib29sZWFufSB1bmRpcmVjdGVkICAgICAgLSBXaGV0aGVyIHRoZSBlZGdlIGlzIHVuZGlyZWN0ZWQuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlICAgICAgICAgICAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAgICAgICAgICAtIFRoZSBzb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgICAgICAtIFRoZSB0YXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge29iamVjdH0gIFthdHRyaWJ1dGVzXSAgICAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHthbnl9ICAgICAgICAgICAgICAgICAgICAgLSBUaGUgZWRnZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBvZiB0aGUgd3JvbmcgdHlwZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbiBvYmplY3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gYWRkRWRnZShcbiAgZ3JhcGgsXG4gIG5hbWUsXG4gIG11c3RHZW5lcmF0ZUtleSxcbiAgdW5kaXJlY3RlZCxcbiAgZWRnZSxcbiAgc291cmNlLFxuICB0YXJnZXQsXG4gIGF0dHJpYnV0ZXNcbikge1xuICAvLyBDaGVja2luZyB2YWxpZGl0eSBvZiBvcGVyYXRpb25cbiAgaWYgKCF1bmRpcmVjdGVkICYmIGdyYXBoLnR5cGUgPT09ICd1bmRpcmVjdGVkJylcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHlvdSBjYW5ub3QgYWRkIGEgZGlyZWN0ZWQgZWRnZSB0byBhbiB1bmRpcmVjdGVkIGdyYXBoLiBVc2UgdGhlICMuYWRkRWRnZSBvciAjLmFkZFVuZGlyZWN0ZWRFZGdlIGluc3RlYWQuYFxuICAgICk7XG5cbiAgaWYgKHVuZGlyZWN0ZWQgJiYgZ3JhcGgudHlwZSA9PT0gJ2RpcmVjdGVkJylcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHlvdSBjYW5ub3QgYWRkIGFuIHVuZGlyZWN0ZWQgZWRnZSB0byBhIGRpcmVjdGVkIGdyYXBoLiBVc2UgdGhlICMuYWRkRWRnZSBvciAjLmFkZERpcmVjdGVkRWRnZSBpbnN0ZWFkLmBcbiAgICApO1xuXG4gIGlmIChhdHRyaWJ1dGVzICYmICFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICApO1xuXG4gIC8vIENvZXJjaW9uIG9mIHNvdXJjZSAmIHRhcmdldDpcbiAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAoIWdyYXBoLmFsbG93U2VsZkxvb3BzICYmIHNvdXJjZSA9PT0gdGFyZ2V0KVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogc291cmNlICYgdGFyZ2V0IGFyZSB0aGUgc2FtZSAoXCIke3NvdXJjZX1cIiksIHRodXMgY3JlYXRpbmcgYSBsb29wIGV4cGxpY2l0bHkgZm9yYmlkZGVuIGJ5IHRoaXMgZ3JhcGggJ2FsbG93U2VsZkxvb3BzJyBvcHRpb24gc2V0IHRvIGZhbHNlLmBcbiAgICApO1xuXG4gIGNvbnN0IHNvdXJjZURhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHNvdXJjZSksXG4gICAgdGFyZ2V0RGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQodGFyZ2V0KTtcblxuICBpZiAoIXNvdXJjZURhdGEpXG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiBzb3VyY2Ugbm9kZSBcIiR7c291cmNlfVwiIG5vdCBmb3VuZC5gXG4gICAgKTtcblxuICBpZiAoIXRhcmdldERhdGEpXG4gICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB0YXJnZXQgbm9kZSBcIiR7dGFyZ2V0fVwiIG5vdCBmb3VuZC5gXG4gICAgKTtcblxuICAvLyBNdXN0IHRoZSBncmFwaCBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhpcyBlZGdlP1xuICBjb25zdCBldmVudERhdGEgPSB7XG4gICAga2V5OiBudWxsLFxuICAgIHVuZGlyZWN0ZWQsXG4gICAgc291cmNlLFxuICAgIHRhcmdldCxcbiAgICBhdHRyaWJ1dGVzXG4gIH07XG5cbiAgaWYgKG11c3RHZW5lcmF0ZUtleSkge1xuICAgIC8vIE5PVEU6IGluIHRoaXMgY2FzZSB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIGtleSBkb2VzIG5vdCBhbHJlYWR5XG4gICAgLy8gZXhpc3QgYW5kIGlzIGFscmVhZHkgY29ycmVjdGx5IGNhc3RlZCBhcyBhIHN0cmluZ1xuICAgIGVkZ2UgPSBncmFwaC5fZWRnZUtleUdlbmVyYXRvcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIENvZXJjaW9uIG9mIGVkZ2Uga2V5XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIC8vIEhlcmUsIHdlIGhhdmUgYSBrZXkgY29sbGlzaW9uXG4gICAgaWYgKGdyYXBoLl9lZGdlcy5oYXMoZWRnZSkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtuYW1lfTogdGhlIFwiJHtlZGdlfVwiIGVkZ2UgYWxyZWFkeSBleGlzdHMgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG4gIH1cblxuICAvLyBIZXJlLCB3ZSBtaWdodCBoYXZlIGEgc291cmNlIC8gdGFyZ2V0IGNvbGxpc2lvblxuICBpZiAoXG4gICAgIWdyYXBoLm11bHRpICYmXG4gICAgKHVuZGlyZWN0ZWRcbiAgICAgID8gdHlwZW9mIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdICE9PSAndW5kZWZpbmVkJ1xuICAgICAgOiB0eXBlb2Ygc291cmNlRGF0YS5vdXRbdGFyZ2V0XSAhPT0gJ3VuZGVmaW5lZCcpXG4gICkge1xuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogYW4gZWRnZSBsaW5raW5nIFwiJHtzb3VyY2V9XCIgdG8gXCIke3RhcmdldH1cIiBhbHJlYWR5IGV4aXN0cy4gSWYgeW91IHJlYWxseSB3YW50IHRvIGFkZCBtdWx0aXBsZSBlZGdlcyBsaW5raW5nIHRob3NlIG5vZGVzLCB5b3Ugc2hvdWxkIGNyZWF0ZSBhIG11bHRpIGdyYXBoIGJ5IHVzaW5nIHRoZSAnbXVsdGknIG9wdGlvbi5gXG4gICAgKTtcbiAgfVxuXG4gIC8vIFN0b3Jpbmcgc29tZSBkYXRhXG4gIGNvbnN0IGVkZ2VEYXRhID0gbmV3IEVkZ2VEYXRhKFxuICAgIHVuZGlyZWN0ZWQsXG4gICAgZWRnZSxcbiAgICBzb3VyY2VEYXRhLFxuICAgIHRhcmdldERhdGEsXG4gICAgYXR0cmlidXRlc1xuICApO1xuXG4gIC8vIEFkZGluZyB0aGUgZWRnZSB0byB0aGUgaW50ZXJuYWwgcmVnaXN0ZXJcbiAgZ3JhcGguX2VkZ2VzLnNldChlZGdlLCBlZGdlRGF0YSk7XG5cbiAgLy8gSW5jcmVtZW50aW5nIG5vZGUgZGVncmVlIGNvdW50ZXJzXG4gIGNvbnN0IGlzU2VsZkxvb3AgPSBzb3VyY2UgPT09IHRhcmdldDtcblxuICBpZiAodW5kaXJlY3RlZCkge1xuICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuICAgIHRhcmdldERhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc291cmNlRGF0YS5vdXREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLmluRGVncmVlKys7XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRpbmcgcmVsZXZhbnQgaW5kZXhcbiAgaWYgKGdyYXBoLm11bHRpKSBlZGdlRGF0YS5hdHRhY2hNdWx0aSgpO1xuICBlbHNlIGVkZ2VEYXRhLmF0dGFjaCgpO1xuXG4gIGlmICh1bmRpcmVjdGVkKSBncmFwaC5fdW5kaXJlY3RlZFNpemUrKztcbiAgZWxzZSBncmFwaC5fZGlyZWN0ZWRTaXplKys7XG5cbiAgLy8gRW1pdHRpbmdcbiAgZXZlbnREYXRhLmtleSA9IGVkZ2U7XG5cbiAgZ3JhcGguZW1pdCgnZWRnZUFkZGVkJywgZXZlbnREYXRhKTtcblxuICByZXR1cm4gZWRnZTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgdXNlZCB0byBhZGQgYW4gYXJiaXRyYXJ5IGVkZ2UgdG8gdGhlIGdpdmVuIGdyYXBoLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoICAgICAgICAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAgICAgICAgICAtIE5hbWUgb2YgdGhlIGNoaWxkIG1ldGhvZCBmb3IgZXJyb3JzLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gbXVzdEdlbmVyYXRlS2V5IC0gU2hvdWxkIHRoZSBncmFwaCBnZW5lcmF0ZSBhbiBpZD9cbiAqIEBwYXJhbSAge2Jvb2xlYW59IHVuZGlyZWN0ZWQgICAgICAtIFdoZXRoZXIgdGhlIGVkZ2UgaXMgdW5kaXJlY3RlZC5cbiAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgICAgICAgICAgICAtIFRoZSBlZGdlJ3Mga2V5LlxuICogQHBhcmFtICB7YW55fSAgICAgc291cmNlICAgICAgICAgIC0gVGhlIHNvdXJjZSBub2RlLlxuICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0ICAgICAgICAgIC0gVGhlIHRhcmdldCBub2RlLlxuICogQHBhcmFtICB7b2JqZWN0fSAgW2F0dHJpYnV0ZXNdICAgIC0gT3B0aW9uYWwgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IFthc1VwZGF0ZXJdICAgICAgIC0gQXJlIHdlIHVwZGF0aW5nIG9yIG1lcmdpbmc/XG4gKiBAcmV0dXJuIHthbnl9ICAgICAgICAgICAgICAgICAgICAgLSBUaGUgZWRnZS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBvZiB0aGUgd3JvbmcgdHlwZS5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBhbiBvYmplY3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgYWxyZWFkeSBleGlzdC5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VFZGdlKFxuICBncmFwaCxcbiAgbmFtZSxcbiAgbXVzdEdlbmVyYXRlS2V5LFxuICB1bmRpcmVjdGVkLFxuICBlZGdlLFxuICBzb3VyY2UsXG4gIHRhcmdldCxcbiAgYXR0cmlidXRlcyxcbiAgYXNVcGRhdGVyXG4pIHtcbiAgLy8gQ2hlY2tpbmcgdmFsaWRpdHkgb2Ygb3BlcmF0aW9uXG4gIGlmICghdW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IG1lcmdlL3VwZGF0ZSBhIGRpcmVjdGVkIGVkZ2UgdG8gYW4gdW5kaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLm1lcmdlRWRnZS8jLnVwZGF0ZUVkZ2Ugb3IgIy5hZGRVbmRpcmVjdGVkRWRnZSBpbnN0ZWFkLmBcbiAgICApO1xuXG4gIGlmICh1bmRpcmVjdGVkICYmIGdyYXBoLnR5cGUgPT09ICdkaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IG1lcmdlL3VwZGF0ZSBhbiB1bmRpcmVjdGVkIGVkZ2UgdG8gYSBkaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLm1lcmdlRWRnZS8jLnVwZGF0ZUVkZ2Ugb3IgIy5hZGREaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGlmIChhc1VwZGF0ZXIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcyAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiBpbnZhbGlkIHVwZGF0ZXIgZnVuY3Rpb24uIEV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvLyBDb2VyY2lvbiBvZiBzb3VyY2UgJiB0YXJnZXQ6XG4gIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICBsZXQgdXBkYXRlcjtcblxuICBpZiAoYXNVcGRhdGVyKSB7XG4gICAgdXBkYXRlciA9IGF0dHJpYnV0ZXM7XG4gICAgYXR0cmlidXRlcyA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICghZ3JhcGguYWxsb3dTZWxmTG9vcHMgJiYgc291cmNlID09PSB0YXJnZXQpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiBzb3VyY2UgJiB0YXJnZXQgYXJlIHRoZSBzYW1lIChcIiR7c291cmNlfVwiKSwgdGh1cyBjcmVhdGluZyBhIGxvb3AgZXhwbGljaXRseSBmb3JiaWRkZW4gYnkgdGhpcyBncmFwaCAnYWxsb3dTZWxmTG9vcHMnIG9wdGlvbiBzZXQgdG8gZmFsc2UuYFxuICAgICk7XG5cbiAgbGV0IHNvdXJjZURhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHNvdXJjZSk7XG4gIGxldCB0YXJnZXREYXRhID0gZ3JhcGguX25vZGVzLmdldCh0YXJnZXQpO1xuICBsZXQgZWRnZURhdGE7XG5cbiAgLy8gRG8gd2UgbmVlZCB0byBoYW5kbGUgZHVwbGljYXRlP1xuICBsZXQgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGE7XG5cbiAgaWYgKCFtdXN0R2VuZXJhdGVLZXkpIHtcbiAgICBlZGdlRGF0YSA9IGdyYXBoLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoZWRnZURhdGEpIHtcbiAgICAgIC8vIEhlcmUsIHdlIG5lZWQgdG8gZW5zdXJlLCBpZiB0aGUgdXNlciBnYXZlIGEga2V5LCB0aGF0IHNvdXJjZSAmIHRhcmdldFxuICAgICAgLy8gYXJlIGNvbnNpc3RlbnRcbiAgICAgIGlmIChlZGdlRGF0YS5zb3VyY2Uua2V5ICE9PSBzb3VyY2UgfHwgZWRnZURhdGEudGFyZ2V0LmtleSAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIC8vIElmIHNvdXJjZSBvciB0YXJnZXQgaW5jb25zaXN0ZW50XG4gICAgICAgIGlmIChcbiAgICAgICAgICAhdW5kaXJlY3RlZCB8fFxuICAgICAgICAgIGVkZ2VEYXRhLnNvdXJjZS5rZXkgIT09IHRhcmdldCB8fFxuICAgICAgICAgIGVkZ2VEYXRhLnRhcmdldC5rZXkgIT09IHNvdXJjZVxuICAgICAgICApIHtcbiAgICAgICAgICAvLyBJZiBkaXJlY3RlZCwgb3Igc291cmNlL3RhcmdldCBhcmVuJ3QgZmxpcHBlZFxuICAgICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgICBgR3JhcGguJHtuYW1lfTogaW5jb25zaXN0ZW5jeSBkZXRlY3RlZCB3aGVuIGF0dGVtcHRpbmcgdG8gbWVyZ2UgdGhlIFwiJHtlZGdlfVwiIGVkZ2Ugd2l0aCBcIiR7c291cmNlfVwiIHNvdXJjZSAmIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IHZzLiAoXCIke2VkZ2VEYXRhLnNvdXJjZS5rZXl9XCIsIFwiJHtlZGdlRGF0YS50YXJnZXQua2V5fVwiKS5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YSA9IGVkZ2VEYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8vIEhlcmUsIHdlIG1pZ2h0IGhhdmUgYSBzb3VyY2UgLyB0YXJnZXQgY29sbGlzaW9uXG4gIGlmICghYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEgJiYgIWdyYXBoLm11bHRpICYmIHNvdXJjZURhdGEpIHtcbiAgICBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YSA9IHVuZGlyZWN0ZWRcbiAgICAgID8gc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF1cbiAgICAgIDogc291cmNlRGF0YS5vdXRbdGFyZ2V0XTtcbiAgfVxuXG4gIC8vIEhhbmRsaW5nIGR1cGxpY2F0ZXNcbiAgaWYgKGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhKSB7XG4gICAgY29uc3QgaW5mbyA9IFthbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5rZXksIGZhbHNlLCBmYWxzZSwgZmFsc2VdO1xuXG4gICAgLy8gV2UgY2FuIHNraXAgdGhlIGF0dHJpYnV0ZSBtZXJnaW5nIHBhcnQgaWYgdGhlIHVzZXIgZGlkIG5vdCBwcm92aWRlIHRoZW1cbiAgICBpZiAoYXNVcGRhdGVyID8gIXVwZGF0ZXIgOiAhYXR0cmlidXRlcykgcmV0dXJuIGluZm87XG5cbiAgICAvLyBVcGRhdGluZyB0aGUgYXR0cmlidXRlc1xuICAgIGlmIChhc1VwZGF0ZXIpIHtcbiAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZXMgPSBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzO1xuICAgICAgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIob2xkQXR0cmlidXRlcyk7XG5cbiAgICAgIGdyYXBoLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgICBrZXk6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmtleSxcbiAgICAgICAgYXR0cmlidXRlczogYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTWVyZ2luZyB0aGUgYXR0cmlidXRlc1xuICAgIGVsc2Uge1xuICAgICAgYXNzaWduKGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgICBncmFwaC5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICAgIGtleTogYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEua2V5LFxuICAgICAgICBhdHRyaWJ1dGVzOiBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gIGlmIChhc1VwZGF0ZXIgJiYgdXBkYXRlcikgYXR0cmlidXRlcyA9IHVwZGF0ZXIoYXR0cmlidXRlcyk7XG5cbiAgLy8gTXVzdCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQgZm9yIHRoaXMgZWRnZT9cbiAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgIGtleTogbnVsbCxcbiAgICB1bmRpcmVjdGVkLFxuICAgIHNvdXJjZSxcbiAgICB0YXJnZXQsXG4gICAgYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmIChtdXN0R2VuZXJhdGVLZXkpIHtcbiAgICAvLyBOT1RFOiBpbiB0aGlzIGNhc2Ugd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBrZXkgZG9lcyBub3QgYWxyZWFkeVxuICAgIC8vIGV4aXN0IGFuZCBpcyBhbHJlYWR5IGNvcnJlY3RseSBjYXN0ZWQgYXMgYSBzdHJpbmdcbiAgICBlZGdlID0gZ3JhcGguX2VkZ2VLZXlHZW5lcmF0b3IoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2lvbiBvZiBlZGdlIGtleVxuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICAvLyBIZXJlLCB3ZSBoYXZlIGEga2V5IGNvbGxpc2lvblxuICAgIGlmIChncmFwaC5fZWRnZXMuaGFzKGVkZ2UpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bmFtZX06IHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuICB9XG5cbiAgbGV0IHNvdXJjZVdhc0FkZGVkID0gZmFsc2U7XG4gIGxldCB0YXJnZXRXYXNBZGRlZCA9IGZhbHNlO1xuXG4gIGlmICghc291cmNlRGF0YSkge1xuICAgIHNvdXJjZURhdGEgPSB1bnNhZmVBZGROb2RlKGdyYXBoLCBzb3VyY2UsIHt9KTtcbiAgICBzb3VyY2VXYXNBZGRlZCA9IHRydWU7XG5cbiAgICBpZiAoc291cmNlID09PSB0YXJnZXQpIHtcbiAgICAgIHRhcmdldERhdGEgPSBzb3VyY2VEYXRhO1xuICAgICAgdGFyZ2V0V2FzQWRkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoIXRhcmdldERhdGEpIHtcbiAgICB0YXJnZXREYXRhID0gdW5zYWZlQWRkTm9kZShncmFwaCwgdGFyZ2V0LCB7fSk7XG4gICAgdGFyZ2V0V2FzQWRkZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gU3RvcmluZyBzb21lIGRhdGFcbiAgZWRnZURhdGEgPSBuZXcgRWRnZURhdGEodW5kaXJlY3RlZCwgZWRnZSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgYXR0cmlidXRlcyk7XG5cbiAgLy8gQWRkaW5nIHRoZSBlZGdlIHRvIHRoZSBpbnRlcm5hbCByZWdpc3RlclxuICBncmFwaC5fZWRnZXMuc2V0KGVkZ2UsIGVkZ2VEYXRhKTtcblxuICAvLyBJbmNyZW1lbnRpbmcgbm9kZSBkZWdyZWUgY291bnRlcnNcbiAgY29uc3QgaXNTZWxmTG9vcCA9IHNvdXJjZSA9PT0gdGFyZ2V0O1xuXG4gIGlmICh1bmRpcmVjdGVkKSB7XG4gICAgc291cmNlRGF0YS51bmRpcmVjdGVkRGVncmVlKys7XG4gICAgdGFyZ2V0RGF0YS51bmRpcmVjdGVkRGVncmVlKys7XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS51bmRpcmVjdGVkTG9vcHMrKztcbiAgICAgIGdyYXBoLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudCsrO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzb3VyY2VEYXRhLm91dERlZ3JlZSsrO1xuICAgIHRhcmdldERhdGEuaW5EZWdyZWUrKztcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLmRpcmVjdGVkTG9vcHMrKztcbiAgICAgIGdyYXBoLl9kaXJlY3RlZFNlbGZMb29wQ291bnQrKztcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGluZyByZWxldmFudCBpbmRleFxuICBpZiAoZ3JhcGgubXVsdGkpIGVkZ2VEYXRhLmF0dGFjaE11bHRpKCk7XG4gIGVsc2UgZWRnZURhdGEuYXR0YWNoKCk7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIGdyYXBoLl91bmRpcmVjdGVkU2l6ZSsrO1xuICBlbHNlIGdyYXBoLl9kaXJlY3RlZFNpemUrKztcblxuICAvLyBFbWl0dGluZ1xuICBldmVudERhdGEua2V5ID0gZWRnZTtcblxuICBncmFwaC5lbWl0KCdlZGdlQWRkZWQnLCBldmVudERhdGEpO1xuXG4gIHJldHVybiBbZWRnZSwgdHJ1ZSwgc291cmNlV2FzQWRkZWQsIHRhcmdldFdhc0FkZGVkXTtcbn1cblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgdXNlZCB0byBkcm9wIGFuIGVkZ2UuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7RWRnZURhdGF9IGVkZ2VEYXRhIC0gRGF0YSBvZiB0aGUgZWRnZSB0byBkcm9wLlxuICovXG5mdW5jdGlvbiBkcm9wRWRnZUZyb21EYXRhKGdyYXBoLCBlZGdlRGF0YSkge1xuICAvLyBEcm9wcGluZyB0aGUgZWRnZSBmcm9tIHRoZSByZWdpc3RlclxuICBncmFwaC5fZWRnZXMuZGVsZXRlKGVkZ2VEYXRhLmtleSk7XG5cbiAgLy8gVXBkYXRpbmcgcmVsYXRlZCBkZWdyZWVzXG4gIGNvbnN0IHtzb3VyY2U6IHNvdXJjZURhdGEsIHRhcmdldDogdGFyZ2V0RGF0YSwgYXR0cmlidXRlc30gPSBlZGdlRGF0YTtcblxuICBjb25zdCB1bmRpcmVjdGVkID0gZWRnZURhdGEudW5kaXJlY3RlZDtcblxuICBjb25zdCBpc1NlbGZMb29wID0gc291cmNlRGF0YSA9PT0gdGFyZ2V0RGF0YTtcblxuICBpZiAodW5kaXJlY3RlZCkge1xuICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZERlZ3JlZS0tO1xuICAgIHRhcmdldERhdGEudW5kaXJlY3RlZERlZ3JlZS0tO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZExvb3BzLS07XG4gICAgICBncmFwaC5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQtLTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc291cmNlRGF0YS5vdXREZWdyZWUtLTtcbiAgICB0YXJnZXREYXRhLmluRGVncmVlLS07XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS5kaXJlY3RlZExvb3BzLS07XG4gICAgICBncmFwaC5fZGlyZWN0ZWRTZWxmTG9vcENvdW50LS07XG4gICAgfVxuICB9XG5cbiAgLy8gQ2xlYXJpbmcgaW5kZXhcbiAgaWYgKGdyYXBoLm11bHRpKSBlZGdlRGF0YS5kZXRhY2hNdWx0aSgpO1xuICBlbHNlIGVkZ2VEYXRhLmRldGFjaCgpO1xuXG4gIGlmICh1bmRpcmVjdGVkKSBncmFwaC5fdW5kaXJlY3RlZFNpemUtLTtcbiAgZWxzZSBncmFwaC5fZGlyZWN0ZWRTaXplLS07XG5cbiAgLy8gRW1pdHRpbmdcbiAgZ3JhcGguZW1pdCgnZWRnZURyb3BwZWQnLCB7XG4gICAga2V5OiBlZGdlRGF0YS5rZXksXG4gICAgYXR0cmlidXRlcyxcbiAgICBzb3VyY2U6IHNvdXJjZURhdGEua2V5LFxuICAgIHRhcmdldDogdGFyZ2V0RGF0YS5rZXksXG4gICAgdW5kaXJlY3RlZFxuICB9KTtcbn1cblxuLyoqXG4gKiBHcmFwaCBjbGFzc1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtICB7b2JqZWN0fSAgW29wdGlvbnNdIC0gT3B0aW9uczpcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgW2FsbG93U2VsZkxvb3BzXSAtIEFsbG93IHNlbGYgbG9vcHM/XG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgIFt0eXBlXSAgICAgICAgICAgLSBUeXBlIG9mIHRoZSBncmFwaC5cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgW21hcF0gICAgICAgICAgICAtIEFsbG93IHJlZmVyZW5jZXMgYXMga2V5cz9cbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgW211bHRpXSAgICAgICAgICAtIEFsbG93IHBhcmFsbGVsIGVkZ2VzP1xuICpcbiAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHZhbGlkLlxuICovXG5jbGFzcyBHcmFwaCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgLy8tLSBTb2x2aW5nIG9wdGlvbnNcbiAgICBvcHRpb25zID0gYXNzaWduKHt9LCBERUZBVUxUUywgb3B0aW9ucyk7XG5cbiAgICAvLyBFbmZvcmNpbmcgb3B0aW9ucyB2YWxpZGl0eVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5tdWx0aSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguY29uc3RydWN0b3I6IGludmFsaWQgJ211bHRpJyBvcHRpb24uIEV4cGVjdGluZyBhIGJvb2xlYW4gYnV0IGdvdCBcIiR7b3B0aW9ucy5tdWx0aX1cIi5gXG4gICAgICApO1xuXG4gICAgaWYgKCFUWVBFUy5oYXMob3B0aW9ucy50eXBlKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvbnN0cnVjdG9yOiBpbnZhbGlkICd0eXBlJyBvcHRpb24uIFNob3VsZCBiZSBvbmUgb2YgXCJtaXhlZFwiLCBcImRpcmVjdGVkXCIgb3IgXCJ1bmRpcmVjdGVkXCIgYnV0IGdvdCBcIiR7b3B0aW9ucy50eXBlfVwiLmBcbiAgICAgICk7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgIT09ICdib29sZWFuJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvbnN0cnVjdG9yOiBpbnZhbGlkICdhbGxvd1NlbGZMb29wcycgb3B0aW9uLiBFeHBlY3RpbmcgYSBib29sZWFuIGJ1dCBnb3QgXCIke29wdGlvbnMuYWxsb3dTZWxmTG9vcHN9XCIuYFxuICAgICAgKTtcblxuICAgIC8vLS0gUHJpdmF0ZSBwcm9wZXJ0aWVzXG5cbiAgICAvLyBVdGlsaXRpZXNcbiAgICBjb25zdCBOb2RlRGF0YUNsYXNzID1cbiAgICAgIG9wdGlvbnMudHlwZSA9PT0gJ21peGVkJ1xuICAgICAgICA/IE1peGVkTm9kZURhdGFcbiAgICAgICAgOiBvcHRpb25zLnR5cGUgPT09ICdkaXJlY3RlZCdcbiAgICAgICAgPyBEaXJlY3RlZE5vZGVEYXRhXG4gICAgICAgIDogVW5kaXJlY3RlZE5vZGVEYXRhO1xuXG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdOb2RlRGF0YUNsYXNzJywgTm9kZURhdGFDbGFzcyk7XG5cbiAgICAvLyBJbnRlcm5hbCBlZGdlIGtleSBnZW5lcmF0b3JcblxuICAgIC8vIE5PVEU6IHRoaXMgaW50ZXJuYWwgZ2VuZXJhdG9yIHByb2R1Y2Uga2V5cyB0aGF0IGFyZSBzdHJpbmdzXG4gICAgLy8gY29tcG9zZWQgb2YgYSB3ZWlyZCBwcmVmaXgsIGFuIGluY3JlbWVudGFsIGluc3RhbmNlIGlkIHN0YXJ0aW5nIGZyb21cbiAgICAvLyBhIHJhbmRvbSBieXRlIGFuZCBmaW5hbGx5IGFuIGludGVybmFsIGluc3RhbmNlIGluY3JlbWVudGFsIGlkLlxuICAgIC8vIEFsbCB0aGlzIHRvIGF2b2lkIGludHJhLWZyYW1lIGFuZCBjcm9zcy1mcmFtZSBhZHZlcnNhcmlhbCBpbnB1dHNcbiAgICAvLyB0aGF0IGNhbiBmb3JjZSBhIHNpbmdsZSAjLmFkZEVkZ2UgY2FsbCB0byBkZWdlbmVyYXRlIGludG8gYSBPKG4pXG4gICAgLy8gYXZhaWxhYmxlIGtleSBzZWFyY2ggbG9vcC5cblxuICAgIC8vIEl0IGFsc28gZW5zdXJlcyB0aGF0IGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGVkZ2Uga2V5cyBhcmUgdW5saWtlbHlcbiAgICAvLyB0byBwcm9kdWNlIGNvbGxpc2lvbnMgd2l0aCBhcmJpdHJhcnkga2V5cyBnaXZlbiBieSB1c2Vycy5cbiAgICBjb25zdCBpbnN0YW5jZVByZWZpeCA9ICdnZWlkXycgKyBJTlNUQU5DRV9JRCgpICsgJ18nO1xuICAgIGxldCBlZGdlSWQgPSAwO1xuXG4gICAgY29uc3QgZWRnZUtleUdlbmVyYXRvciA9ICgpID0+IHtcbiAgICAgIGxldCBhdmFpbGFibGVFZGdlS2V5O1xuXG4gICAgICBkbyB7XG4gICAgICAgIGF2YWlsYWJsZUVkZ2VLZXkgPSBpbnN0YW5jZVByZWZpeCArIGVkZ2VJZCsrO1xuICAgICAgfSB3aGlsZSAodGhpcy5fZWRnZXMuaGFzKGF2YWlsYWJsZUVkZ2VLZXkpKTtcblxuICAgICAgcmV0dXJuIGF2YWlsYWJsZUVkZ2VLZXk7XG4gICAgfTtcblxuICAgIC8vIEluZGV4ZXNcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19hdHRyaWJ1dGVzJywge30pO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX25vZGVzJywgbmV3IE1hcCgpKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19lZGdlcycsIG5ldyBNYXAoKSk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZGlyZWN0ZWRTaXplJywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfdW5kaXJlY3RlZFNpemUnLCAwKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19kaXJlY3RlZFNlbGZMb29wQ291bnQnLCAwKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ191bmRpcmVjdGVkU2VsZkxvb3BDb3VudCcsIDApO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2VkZ2VLZXlHZW5lcmF0b3InLCBlZGdlS2V5R2VuZXJhdG9yKTtcblxuICAgIC8vIE9wdGlvbnNcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19vcHRpb25zJywgb3B0aW9ucyk7XG5cbiAgICAvLyBFbWl0dGVyIHByb3BlcnRpZXNcbiAgICBFTUlUVEVSX1BST1BTLmZvckVhY2gocHJvcCA9PiBwcml2YXRlUHJvcGVydHkodGhpcywgcHJvcCwgdGhpc1twcm9wXSkpO1xuXG4gICAgLy8tLSBQcm9wZXJ0aWVzIHJlYWRlcnNcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdvcmRlcicsICgpID0+IHRoaXMuX25vZGVzLnNpemUpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ3NpemUnLCAoKSA9PiB0aGlzLl9lZGdlcy5zaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdkaXJlY3RlZFNpemUnLCAoKSA9PiB0aGlzLl9kaXJlY3RlZFNpemUpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ3VuZGlyZWN0ZWRTaXplJywgKCkgPT4gdGhpcy5fdW5kaXJlY3RlZFNpemUpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ3NlbGZMb29wQ291bnQnLFxuICAgICAgKCkgPT4gdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50ICsgdGhpcy5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnRcbiAgICApO1xuICAgIHJlYWRPbmx5UHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ2RpcmVjdGVkU2VsZkxvb3BDb3VudCcsXG4gICAgICAoKSA9PiB0aGlzLl9kaXJlY3RlZFNlbGZMb29wQ291bnRcbiAgICApO1xuICAgIHJlYWRPbmx5UHJvcGVydHkoXG4gICAgICB0aGlzLFxuICAgICAgJ3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50JyxcbiAgICAgICgpID0+IHRoaXMuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50XG4gICAgKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdtdWx0aScsIHRoaXMuX29wdGlvbnMubXVsdGkpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ3R5cGUnLCB0aGlzLl9vcHRpb25zLnR5cGUpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ2FsbG93U2VsZkxvb3BzJywgdGhpcy5fb3B0aW9ucy5hbGxvd1NlbGZMb29wcyk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnaW1wbGVtZW50YXRpb24nLCAoKSA9PiAnZ3JhcGhvbG9neScpO1xuICB9XG5cbiAgX3Jlc2V0SW5zdGFuY2VDb3VudGVycygpIHtcbiAgICB0aGlzLl9kaXJlY3RlZFNpemUgPSAwO1xuICAgIHRoaXMuX3VuZGlyZWN0ZWRTaXplID0gMDtcbiAgICB0aGlzLl9kaXJlY3RlZFNlbGZMb29wQ291bnQgPSAwO1xuICAgIHRoaXMuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50ID0gMDtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBSZWFkXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBub2RlIGlzIGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzTm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzLmhhcygnJyArIG5vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZGlyZWN0ZWQgZWRnZSBpcyBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEFyaXR5IDE6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBhcmd1bWVudHMgYXJlIGludmFsaWQuXG4gICAqL1xuICBoYXNEaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3QgZWRnZURhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICAgIHJldHVybiAhIWVkZ2VEYXRhICYmICFlZGdlRGF0YS51bmRpcmVjdGVkO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgc291cmNlIG9yIHRoZSB0YXJnZXQgaXMgbm90IGluIHRoZSBncmFwaCB3ZSBicmVha1xuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFub2RlRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJcyB0aGVyZSBhIGRpcmVjdGVkIGVkZ2UgcG9pbnRpbmcgdG93YXJkIHRhcmdldD9cbiAgICAgIHJldHVybiBub2RlRGF0YS5vdXQuaGFzT3duUHJvcGVydHkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguaGFzRGlyZWN0ZWRFZGdlOiBpbnZhbGlkIGFyaXR5ICgke2FyZ3VtZW50cy5sZW5ndGh9LCBpbnN0ZWFkIG9mIDEgb3IgMikuIFlvdSBjYW4gZWl0aGVyIGFzayBmb3IgYW4gZWRnZSBpZCBvciBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBlZGdlIGJldHdlZW4gYSBzb3VyY2UgJiBhIHRhcmdldC5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIHVuZGlyZWN0ZWQgZWRnZSBpcyBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEFyaXR5IDE6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBhcmd1bWVudHMgYXJlIGludmFsaWQuXG4gICAqL1xuICBoYXNVbmRpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGVkZ2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3QgZWRnZURhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICAgIHJldHVybiAhIWVkZ2VEYXRhICYmIGVkZ2VEYXRhLnVuZGlyZWN0ZWQ7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICAvLyBJZiB0aGUgbm9kZSBzb3VyY2Ugb3IgdGhlIHRhcmdldCBpcyBub3QgaW4gdGhlIGdyYXBoIHdlIGJyZWFrXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIW5vZGVEYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIElzIHRoZXJlIGEgZGlyZWN0ZWQgZWRnZSBwb2ludGluZyB0b3dhcmQgdGFyZ2V0P1xuICAgICAgcmV0dXJuIG5vZGVEYXRhLnVuZGlyZWN0ZWQuaGFzT3duUHJvcGVydHkodGFyZ2V0KTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguaGFzRGlyZWN0ZWRFZGdlOiBpbnZhbGlkIGFyaXR5ICgke2FyZ3VtZW50cy5sZW5ndGh9LCBpbnN0ZWFkIG9mIDEgb3IgMikuIFlvdSBjYW4gZWl0aGVyIGFzayBmb3IgYW4gZWRnZSBpZCBvciBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBlZGdlIGJldHdlZW4gYSBzb3VyY2UgJiBhIHRhcmdldC5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICAgKi9cbiAgaGFzRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlZGdlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIHJldHVybiB0aGlzLl9lZGdlcy5oYXMoZWRnZSk7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICAvLyBJZiB0aGUgbm9kZSBzb3VyY2Ugb3IgdGhlIHRhcmdldCBpcyBub3QgaW4gdGhlIGdyYXBoIHdlIGJyZWFrXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIW5vZGVEYXRhKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIElzIHRoZXJlIGEgZGlyZWN0ZWQgZWRnZSBwb2ludGluZyB0b3dhcmQgdGFyZ2V0P1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKHR5cGVvZiBub2RlRGF0YS5vdXQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgbm9kZURhdGEub3V0Lmhhc093blByb3BlcnR5KHRhcmdldCkpIHx8XG4gICAgICAgICh0eXBlb2Ygbm9kZURhdGEudW5kaXJlY3RlZCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICBub2RlRGF0YS51bmRpcmVjdGVkLmhhc093blByb3BlcnR5KHRhcmdldCkpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5oYXNFZGdlOiBpbnZhbGlkIGFyaXR5ICgke2FyZ3VtZW50cy5sZW5ndGh9LCBpbnN0ZWFkIG9mIDEgb3IgMikuIFlvdSBjYW4gZWl0aGVyIGFzayBmb3IgYW4gZWRnZSBpZCBvciBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBlZGdlIGJldHdlZW4gYSBzb3VyY2UgJiBhIHRhcmdldC5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBlZGdlIG1hdGNoaW5nIHNvdXJjZSAmIHRhcmdldCBpbiBhIGRpcmVjdGVkIGZhc2hpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueXx1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG11bHRpLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGRpcmVjdGVkRWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5kaXJlY3RlZEVkZ2U6IHRoaXMgbWV0aG9kIGlzIGlycmVsZXZhbnQgd2l0aCBtdWx0aWdyYXBocyBzaW5jZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldC4gU2VlICMuZGlyZWN0ZWRFZGdlcyBpbnN0ZWFkLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3RhcmdldH1cIiB0YXJnZXQgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID0gKHNvdXJjZURhdGEub3V0ICYmIHNvdXJjZURhdGEub3V0W3RhcmdldF0pIHx8IHVuZGVmaW5lZDtcblxuICAgIGlmIChlZGdlRGF0YSkgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBlZGdlIG1hdGNoaW5nIHNvdXJjZSAmIHRhcmdldCBpbiBhIHVuZGlyZWN0ZWQgZmFzaGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7YW55fHVuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgdW5kaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAnZGlyZWN0ZWQnKSByZXR1cm47XG5cbiAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVuZGlyZWN0ZWRFZGdlOiB0aGlzIG1ldGhvZCBpcyBpcnJlbGV2YW50IHdpdGggbXVsdGlncmFwaHMgc2luY2UgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQuIFNlZSAjLnVuZGlyZWN0ZWRFZGdlcyBpbnN0ZWFkLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIHNvdXJjZSBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC51bmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9XG4gICAgICAoc291cmNlRGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdKSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZWRnZURhdGEpIHJldHVybiBlZGdlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZWRnZSBtYXRjaGluZyBzb3VyY2UgJiB0YXJnZXQgaW4gYSBtaXhlZCBmYXNoaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl8dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBlZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy5lZGdlcyBpbnN0ZWFkLidcbiAgICAgICk7XG5cbiAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5lZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9XG4gICAgICAoc291cmNlRGF0YS5vdXQgJiYgc291cmNlRGF0YS5vdXRbdGFyZ2V0XSkgfHxcbiAgICAgIChzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF0pIHx8XG4gICAgICB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZWRnZURhdGEpIHJldHVybiBlZGdlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgZGlyZWN0ZWQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVEaXJlY3RlZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZURpcmVjdGVkTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5laWdoYm9yIGluIG5vZGVEYXRhLmluIHx8IG5laWdoYm9yIGluIG5vZGVEYXRhLm91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBvdXQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVPdXROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVPdXROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmVpZ2hib3IgaW4gbm9kZURhdGEub3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIGluIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlSW5OZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVJbk5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS5pbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSB1bmRpcmVjdGVkIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlVW5kaXJlY3RlZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZVVuZGlyZWN0ZWROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVOZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVOZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEuaW4gfHwgbmVpZ2hib3IgaW4gbm9kZURhdGEub3V0KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEudW5kaXJlY3RlZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIGluYm91bmQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVJbmJvdW5kTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlSW5ib3VuZE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS5pbikgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBvdXRib3VuZCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZU91dGJvdW5kTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlT3V0Ym91bmROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEub3V0KSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEudW5kaXJlY3RlZCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGluRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmluRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIG91dCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIG91dERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5vdXREZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGRpcmVjdGVkIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGlyZWN0ZWREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGlyZWN0ZWREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5pbkRlZ3JlZSArIG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgdW5kaXJlY3RlZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHVuZGlyZWN0ZWREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBpbmJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbmJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbmJvdW5kRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmluYm91bmREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5pbkRlZ3JlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXRib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIG91dGJvdW5kRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm91dGJvdW5kRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEub3V0RGVncmVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGRpcmVjdGVkIGRlZ3JlZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLmluRGVncmVlICsgbm9kZURhdGEub3V0RGVncmVlO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGluIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGluRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbkRlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5pbkRlZ3JlZSAtIG5vZGVEYXRhLmRpcmVjdGVkTG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIG91dCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm91dERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS5vdXREZWdyZWUgLSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBkaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWUgLSBub2RlRGF0YS5kaXJlY3RlZExvb3BzICogMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgdW5kaXJlY3RlZCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICB1bmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC51bmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAnZGlyZWN0ZWQnKSByZXR1cm4gMDtcblxuICAgIHJldHVybiBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlIC0gbm9kZURhdGEudW5kaXJlY3RlZExvb3BzICogMjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW5ib3VuZCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluYm91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGluYm91bmREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmluYm91bmREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuICAgIGxldCBsb29wcyA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWUgLSBsb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBvdXRib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgb3V0Ym91bmREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm91dGJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcbiAgICBsZXQgbG9vcHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS51bmRpcmVjdGVkTG9vcHMgKiAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLmRpcmVjdGVkTG9vcHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZSAtIGxvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBkZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG4gICAgbGV0IGxvb3BzID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEudW5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5pbkRlZ3JlZSArIG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLmRpcmVjdGVkTG9vcHMgKiAyO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWUgLSBsb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBlZGdlJ3Mgc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7YW55fSAgICAgIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgc291cmNlKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5zb3VyY2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuc291cmNlLmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7YW55fSAgICAgIC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgdGFyZ2V0KGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC50YXJnZXQ6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEudGFyZ2V0LmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBlZGdlJ3MgZXh0cmVtaXRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FycmF5fSAgICAgIC0gVGhlIGVkZ2UncyBleHRyZW1pdGllcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBleHRyZW1pdGllcyhlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5leHRyZW1pdGllczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gW2VkZ2VEYXRhLnNvdXJjZS5rZXksIGVkZ2VEYXRhLnRhcmdldC5rZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIEdpdmVuIGEgbm9kZSAmIGFuIGVkZ2UsIHJldHVybnMgdGhlIG90aGVyIGV4dHJlbWl0eSBvZiB0aGUgZWRnZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7YW55fSAgICAgICAgLSBUaGUgcmVsYXRlZCBub2RlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaCBvciBpZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgZWRnZSAmIG5vZGUgYXJlIG5vdCByZWxhdGVkLlxuICAgKi9cbiAgb3Bwb3NpdGUobm9kZSwgZWRnZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3Bwb3NpdGU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlID0gZGF0YS5zb3VyY2Uua2V5O1xuICAgIGNvbnN0IHRhcmdldCA9IGRhdGEudGFyZ2V0LmtleTtcblxuICAgIGlmIChub2RlID09PSBzb3VyY2UpIHJldHVybiB0YXJnZXQ7XG4gICAgaWYgKG5vZGUgPT09IHRhcmdldCkgcmV0dXJuIHNvdXJjZTtcblxuICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGgub3Bwb3NpdGU6IHRoZSBcIiR7bm9kZX1cIiBub2RlIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgXCIke2VkZ2V9XCIgZWRnZSAoJHtzb3VyY2V9LCAke3RhcmdldH0pLmBcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBoYXMgdGhlIGdpdmVuIG5vZGUgYXMgZXh0cmVtaXR5LlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gICAgICAtIFRoZSByZWxhdGVkIG5vZGUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgZWl0aGVyIHRoZSBub2RlIG9yIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGhhc0V4dHJlbWl0eShlZGdlLCBub2RlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5oYXNFeHRyZW1pdHk6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuc291cmNlLmtleSA9PT0gbm9kZSB8fCBkYXRhLnRhcmdldC5rZXkgPT09IG5vZGU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGlzIHVuZGlyZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpc1VuZGlyZWN0ZWQoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmlzVW5kaXJlY3RlZDogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS51bmRpcmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyBkaXJlY3RlZC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGlzRGlyZWN0ZWQoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmlzRGlyZWN0ZWQ6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuICFkYXRhLnVuZGlyZWN0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGlzIGEgc2VsZiBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaXNTZWxmTG9vcChlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaXNTZWxmTG9vcDogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5zb3VyY2UgPT09IGRhdGEudGFyZ2V0O1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIE11dGF0aW9uXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gYWRkIGEgbm9kZSB0byB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgbm9kZSAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gW2F0dHJpYnV0ZXNdIC0gT3B0aW9uYWwgYXR0cmlidXRlcy5cbiAgICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gbm9kZSBhbHJlYWR5IGV4aXN0LlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYW4gb2JqZWN0LlxuICAgKi9cbiAgYWRkTm9kZShub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBhZGROb2RlKHRoaXMsIG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBtZXJnZSBhIG5vZGUgaW50byB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgbm9kZSAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqIEBwYXJhbSAge29iamVjdH0gW2F0dHJpYnV0ZXNdIC0gT3B0aW9uYWwgYXR0cmlidXRlcy5cbiAgICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICovXG4gIG1lcmdlTm9kZShub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKGF0dHJpYnV0ZXMgJiYgIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5tZXJnZU5vZGU6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGFuIG9iamVjdCBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICAgKTtcblxuICAgIC8vIFN0cmluZyBjb2VyY2lvblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBhbHJlYWR5IGV4aXN0cywgd2UgbWVyZ2UgdGhlIGF0dHJpYnV0ZXNcbiAgICBsZXQgZGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAoYXR0cmlidXRlcykge1xuICAgICAgICBhc3NpZ24oZGF0YS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgICAgIGtleTogbm9kZSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZSwgZmFsc2VdO1xuICAgIH1cblxuICAgIGRhdGEgPSBuZXcgdGhpcy5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gQWRkaW5nIHRoZSBub2RlIHRvIGludGVybmFsIHJlZ2lzdGVyXG4gICAgdGhpcy5fbm9kZXMuc2V0KG5vZGUsIGRhdGEpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBZGRlZCcsIHtcbiAgICAgIGtleTogbm9kZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiBbbm9kZSwgdHJ1ZV07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gYWRkIGEgbm9kZSBpZiBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ3JhcGggb3IgZWxzZSB0b1xuICAgKiB1cGRhdGUgaXRzIGF0dHJpYnV0ZXMgdXNpbmcgYSBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgICAtIFRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gW3VwZGF0ZXJdIC0gT3B0aW9uYWwgdXBkYXRlciBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAtIFRoZSBub2RlLlxuICAgKi9cbiAgdXBkYXRlTm9kZShub2RlLCB1cGRhdGVyKSB7XG4gICAgaWYgKHVwZGF0ZXIgJiYgdHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC51cGRhdGVOb2RlOiBpbnZhbGlkIHVwZGF0ZXIgZnVuY3Rpb24uIEV4cGVjdGluZyBhIGZ1bmN0aW9uIGJ1dCBnb3QgXCIke3VwZGF0ZXJ9XCJgXG4gICAgICApO1xuXG4gICAgLy8gU3RyaW5nIGNvZXJjaW9uXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIC8vIElmIHRoZSBub2RlIGFscmVhZHkgZXhpc3RzLCB3ZSB1cGRhdGUgdGhlIGF0dHJpYnV0ZXNcbiAgICBsZXQgZGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmIChkYXRhKSB7XG4gICAgICBpZiAodXBkYXRlcikge1xuICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gZGF0YS5hdHRyaWJ1dGVzO1xuICAgICAgICBkYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKG9sZEF0dHJpYnV0ZXMpO1xuXG4gICAgICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgICAgICBrZXk6IG5vZGUsXG4gICAgICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtub2RlLCBmYWxzZV07XG4gICAgfVxuXG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHVwZGF0ZXIgPyB1cGRhdGVyKHt9KSA6IHt9O1xuXG4gICAgZGF0YSA9IG5ldyB0aGlzLk5vZGVEYXRhQ2xhc3Mobm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBBZGRpbmcgdGhlIG5vZGUgdG8gaW50ZXJuYWwgcmVnaXN0ZXJcbiAgICB0aGlzLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUFkZGVkJywge1xuICAgICAga2V5OiBub2RlLFxuICAgICAgYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIFtub2RlLCB0cnVlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBkcm9wIGEgc2luZ2xlIG5vZGUgJiBhbGwgaXRzIGF0dGFjaGVkIGVkZ2VzIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIG5vZGUgLSBUaGUgbm9kZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGRyb3BOb2RlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRyb3BOb2RlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBlZGdlRGF0YTtcblxuICAgIC8vIFJlbW92aW5nIGF0dGFjaGVkIGVkZ2VzXG4gICAgLy8gTk9URTogd2UgY291bGQgYmUgZmFzdGVyIGhlcmUsIGJ1dCB0aGlzIGlzIHN1Y2ggYSBwYWluIHRvIG1haW50YWluXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIGluIG5vZGVEYXRhLm91dCkge1xuICAgICAgICBlZGdlRGF0YSA9IG5vZGVEYXRhLm91dFtuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIGluIG5vZGVEYXRhLmluKSB7XG4gICAgICAgIGVkZ2VEYXRhID0gbm9kZURhdGEuaW5bbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBmb3IgKGNvbnN0IG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHtcbiAgICAgICAgZWRnZURhdGEgPSBub2RlRGF0YS51bmRpcmVjdGVkW25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gRHJvcHBpbmcgdGhlIG5vZGUgZnJvbSB0aGUgcmVnaXN0ZXJcbiAgICB0aGlzLl9ub2Rlcy5kZWxldGUobm9kZSk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZURyb3BwZWQnLCB7XG4gICAgICBrZXk6IG5vZGUsXG4gICAgICBhdHRyaWJ1dGVzOiBub2RlRGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZHJvcCBhIHNpbmdsZSBlZGdlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVkZ2UgLSBUaGUgZWRnZS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGRyb3BFZGdlKGVkZ2UpIHtcbiAgICBsZXQgZWRnZURhdGE7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBhcmd1bWVudHNbMV07XG5cbiAgICAgIGVkZ2VEYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0aGlzLnR5cGUpO1xuXG4gICAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC5kcm9wRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgLT4gXCIke3RhcmdldH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICAgIGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC5kcm9wRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgZGlyZWN0ZWQgZWRnZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICB0YXJnZXQgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIGRyb3BEaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZHJvcERpcmVjdGVkRWRnZTogaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byB0cnkgYW5kIGRyb3AgYSBkaXJlY3RlZCBlZGdlIGJ5IGtleS4gV2hhdCBpZiB0aGUgZWRnZSB3aXRoIHRoaXMga2V5IGlzIHVuZGlyZWN0ZWQ/IFVzZSAjLmRyb3BFZGdlIGZvciB0aGlzIHB1cnBvc2UgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZHJvcERpcmVjdGVkRWRnZTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGRyb3BwaW5nIGFuIGVkZ2UgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IHRvIGRlbGV0ZSBhcyB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBvbmVzLidcbiAgICAgICk7XG5cbiAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCAnZGlyZWN0ZWQnKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZHJvcERpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgYSBcIiR7c291cmNlfVwiIC0+IFwiJHt0YXJnZXR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZHJvcCBhIHNpbmdsZSB1bmRpcmVjdGVkIGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wVW5kaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZHJvcFVuZGlyZWN0ZWRFZGdlOiBpdCBkb2VzIG5vdCBtYWtlIHNlbnNlIHRvIGRyb3AgYSBkaXJlY3RlZCBlZGdlIGJ5IGtleS4gV2hhdCBpZiB0aGUgZWRnZSB3aXRoIHRoaXMga2V5IGlzIHVuZGlyZWN0ZWQ/IFVzZSAjLmRyb3BFZGdlIGZvciB0aGlzIHB1cnBvc2UgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZHJvcFVuZGlyZWN0ZWRFZGdlOiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gZHJvcHBpbmcgYW4gZWRnZSBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgdG8gZGVsZXRlIGFzIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIG9uZXMuJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGVkZ2VEYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCAndW5kaXJlY3RlZCcpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kcm9wVW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIGEgXCIke3NvdXJjZX1cIiAtPiBcIiR7dGFyZ2V0fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIHJlbW92ZSBldmVyeSBlZGdlICYgZXZlcnkgbm9kZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICBjbGVhcigpIHtcbiAgICAvLyBDbGVhcmluZyBlZGdlc1xuICAgIHRoaXMuX2VkZ2VzLmNsZWFyKCk7XG5cbiAgICAvLyBDbGVhcmluZyBub2Rlc1xuICAgIHRoaXMuX25vZGVzLmNsZWFyKCk7XG5cbiAgICAvLyBSZXNldCBjb3VudGVyc1xuICAgIHRoaXMuX3Jlc2V0SW5zdGFuY2VDb3VudGVycygpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2NsZWFyZWQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byByZW1vdmUgZXZlcnkgZWRnZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICBjbGVhckVkZ2VzKCkge1xuICAgIC8vIENsZWFyaW5nIHN0cnVjdHVyZSBpbmRleFxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcDtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBzdGVwLnZhbHVlLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYXJpbmcgZWRnZXNcbiAgICB0aGlzLl9lZGdlcy5jbGVhcigpO1xuXG4gICAgLy8gUmVzZXQgY291bnRlcnNcbiAgICB0aGlzLl9yZXNldEluc3RhbmNlQ291bnRlcnMoKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlc0NsZWFyZWQnKTtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBBdHRyaWJ1dGVzLXJlbGF0ZWQgbWV0aG9kc1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGRlc2lyZWQgZ3JhcGgncyBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBncmFwaCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICovXG4gIGdldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBncmFwaCBoYXMgdGhlIGRlc2lyZWQgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzQXR0cmlidXRlKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2Qgc2V0dGluZyBhIHZhbHVlIGZvciB0aGUgZGVzaXJlZCBncmFwaCdzIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHZhbHVlIC0gVmFsdWUgZm9yIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSB7XG4gICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzaW5nIGEgZnVuY3Rpb24gdG8gdXBkYXRlIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlJ3MgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICBuYW1lICAgIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIEZ1bmN0aW9uIHVzZSB0byB1cGRhdGUgdGhlIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIHVwZGF0ZUF0dHJpYnV0ZShuYW1lLCB1cGRhdGVyKSB7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlQXR0cmlidXRlOiB1cGRhdGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLidcbiAgICAgICk7XG5cbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdXBkYXRlcih2YWx1ZSk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmVtb3ZpbmcgdGhlIGRlc2lyZWQgZ3JhcGgncyBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHtcbiAgICBkZWxldGUgdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXBsYWNpbmcgdGhlIGdyYXBoJ3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBhdHRyaWJ1dGVzIC0gTmV3IGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGdpdmVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5cbiAgICovXG4gIHJlcGxhY2VBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5yZXBsYWNlQXR0cmlidXRlczogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LidcbiAgICAgICk7XG5cbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBtZXJnaW5nIHRoZSBncmFwaCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgdG8gbWVyZ2UuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGdpdmVuIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5cbiAgICovXG4gIG1lcmdlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgubWVyZ2VBdHRyaWJ1dGVzOiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuJ1xuICAgICAgKTtcblxuICAgIGFzc2lnbih0aGlzLl9hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVwZGF0aW5nIHRoZSBncmFwaCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gRnVuY3Rpb24gdXNlZCB0byB1cGRhdGUgdGhlIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGdpdmVuIHVwZGF0ZXIgaXMgbm90IGEgZnVuY3Rpb24uXG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGVzKHVwZGF0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVBdHRyaWJ1dGVzOiBwcm92aWRlZCB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLidcbiAgICAgICk7XG5cbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gdXBkYXRlcih0aGlzLl9hdHRyaWJ1dGVzKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gdXBkYXRlIGVhY2ggbm9kZSdzIGF0dHJpYnV0ZXMgdXNpbmcgdGhlIGdpdmVuIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSAgdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24gdG8gdXNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgW2hpbnRzXSAtIE9wdGlvbmFsIGhpbnRzLlxuICAgKi9cbiAgdXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzKHVwZGF0ZXIsIGhpbnRzKSB7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzOiBleHBlY3RpbmcgYW4gdXBkYXRlciBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgaWYgKGhpbnRzICYmICF2YWxpZGF0ZUhpbnRzKGhpbnRzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlczogaW52YWxpZCBoaW50cy4gRXhwZWN0aW5nIGFuIG9iamVjdCBoYXZpbmcgdGhlIGZvbGxvd2luZyBzaGFwZToge2F0dHJpYnV0ZXM/OiBbc3RyaW5nXX0nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICBub2RlRGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGhpbnRzOiBoaW50cyA/IGhpbnRzIDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIHVwZGF0ZSBlYWNoIGVkZ2UncyBhdHRyaWJ1dGVzIHVzaW5nIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgIFtoaW50c10gLSBPcHRpb25hbCBoaW50cy5cbiAgICovXG4gIHVwZGF0ZUVhY2hFZGdlQXR0cmlidXRlcyh1cGRhdGVyLCBoaW50cykge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUVhY2hFZGdlQXR0cmlidXRlczogZXhwZWN0aW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24uJ1xuICAgICAgKTtcblxuICAgIGlmIChoaW50cyAmJiAhdmFsaWRhdGVIaW50cyhoaW50cykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXM6IGludmFsaWQgaGludHMuIEV4cGVjdGluZyBhbiBvYmplY3QgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2hhcGU6IHthdHRyaWJ1dGVzPzogW3N0cmluZ119J1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fZWRnZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgZWRnZURhdGEsIHNvdXJjZURhdGEsIHRhcmdldERhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgZWRnZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICAgIHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKFxuICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgICB0YXJnZXREYXRhLmtleSxcbiAgICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICB0YXJnZXREYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgaGludHM6IGhpbnRzID8gaGludHMgOiBudWxsXG4gICAgfSk7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogSXRlcmF0aW9uLXJlbGF0ZWQgbWV0aG9kc1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyBhZGphY2VuY3kgdXNpbmcgdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKi9cbiAgZm9yRWFjaEFkamFjZW5jeUVudHJ5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hBZGphY2VuY3lFbnRyeTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIGZhbHNlLCBmYWxzZSwgdGhpcywgY2FsbGJhY2spO1xuICB9XG4gIGZvckVhY2hBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgZm9yRWFjaEFkamFjZW5jeShmYWxzZSwgZmFsc2UsIHRydWUsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgYXNzeW1ldHJpYyBhZGphY2VuY3kgdXNpbmcgdGhlIGdpdmVuIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKi9cbiAgZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQXNzeW1ldHJpY0FkamFjZW5jeUVudHJ5OiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgZm9yRWFjaEFkamFjZW5jeShmYWxzZSwgdHJ1ZSwgZmFsc2UsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuICBmb3JFYWNoQXNzeW1ldHJpY0FkamFjZW5jeUVudHJ5V2l0aE9ycGhhbnMoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgZm9yRWFjaEFkamFjZW5jeShmYWxzZSwgdHJ1ZSwgdHJ1ZSwgdGhpcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGxpc3Qgb2YgdGhlIGdyYXBoJ3Mgbm9kZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fSAtIFRoZSBub2Rlcy5cbiAgICovXG4gIG5vZGVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuX25vZGVzLmtleXMoKSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIG5vZGVzIHVzaW5nIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMsIGluZGV4KS5cbiAgICovXG4gIGZvckVhY2hOb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICBjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgaXRlcmF0aW5nIGF0dGVtcHRpbmcgdG8gZmluZCBhIG5vZGUgbWF0Y2hpbmcgdGhlIGdpdmVuIHByZWRpY2F0ZVxuICAgKiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgZmluZE5vZGUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZmluZE5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcykpIHJldHVybiBub2RlRGF0YS5rZXk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBtYXBwaW5nIG5vZGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBtYXBOb2RlcyhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5tYXBOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheSh0aGlzLm9yZGVyKTtcbiAgICBsZXQgaSA9IDA7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgcmVzdWx0W2krK10gPSBjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHNvbWUgbm9kZSB2ZXJpZnkgdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgc29tZU5vZGUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguc29tZU5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcykpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgYWxsIG5vZGUgdmVyaWZ5IHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIGV2ZXJ5Tm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5ldmVyeU5vZGU6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKCFjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGZpbHRlcmluZyBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgZmlsdGVyTm9kZXMoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZmlsdGVyTm9kZXM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKSlcbiAgICAgICAgcmVzdWx0LnB1c2gobm9kZURhdGEua2V5KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZWR1Y2luZyBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChhY2N1bXVsYXRvciwga2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIHJlZHVjZU5vZGVzKGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgucmVkdWNlTm9kZXM6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5yZWR1Y2VOb2RlczogbWlzc2luZyBpbml0aWFsIHZhbHVlLiBZb3UgbXVzdCBwcm92aWRlIGl0IGJlY2F1c2UgdGhlIGNhbGxiYWNrIHRha2VzIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQgYW5kIHdlIGNhbm5vdCBpbmZlciB0aGUgaW5pdGlhbCB2YWx1ZSBmcm9tIHRoZSBmaXJzdCBpdGVyYXRpb24sIGFzIHlvdSBjb3VsZCB3aXRoIGEgc2ltcGxlIGFycmF5LidcbiAgICAgICk7XG5cbiAgICBsZXQgYWNjdW11bGF0b3IgPSBpbml0aWFsVmFsdWU7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIG5vZGVEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIGFjY3VtdWxhdG9yID0gY2FsbGJhY2soYWNjdW11bGF0b3IsIG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgYW4gaXRlcmF0b3Igb3ZlciB0aGUgZ3JhcGgncyBub2RlIGVudHJpZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICAgKi9cbiAgbm9kZUVudHJpZXMoKSB7XG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIHJldHVybiB7XG4gICAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9LFxuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkgcmV0dXJuIHN0ZXA7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHZhbHVlOiB7bm9kZTogZGF0YS5rZXksIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc30sXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFNlcmlhbGl6YXRpb25cbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBleHBvcnQgdGhlIHdob2xlIGdyYXBoLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHNlcmlhbGl6ZWQgZ3JhcGguXG4gICAqL1xuICBleHBvcnQoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBuZXcgQXJyYXkodGhpcy5fbm9kZXMuc2l6ZSk7XG5cbiAgICBsZXQgaSA9IDA7XG5cbiAgICB0aGlzLl9ub2Rlcy5mb3JFYWNoKChkYXRhLCBrZXkpID0+IHtcbiAgICAgIG5vZGVzW2krK10gPSBzZXJpYWxpemVOb2RlKGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBlZGdlcyA9IG5ldyBBcnJheSh0aGlzLl9lZGdlcy5zaXplKTtcblxuICAgIGkgPSAwO1xuXG4gICAgdGhpcy5fZWRnZXMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBlZGdlc1tpKytdID0gc2VyaWFsaXplRWRnZSh0aGlzLnR5cGUsIGtleSwgZGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgb3B0aW9uczoge1xuICAgICAgICB0eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgIG11bHRpOiB0aGlzLm11bHRpLFxuICAgICAgICBhbGxvd1NlbGZMb29wczogdGhpcy5hbGxvd1NlbGZMb29wc1xuICAgICAgfSxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuZ2V0QXR0cmlidXRlcygpLFxuICAgICAgbm9kZXMsXG4gICAgICBlZGdlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gaW1wb3J0IGEgc2VyaWFsaXplZCBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fEdyYXBofSBkYXRhICAtIFRoZSBzZXJpYWxpemVkIGdyYXBoLlxuICAgKiBAcGFyYW0gIHtib29sZWFufSAgICAgIG1lcmdlIC0gV2hldGhlciB0byBtZXJnZSBkYXRhLlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKi9cbiAgaW1wb3J0KGRhdGEsIG1lcmdlID0gZmFsc2UpIHtcbiAgICAvLyBJbXBvcnRpbmcgYSBHcmFwaCBpbnN0YW5jZSBkaXJlY3RseVxuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgR3JhcGgpIHtcbiAgICAgIC8vIE5vZGVzXG4gICAgICBkYXRhLmZvckVhY2hOb2RlKChuLCBhKSA9PiB7XG4gICAgICAgIGlmIChtZXJnZSkgdGhpcy5tZXJnZU5vZGUobiwgYSk7XG4gICAgICAgIGVsc2UgdGhpcy5hZGROb2RlKG4sIGEpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIEVkZ2VzXG4gICAgICBkYXRhLmZvckVhY2hFZGdlKChlLCBhLCBzLCB0LCBfc2EsIF90YSwgdSkgPT4ge1xuICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICBpZiAodSkgdGhpcy5tZXJnZVVuZGlyZWN0ZWRFZGdlV2l0aEtleShlLCBzLCB0LCBhKTtcbiAgICAgICAgICBlbHNlIHRoaXMubWVyZ2VEaXJlY3RlZEVkZ2VXaXRoS2V5KGUsIHMsIHQsIGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh1KSB0aGlzLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleShlLCBzLCB0LCBhKTtcbiAgICAgICAgICBlbHNlIHRoaXMuYWRkRGlyZWN0ZWRFZGdlV2l0aEtleShlLCBzLCB0LCBhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEltcG9ydGluZyBhIHNlcmlhbGl6ZWQgZ3JhcGhcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YSkpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXJndW1lbnQuIEV4cGVjdGluZyBhIHNlcmlhbGl6ZWQgZ3JhcGggb3IsIGFsdGVybmF0aXZlbHksIGEgR3JhcGggaW5zdGFuY2UuJ1xuICAgICAgKTtcblxuICAgIGlmIChkYXRhLmF0dHJpYnV0ZXMpIHtcbiAgICAgIGlmICghaXNQbGFpbk9iamVjdChkYXRhLmF0dHJpYnV0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYSBwbGFpbiBvYmplY3QuJ1xuICAgICAgICApO1xuXG4gICAgICBpZiAobWVyZ2UpIHRoaXMubWVyZ2VBdHRyaWJ1dGVzKGRhdGEuYXR0cmlidXRlcyk7XG4gICAgICBlbHNlIHRoaXMucmVwbGFjZUF0dHJpYnV0ZXMoZGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICBsZXQgaSwgbCwgbGlzdCwgbm9kZSwgZWRnZTtcblxuICAgIGlmIChkYXRhLm5vZGVzKSB7XG4gICAgICBsaXN0ID0gZGF0YS5ub2RlcztcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBub2Rlcy4gRXhwZWN0aW5nIGFuIGFycmF5LidcbiAgICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBsaXN0W2ldO1xuXG4gICAgICAgIC8vIFZhbGlkYXRpbmdcbiAgICAgICAgdmFsaWRhdGVTZXJpYWxpemVkTm9kZShub2RlKTtcblxuICAgICAgICAvLyBBZGRpbmcgdGhlIG5vZGVcbiAgICAgICAgY29uc3Qge2tleSwgYXR0cmlidXRlc30gPSBub2RlO1xuXG4gICAgICAgIGlmIChtZXJnZSkgdGhpcy5tZXJnZU5vZGUoa2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgZWxzZSB0aGlzLmFkZE5vZGUoa2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5lZGdlcykge1xuICAgICAgbGV0IHVuZGlyZWN0ZWRCeURlZmF1bHQgPSBmYWxzZTtcblxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICAgIHVuZGlyZWN0ZWRCeURlZmF1bHQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBsaXN0ID0gZGF0YS5lZGdlcztcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKVxuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBlZGdlcy4gRXhwZWN0aW5nIGFuIGFycmF5LidcbiAgICAgICAgKTtcblxuICAgICAgZm9yIChpID0gMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGVkZ2UgPSBsaXN0W2ldO1xuXG4gICAgICAgIC8vIFZhbGlkYXRpbmdcbiAgICAgICAgdmFsaWRhdGVTZXJpYWxpemVkRWRnZShlZGdlKTtcblxuICAgICAgICAvLyBBZGRpbmcgdGhlIGVkZ2VcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkID0gdW5kaXJlY3RlZEJ5RGVmYXVsdFxuICAgICAgICB9ID0gZWRnZTtcblxuICAgICAgICBsZXQgbWV0aG9kO1xuXG4gICAgICAgIGlmICgna2V5JyBpbiBlZGdlKSB7XG4gICAgICAgICAgbWV0aG9kID0gbWVyZ2VcbiAgICAgICAgICAgID8gdW5kaXJlY3RlZFxuICAgICAgICAgICAgICA/IHRoaXMubWVyZ2VVbmRpcmVjdGVkRWRnZVdpdGhLZXlcbiAgICAgICAgICAgICAgOiB0aGlzLm1lcmdlRGlyZWN0ZWRFZGdlV2l0aEtleVxuICAgICAgICAgICAgOiB1bmRpcmVjdGVkXG4gICAgICAgICAgICA/IHRoaXMuYWRkVW5kaXJlY3RlZEVkZ2VXaXRoS2V5XG4gICAgICAgICAgICA6IHRoaXMuYWRkRGlyZWN0ZWRFZGdlV2l0aEtleTtcblxuICAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIGVkZ2Uua2V5LCBzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0aG9kID0gbWVyZ2VcbiAgICAgICAgICAgID8gdW5kaXJlY3RlZFxuICAgICAgICAgICAgICA/IHRoaXMubWVyZ2VVbmRpcmVjdGVkRWRnZVxuICAgICAgICAgICAgICA6IHRoaXMubWVyZ2VEaXJlY3RlZEVkZ2VcbiAgICAgICAgICAgIDogdW5kaXJlY3RlZFxuICAgICAgICAgICAgPyB0aGlzLmFkZFVuZGlyZWN0ZWRFZGdlXG4gICAgICAgICAgICA6IHRoaXMuYWRkRGlyZWN0ZWRFZGdlO1xuXG4gICAgICAgICAgbWV0aG9kLmNhbGwodGhpcywgc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogVXRpbHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGEgbnVsbCBjb3B5IG9mIHRoZSBncmFwaCwgaS5lLiBhIGdyYXBoIHdpdGhvdXQgbm9kZXNcbiAgICogJiBlZGdlcyBidXQgd2l0aCB0aGUgZXhhY3Qgc2FtZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIG1lcmdlIHdpdGggdGhlIGN1cnJlbnQgb25lcy5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gVGhlIG51bGwgY29weS5cbiAgICovXG4gIG51bGxDb3B5KG9wdGlvbnMpIHtcbiAgICBjb25zdCBncmFwaCA9IG5ldyBHcmFwaChhc3NpZ24oe30sIHRoaXMuX29wdGlvbnMsIG9wdGlvbnMpKTtcbiAgICBncmFwaC5yZXBsYWNlQXR0cmlidXRlcyhhc3NpZ24oe30sIHRoaXMuZ2V0QXR0cmlidXRlcygpKSk7XG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgYW4gZW1wdHkgY29weSBvZiB0aGUgZ3JhcGgsIGkuZS4gYSBncmFwaCB3aXRob3V0IGVkZ2VzIGJ1dFxuICAgKiB3aXRoIHRoZSBleGFjdCBzYW1lIG9wdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gbWVyZ2Ugd2l0aCB0aGUgY3VycmVudCBvbmVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgLSBUaGUgZW1wdHkgY29weS5cbiAgICovXG4gIGVtcHR5Q29weShvcHRpb25zKSB7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLm51bGxDb3B5KG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaCgobm9kZURhdGEsIGtleSkgPT4ge1xuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IGFzc2lnbih7fSwgbm9kZURhdGEuYXR0cmlidXRlcyk7XG5cbiAgICAgIC8vIE5PVEU6IG5vIG5lZWQgdG8gZW1pdCBldmVudHMgc2luY2UgdXNlciBjYW5ub3QgYWNjZXNzIHRoZSBpbnN0YW5jZSB5ZXRcbiAgICAgIG5vZGVEYXRhID0gbmV3IGdyYXBoLk5vZGVEYXRhQ2xhc3Moa2V5LCBhdHRyaWJ1dGVzKTtcbiAgICAgIGdyYXBoLl9ub2Rlcy5zZXQoa2V5LCBub2RlRGF0YSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBhbiBleGFjdCBjb3B5IG9mIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gVXBncmFkZSBvcHRpb25zLlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgLSBUaGUgY29weS5cbiAgICovXG4gIGNvcHkob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICAgIG9wdGlvbnMudHlwZSAhPT0gdGhpcy50eXBlICYmXG4gICAgICBvcHRpb25zLnR5cGUgIT09ICdtaXhlZCdcbiAgICApXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguY29weTogY2Fubm90IGNyZWF0ZSBhbiBpbmNvbXBhdGlibGUgY29weSBmcm9tIFwiJHt0aGlzLnR5cGV9XCIgdHlwZSB0byBcIiR7b3B0aW9ucy50eXBlfVwiIGJlY2F1c2UgdGhpcyB3b3VsZCBtZWFuIGxvc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMubXVsdGkgPT09ICdib29sZWFuJyAmJlxuICAgICAgb3B0aW9ucy5tdWx0aSAhPT0gdGhpcy5tdWx0aSAmJlxuICAgICAgb3B0aW9ucy5tdWx0aSAhPT0gdHJ1ZVxuICAgIClcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5jb3B5OiBjYW5ub3QgY3JlYXRlIGFuIGluY29tcGF0aWJsZSBjb3B5IGJ5IGRvd25ncmFkaW5nIGEgbXVsdGkgZ3JhcGggdG8gYSBzaW1wbGUgb25lIGJlY2F1c2UgdGhpcyB3b3VsZCBtZWFuIGxvc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBncmFwaC4nXG4gICAgICApO1xuXG4gICAgaWYgKFxuICAgICAgdHlwZW9mIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgPT09ICdib29sZWFuJyAmJlxuICAgICAgb3B0aW9ucy5hbGxvd1NlbGZMb29wcyAhPT0gdGhpcy5hbGxvd1NlbGZMb29wcyAmJlxuICAgICAgb3B0aW9ucy5hbGxvd1NlbGZMb29wcyAhPT0gdHJ1ZVxuICAgIClcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5jb3B5OiBjYW5ub3QgY3JlYXRlIGFuIGluY29tcGF0aWJsZSBjb3B5IGZyb20gYSBncmFwaCBhbGxvd2luZyBzZWxmIGxvb3BzIHRvIG9uZSB0aGF0IGRvZXMgbm90IGJlY2F1c2UgdGhpcyB3b3VsZCBtZWFuIGxvc2luZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBncmFwaC4nXG4gICAgICApO1xuXG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLmVtcHR5Q29weShvcHRpb25zKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fZWRnZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgZWRnZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgZWRnZURhdGEgPSBzdGVwLnZhbHVlO1xuXG4gICAgICAvLyBOT1RFOiBubyBuZWVkIHRvIGVtaXQgZXZlbnRzIHNpbmNlIHVzZXIgY2Fubm90IGFjY2VzcyB0aGUgaW5zdGFuY2UgeWV0XG4gICAgICBhZGRFZGdlKFxuICAgICAgICBncmFwaCxcbiAgICAgICAgJ2NvcHknLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZCxcbiAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgICBhc3NpZ24oe30sIGVkZ2VEYXRhLmF0dHJpYnV0ZXMpXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBLbm93biBtZXRob2RzXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgYnkgSmF2YVNjcmlwdCB0byBwZXJmb3JtIEpTT04gc2VyaWFsaXphdGlvbi5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBzZXJpYWxpemVkIGdyYXBoLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB0aGlzLmV4cG9ydCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgW29iamVjdCBHcmFwaF0uXG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1tvYmplY3QgR3JhcGhdJztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCBpbnRlcm5hbGx5IGJ5IG5vZGUncyBjb25zb2xlIHRvIGRpc3BsYXkgYSBjdXN0b20gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gRm9ybWF0dGVkIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbnNwZWN0KCkge1xuICAgIGNvbnN0IG5vZGVzID0ge307XG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBub2Rlc1trZXldID0gZGF0YS5hdHRyaWJ1dGVzO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZWRnZXMgPSB7fSxcbiAgICAgIG11bHRpSW5kZXggPSB7fTtcblxuICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgY29uc3QgZGlyZWN0aW9uID0gZGF0YS51bmRpcmVjdGVkID8gJy0tJyA6ICctPic7XG5cbiAgICAgIGxldCBsYWJlbCA9ICcnO1xuXG4gICAgICBsZXQgc291cmNlID0gZGF0YS5zb3VyY2Uua2V5O1xuICAgICAgbGV0IHRhcmdldCA9IGRhdGEudGFyZ2V0LmtleTtcbiAgICAgIGxldCB0bXA7XG5cbiAgICAgIGlmIChkYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlID4gdGFyZ2V0KSB7XG4gICAgICAgIHRtcCA9IHNvdXJjZTtcbiAgICAgICAgc291cmNlID0gdGFyZ2V0O1xuICAgICAgICB0YXJnZXQgPSB0bXA7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRlc2MgPSBgKCR7c291cmNlfSkke2RpcmVjdGlvbn0oJHt0YXJnZXR9KWA7XG5cbiAgICAgIGlmICgha2V5LnN0YXJ0c1dpdGgoJ2dlaWRfJykpIHtcbiAgICAgICAgbGFiZWwgKz0gYFske2tleX1dOiBgO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbXVsdGlJbmRleFtkZXNjXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBtdWx0aUluZGV4W2Rlc2NdID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aUluZGV4W2Rlc2NdKys7XG4gICAgICAgIH1cblxuICAgICAgICBsYWJlbCArPSBgJHttdWx0aUluZGV4W2Rlc2NdfS4gYDtcbiAgICAgIH1cblxuICAgICAgbGFiZWwgKz0gZGVzYztcblxuICAgICAgZWRnZXNbbGFiZWxdID0gZGF0YS5hdHRyaWJ1dGVzO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZHVtbXkgPSB7fTtcblxuICAgIGZvciAoY29uc3QgayBpbiB0aGlzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuaGFzT3duUHJvcGVydHkoaykgJiZcbiAgICAgICAgIUVNSVRURVJfUFJPUFMuaGFzKGspICYmXG4gICAgICAgIHR5cGVvZiB0aGlzW2tdICE9PSAnZnVuY3Rpb24nICYmXG4gICAgICAgIHR5cGVvZiBrICE9PSAnc3ltYm9sJ1xuICAgICAgKVxuICAgICAgICBkdW1teVtrXSA9IHRoaXNba107XG4gICAgfVxuXG4gICAgZHVtbXkuYXR0cmlidXRlcyA9IHRoaXMuX2F0dHJpYnV0ZXM7XG4gICAgZHVtbXkubm9kZXMgPSBub2RlcztcbiAgICBkdW1teS5lZGdlcyA9IGVkZ2VzO1xuXG4gICAgcHJpdmF0ZVByb3BlcnR5KGR1bW15LCAnY29uc3RydWN0b3InLCB0aGlzLmNvbnN0cnVjdG9yKTtcblxuICAgIHJldHVybiBkdW1teTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGFjaGluZyBtZXRob2RzIHRvIHRoZSBwcm90b3R5cGUuXG4gKlxuICogSGVyZSwgd2UgYXJlIGF0dGFjaGluZyBhIHdpZGUgdmFyaWV0eSBvZiBtZXRob2RzIHRvIHRoZSBHcmFwaCBjbGFzcydcbiAqIHByb3RvdHlwZSB3aGVuIHRob3NlIGFyZSB2ZXJ5IG51bWVyb3VzIGFuZCB3aGVuIHRoZWlyIGNyZWF0aW9uIGlzXG4gKiBhYnN0cmFjdGVkLlxuICovXG5cbi8qKlxuICogQXR0YWNoaW5nIGN1c3RvbSBpbnNwZWN0IG1ldGhvZCBmb3Igbm9kZSA+PSAxMC5cbiAqL1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKVxuICBHcmFwaC5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPVxuICAgIEdyYXBoLnByb3RvdHlwZS5pbnNwZWN0O1xuXG4vKipcbiAqIFJlbGF0ZWQgdG8gZWRnZSBhZGRpdGlvbi5cbiAqL1xuRURHRV9BRERfTUVUSE9EUy5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gIFsnYWRkJywgJ21lcmdlJywgJ3VwZGF0ZSddLmZvckVhY2godmVyYiA9PiB7XG4gICAgY29uc3QgbmFtZSA9IG1ldGhvZC5uYW1lKHZlcmIpO1xuICAgIGNvbnN0IGZuID0gdmVyYiA9PT0gJ2FkZCcgPyBhZGRFZGdlIDogbWVyZ2VFZGdlO1xuXG4gICAgaWYgKG1ldGhvZC5nZW5lcmF0ZUtleSkge1xuICAgICAgR3JhcGgucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAobWV0aG9kLnR5cGUgfHwgdGhpcy50eXBlKSA9PT0gJ3VuZGlyZWN0ZWQnLFxuICAgICAgICAgIG51bGwsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIHZlcmIgPT09ICd1cGRhdGUnXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBHcmFwaC5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAoZWRnZSwgc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIGZuKFxuICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAobWV0aG9kLnR5cGUgfHwgdGhpcy50eXBlKSA9PT0gJ3VuZGlyZWN0ZWQnLFxuICAgICAgICAgIGVkZ2UsXG4gICAgICAgICAgc291cmNlLFxuICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICBhdHRyaWJ1dGVzLFxuICAgICAgICAgIHZlcmIgPT09ICd1cGRhdGUnXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59KTtcblxuLyoqXG4gKiBBdHRyaWJ1dGVzLXJlbGF0ZWQuXG4gKi9cbmF0dGFjaE5vZGVBdHRyaWJ1dGVzTWV0aG9kcyhHcmFwaCk7XG5hdHRhY2hFZGdlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpO1xuXG4vKipcbiAqIEVkZ2UgaXRlcmF0aW9uLXJlbGF0ZWQuXG4gKi9cbmF0dGFjaEVkZ2VJdGVyYXRpb25NZXRob2RzKEdyYXBoKTtcblxuLyoqXG4gKiBOZWlnaGJvciBpdGVyYXRpb24tcmVsYXRlZC5cbiAqL1xuYXR0YWNoTmVpZ2hib3JJdGVyYXRpb25NZXRob2RzKEdyYXBoKTtcblxuLyoqXG4gKiBHcmFwaG9sb2d5IEhlbHBlciBDbGFzc2VzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEJ1aWxkaW5nIHNvbWUgaGlnaGVyLW9yZGVyIGNsYXNzZXMgaW5zdGFudGlhdGluZyB0aGUgZ3JhcGggd2l0aFxuICogcHJlZGVmaW5pdGUgb3B0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEFsdGVybmF0aXZlIGNvbnN0cnVjdG9ycy5cbiAqL1xuY2xhc3MgRGlyZWN0ZWRHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7dHlwZTogJ2RpcmVjdGVkJ30sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBtdWx0aSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBpZiAoZmluYWxPcHRpb25zLnR5cGUgIT09ICdkaXJlY3RlZCcpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicgK1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy50eXBlICtcbiAgICAgICAgICAnXCIgdHlwZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBzdXBlcihmaW5hbE9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBVbmRpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICd1bmRpcmVjdGVkJ30sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdVbmRpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIG11bHRpIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicgK1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy50eXBlICtcbiAgICAgICAgICAnXCIgdHlwZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBzdXBlcihmaW5hbE9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBNdWx0aUdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHttdWx0aTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gdHJ1ZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IGluZGljYXRpb24gdGhhdCB0aGUgZ3JhcGggc2hvdWxkIGJlIHNpbXBsZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBzdXBlcihmaW5hbE9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBNdWx0aURpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICdkaXJlY3RlZCcsIG11bHRpOiB0cnVlfSwgb3B0aW9ucyk7XG5cbiAgICBpZiAoJ211bHRpJyBpbiBmaW5hbE9wdGlvbnMgJiYgZmluYWxPcHRpb25zLm11bHRpICE9PSB0cnVlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBzaW1wbGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgaWYgKGZpbmFsT3B0aW9ucy50eXBlICE9PSAnZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlEaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBcIicgK1xuICAgICAgICAgIGZpbmFsT3B0aW9ucy50eXBlICtcbiAgICAgICAgICAnXCIgdHlwZSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBzdXBlcihmaW5hbE9wdGlvbnMpO1xuICB9XG59XG5jbGFzcyBNdWx0aVVuZGlyZWN0ZWRHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7dHlwZTogJ3VuZGlyZWN0ZWQnLCBtdWx0aTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gdHJ1ZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBzaW1wbGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgaWYgKGZpbmFsT3B0aW9ucy50eXBlICE9PSAndW5kaXJlY3RlZCcpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aVVuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGFjaGluZyBzdGF0aWMgIy5mcm9tIG1ldGhvZCB0byBlYWNoIG9mIHRoZSBjb25zdHJ1Y3RvcnMuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaFN0YXRpY0Zyb21NZXRob2QoQ2xhc3MpIHtcbiAgLyoqXG4gICAqIEJ1aWxkcyBhIGdyYXBoIGZyb20gc2VyaWFsaXplZCBkYXRhIG9yIGFub3RoZXIgZ3JhcGgncyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gIHtHcmFwaHxTZXJpYWxpemVkR3JhcGh9IGRhdGEgICAgICAtIEh5ZHJhdGF0aW9uIGRhdGEuXG4gICAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgICAgICAgW29wdGlvbnNdIC0gT3B0aW9ucy5cbiAgICogQHJldHVybiB7Q2xhc3N9XG4gICAqL1xuICBDbGFzcy5mcm9tID0gZnVuY3Rpb24gKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAvLyBNZXJnaW5nIGdpdmVuIG9wdGlvbnMgd2l0aCBzZXJpYWxpemVkIG9uZXNcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe30sIGRhdGEub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBDbGFzcyhmaW5hbE9wdGlvbnMpO1xuICAgIGluc3RhbmNlLmltcG9ydChkYXRhKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcbn1cblxuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKERpcmVjdGVkR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChVbmRpcmVjdGVkR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChNdWx0aUdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoTXVsdGlEaXJlY3RlZEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoTXVsdGlVbmRpcmVjdGVkR3JhcGgpO1xuXG5HcmFwaC5HcmFwaCA9IEdyYXBoO1xuR3JhcGguRGlyZWN0ZWRHcmFwaCA9IERpcmVjdGVkR3JhcGg7XG5HcmFwaC5VbmRpcmVjdGVkR3JhcGggPSBVbmRpcmVjdGVkR3JhcGg7XG5HcmFwaC5NdWx0aUdyYXBoID0gTXVsdGlHcmFwaDtcbkdyYXBoLk11bHRpRGlyZWN0ZWRHcmFwaCA9IE11bHRpRGlyZWN0ZWRHcmFwaDtcbkdyYXBoLk11bHRpVW5kaXJlY3RlZEdyYXBoID0gTXVsdGlVbmRpcmVjdGVkR3JhcGg7XG5cbkdyYXBoLkludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yID0gSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3I7XG5HcmFwaC5Ob3RGb3VuZEdyYXBoRXJyb3IgPSBOb3RGb3VuZEdyYXBoRXJyb3I7XG5HcmFwaC5Vc2FnZUdyYXBoRXJyb3IgPSBVc2FnZUdyYXBoRXJyb3I7XG5cbi8qKlxuICogR3JhcGhvbG9neSBFU00gRW5kb2ludFxuICogPT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBFbmRwb2ludCBmb3IgRVNNIG1vZHVsZXMgY29uc3VtZXJzLlxuICovXG5cbmV4cG9ydCB7IERpcmVjdGVkR3JhcGgsIEdyYXBoLCBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvciwgTXVsdGlEaXJlY3RlZEdyYXBoLCBNdWx0aUdyYXBoLCBNdWx0aVVuZGlyZWN0ZWRHcmFwaCwgTm90Rm91bmRHcmFwaEVycm9yLCBVbmRpcmVjdGVkR3JhcGgsIFVzYWdlR3JhcGhFcnJvciwgR3JhcGggYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhvbG9neS5tanMubWFwXG4iLCIvKiBAbGljZW5zZVxuUGFwYSBQYXJzZVxudjUuNS4zXG5odHRwczovL2dpdGh1Yi5jb20vbWhvbHQvUGFwYVBhcnNlXG5MaWNlbnNlOiBNSVRcbiovXG4oKGUsdCk9PntcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtdLHQpOlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBleHBvcnRzP21vZHVsZS5leHBvcnRzPXQoKTplLlBhcGE9dCgpfSkodGhpcyxmdW5jdGlvbiByKCl7dmFyIG49XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHNlbGY/c2VsZjpcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93P3dpbmRvdzp2b2lkIDAhPT1uP246e307dmFyIGQscz0hbi5kb2N1bWVudCYmISFuLnBvc3RNZXNzYWdlLGE9bi5JU19QQVBBX1dPUktFUnx8ITEsbz17fSxoPTAsdj17fTtmdW5jdGlvbiB1KGUpe3RoaXMuX2hhbmRsZT1udWxsLHRoaXMuX2ZpbmlzaGVkPSExLHRoaXMuX2NvbXBsZXRlZD0hMSx0aGlzLl9oYWx0ZWQ9ITEsdGhpcy5faW5wdXQ9bnVsbCx0aGlzLl9iYXNlSW5kZXg9MCx0aGlzLl9wYXJ0aWFsTGluZT1cIlwiLHRoaXMuX3Jvd0NvdW50PTAsdGhpcy5fc3RhcnQ9MCx0aGlzLl9uZXh0Q2h1bms9bnVsbCx0aGlzLmlzRmlyc3RDaHVuaz0hMCx0aGlzLl9jb21wbGV0ZVJlc3VsdHM9e2RhdGE6W10sZXJyb3JzOltdLG1ldGE6e319LGZ1bmN0aW9uKGUpe3ZhciB0PWIoZSk7dC5jaHVua1NpemU9cGFyc2VJbnQodC5jaHVua1NpemUpLGUuc3RlcHx8ZS5jaHVua3x8KHQuY2h1bmtTaXplPW51bGwpO3RoaXMuX2hhbmRsZT1uZXcgaSh0KSwodGhpcy5faGFuZGxlLnN0cmVhbWVyPXRoaXMpLl9jb25maWc9dH0uY2FsbCh0aGlzLGUpLHRoaXMucGFyc2VDaHVuaz1mdW5jdGlvbih0LGUpe3ZhciBpPXBhcnNlSW50KHRoaXMuX2NvbmZpZy5za2lwRmlyc3ROTGluZXMpfHwwO2lmKHRoaXMuaXNGaXJzdENodW5rJiYwPGkpe2xldCBlPXRoaXMuX2NvbmZpZy5uZXdsaW5lO2V8fChyPXRoaXMuX2NvbmZpZy5xdW90ZUNoYXJ8fCdcIicsZT10aGlzLl9oYW5kbGUuZ3Vlc3NMaW5lRW5kaW5ncyh0LHIpKSx0PVsuLi50LnNwbGl0KGUpLnNsaWNlKGkpXS5qb2luKGUpfXRoaXMuaXNGaXJzdENodW5rJiZVKHRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKSYmdm9pZCAwIT09KHI9dGhpcy5fY29uZmlnLmJlZm9yZUZpcnN0Q2h1bmsodCkpJiYodD1yKSx0aGlzLmlzRmlyc3RDaHVuaz0hMSx0aGlzLl9oYWx0ZWQ9ITE7dmFyIGk9dGhpcy5fcGFydGlhbExpbmUrdCxyPSh0aGlzLl9wYXJ0aWFsTGluZT1cIlwiLHRoaXMuX2hhbmRsZS5wYXJzZShpLHRoaXMuX2Jhc2VJbmRleCwhdGhpcy5fZmluaXNoZWQpKTtpZighdGhpcy5faGFuZGxlLnBhdXNlZCgpJiYhdGhpcy5faGFuZGxlLmFib3J0ZWQoKSl7dD1yLm1ldGEuY3Vyc29yLGk9KHRoaXMuX2ZpbmlzaGVkfHwodGhpcy5fcGFydGlhbExpbmU9aS5zdWJzdHJpbmcodC10aGlzLl9iYXNlSW5kZXgpLHRoaXMuX2Jhc2VJbmRleD10KSxyJiZyLmRhdGEmJih0aGlzLl9yb3dDb3VudCs9ci5kYXRhLmxlbmd0aCksdGhpcy5fZmluaXNoZWR8fHRoaXMuX2NvbmZpZy5wcmV2aWV3JiZ0aGlzLl9yb3dDb3VudD49dGhpcy5fY29uZmlnLnByZXZpZXcpO2lmKGEpbi5wb3N0TWVzc2FnZSh7cmVzdWx0czpyLHdvcmtlcklkOnYuV09SS0VSX0lELGZpbmlzaGVkOml9KTtlbHNlIGlmKFUodGhpcy5fY29uZmlnLmNodW5rKSYmIWUpe2lmKHRoaXMuX2NvbmZpZy5jaHVuayhyLHRoaXMuX2hhbmRsZSksdGhpcy5faGFuZGxlLnBhdXNlZCgpfHx0aGlzLl9oYW5kbGUuYWJvcnRlZCgpKXJldHVybiB2b2lkKHRoaXMuX2hhbHRlZD0hMCk7dGhpcy5fY29tcGxldGVSZXN1bHRzPXI9dm9pZCAwfXJldHVybiB0aGlzLl9jb25maWcuc3RlcHx8dGhpcy5fY29uZmlnLmNodW5rfHwodGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGE9dGhpcy5fY29tcGxldGVSZXN1bHRzLmRhdGEuY29uY2F0KHIuZGF0YSksdGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycz10aGlzLl9jb21wbGV0ZVJlc3VsdHMuZXJyb3JzLmNvbmNhdChyLmVycm9ycyksdGhpcy5fY29tcGxldGVSZXN1bHRzLm1ldGE9ci5tZXRhKSx0aGlzLl9jb21wbGV0ZWR8fCFpfHwhVSh0aGlzLl9jb25maWcuY29tcGxldGUpfHxyJiZyLm1ldGEuYWJvcnRlZHx8KHRoaXMuX2NvbmZpZy5jb21wbGV0ZSh0aGlzLl9jb21wbGV0ZVJlc3VsdHMsdGhpcy5faW5wdXQpLHRoaXMuX2NvbXBsZXRlZD0hMCksaXx8ciYmci5tZXRhLnBhdXNlZHx8dGhpcy5fbmV4dENodW5rKCkscn10aGlzLl9oYWx0ZWQ9ITB9LHRoaXMuX3NlbmRFcnJvcj1mdW5jdGlvbihlKXtVKHRoaXMuX2NvbmZpZy5lcnJvcik/dGhpcy5fY29uZmlnLmVycm9yKGUpOmEmJnRoaXMuX2NvbmZpZy5lcnJvciYmbi5wb3N0TWVzc2FnZSh7d29ya2VySWQ6di5XT1JLRVJfSUQsZXJyb3I6ZSxmaW5pc2hlZDohMX0pfX1mdW5jdGlvbiBmKGUpe3ZhciByOyhlPWV8fHt9KS5jaHVua1NpemV8fChlLmNodW5rU2l6ZT12LlJlbW90ZUNodW5rU2l6ZSksdS5jYWxsKHRoaXMsZSksdGhpcy5fbmV4dENodW5rPXM/ZnVuY3Rpb24oKXt0aGlzLl9yZWFkQ2h1bmsoKSx0aGlzLl9jaHVua0xvYWRlZCgpfTpmdW5jdGlvbigpe3RoaXMuX3JlYWRDaHVuaygpfSx0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXt0aGlzLl9pbnB1dD1lLHRoaXMuX25leHRDaHVuaygpfSx0aGlzLl9yZWFkQ2h1bms9ZnVuY3Rpb24oKXtpZih0aGlzLl9maW5pc2hlZCl0aGlzLl9jaHVua0xvYWRlZCgpO2Vsc2V7aWYocj1uZXcgWE1MSHR0cFJlcXVlc3QsdGhpcy5fY29uZmlnLndpdGhDcmVkZW50aWFscyYmKHIud2l0aENyZWRlbnRpYWxzPXRoaXMuX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMpLHN8fChyLm9ubG9hZD15KHRoaXMuX2NodW5rTG9hZGVkLHRoaXMpLHIub25lcnJvcj15KHRoaXMuX2NodW5rRXJyb3IsdGhpcykpLHIub3Blbih0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0Qm9keT9cIlBPU1RcIjpcIkdFVFwiLHRoaXMuX2lucHV0LCFzKSx0aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0SGVhZGVycyl7dmFyIGUsdD10aGlzLl9jb25maWcuZG93bmxvYWRSZXF1ZXN0SGVhZGVycztmb3IoZSBpbiB0KXIuc2V0UmVxdWVzdEhlYWRlcihlLHRbZV0pfXZhciBpO3RoaXMuX2NvbmZpZy5jaHVua1NpemUmJihpPXRoaXMuX3N0YXJ0K3RoaXMuX2NvbmZpZy5jaHVua1NpemUtMSxyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLFwiYnl0ZXM9XCIrdGhpcy5fc3RhcnQrXCItXCIraSkpO3RyeXtyLnNlbmQodGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEJvZHkpfWNhdGNoKGUpe3RoaXMuX2NodW5rRXJyb3IoZS5tZXNzYWdlKX1zJiYwPT09ci5zdGF0dXMmJnRoaXMuX2NodW5rRXJyb3IoKX19LHRoaXMuX2NodW5rTG9hZGVkPWZ1bmN0aW9uKCl7ND09PXIucmVhZHlTdGF0ZSYmKHIuc3RhdHVzPDIwMHx8NDAwPD1yLnN0YXR1cz90aGlzLl9jaHVua0Vycm9yKCk6KHRoaXMuX3N0YXJ0Kz10aGlzLl9jb25maWcuY2h1bmtTaXplfHxyLnJlc3BvbnNlVGV4dC5sZW5ndGgsdGhpcy5fZmluaXNoZWQ9IXRoaXMuX2NvbmZpZy5jaHVua1NpemV8fHRoaXMuX3N0YXJ0Pj0oZT0+bnVsbCE9PShlPWUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpKT9wYXJzZUludChlLnN1YnN0cmluZyhlLmxhc3RJbmRleE9mKFwiL1wiKSsxKSk6LTEpKHIpLHRoaXMucGFyc2VDaHVuayhyLnJlc3BvbnNlVGV4dCkpKX0sdGhpcy5fY2h1bmtFcnJvcj1mdW5jdGlvbihlKXtlPXIuc3RhdHVzVGV4dHx8ZTt0aGlzLl9zZW5kRXJyb3IobmV3IEVycm9yKGUpKX19ZnVuY3Rpb24gbChlKXsoZT1lfHx7fSkuY2h1bmtTaXplfHwoZS5jaHVua1NpemU9di5Mb2NhbENodW5rU2l6ZSksdS5jYWxsKHRoaXMsZSk7dmFyIGkscixuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBGaWxlUmVhZGVyO3RoaXMuc3RyZWFtPWZ1bmN0aW9uKGUpe3RoaXMuX2lucHV0PWUscj1lLnNsaWNlfHxlLndlYmtpdFNsaWNlfHxlLm1velNsaWNlLG4/KChpPW5ldyBGaWxlUmVhZGVyKS5vbmxvYWQ9eSh0aGlzLl9jaHVua0xvYWRlZCx0aGlzKSxpLm9uZXJyb3I9eSh0aGlzLl9jaHVua0Vycm9yLHRoaXMpKTppPW5ldyBGaWxlUmVhZGVyU3luYyx0aGlzLl9uZXh0Q2h1bmsoKX0sdGhpcy5fbmV4dENodW5rPWZ1bmN0aW9uKCl7dGhpcy5fZmluaXNoZWR8fHRoaXMuX2NvbmZpZy5wcmV2aWV3JiYhKHRoaXMuX3Jvd0NvdW50PHRoaXMuX2NvbmZpZy5wcmV2aWV3KXx8dGhpcy5fcmVhZENodW5rKCl9LHRoaXMuX3JlYWRDaHVuaz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX2lucHV0LHQ9KHRoaXMuX2NvbmZpZy5jaHVua1NpemUmJih0PU1hdGgubWluKHRoaXMuX3N0YXJ0K3RoaXMuX2NvbmZpZy5jaHVua1NpemUsdGhpcy5faW5wdXQuc2l6ZSksZT1yLmNhbGwoZSx0aGlzLl9zdGFydCx0KSksaS5yZWFkQXNUZXh0KGUsdGhpcy5fY29uZmlnLmVuY29kaW5nKSk7bnx8dGhpcy5fY2h1bmtMb2FkZWQoe3RhcmdldDp7cmVzdWx0OnR9fSl9LHRoaXMuX2NodW5rTG9hZGVkPWZ1bmN0aW9uKGUpe3RoaXMuX3N0YXJ0Kz10aGlzLl9jb25maWcuY2h1bmtTaXplLHRoaXMuX2ZpbmlzaGVkPSF0aGlzLl9jb25maWcuY2h1bmtTaXplfHx0aGlzLl9zdGFydD49dGhpcy5faW5wdXQuc2l6ZSx0aGlzLnBhcnNlQ2h1bmsoZS50YXJnZXQucmVzdWx0KX0sdGhpcy5fY2h1bmtFcnJvcj1mdW5jdGlvbigpe3RoaXMuX3NlbmRFcnJvcihpLmVycm9yKX19ZnVuY3Rpb24gYyhlKXt2YXIgaTt1LmNhbGwodGhpcyxlPWV8fHt9KSx0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXtyZXR1cm4gaT1lLHRoaXMuX25leHRDaHVuaygpfSx0aGlzLl9uZXh0Q2h1bms9ZnVuY3Rpb24oKXt2YXIgZSx0O2lmKCF0aGlzLl9maW5pc2hlZClyZXR1cm4gZT10aGlzLl9jb25maWcuY2h1bmtTaXplLGk9ZT8odD1pLnN1YnN0cmluZygwLGUpLGkuc3Vic3RyaW5nKGUpKToodD1pLFwiXCIpLHRoaXMuX2ZpbmlzaGVkPSFpLHRoaXMucGFyc2VDaHVuayh0KX19ZnVuY3Rpb24gcChlKXt1LmNhbGwodGhpcyxlPWV8fHt9KTt2YXIgdD1bXSxpPSEwLHI9ITE7dGhpcy5wYXVzZT1mdW5jdGlvbigpe3UucHJvdG90eXBlLnBhdXNlLmFwcGx5KHRoaXMsYXJndW1lbnRzKSx0aGlzLl9pbnB1dC5wYXVzZSgpfSx0aGlzLnJlc3VtZT1mdW5jdGlvbigpe3UucHJvdG90eXBlLnJlc3VtZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5faW5wdXQucmVzdW1lKCl9LHRoaXMuc3RyZWFtPWZ1bmN0aW9uKGUpe3RoaXMuX2lucHV0PWUsdGhpcy5faW5wdXQub24oXCJkYXRhXCIsdGhpcy5fc3RyZWFtRGF0YSksdGhpcy5faW5wdXQub24oXCJlbmRcIix0aGlzLl9zdHJlYW1FbmQpLHRoaXMuX2lucHV0Lm9uKFwiZXJyb3JcIix0aGlzLl9zdHJlYW1FcnJvcil9LHRoaXMuX2NoZWNrSXNGaW5pc2hlZD1mdW5jdGlvbigpe3ImJjE9PT10Lmxlbmd0aCYmKHRoaXMuX2ZpbmlzaGVkPSEwKX0sdGhpcy5fbmV4dENodW5rPWZ1bmN0aW9uKCl7dGhpcy5fY2hlY2tJc0ZpbmlzaGVkKCksdC5sZW5ndGg/dGhpcy5wYXJzZUNodW5rKHQuc2hpZnQoKSk6aT0hMH0sdGhpcy5fc3RyZWFtRGF0YT15KGZ1bmN0aW9uKGUpe3RyeXt0LnB1c2goXCJzdHJpbmdcIj09dHlwZW9mIGU/ZTplLnRvU3RyaW5nKHRoaXMuX2NvbmZpZy5lbmNvZGluZykpLGkmJihpPSExLHRoaXMuX2NoZWNrSXNGaW5pc2hlZCgpLHRoaXMucGFyc2VDaHVuayh0LnNoaWZ0KCkpKX1jYXRjaChlKXt0aGlzLl9zdHJlYW1FcnJvcihlKX19LHRoaXMpLHRoaXMuX3N0cmVhbUVycm9yPXkoZnVuY3Rpb24oZSl7dGhpcy5fc3RyZWFtQ2xlYW5VcCgpLHRoaXMuX3NlbmRFcnJvcihlKX0sdGhpcyksdGhpcy5fc3RyZWFtRW5kPXkoZnVuY3Rpb24oKXt0aGlzLl9zdHJlYW1DbGVhblVwKCkscj0hMCx0aGlzLl9zdHJlYW1EYXRhKFwiXCIpfSx0aGlzKSx0aGlzLl9zdHJlYW1DbGVhblVwPXkoZnVuY3Rpb24oKXt0aGlzLl9pbnB1dC5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIix0aGlzLl9zdHJlYW1EYXRhKSx0aGlzLl9pbnB1dC5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLHRoaXMuX3N0cmVhbUVuZCksdGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLHRoaXMuX3N0cmVhbUVycm9yKX0sdGhpcyl9ZnVuY3Rpb24gaShtKXt2YXIgbixzLGEsdCxvPU1hdGgucG93KDIsNTMpLGg9LW8sdT0vXlxccyotPyhcXGQrXFwuP3xcXC5cXGQrfFxcZCtcXC5cXGQrKShbZUVdWy0rXT9cXGQrKT9cXHMqJC8sZD0vXigoXFxkezR9LVswMV1cXGQtWzAtM11cXGRUWzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGRcXC5cXGQrKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSl8KFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkKFsrLV1bMC0yXVxcZDpbMC01XVxcZHxaKSkpJC8saT10aGlzLHI9MCxmPTAsbD0hMSxlPSExLGM9W10scD17ZGF0YTpbXSxlcnJvcnM6W10sbWV0YTp7fX07ZnVuY3Rpb24geShlKXtyZXR1cm5cImdyZWVkeVwiPT09bS5za2lwRW1wdHlMaW5lcz9cIlwiPT09ZS5qb2luKFwiXCIpLnRyaW0oKToxPT09ZS5sZW5ndGgmJjA9PT1lWzBdLmxlbmd0aH1mdW5jdGlvbiBnKCl7aWYocCYmYSYmKGsoXCJEZWxpbWl0ZXJcIixcIlVuZGV0ZWN0YWJsZURlbGltaXRlclwiLFwiVW5hYmxlIHRvIGF1dG8tZGV0ZWN0IGRlbGltaXRpbmcgY2hhcmFjdGVyOyBkZWZhdWx0ZWQgdG8gJ1wiK3YuRGVmYXVsdERlbGltaXRlcitcIidcIiksYT0hMSksbS5za2lwRW1wdHlMaW5lcyYmKHAuZGF0YT1wLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKGUpe3JldHVybiF5KGUpfSkpLF8oKSl7aWYocClpZihBcnJheS5pc0FycmF5KHAuZGF0YVswXSkpe2Zvcih2YXIgZT0wO18oKSYmZTxwLmRhdGEubGVuZ3RoO2UrKylwLmRhdGFbZV0uZm9yRWFjaCh0KTtwLmRhdGEuc3BsaWNlKDAsMSl9ZWxzZSBwLmRhdGEuZm9yRWFjaCh0KTtmdW5jdGlvbiB0KGUsdCl7VShtLnRyYW5zZm9ybUhlYWRlcikmJihlPW0udHJhbnNmb3JtSGVhZGVyKGUsdCkpLGMucHVzaChlKX19ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgaT1tLmhlYWRlcj97fTpbXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBuPXIscz1lW3JdLHM9KChlLHQpPT4oZT0+KG0uZHluYW1pY1R5cGluZ0Z1bmN0aW9uJiZ2b2lkIDA9PT1tLmR5bmFtaWNUeXBpbmdbZV0mJihtLmR5bmFtaWNUeXBpbmdbZV09bS5keW5hbWljVHlwaW5nRnVuY3Rpb24oZSkpLCEwPT09KG0uZHluYW1pY1R5cGluZ1tlXXx8bS5keW5hbWljVHlwaW5nKSkpKGUpP1widHJ1ZVwiPT09dHx8XCJUUlVFXCI9PT10fHxcImZhbHNlXCIhPT10JiZcIkZBTFNFXCIhPT10JiYoKGU9PntpZih1LnRlc3QoZSkpe2U9cGFyc2VGbG9hdChlKTtpZihoPGUmJmU8bylyZXR1cm4gMX19KSh0KT9wYXJzZUZsb2F0KHQpOmQudGVzdCh0KT9uZXcgRGF0ZSh0KTpcIlwiPT09dD9udWxsOnQpOnQpKG49bS5oZWFkZXI/cj49Yy5sZW5ndGg/XCJfX3BhcnNlZF9leHRyYVwiOmNbcl06bixzPW0udHJhbnNmb3JtP20udHJhbnNmb3JtKHMsbik6cyk7XCJfX3BhcnNlZF9leHRyYVwiPT09bj8oaVtuXT1pW25dfHxbXSxpW25dLnB1c2gocykpOmlbbl09c31yZXR1cm4gbS5oZWFkZXImJihyPmMubGVuZ3RoP2soXCJGaWVsZE1pc21hdGNoXCIsXCJUb29NYW55RmllbGRzXCIsXCJUb28gbWFueSBmaWVsZHM6IGV4cGVjdGVkIFwiK2MubGVuZ3RoK1wiIGZpZWxkcyBidXQgcGFyc2VkIFwiK3IsZit0KTpyPGMubGVuZ3RoJiZrKFwiRmllbGRNaXNtYXRjaFwiLFwiVG9vRmV3RmllbGRzXCIsXCJUb28gZmV3IGZpZWxkczogZXhwZWN0ZWQgXCIrYy5sZW5ndGgrXCIgZmllbGRzIGJ1dCBwYXJzZWQgXCIrcixmK3QpKSxpfXZhciByO3AmJihtLmhlYWRlcnx8bS5keW5hbWljVHlwaW5nfHxtLnRyYW5zZm9ybSkmJihyPTEsIXAuZGF0YS5sZW5ndGh8fEFycmF5LmlzQXJyYXkocC5kYXRhWzBdKT8ocC5kYXRhPXAuZGF0YS5tYXAoaSkscj1wLmRhdGEubGVuZ3RoKTpwLmRhdGE9aShwLmRhdGEsMCksbS5oZWFkZXImJnAubWV0YSYmKHAubWV0YS5maWVsZHM9YyksZis9cil9ZnVuY3Rpb24gXygpe3JldHVybiBtLmhlYWRlciYmMD09PWMubGVuZ3RofWZ1bmN0aW9uIGsoZSx0LGkscil7ZT17dHlwZTplLGNvZGU6dCxtZXNzYWdlOml9O3ZvaWQgMCE9PXImJihlLnJvdz1yKSxwLmVycm9ycy5wdXNoKGUpfVUobS5zdGVwKSYmKHQ9bS5zdGVwLG0uc3RlcD1mdW5jdGlvbihlKXtwPWUsXygpP2coKTooZygpLDAhPT1wLmRhdGEubGVuZ3RoJiYocis9ZS5kYXRhLmxlbmd0aCxtLnByZXZpZXcmJnI+bS5wcmV2aWV3P3MuYWJvcnQoKToocC5kYXRhPXAuZGF0YVswXSx0KHAsaSkpKSl9KSx0aGlzLnBhcnNlPWZ1bmN0aW9uKGUsdCxpKXt2YXIgcj1tLnF1b3RlQ2hhcnx8J1wiJyxyPShtLm5ld2xpbmV8fChtLm5ld2xpbmU9dGhpcy5ndWVzc0xpbmVFbmRpbmdzKGUscikpLGE9ITEsbS5kZWxpbWl0ZXI/VShtLmRlbGltaXRlcikmJihtLmRlbGltaXRlcj1tLmRlbGltaXRlcihlKSxwLm1ldGEuZGVsaW1pdGVyPW0uZGVsaW1pdGVyKTooKHI9KChlLHQsaSxyLG4pPT57dmFyIHMsYSxvLGg7bj1ufHxbXCIsXCIsXCJcXHRcIixcInxcIixcIjtcIix2LlJFQ09SRF9TRVAsdi5VTklUX1NFUF07Zm9yKHZhciB1PTA7dTxuLmxlbmd0aDt1Kyspe2Zvcih2YXIgZCxmPW5bdV0sbD0wLGM9MCxwPTAsZz0obz12b2lkIDAsbmV3IEUoe2NvbW1lbnRzOnIsZGVsaW1pdGVyOmYsbmV3bGluZTp0LHByZXZpZXc6MTB9KS5wYXJzZShlKSksXz0wO188Zy5kYXRhLmxlbmd0aDtfKyspaSYmeShnLmRhdGFbX10pP3ArKzooZD1nLmRhdGFbX10ubGVuZ3RoLGMrPWQsdm9pZCAwPT09bz9vPWQ6MDxkJiYobCs9TWF0aC5hYnMoZC1vKSxvPWQpKTswPGcuZGF0YS5sZW5ndGgmJihjLz1nLmRhdGEubGVuZ3RoLXApLCh2b2lkIDA9PT1hfHxsPD1hKSYmKHZvaWQgMD09PWh8fGg8YykmJjEuOTk8YyYmKGE9bCxzPWYsaD1jKX1yZXR1cm57c3VjY2Vzc2Z1bDohIShtLmRlbGltaXRlcj1zKSxiZXN0RGVsaW1pdGVyOnN9fSkoZSxtLm5ld2xpbmUsbS5za2lwRW1wdHlMaW5lcyxtLmNvbW1lbnRzLG0uZGVsaW1pdGVyc1RvR3Vlc3MpKS5zdWNjZXNzZnVsP20uZGVsaW1pdGVyPXIuYmVzdERlbGltaXRlcjooYT0hMCxtLmRlbGltaXRlcj12LkRlZmF1bHREZWxpbWl0ZXIpLHAubWV0YS5kZWxpbWl0ZXI9bS5kZWxpbWl0ZXIpLGIobSkpO3JldHVybiBtLnByZXZpZXcmJm0uaGVhZGVyJiZyLnByZXZpZXcrKyxuPWUscz1uZXcgRShyKSxwPXMucGFyc2Uobix0LGkpLGcoKSxsP3ttZXRhOntwYXVzZWQ6ITB9fTpwfHx7bWV0YTp7cGF1c2VkOiExfX19LHRoaXMucGF1c2VkPWZ1bmN0aW9uKCl7cmV0dXJuIGx9LHRoaXMucGF1c2U9ZnVuY3Rpb24oKXtsPSEwLHMuYWJvcnQoKSxuPVUobS5jaHVuayk/XCJcIjpuLnN1YnN0cmluZyhzLmdldENoYXJJbmRleCgpKX0sdGhpcy5yZXN1bWU9ZnVuY3Rpb24oKXtpLnN0cmVhbWVyLl9oYWx0ZWQ/KGw9ITEsaS5zdHJlYW1lci5wYXJzZUNodW5rKG4sITApKTpzZXRUaW1lb3V0KGkucmVzdW1lLDMpfSx0aGlzLmFib3J0ZWQ9ZnVuY3Rpb24oKXtyZXR1cm4gZX0sdGhpcy5hYm9ydD1mdW5jdGlvbigpe2U9ITAscy5hYm9ydCgpLHAubWV0YS5hYm9ydGVkPSEwLFUobS5jb21wbGV0ZSkmJm0uY29tcGxldGUocCksbj1cIlwifSx0aGlzLmd1ZXNzTGluZUVuZGluZ3M9ZnVuY3Rpb24oZSx0KXtlPWUuc3Vic3RyaW5nKDAsMTA0ODU3Nik7dmFyIHQ9bmV3IFJlZ0V4cChQKHQpK1wiKFteXSo/KVwiK1AodCksXCJnbVwiKSxpPShlPWUucmVwbGFjZSh0LFwiXCIpKS5zcGxpdChcIlxcclwiKSx0PWUuc3BsaXQoXCJcXG5cIiksZT0xPHQubGVuZ3RoJiZ0WzBdLmxlbmd0aDxpWzBdLmxlbmd0aDtpZigxPT09aS5sZW5ndGh8fGUpcmV0dXJuXCJcXG5cIjtmb3IodmFyIHI9MCxuPTA7bjxpLmxlbmd0aDtuKyspXCJcXG5cIj09PWlbbl1bMF0mJnIrKztyZXR1cm4gcj49aS5sZW5ndGgvMj9cIlxcclxcblwiOlwiXFxyXCJ9fWZ1bmN0aW9uIFAoZSl7cmV0dXJuIGUucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csXCJcXFxcJCZcIil9ZnVuY3Rpb24gRShDKXt2YXIgUz0oQz1DfHx7fSkuZGVsaW1pdGVyLE89Qy5uZXdsaW5lLHg9Qy5jb21tZW50cyxJPUMuc3RlcCxBPUMucHJldmlldyxUPUMuZmFzdE1vZGUsRD1udWxsLEw9ITEsRj1udWxsPT1DLnF1b3RlQ2hhcj8nXCInOkMucXVvdGVDaGFyLGo9RjtpZih2b2lkIDAhPT1DLmVzY2FwZUNoYXImJihqPUMuZXNjYXBlQ2hhciksKFwic3RyaW5nXCIhPXR5cGVvZiBTfHwtMTx2LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoUykpJiYoUz1cIixcIikseD09PVMpdGhyb3cgbmV3IEVycm9yKFwiQ29tbWVudCBjaGFyYWN0ZXIgc2FtZSBhcyBkZWxpbWl0ZXJcIik7ITA9PT14P3g9XCIjXCI6KFwic3RyaW5nXCIhPXR5cGVvZiB4fHwtMTx2LkJBRF9ERUxJTUlURVJTLmluZGV4T2YoeCkpJiYoeD0hMSksXCJcXG5cIiE9PU8mJlwiXFxyXCIhPT1PJiZcIlxcclxcblwiIT09TyYmKE89XCJcXG5cIik7dmFyIHo9MCxNPSExO3RoaXMucGFyc2U9ZnVuY3Rpb24oaSx0LHIpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiBpKXRocm93IG5ldyBFcnJvcihcIklucHV0IG11c3QgYmUgYSBzdHJpbmdcIik7dmFyIG49aS5sZW5ndGgsZT1TLmxlbmd0aCxzPU8ubGVuZ3RoLGE9eC5sZW5ndGgsbz1VKEkpLGg9W10sdT1bXSxkPVtdLGY9ej0wO2lmKCFpKXJldHVybiB3KCk7aWYoVHx8ITEhPT1UJiYtMT09PWkuaW5kZXhPZihGKSl7Zm9yKHZhciBsPWkuc3BsaXQoTyksYz0wO2M8bC5sZW5ndGg7YysrKXtpZihkPWxbY10seis9ZC5sZW5ndGgsYyE9PWwubGVuZ3RoLTEpeis9Ty5sZW5ndGg7ZWxzZSBpZihyKXJldHVybiB3KCk7aWYoIXh8fGQuc3Vic3RyaW5nKDAsYSkhPT14KXtpZihvKXtpZihoPVtdLGsoZC5zcGxpdChTKSksUigpLE0pcmV0dXJuIHcoKX1lbHNlIGsoZC5zcGxpdChTKSk7aWYoQSYmQTw9YylyZXR1cm4gaD1oLnNsaWNlKDAsQSksdyghMCl9fXJldHVybiB3KCl9Zm9yKHZhciBwPWkuaW5kZXhPZihTLHopLGc9aS5pbmRleE9mKE8seiksXz1uZXcgUmVnRXhwKFAoaikrUChGKSxcImdcIiksbT1pLmluZGV4T2YoRix6KTs7KWlmKGlbel09PT1GKWZvcihtPXoseisrOzspe2lmKC0xPT09KG09aS5pbmRleE9mKEYsbSsxKSkpcmV0dXJuIHJ8fHUucHVzaCh7dHlwZTpcIlF1b3Rlc1wiLGNvZGU6XCJNaXNzaW5nUXVvdGVzXCIsbWVzc2FnZTpcIlF1b3RlZCBmaWVsZCB1bnRlcm1pbmF0ZWRcIixyb3c6aC5sZW5ndGgsaW5kZXg6en0pLEUoKTtpZihtPT09bi0xKXJldHVybiBFKGkuc3Vic3RyaW5nKHosbSkucmVwbGFjZShfLEYpKTtpZihGPT09aiYmaVttKzFdPT09ailtKys7ZWxzZSBpZihGPT09anx8MD09PW18fGlbbS0xXSE9PWopey0xIT09cCYmcDxtKzEmJihwPWkuaW5kZXhPZihTLG0rMSkpO3ZhciB5PXYoLTE9PT0oZz0tMSE9PWcmJmc8bSsxP2kuaW5kZXhPZihPLG0rMSk6Zyk/cDpNYXRoLm1pbihwLGcpKTtpZihpLnN1YnN0cihtKzEreSxlKT09PVMpe2QucHVzaChpLnN1YnN0cmluZyh6LG0pLnJlcGxhY2UoXyxGKSksaVt6PW0rMSt5K2VdIT09RiYmKG09aS5pbmRleE9mKEYseikpLHA9aS5pbmRleE9mKFMseiksZz1pLmluZGV4T2YoTyx6KTticmVha315PXYoZyk7aWYoaS5zdWJzdHJpbmcobSsxK3ksbSsxK3krcyk9PT1PKXtpZihkLnB1c2goaS5zdWJzdHJpbmcoeixtKS5yZXBsYWNlKF8sRikpLGIobSsxK3krcykscD1pLmluZGV4T2YoUyx6KSxtPWkuaW5kZXhPZihGLHopLG8mJihSKCksTSkpcmV0dXJuIHcoKTtpZihBJiZoLmxlbmd0aD49QSlyZXR1cm4gdyghMCk7YnJlYWt9dS5wdXNoKHt0eXBlOlwiUXVvdGVzXCIsY29kZTpcIkludmFsaWRRdW90ZXNcIixtZXNzYWdlOlwiVHJhaWxpbmcgcXVvdGUgb24gcXVvdGVkIGZpZWxkIGlzIG1hbGZvcm1lZFwiLHJvdzpoLmxlbmd0aCxpbmRleDp6fSksbSsrfX1lbHNlIGlmKHgmJjA9PT1kLmxlbmd0aCYmaS5zdWJzdHJpbmcoeix6K2EpPT09eCl7aWYoLTE9PT1nKXJldHVybiB3KCk7ej1nK3MsZz1pLmluZGV4T2YoTyx6KSxwPWkuaW5kZXhPZihTLHopfWVsc2UgaWYoLTEhPT1wJiYocDxnfHwtMT09PWcpKWQucHVzaChpLnN1YnN0cmluZyh6LHApKSx6PXArZSxwPWkuaW5kZXhPZihTLHopO2Vsc2V7aWYoLTE9PT1nKWJyZWFrO2lmKGQucHVzaChpLnN1YnN0cmluZyh6LGcpKSxiKGcrcyksbyYmKFIoKSxNKSlyZXR1cm4gdygpO2lmKEEmJmgubGVuZ3RoPj1BKXJldHVybiB3KCEwKX1yZXR1cm4gRSgpO2Z1bmN0aW9uIGsoZSl7aC5wdXNoKGUpLGY9en1mdW5jdGlvbiB2KGUpe3ZhciB0PTA7cmV0dXJuIHQ9LTEhPT1lJiYoZT1pLnN1YnN0cmluZyhtKzEsZSkpJiZcIlwiPT09ZS50cmltKCk/ZS5sZW5ndGg6dH1mdW5jdGlvbiBFKGUpe3JldHVybiByfHwodm9pZCAwPT09ZSYmKGU9aS5zdWJzdHJpbmcoeikpLGQucHVzaChlKSx6PW4sayhkKSxvJiZSKCkpLHcoKX1mdW5jdGlvbiBiKGUpe3o9ZSxrKGQpLGQ9W10sZz1pLmluZGV4T2YoTyx6KX1mdW5jdGlvbiB3KGUpe2lmKEMuaGVhZGVyJiYhdCYmaC5sZW5ndGgmJiFMKXt2YXIgcz1oWzBdLGE9T2JqZWN0LmNyZWF0ZShudWxsKSxvPW5ldyBTZXQocyk7bGV0IG49ITE7Zm9yKGxldCByPTA7cjxzLmxlbmd0aDtyKyspe2xldCBpPXNbcl07aWYoYVtpPVUoQy50cmFuc2Zvcm1IZWFkZXIpP0MudHJhbnNmb3JtSGVhZGVyKGkscik6aV0pe2xldCBlLHQ9YVtpXTtmb3IoO2U9aStcIl9cIit0LHQrKyxvLmhhcyhlKTspO28uYWRkKGUpLHNbcl09ZSxhW2ldKyssbj0hMCwoRD1udWxsPT09RD97fTpEKVtlXT1pfWVsc2UgYVtpXT0xLHNbcl09aTtvLmFkZChpKX1uJiZjb25zb2xlLndhcm4oXCJEdXBsaWNhdGUgaGVhZGVycyBmb3VuZCBhbmQgcmVuYW1lZC5cIiksTD0hMH1yZXR1cm57ZGF0YTpoLGVycm9yczp1LG1ldGE6e2RlbGltaXRlcjpTLGxpbmVicmVhazpPLGFib3J0ZWQ6TSx0cnVuY2F0ZWQ6ISFlLGN1cnNvcjpmKyh0fHwwKSxyZW5hbWVkSGVhZGVyczpEfX19ZnVuY3Rpb24gUigpe0kodygpKSxoPVtdLHU9W119fSx0aGlzLmFib3J0PWZ1bmN0aW9uKCl7TT0hMH0sdGhpcy5nZXRDaGFySW5kZXg9ZnVuY3Rpb24oKXtyZXR1cm4gen19ZnVuY3Rpb24gZyhlKXt2YXIgdD1lLmRhdGEsaT1vW3Qud29ya2VySWRdLHI9ITE7aWYodC5lcnJvcilpLnVzZXJFcnJvcih0LmVycm9yLHQuZmlsZSk7ZWxzZSBpZih0LnJlc3VsdHMmJnQucmVzdWx0cy5kYXRhKXt2YXIgbj17YWJvcnQ6ZnVuY3Rpb24oKXtyPSEwLF8odC53b3JrZXJJZCx7ZGF0YTpbXSxlcnJvcnM6W10sbWV0YTp7YWJvcnRlZDohMH19KX0scGF1c2U6bSxyZXN1bWU6bX07aWYoVShpLnVzZXJTdGVwKSl7Zm9yKHZhciBzPTA7czx0LnJlc3VsdHMuZGF0YS5sZW5ndGgmJihpLnVzZXJTdGVwKHtkYXRhOnQucmVzdWx0cy5kYXRhW3NdLGVycm9yczp0LnJlc3VsdHMuZXJyb3JzLG1ldGE6dC5yZXN1bHRzLm1ldGF9LG4pLCFyKTtzKyspO2RlbGV0ZSB0LnJlc3VsdHN9ZWxzZSBVKGkudXNlckNodW5rKSYmKGkudXNlckNodW5rKHQucmVzdWx0cyxuLHQuZmlsZSksZGVsZXRlIHQucmVzdWx0cyl9dC5maW5pc2hlZCYmIXImJl8odC53b3JrZXJJZCx0LnJlc3VsdHMpfWZ1bmN0aW9uIF8oZSx0KXt2YXIgaT1vW2VdO1UoaS51c2VyQ29tcGxldGUpJiZpLnVzZXJDb21wbGV0ZSh0KSxpLnRlcm1pbmF0ZSgpLGRlbGV0ZSBvW2VdfWZ1bmN0aW9uIG0oKXt0aHJvdyBuZXcgRXJyb3IoXCJOb3QgaW1wbGVtZW50ZWQuXCIpfWZ1bmN0aW9uIGIoZSl7aWYoXCJvYmplY3RcIiE9dHlwZW9mIGV8fG51bGw9PT1lKXJldHVybiBlO3ZhciB0LGk9QXJyYXkuaXNBcnJheShlKT9bXTp7fTtmb3IodCBpbiBlKWlbdF09YihlW3RdKTtyZXR1cm4gaX1mdW5jdGlvbiB5KGUsdCl7cmV0dXJuIGZ1bmN0aW9uKCl7ZS5hcHBseSh0LGFyZ3VtZW50cyl9fWZ1bmN0aW9uIFUoZSl7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZX1yZXR1cm4gdi5wYXJzZT1mdW5jdGlvbihlLHQpe3ZhciBpPSh0PXR8fHt9KS5keW5hbWljVHlwaW5nfHwhMTtVKGkpJiYodC5keW5hbWljVHlwaW5nRnVuY3Rpb249aSxpPXt9KTtpZih0LmR5bmFtaWNUeXBpbmc9aSx0LnRyYW5zZm9ybT0hIVUodC50cmFuc2Zvcm0pJiZ0LnRyYW5zZm9ybSwhdC53b3JrZXJ8fCF2LldPUktFUlNfU1VQUE9SVEVEKXJldHVybiBpPW51bGwsdi5OT0RFX1NUUkVBTV9JTlBVVCxcInN0cmluZ1wiPT10eXBlb2YgZT8oZT0oZT0+NjUyNzkhPT1lLmNoYXJDb2RlQXQoMCk/ZTplLnNsaWNlKDEpKShlKSxpPW5ldyh0LmRvd25sb2FkP2Y6YykodCkpOiEwPT09ZS5yZWFkYWJsZSYmVShlLnJlYWQpJiZVKGUub24pP2k9bmV3IHAodCk6KG4uRmlsZSYmZSBpbnN0YW5jZW9mIEZpbGV8fGUgaW5zdGFuY2VvZiBPYmplY3QpJiYoaT1uZXcgbCh0KSksaS5zdHJlYW0oZSk7KGk9KCgpPT57dmFyIGU7cmV0dXJuISF2LldPUktFUlNfU1VQUE9SVEVEJiYoZT0oKCk9Pnt2YXIgZT1uLlVSTHx8bi53ZWJraXRVUkx8fG51bGwsdD1yLnRvU3RyaW5nKCk7cmV0dXJuIHYuQkxPQl9VUkx8fCh2LkJMT0JfVVJMPWUuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtcInZhciBnbG9iYWwgPSAoZnVuY3Rpb24oKSB7IGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgcmV0dXJuIHNlbGY7IH0gaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiB3aW5kb3c7IH0gaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBnbG9iYWw7IH0gcmV0dXJuIHt9OyB9KSgpOyBnbG9iYWwuSVNfUEFQQV9XT1JLRVI9dHJ1ZTsgXCIsXCIoXCIsdCxcIikoKTtcIl0se3R5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIn0pKSl9KSgpLChlPW5ldyBuLldvcmtlcihlKSkub25tZXNzYWdlPWcsZS5pZD1oKyssb1tlLmlkXT1lKX0pKCkpLnVzZXJTdGVwPXQuc3RlcCxpLnVzZXJDaHVuaz10LmNodW5rLGkudXNlckNvbXBsZXRlPXQuY29tcGxldGUsaS51c2VyRXJyb3I9dC5lcnJvcix0LnN0ZXA9VSh0LnN0ZXApLHQuY2h1bms9VSh0LmNodW5rKSx0LmNvbXBsZXRlPVUodC5jb21wbGV0ZSksdC5lcnJvcj1VKHQuZXJyb3IpLGRlbGV0ZSB0LndvcmtlcixpLnBvc3RNZXNzYWdlKHtpbnB1dDplLGNvbmZpZzp0LHdvcmtlcklkOmkuaWR9KX0sdi51bnBhcnNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49ITEsXz0hMCxtPVwiLFwiLHk9XCJcXHJcXG5cIixzPSdcIicsYT1zK3MsaT0hMSxyPW51bGwsbz0hMSxoPSgoKCk9PntpZihcIm9iamVjdFwiPT10eXBlb2YgdCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQuZGVsaW1pdGVyfHx2LkJBRF9ERUxJTUlURVJTLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4tMSE9PXQuZGVsaW1pdGVyLmluZGV4T2YoZSl9KS5sZW5ndGh8fChtPXQuZGVsaW1pdGVyKSxcImJvb2xlYW5cIiE9dHlwZW9mIHQucXVvdGVzJiZcImZ1bmN0aW9uXCIhPXR5cGVvZiB0LnF1b3RlcyYmIUFycmF5LmlzQXJyYXkodC5xdW90ZXMpfHwobj10LnF1b3RlcyksXCJib29sZWFuXCIhPXR5cGVvZiB0LnNraXBFbXB0eUxpbmVzJiZcInN0cmluZ1wiIT10eXBlb2YgdC5za2lwRW1wdHlMaW5lc3x8KGk9dC5za2lwRW1wdHlMaW5lcyksXCJzdHJpbmdcIj09dHlwZW9mIHQubmV3bGluZSYmKHk9dC5uZXdsaW5lKSxcInN0cmluZ1wiPT10eXBlb2YgdC5xdW90ZUNoYXImJihzPXQucXVvdGVDaGFyKSxcImJvb2xlYW5cIj09dHlwZW9mIHQuaGVhZGVyJiYoXz10LmhlYWRlciksQXJyYXkuaXNBcnJheSh0LmNvbHVtbnMpKXtpZigwPT09dC5jb2x1bW5zLmxlbmd0aCl0aHJvdyBuZXcgRXJyb3IoXCJPcHRpb24gY29sdW1ucyBpcyBlbXB0eVwiKTtyPXQuY29sdW1uc312b2lkIDAhPT10LmVzY2FwZUNoYXImJihhPXQuZXNjYXBlQ2hhcitzKSx0LmVzY2FwZUZvcm11bGFlIGluc3RhbmNlb2YgUmVnRXhwP289dC5lc2NhcGVGb3JtdWxhZTpcImJvb2xlYW5cIj09dHlwZW9mIHQuZXNjYXBlRm9ybXVsYWUmJnQuZXNjYXBlRm9ybXVsYWUmJihvPS9eWz0rXFwtQFxcdFxccl0uKiQvKX19KSgpLG5ldyBSZWdFeHAoUChzKSxcImdcIikpO1wic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1KU09OLnBhcnNlKGUpKTtpZihBcnJheS5pc0FycmF5KGUpKXtpZighZS5sZW5ndGh8fEFycmF5LmlzQXJyYXkoZVswXSkpcmV0dXJuIHUobnVsbCxlLGkpO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBlWzBdKXJldHVybiB1KHJ8fE9iamVjdC5rZXlzKGVbMF0pLGUsaSl9ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgZSlyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgZS5kYXRhJiYoZS5kYXRhPUpTT04ucGFyc2UoZS5kYXRhKSksQXJyYXkuaXNBcnJheShlLmRhdGEpJiYoZS5maWVsZHN8fChlLmZpZWxkcz1lLm1ldGEmJmUubWV0YS5maWVsZHN8fHIpLGUuZmllbGRzfHwoZS5maWVsZHM9QXJyYXkuaXNBcnJheShlLmRhdGFbMF0pP2UuZmllbGRzOlwib2JqZWN0XCI9PXR5cGVvZiBlLmRhdGFbMF0/T2JqZWN0LmtleXMoZS5kYXRhWzBdKTpbXSksQXJyYXkuaXNBcnJheShlLmRhdGFbMF0pfHxcIm9iamVjdFwiPT10eXBlb2YgZS5kYXRhWzBdfHwoZS5kYXRhPVtlLmRhdGFdKSksdShlLmZpZWxkc3x8W10sZS5kYXRhfHxbXSxpKTt0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gc2VyaWFsaXplIHVucmVjb2duaXplZCBpbnB1dFwiKTtmdW5jdGlvbiB1KGUsdCxpKXt2YXIgcj1cIlwiLG49KFwic3RyaW5nXCI9PXR5cGVvZiBlJiYoZT1KU09OLnBhcnNlKGUpKSxcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9SlNPTi5wYXJzZSh0KSksQXJyYXkuaXNBcnJheShlKSYmMDxlLmxlbmd0aCkscz0hQXJyYXkuaXNBcnJheSh0WzBdKTtpZihuJiZfKXtmb3IodmFyIGE9MDthPGUubGVuZ3RoO2ErKykwPGEmJihyKz1tKSxyKz1rKGVbYV0sYSk7MDx0Lmxlbmd0aCYmKHIrPXkpfWZvcih2YXIgbz0wO288dC5sZW5ndGg7bysrKXt2YXIgaD0obj9lOnRbb10pLmxlbmd0aCx1PSExLGQ9bj8wPT09T2JqZWN0LmtleXModFtvXSkubGVuZ3RoOjA9PT10W29dLmxlbmd0aDtpZihpJiYhbiYmKHU9XCJncmVlZHlcIj09PWk/XCJcIj09PXRbb10uam9pbihcIlwiKS50cmltKCk6MT09PXRbb10ubGVuZ3RoJiYwPT09dFtvXVswXS5sZW5ndGgpLFwiZ3JlZWR5XCI9PT1pJiZuKXtmb3IodmFyIGY9W10sbD0wO2w8aDtsKyspe3ZhciBjPXM/ZVtsXTpsO2YucHVzaCh0W29dW2NdKX11PVwiXCI9PT1mLmpvaW4oXCJcIikudHJpbSgpfWlmKCF1KXtmb3IodmFyIHA9MDtwPGg7cCsrKXswPHAmJiFkJiYocis9bSk7dmFyIGc9biYmcz9lW3BdOnA7cis9ayh0W29dW2ddLHApfW88dC5sZW5ndGgtMSYmKCFpfHwwPGgmJiFkKSYmKHIrPXkpfX1yZXR1cm4gcn1mdW5jdGlvbiBrKGUsdCl7dmFyIGkscjtyZXR1cm4gbnVsbD09ZT9cIlwiOmUuY29uc3RydWN0b3I9PT1EYXRlP0pTT04uc3RyaW5naWZ5KGUpLnNsaWNlKDEsMjUpOihyPSExLG8mJlwic3RyaW5nXCI9PXR5cGVvZiBlJiZvLnRlc3QoZSkmJihlPVwiJ1wiK2Uscj0hMCksaT1lLnRvU3RyaW5nKCkucmVwbGFjZShoLGEpLChyPXJ8fCEwPT09bnx8XCJmdW5jdGlvblwiPT10eXBlb2YgbiYmbihlLHQpfHxBcnJheS5pc0FycmF5KG4pJiZuW3RdfHwoKGUsdCk9Pntmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKylpZigtMTxlLmluZGV4T2YodFtpXSkpcmV0dXJuITA7cmV0dXJuITF9KShpLHYuQkFEX0RFTElNSVRFUlMpfHwtMTxpLmluZGV4T2YobSl8fFwiIFwiPT09aS5jaGFyQXQoMCl8fFwiIFwiPT09aS5jaGFyQXQoaS5sZW5ndGgtMSkpP3MraStzOmkpfX0sdi5SRUNPUkRfU0VQPVN0cmluZy5mcm9tQ2hhckNvZGUoMzApLHYuVU5JVF9TRVA9U3RyaW5nLmZyb21DaGFyQ29kZSgzMSksdi5CWVRFX09SREVSX01BUks9XCJcXHVmZWZmXCIsdi5CQURfREVMSU1JVEVSUz1bXCJcXHJcIixcIlxcblwiLCdcIicsdi5CWVRFX09SREVSX01BUktdLHYuV09SS0VSU19TVVBQT1JURUQ9IXMmJiEhbi5Xb3JrZXIsdi5OT0RFX1NUUkVBTV9JTlBVVD0xLHYuTG9jYWxDaHVua1NpemU9MTA0ODU3NjAsdi5SZW1vdGVDaHVua1NpemU9NTI0Mjg4MCx2LkRlZmF1bHREZWxpbWl0ZXI9XCIsXCIsdi5QYXJzZXI9RSx2LlBhcnNlckhhbmRsZT1pLHYuTmV0d29ya1N0cmVhbWVyPWYsdi5GaWxlU3RyZWFtZXI9bCx2LlN0cmluZ1N0cmVhbWVyPWMsdi5SZWFkYWJsZVN0cmVhbVN0cmVhbWVyPXAsbi5qUXVlcnkmJigoZD1uLmpRdWVyeSkuZm4ucGFyc2U9ZnVuY3Rpb24obyl7dmFyIGk9by5jb25maWd8fHt9LGg9W107cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbihlKXtpZighKFwiSU5QVVRcIj09PWQodGhpcykucHJvcChcInRhZ05hbWVcIikudG9VcHBlckNhc2UoKSYmXCJmaWxlXCI9PT1kKHRoaXMpLmF0dHIoXCJ0eXBlXCIpLnRvTG93ZXJDYXNlKCkmJm4uRmlsZVJlYWRlcil8fCF0aGlzLmZpbGVzfHwwPT09dGhpcy5maWxlcy5sZW5ndGgpcmV0dXJuITA7Zm9yKHZhciB0PTA7dDx0aGlzLmZpbGVzLmxlbmd0aDt0KyspaC5wdXNoKHtmaWxlOnRoaXMuZmlsZXNbdF0saW5wdXRFbGVtOnRoaXMsaW5zdGFuY2VDb25maWc6ZC5leHRlbmQoe30saSl9KX0pLGUoKSx0aGlzO2Z1bmN0aW9uIGUoKXtpZigwPT09aC5sZW5ndGgpVShvLmNvbXBsZXRlKSYmby5jb21wbGV0ZSgpO2Vsc2V7dmFyIGUsdCxpLHIsbj1oWzBdO2lmKFUoby5iZWZvcmUpKXt2YXIgcz1vLmJlZm9yZShuLmZpbGUsbi5pbnB1dEVsZW0pO2lmKFwib2JqZWN0XCI9PXR5cGVvZiBzKXtpZihcImFib3J0XCI9PT1zLmFjdGlvbilyZXR1cm4gZT1cIkFib3J0RXJyb3JcIix0PW4uZmlsZSxpPW4uaW5wdXRFbGVtLHI9cy5yZWFzb24sdm9pZChVKG8uZXJyb3IpJiZvLmVycm9yKHtuYW1lOmV9LHQsaSxyKSk7aWYoXCJza2lwXCI9PT1zLmFjdGlvbilyZXR1cm4gdm9pZCB1KCk7XCJvYmplY3RcIj09dHlwZW9mIHMuY29uZmlnJiYobi5pbnN0YW5jZUNvbmZpZz1kLmV4dGVuZChuLmluc3RhbmNlQ29uZmlnLHMuY29uZmlnKSl9ZWxzZSBpZihcInNraXBcIj09PXMpcmV0dXJuIHZvaWQgdSgpfXZhciBhPW4uaW5zdGFuY2VDb25maWcuY29tcGxldGU7bi5pbnN0YW5jZUNvbmZpZy5jb21wbGV0ZT1mdW5jdGlvbihlKXtVKGEpJiZhKGUsbi5maWxlLG4uaW5wdXRFbGVtKSx1KCl9LHYucGFyc2Uobi5maWxlLG4uaW5zdGFuY2VDb25maWcpfX1mdW5jdGlvbiB1KCl7aC5zcGxpY2UoMCwxKSxlKCl9fSksYSYmKG4ub25tZXNzYWdlPWZ1bmN0aW9uKGUpe2U9ZS5kYXRhO3ZvaWQgMD09PXYuV09SS0VSX0lEJiZlJiYodi5XT1JLRVJfSUQ9ZS53b3JrZXJJZCk7XCJzdHJpbmdcIj09dHlwZW9mIGUuaW5wdXQ/bi5wb3N0TWVzc2FnZSh7d29ya2VySWQ6di5XT1JLRVJfSUQscmVzdWx0czp2LnBhcnNlKGUuaW5wdXQsZS5jb25maWcpLGZpbmlzaGVkOiEwfSk6KG4uRmlsZSYmZS5pbnB1dCBpbnN0YW5jZW9mIEZpbGV8fGUuaW5wdXQgaW5zdGFuY2VvZiBPYmplY3QpJiYoZT12LnBhcnNlKGUuaW5wdXQsZS5jb25maWcpKSYmbi5wb3N0TWVzc2FnZSh7d29ya2VySWQ6di5XT1JLRVJfSUQscmVzdWx0czplLGZpbmlzaGVkOiEwfSl9KSwoZi5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWYsKGwucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1sLChjLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKSkuY29uc3RydWN0b3I9YywocC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh1LnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPXAsdn0pOyIsImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIHtcbiAgKG51bGwgPT0gYSB8fCBhID4gci5sZW5ndGgpICYmIChhID0gci5sZW5ndGgpO1xuICBmb3IgKHZhciBlID0gMCwgbiA9IEFycmF5KGEpOyBlIDwgYTsgZSsrKSBuW2VdID0gcltlXTtcbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KHIsIGUpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQociwgZSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIsIGUpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxudmFyIEhUTUxfQ09MT1JTID0ge1xuICBibGFjazogXCIjMDAwMDAwXCIsXG4gIHNpbHZlcjogXCIjQzBDMEMwXCIsXG4gIGdyYXk6IFwiIzgwODA4MFwiLFxuICBncmV5OiBcIiM4MDgwODBcIixcbiAgd2hpdGU6IFwiI0ZGRkZGRlwiLFxuICBtYXJvb246IFwiIzgwMDAwMFwiLFxuICByZWQ6IFwiI0ZGMDAwMFwiLFxuICBwdXJwbGU6IFwiIzgwMDA4MFwiLFxuICBmdWNoc2lhOiBcIiNGRjAwRkZcIixcbiAgZ3JlZW46IFwiIzAwODAwMFwiLFxuICBsaW1lOiBcIiMwMEZGMDBcIixcbiAgb2xpdmU6IFwiIzgwODAwMFwiLFxuICB5ZWxsb3c6IFwiI0ZGRkYwMFwiLFxuICBuYXZ5OiBcIiMwMDAwODBcIixcbiAgYmx1ZTogXCIjMDAwMEZGXCIsXG4gIHRlYWw6IFwiIzAwODA4MFwiLFxuICBhcXVhOiBcIiMwMEZGRkZcIixcbiAgZGFya2JsdWU6IFwiIzAwMDA4QlwiLFxuICBtZWRpdW1ibHVlOiBcIiMwMDAwQ0RcIixcbiAgZGFya2dyZWVuOiBcIiMwMDY0MDBcIixcbiAgZGFya2N5YW46IFwiIzAwOEI4QlwiLFxuICBkZWVwc2t5Ymx1ZTogXCIjMDBCRkZGXCIsXG4gIGRhcmt0dXJxdW9pc2U6IFwiIzAwQ0VEMVwiLFxuICBtZWRpdW1zcHJpbmdncmVlbjogXCIjMDBGQTlBXCIsXG4gIHNwcmluZ2dyZWVuOiBcIiMwMEZGN0ZcIixcbiAgY3lhbjogXCIjMDBGRkZGXCIsXG4gIG1pZG5pZ2h0Ymx1ZTogXCIjMTkxOTcwXCIsXG4gIGRvZGdlcmJsdWU6IFwiIzFFOTBGRlwiLFxuICBsaWdodHNlYWdyZWVuOiBcIiMyMEIyQUFcIixcbiAgZm9yZXN0Z3JlZW46IFwiIzIyOEIyMlwiLFxuICBzZWFncmVlbjogXCIjMkU4QjU3XCIsXG4gIGRhcmtzbGF0ZWdyYXk6IFwiIzJGNEY0RlwiLFxuICBkYXJrc2xhdGVncmV5OiBcIiMyRjRGNEZcIixcbiAgbGltZWdyZWVuOiBcIiMzMkNEMzJcIixcbiAgbWVkaXVtc2VhZ3JlZW46IFwiIzNDQjM3MVwiLFxuICB0dXJxdW9pc2U6IFwiIzQwRTBEMFwiLFxuICByb3lhbGJsdWU6IFwiIzQxNjlFMVwiLFxuICBzdGVlbGJsdWU6IFwiIzQ2ODJCNFwiLFxuICBkYXJrc2xhdGVibHVlOiBcIiM0ODNEOEJcIixcbiAgbWVkaXVtdHVycXVvaXNlOiBcIiM0OEQxQ0NcIixcbiAgaW5kaWdvOiBcIiM0QjAwODJcIixcbiAgZGFya29saXZlZ3JlZW46IFwiIzU1NkIyRlwiLFxuICBjYWRldGJsdWU6IFwiIzVGOUVBMFwiLFxuICBjb3JuZmxvd2VyYmx1ZTogXCIjNjQ5NUVEXCIsXG4gIHJlYmVjY2FwdXJwbGU6IFwiIzY2MzM5OVwiLFxuICBtZWRpdW1hcXVhbWFyaW5lOiBcIiM2NkNEQUFcIixcbiAgZGltZ3JheTogXCIjNjk2OTY5XCIsXG4gIGRpbWdyZXk6IFwiIzY5Njk2OVwiLFxuICBzbGF0ZWJsdWU6IFwiIzZBNUFDRFwiLFxuICBvbGl2ZWRyYWI6IFwiIzZCOEUyM1wiLFxuICBzbGF0ZWdyYXk6IFwiIzcwODA5MFwiLFxuICBzbGF0ZWdyZXk6IFwiIzcwODA5MFwiLFxuICBsaWdodHNsYXRlZ3JheTogXCIjNzc4ODk5XCIsXG4gIGxpZ2h0c2xhdGVncmV5OiBcIiM3Nzg4OTlcIixcbiAgbWVkaXVtc2xhdGVibHVlOiBcIiM3QjY4RUVcIixcbiAgbGF3bmdyZWVuOiBcIiM3Q0ZDMDBcIixcbiAgY2hhcnRyZXVzZTogXCIjN0ZGRjAwXCIsXG4gIGFxdWFtYXJpbmU6IFwiIzdGRkZENFwiLFxuICBza3libHVlOiBcIiM4N0NFRUJcIixcbiAgbGlnaHRza3libHVlOiBcIiM4N0NFRkFcIixcbiAgYmx1ZXZpb2xldDogXCIjOEEyQkUyXCIsXG4gIGRhcmtyZWQ6IFwiIzhCMDAwMFwiLFxuICBkYXJrbWFnZW50YTogXCIjOEIwMDhCXCIsXG4gIHNhZGRsZWJyb3duOiBcIiM4QjQ1MTNcIixcbiAgZGFya3NlYWdyZWVuOiBcIiM4RkJDOEZcIixcbiAgbGlnaHRncmVlbjogXCIjOTBFRTkwXCIsXG4gIG1lZGl1bXB1cnBsZTogXCIjOTM3MERCXCIsXG4gIGRhcmt2aW9sZXQ6IFwiIzk0MDBEM1wiLFxuICBwYWxlZ3JlZW46IFwiIzk4RkI5OFwiLFxuICBkYXJrb3JjaGlkOiBcIiM5OTMyQ0NcIixcbiAgeWVsbG93Z3JlZW46IFwiIzlBQ0QzMlwiLFxuICBzaWVubmE6IFwiI0EwNTIyRFwiLFxuICBicm93bjogXCIjQTUyQTJBXCIsXG4gIGRhcmtncmF5OiBcIiNBOUE5QTlcIixcbiAgZGFya2dyZXk6IFwiI0E5QTlBOVwiLFxuICBsaWdodGJsdWU6IFwiI0FERDhFNlwiLFxuICBncmVlbnllbGxvdzogXCIjQURGRjJGXCIsXG4gIHBhbGV0dXJxdW9pc2U6IFwiI0FGRUVFRVwiLFxuICBsaWdodHN0ZWVsYmx1ZTogXCIjQjBDNERFXCIsXG4gIHBvd2RlcmJsdWU6IFwiI0IwRTBFNlwiLFxuICBmaXJlYnJpY2s6IFwiI0IyMjIyMlwiLFxuICBkYXJrZ29sZGVucm9kOiBcIiNCODg2MEJcIixcbiAgbWVkaXVtb3JjaGlkOiBcIiNCQTU1RDNcIixcbiAgcm9zeWJyb3duOiBcIiNCQzhGOEZcIixcbiAgZGFya2toYWtpOiBcIiNCREI3NkJcIixcbiAgbWVkaXVtdmlvbGV0cmVkOiBcIiNDNzE1ODVcIixcbiAgaW5kaWFucmVkOiBcIiNDRDVDNUNcIixcbiAgcGVydTogXCIjQ0Q4NTNGXCIsXG4gIGNob2NvbGF0ZTogXCIjRDI2OTFFXCIsXG4gIHRhbjogXCIjRDJCNDhDXCIsXG4gIGxpZ2h0Z3JheTogXCIjRDNEM0QzXCIsXG4gIGxpZ2h0Z3JleTogXCIjRDNEM0QzXCIsXG4gIHRoaXN0bGU6IFwiI0Q4QkZEOFwiLFxuICBvcmNoaWQ6IFwiI0RBNzBENlwiLFxuICBnb2xkZW5yb2Q6IFwiI0RBQTUyMFwiLFxuICBwYWxldmlvbGV0cmVkOiBcIiNEQjcwOTNcIixcbiAgY3JpbXNvbjogXCIjREMxNDNDXCIsXG4gIGdhaW5zYm9ybzogXCIjRENEQ0RDXCIsXG4gIHBsdW06IFwiI0REQTBERFwiLFxuICBidXJseXdvb2Q6IFwiI0RFQjg4N1wiLFxuICBsaWdodGN5YW46IFwiI0UwRkZGRlwiLFxuICBsYXZlbmRlcjogXCIjRTZFNkZBXCIsXG4gIGRhcmtzYWxtb246IFwiI0U5OTY3QVwiLFxuICB2aW9sZXQ6IFwiI0VFODJFRVwiLFxuICBwYWxlZ29sZGVucm9kOiBcIiNFRUU4QUFcIixcbiAgbGlnaHRjb3JhbDogXCIjRjA4MDgwXCIsXG4gIGtoYWtpOiBcIiNGMEU2OENcIixcbiAgYWxpY2VibHVlOiBcIiNGMEY4RkZcIixcbiAgaG9uZXlkZXc6IFwiI0YwRkZGMFwiLFxuICBhenVyZTogXCIjRjBGRkZGXCIsXG4gIHNhbmR5YnJvd246IFwiI0Y0QTQ2MFwiLFxuICB3aGVhdDogXCIjRjVERUIzXCIsXG4gIGJlaWdlOiBcIiNGNUY1RENcIixcbiAgd2hpdGVzbW9rZTogXCIjRjVGNUY1XCIsXG4gIG1pbnRjcmVhbTogXCIjRjVGRkZBXCIsXG4gIGdob3N0d2hpdGU6IFwiI0Y4RjhGRlwiLFxuICBzYWxtb246IFwiI0ZBODA3MlwiLFxuICBhbnRpcXVld2hpdGU6IFwiI0ZBRUJEN1wiLFxuICBsaW5lbjogXCIjRkFGMEU2XCIsXG4gIGxpZ2h0Z29sZGVucm9keWVsbG93OiBcIiNGQUZBRDJcIixcbiAgb2xkbGFjZTogXCIjRkRGNUU2XCIsXG4gIG1hZ2VudGE6IFwiI0ZGMDBGRlwiLFxuICBkZWVwcGluazogXCIjRkYxNDkzXCIsXG4gIG9yYW5nZXJlZDogXCIjRkY0NTAwXCIsXG4gIHRvbWF0bzogXCIjRkY2MzQ3XCIsXG4gIGhvdHBpbms6IFwiI0ZGNjlCNFwiLFxuICBjb3JhbDogXCIjRkY3RjUwXCIsXG4gIGRhcmtvcmFuZ2U6IFwiI0ZGOEMwMFwiLFxuICBsaWdodHNhbG1vbjogXCIjRkZBMDdBXCIsXG4gIG9yYW5nZTogXCIjRkZBNTAwXCIsXG4gIGxpZ2h0cGluazogXCIjRkZCNkMxXCIsXG4gIHBpbms6IFwiI0ZGQzBDQlwiLFxuICBnb2xkOiBcIiNGRkQ3MDBcIixcbiAgcGVhY2hwdWZmOiBcIiNGRkRBQjlcIixcbiAgbmF2YWpvd2hpdGU6IFwiI0ZGREVBRFwiLFxuICBtb2NjYXNpbjogXCIjRkZFNEI1XCIsXG4gIGJpc3F1ZTogXCIjRkZFNEM0XCIsXG4gIG1pc3R5cm9zZTogXCIjRkZFNEUxXCIsXG4gIGJsYW5jaGVkYWxtb25kOiBcIiNGRkVCQ0RcIixcbiAgcGFwYXlhd2hpcDogXCIjRkZFRkQ1XCIsXG4gIGxhdmVuZGVyYmx1c2g6IFwiI0ZGRjBGNVwiLFxuICBzZWFzaGVsbDogXCIjRkZGNUVFXCIsXG4gIGNvcm5zaWxrOiBcIiNGRkY4RENcIixcbiAgbGVtb25jaGlmZm9uOiBcIiNGRkZBQ0RcIixcbiAgZmxvcmFsd2hpdGU6IFwiI0ZGRkFGMFwiLFxuICBzbm93OiBcIiNGRkZBRkFcIixcbiAgbGlnaHR5ZWxsb3c6IFwiI0ZGRkZFMFwiLFxuICBpdm9yeTogXCIjRkZGRkYwXCJcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gZXh0cmFjdGluZyB0aGUgY29sb3IgYXQgdGhlIGdpdmVuIHBpeGVsLlxuICovXG5mdW5jdGlvbiBleHRyYWN0UGl4ZWwoZ2wsIHgsIHksIGFycmF5KSB7XG4gIHZhciBkYXRhID0gYXJyYXkgfHwgbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGdsLnJlYWRQaXhlbHMoeCwgeSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgZGF0YSk7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIE1lbW9pemVkIGZ1bmN0aW9uIHJldHVybmluZyBhIGZsb2F0LWVuY29kZWQgY29sb3IgZnJvbSB2YXJpb3VzIHN0cmluZ1xuICogZm9ybWF0cyBkZXNjcmliaW5nIGNvbG9ycy5cbiAqL1xudmFyIElOVDggPSBuZXcgSW50OEFycmF5KDQpO1xudmFyIElOVDMyID0gbmV3IEludDMyQXJyYXkoSU5UOC5idWZmZXIsIDAsIDEpO1xudmFyIEZMT0FUMzIgPSBuZXcgRmxvYXQzMkFycmF5KElOVDguYnVmZmVyLCAwLCAxKTtcbnZhciBSR0JBX1RFU1RfUkVHRVggPSAvXlxccypyZ2JhP1xccypcXCgvO1xudmFyIFJHQkFfRVhUUkFDVF9SRUdFWCA9IC9eXFxzKnJnYmE/XFxzKlxcKFxccyooWzAtOV0qKVxccyosXFxzKihbMC05XSopXFxzKixcXHMqKFswLTldKikoPzpcXHMqLFxccyooLiopPyk/XFwpXFxzKiQvO1xuZnVuY3Rpb24gcGFyc2VDb2xvcih2YWwpIHtcbiAgdmFyIHIgPSAwOyAvLyBieXRlXG4gIHZhciBnID0gMDsgLy8gYnl0ZVxuICB2YXIgYiA9IDA7IC8vIGJ5dGVcbiAgdmFyIGEgPSAxOyAvLyBmbG9hdFxuXG4gIC8vIEhhbmRsaW5nIGhleGFkZWNpbWFsIG5vdGF0aW9uXG4gIGlmICh2YWxbMF0gPT09IFwiI1wiKSB7XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDQpIHtcbiAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgxKSwgMTYpO1xuICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMikgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCgzKSArIHZhbC5jaGFyQXQoMyksIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDIpLCAxNik7XG4gICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgzKSArIHZhbC5jaGFyQXQoNCksIDE2KTtcbiAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDUpICsgdmFsLmNoYXJBdCg2KSwgMTYpO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gOSkge1xuICAgICAgYSA9IHBhcnNlSW50KHZhbC5jaGFyQXQoNykgKyB2YWwuY2hhckF0KDgpLCAxNikgLyAyNTU7XG4gICAgfVxuICB9XG5cbiAgLy8gSGFuZGxpbmcgcmdiIG5vdGF0aW9uXG4gIGVsc2UgaWYgKFJHQkFfVEVTVF9SRUdFWC50ZXN0KHZhbCkpIHtcbiAgICB2YXIgbWF0Y2ggPSB2YWwubWF0Y2goUkdCQV9FWFRSQUNUX1JFR0VYKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHIgPSArbWF0Y2hbMV07XG4gICAgICBnID0gK21hdGNoWzJdO1xuICAgICAgYiA9ICttYXRjaFszXTtcbiAgICAgIGlmIChtYXRjaFs0XSkgYSA9ICttYXRjaFs0XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByOiByLFxuICAgIGc6IGcsXG4gICAgYjogYixcbiAgICBhOiBhXG4gIH07XG59XG52YXIgRkxPQVRfQ09MT1JfQ0FDSEUgPSB7fTtcbmZvciAodmFyIGh0bWxDb2xvciBpbiBIVE1MX0NPTE9SUykge1xuICBGTE9BVF9DT0xPUl9DQUNIRVtodG1sQ29sb3JdID0gZmxvYXRDb2xvcihIVE1MX0NPTE9SU1todG1sQ29sb3JdKTtcbiAgLy8gUmVwbGljYXRpbmcgY2FjaGUgZm9yIGhleCB2YWx1ZXMgZm9yIGZyZWVcbiAgRkxPQVRfQ09MT1JfQ0FDSEVbSFRNTF9DT0xPUlNbaHRtbENvbG9yXV0gPSBGTE9BVF9DT0xPUl9DQUNIRVtodG1sQ29sb3JdO1xufVxuZnVuY3Rpb24gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgbWFza2luZykge1xuICBJTlQzMlswXSA9IGEgPDwgMjQgfCBiIDw8IDE2IHwgZyA8PCA4IHwgcjtcbiAgaWYgKG1hc2tpbmcpIElOVDMyWzBdID0gSU5UMzJbMF0gJiAweGZlZmZmZmZmO1xuICByZXR1cm4gRkxPQVQzMlswXTtcbn1cbmZ1bmN0aW9uIGZsb2F0Q29sb3IodmFsKSB7XG4gIC8vIFRoZSBodG1sIGNvbG9yIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG4gIHZhbCA9IHZhbC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIElmIHRoZSBjb2xvciBpcyBhbHJlYWR5IGNvbXB1dGVkLCB3ZSB5aWVsZCBpdFxuICBpZiAodHlwZW9mIEZMT0FUX0NPTE9SX0NBQ0hFW3ZhbF0gIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdO1xuICB2YXIgcGFyc2VkID0gcGFyc2VDb2xvcih2YWwpO1xuICB2YXIgciA9IHBhcnNlZC5yLFxuICAgIGcgPSBwYXJzZWQuZyxcbiAgICBiID0gcGFyc2VkLmI7XG4gIHZhciBhID0gcGFyc2VkLmE7XG4gIGEgPSBhICogMjU1IHwgMDtcbiAgdmFyIGNvbG9yID0gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgdHJ1ZSk7XG4gIEZMT0FUX0NPTE9SX0NBQ0hFW3ZhbF0gPSBjb2xvcjtcbiAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gY29sb3JUb0FycmF5KHZhbCwgbWFza2luZykge1xuICBGTE9BVDMyWzBdID0gZmxvYXRDb2xvcih2YWwpO1xuICB2YXIgaW50VmFsdWUgPSBJTlQzMlswXTtcbiAgaWYgKG1hc2tpbmcpIHtcbiAgICBpbnRWYWx1ZSA9IGludFZhbHVlIHwgMHgwMTAwMDAwMDtcbiAgfVxuICB2YXIgciA9IGludFZhbHVlICYgMHhmZjtcbiAgdmFyIGcgPSBpbnRWYWx1ZSA+PiA4ICYgMHhmZjtcbiAgdmFyIGIgPSBpbnRWYWx1ZSA+PiAxNiAmIDB4ZmY7XG4gIHZhciBhID0gaW50VmFsdWUgPj4gMjQgJiAweGZmO1xuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxudmFyIEZMT0FUX0lOREVYX0NBQ0hFID0ge307XG5mdW5jdGlvbiBpbmRleFRvQ29sb3IoaW5kZXgpIHtcbiAgLy8gSWYgdGhlIGluZGV4IGlzIGFscmVhZHkgY29tcHV0ZWQsIHdlIHlpZWxkIGl0XG4gIGlmICh0eXBlb2YgRkxPQVRfSU5ERVhfQ0FDSEVbaW5kZXhdICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gRkxPQVRfSU5ERVhfQ0FDSEVbaW5kZXhdO1xuXG4gIC8vIFRvIGFkZHJlc3MgaXNzdWUgIzEzOTcsIG9uZSBzdHJhdGVneSBpcyB0byBrZWVwIGVuY29kaW5nIDQgYnl0ZXMgY29sb3JzLFxuICAvLyBidXQgd2l0aCBhbHBoYSBoYXJkLXNldCB0byAxLjAgKG9yIDI1NSk6XG4gIHZhciByID0gKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICB2YXIgZyA9IChpbmRleCAmIDB4MDAwMGZmMDApID4+PiA4O1xuICB2YXIgYiA9IGluZGV4ICYgMHgwMDAwMDBmZjtcbiAgdmFyIGEgPSAweDAwMDAwMGZmO1xuXG4gIC8vIFRoZSBvcmlnaW5hbCA0IGJ5dGVzIGNvbG9yIGVuY29kaW5nIHdhcyB0aGUgZm9sbG93aW5nOlxuICAvLyBjb25zdCByID0gKGluZGV4ICYgMHhmZjAwMDAwMCkgPj4+IDI0O1xuICAvLyBjb25zdCBnID0gKGluZGV4ICYgMHgwMGZmMDAwMCkgPj4+IDE2O1xuICAvLyBjb25zdCBiID0gKGluZGV4ICYgMHgwMDAwZmYwMCkgPj4+IDg7XG4gIC8vIGNvbnN0IGEgPSBpbmRleCAmIDB4MDAwMDAwZmY7XG5cbiAgdmFyIGNvbG9yID0gcmdiYVRvRmxvYXQociwgZywgYiwgYSwgdHJ1ZSk7XG4gIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XSA9IGNvbG9yO1xuICByZXR1cm4gY29sb3I7XG59XG5mdW5jdGlvbiBjb2xvclRvSW5kZXgociwgZywgYiwgX2EpIHtcbiAgLy8gQXMgZm9yIHRoZSBmdW5jdGlvbiBpbmRleFRvQ29sb3IsIGJlY2F1c2Ugb2YgIzEzOTcgYW5kIHRoZSBcImFscGhhIGlzIGFsd2F5c1xuICAvLyAxLjBcIiBzdHJhdGVneSwgd2UgbmVlZCB0byBmaXggdGhpcyBmdW5jdGlvbiBhcyB3ZWxsOlxuICByZXR1cm4gYiArIChnIDw8IDgpICsgKHIgPDwgMTYpO1xuXG4gIC8vIFRoZSBvcmlnaW5hbCA0IGJ5dGVzIGNvbG9yIGRlY29kaW5nIGlzIHRoZSBmb2xsb3dpbmc6XG4gIC8vIHJldHVybiBhICsgKGIgPDwgOCkgKyAoZyA8PCAxNikgKyAociA8PCAyNCk7XG59XG5mdW5jdGlvbiBnZXRQaXhlbENvbG9yKGdsLCBmcmFtZUJ1ZmZlciwgeCwgeSwgcGl4ZWxSYXRpbywgZG93blNpemluZ1JhdGlvKSB7XG4gIHZhciBidWZmZXJYID0gTWF0aC5mbG9vcih4IC8gZG93blNpemluZ1JhdGlvICogcGl4ZWxSYXRpbyk7XG4gIHZhciBidWZmZXJZID0gTWF0aC5mbG9vcihnbC5kcmF3aW5nQnVmZmVySGVpZ2h0IC8gZG93blNpemluZ1JhdGlvIC0geSAvIGRvd25TaXppbmdSYXRpbyAqIHBpeGVsUmF0aW8pO1xuICB2YXIgcGl4ZWwgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gIGdsLnJlYWRQaXhlbHMoYnVmZmVyWCwgYnVmZmVyWSwgMSwgMSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgcGl4ZWwpO1xuICB2YXIgX3BpeGVsID0gX3NsaWNlZFRvQXJyYXkocGl4ZWwsIDQpLFxuICAgIHIgPSBfcGl4ZWxbMF0sXG4gICAgZyA9IF9waXhlbFsxXSxcbiAgICBiID0gX3BpeGVsWzJdLFxuICAgIGEgPSBfcGl4ZWxbM107XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG5cbmV4cG9ydCB7IEhUTUxfQ09MT1JTIGFzIEgsIF9zbGljZWRUb0FycmF5IGFzIF8sIF9hcnJheUxpa2VUb0FycmF5IGFzIGEsIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBhcyBiLCBjb2xvclRvSW5kZXggYXMgYywgY29sb3JUb0FycmF5IGFzIGQsIGV4dHJhY3RQaXhlbCBhcyBlLCBmbG9hdENvbG9yIGFzIGYsIGdldFBpeGVsQ29sb3IgYXMgZywgaW5kZXhUb0NvbG9yIGFzIGksIHBhcnNlQ29sb3IgYXMgcCwgcmdiYVRvRmxvYXQgYXMgciB9O1xuIiwiZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIHRoZSB0YXJnZXQgYXJyYXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICovXG5mdW5jdGlvbiBleHRlbmQoYXJyYXksIHZhbHVlcykge1xuICB2YXIgbDIgPSB2YWx1ZXMuc2l6ZTtcbiAgaWYgKGwyID09PSAwKSByZXR1cm47XG4gIHZhciBsMSA9IGFycmF5Lmxlbmd0aDtcbiAgYXJyYXkubGVuZ3RoICs9IGwyO1xuICB2YXIgaSA9IDA7XG4gIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGFycmF5W2wxICsgaV0gPSB2YWx1ZTtcbiAgICBpKys7XG4gIH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gX3R5cGVvZih2YWx1ZSkgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IE9iamVjdDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gdXNlIGBPYmplY3QuYXNzaWduYCB3aXRoIG1vcmUgdGhhbiB0d28gb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gYXNzaWduKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG8gPSBpICsgMSA8IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKCFvKSBjb250aW51ZTtcbiAgICBPYmplY3QuYXNzaWduKHRhcmdldCwgbyk7XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBWZXJ5IHNpbXBsZSByZWN1cnNpdmUgYE9iamVjdC5hc3NpZ25gIGxpa2UgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbkRlZXAodGFyZ2V0KSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgPyAwIDogYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgbyA9IGkgKyAxIDwgMSB8fCBhcmd1bWVudHMubGVuZ3RoIDw9IGkgKyAxID8gdW5kZWZpbmVkIDogYXJndW1lbnRzW2kgKyAxXTtcbiAgICBpZiAoIW8pIGNvbnRpbnVlO1xuICAgIGZvciAodmFyIGsgaW4gbykge1xuICAgICAgaWYgKGlzUGxhaW5PYmplY3Qob1trXSkpIHtcbiAgICAgICAgdGFyZ2V0W2tdID0gYXNzaWduRGVlcCh0YXJnZXRba10sIG9ba10pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0W2tdID0gb1trXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuZXhwb3J0IHsgX3R5cGVvZiBhcyBfLCBhc3NpZ24gYXMgYSwgYXNzaWduRGVlcCBhcyBiLCBleHRlbmQgYXMgZSwgaXNQbGFpbk9iamVjdCBhcyBpIH07XG4iLCJpbXBvcnQgeyBkIGFzIF90b1Byb3BlcnR5S2V5LCBlIGFzIF9nZXRQcm90b3R5cGVPZiwgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBfIGFzIF9pbmhlcml0cywgYyBhcyBfY2FsbFN1cGVyIH0gZnJvbSAnLi9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMnO1xuaW1wb3J0IHsgaSBhcyBpbmRleFRvQ29sb3IsIGYgYXMgZmxvYXRDb2xvciB9IGZyb20gJy4vY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wQmFzZSh0LCBvKSB7XG4gIGZvciAoOyAhe30uaGFzT3duUHJvcGVydHkuY2FsbCh0LCBvKSAmJiBudWxsICE9PSAodCA9IF9nZXRQcm90b3R5cGVPZih0KSk7KTtcbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIHJldHVybiBfZ2V0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmdldCA/IFJlZmxlY3QuZ2V0LmJpbmQoKSA6IGZ1bmN0aW9uIChlLCB0LCByKSB7XG4gICAgdmFyIHAgPSBfc3VwZXJQcm9wQmFzZShlLCB0KTtcbiAgICBpZiAocCkge1xuICAgICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHAsIHQpO1xuICAgICAgcmV0dXJuIG4uZ2V0ID8gbi5nZXQuY2FsbChhcmd1bWVudHMubGVuZ3RoIDwgMyA/IGUgOiByKSA6IG4udmFsdWU7XG4gICAgfVxuICB9LCBfZ2V0LmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BHZXQodCwgbywgZSwgcikge1xuICB2YXIgcCA9IF9nZXQoX2dldFByb3RvdHlwZU9mKDEgJiByID8gdC5wcm90b3R5cGUgOiB0KSwgbywgZSk7XG4gIHJldHVybiAyICYgciAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHAgPyBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBwLmFwcGx5KGUsIHQpO1xuICB9IDogcDtcbn1cblxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlSXRlbXNDb3VudChhdHRyKSB7XG4gIHJldHVybiBhdHRyLm5vcm1hbGl6ZWQgPyAxIDogYXR0ci5zaXplO1xufVxuZnVuY3Rpb24gZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQoYXR0cnMpIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGF0dHJzLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICByZXR1cm4gcmVzICs9IGdldEF0dHJpYnV0ZUl0ZW1zQ291bnQoYXR0cik7XG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gbG9hZFNoYWRlcih0eXBlLCBnbCwgc291cmNlKSB7XG4gIHZhciBnbFR5cGUgPSB0eXBlID09PSBcIlZFUlRFWFwiID8gZ2wuVkVSVEVYX1NIQURFUiA6IGdsLkZSQUdNRU5UX1NIQURFUjtcblxuICAvLyBDcmVhdGluZyB0aGUgc2hhZGVyXG4gIHZhciBzaGFkZXIgPSBnbC5jcmVhdGVTaGFkZXIoZ2xUeXBlKTtcbiAgaWYgKHNoYWRlciA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTaGFkZXI6IGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBzaGFkZXJcIik7XG4gIH1cblxuICAvLyBMb2FkaW5nIHNvdXJjZVxuICBnbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpO1xuXG4gIC8vIENvbXBpbGluZyB0aGUgc2hhZGVyXG4gIGdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTtcblxuICAvLyBSZXRyaWV2aW5nIGNvbXBpbGF0aW9uIHN0YXR1c1xuICB2YXIgc3VjY2Vzc2Z1bGx5Q29tcGlsZWQgPSBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUyk7XG5cbiAgLy8gVGhyb3dpbmcgaWYgc29tZXRoaW5nIHdlbnQgYXdyeVxuICBpZiAoIXN1Y2Nlc3NmdWxseUNvbXBpbGVkKSB7XG4gICAgdmFyIGluZm9Mb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNoYWRlcjogZXJyb3Igd2hpbGUgY29tcGlsaW5nIHRoZSBzaGFkZXI6XFxuXCIuY29uY2F0KGluZm9Mb2csIFwiXFxuXCIpLmNvbmNhdChzb3VyY2UpKTtcbiAgfVxuICByZXR1cm4gc2hhZGVyO1xufVxuZnVuY3Rpb24gbG9hZFZlcnRleFNoYWRlcihnbCwgc291cmNlKSB7XG4gIHJldHVybiBsb2FkU2hhZGVyKFwiVkVSVEVYXCIsIGdsLCBzb3VyY2UpO1xufVxuZnVuY3Rpb24gbG9hZEZyYWdtZW50U2hhZGVyKGdsLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGxvYWRTaGFkZXIoXCJGUkFHTUVOVFwiLCBnbCwgc291cmNlKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGxvYWQgYSBwcm9ncmFtLlxuICovXG5mdW5jdGlvbiBsb2FkUHJvZ3JhbShnbCwgc2hhZGVycykge1xuICB2YXIgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgaWYgKHByb2dyYW0gPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIHByb2dyYW0uXCIpO1xuICB9XG4gIHZhciBpLCBsO1xuXG4gIC8vIEF0dGFjaGluZyB0aGUgc2hhZGVyc1xuICBmb3IgKGkgPSAwLCBsID0gc2hhZGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBzaGFkZXJzW2ldKTtcbiAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG5cbiAgLy8gQ2hlY2tpbmcgc3RhdHVzXG4gIHZhciBzdWNjZXNzZnVsbHlMaW5rZWQgPSBnbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIGdsLkxJTktfU1RBVFVTKTtcbiAgaWYgKCFzdWNjZXNzZnVsbHlMaW5rZWQpIHtcbiAgICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBsaW5raW5nIHRoZSBwcm9ncmFtLlwiKTtcbiAgfVxuICByZXR1cm4gcHJvZ3JhbTtcbn1cbmZ1bmN0aW9uIGtpbGxQcm9ncmFtKF9yZWYpIHtcbiAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICBidWZmZXIgPSBfcmVmLmJ1ZmZlcixcbiAgICBwcm9ncmFtID0gX3JlZi5wcm9ncmFtLFxuICAgIHZlcnRleFNoYWRlciA9IF9yZWYudmVydGV4U2hhZGVyLFxuICAgIGZyYWdtZW50U2hhZGVyID0gX3JlZi5mcmFnbWVudFNoYWRlcjtcbiAgZ2wuZGVsZXRlU2hhZGVyKHZlcnRleFNoYWRlcik7XG4gIGdsLmRlbGV0ZVNoYWRlcihmcmFnbWVudFNoYWRlcik7XG4gIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gIGdsLmRlbGV0ZUJ1ZmZlcihidWZmZXIpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZSB0byBwcmludCBhIGZsb2F0IGZvciBpbnNlcnRpbmcgaW4gYSBHTFNMIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvR0xTTEZsb2F0KG4pIHtcbiAgcmV0dXJuIG4gJSAxID09PSAwID8gbi50b0ZpeGVkKDEpIDogbi50b1N0cmluZygpO1xufVxuXG52YXIgUElDS0lOR19QUkVGSVggPSBcIiNkZWZpbmUgUElDS0lOR19NT0RFXFxuXCI7XG52YXIgU0laRV9GQUNUT1JfUEVSX0FUVFJJQlVURV9UWVBFID0gX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CT09MLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CWVRFLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TSE9SVCwgMiksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDIpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LklOVCwgNCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfSU5ULCA0KSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgNCk7XG52YXIgQWJzdHJhY3RQcm9ncmFtID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhmdW5jdGlvbiBBYnN0cmFjdFByb2dyYW0oX2dsLCBfcGlja0dsLCBfcmVuZGVyZXIpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0UHJvZ3JhbSk7XG59KTtcbnZhciBQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUHJvZ3JhbSk7XG4gICAgLy8gR0xlbnVtXG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiYXJyYXlcIiwgbmV3IEZsb2F0MzJBcnJheSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb25zdGFudEFycmF5XCIsIG5ldyBGbG9hdDMyQXJyYXkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2FwYWNpdHlcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwidmVydGljZXNDb3VudFwiLCAwKTtcbiAgICAvLyBSZWFkaW5nIGFuZCBjYWNoaW5nIHByb2dyYW0gZGVmaW5pdGlvblxuICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcbiAgICB0aGlzLlZFUlRJQ0VTID0gZGVmLlZFUlRJQ0VTO1xuICAgIHRoaXMuVkVSVEVYX1NIQURFUl9TT1VSQ0UgPSBkZWYuVkVSVEVYX1NIQURFUl9TT1VSQ0U7XG4gICAgdGhpcy5GUkFHTUVOVF9TSEFERVJfU09VUkNFID0gZGVmLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0U7XG4gICAgdGhpcy5VTklGT1JNUyA9IGRlZi5VTklGT1JNUztcbiAgICB0aGlzLkFUVFJJQlVURVMgPSBkZWYuQVRUUklCVVRFUztcbiAgICB0aGlzLk1FVEhPRCA9IGRlZi5NRVRIT0Q7XG4gICAgdGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTID0gXCJDT05TVEFOVF9BVFRSSUJVVEVTXCIgaW4gZGVmID8gZGVmLkNPTlNUQU5UX0FUVFJJQlVURVMgOiBbXTtcbiAgICB0aGlzLkNPTlNUQU5UX0RBVEEgPSBcIkNPTlNUQU5UX0RBVEFcIiBpbiBkZWYgPyBkZWYuQ09OU1RBTlRfREFUQSA6IFtdO1xuICAgIHRoaXMuaXNJbnN0YW5jZWQgPSBcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWY7XG5cbiAgICAvLyBDb21wdXRpbmcgc3RyaWRlXG4gICAgdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UID0gZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQodGhpcy5BVFRSSUJVVEVTKTtcbiAgICB0aGlzLlNUUklERSA9IHRoaXMuVkVSVElDRVMgKiB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQ7XG5cbiAgICAvLyBNZW1iZXJzXG4gICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHRoaXMubm9ybWFsUHJvZ3JhbSA9IHRoaXMuZ2V0UHJvZ3JhbUluZm8oXCJub3JtYWxcIiwgZ2wsIGRlZi5WRVJURVhfU0hBREVSX1NPVVJDRSwgZGVmLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIG51bGwpO1xuICAgIHRoaXMucGlja1Byb2dyYW0gPSBwaWNraW5nQnVmZmVyID8gdGhpcy5nZXRQcm9ncmFtSW5mbyhcInBpY2tcIiwgZ2wsIFBJQ0tJTkdfUFJFRklYICsgZGVmLlZFUlRFWF9TSEFERVJfU09VUkNFLCBQSUNLSU5HX1BSRUZJWCArIGRlZi5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBwaWNraW5nQnVmZmVyKSA6IG51bGw7XG5cbiAgICAvLyBGb3IgaW5zdGFuY2VkIHByb2dyYW1zOlxuICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICB2YXIgY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCA9IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUyk7XG4gICAgICBpZiAodGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aCAhPT0gdGhpcy5WRVJUSUNFUykgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBjb25zdGFudCBkYXRhIChleHBlY3RlZCBcIi5jb25jYXQodGhpcy5WRVJUSUNFUywgXCIgaXRlbXMsIHJlY2VpdmVkIFwiKS5jb25jYXQodGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aCwgXCIgaW5zdGVhZClcIikpO1xuICAgICAgdGhpcy5jb25zdGFudEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSh0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoICogY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdmVjdG9yID0gdGhpcy5DT05TVEFOVF9EQVRBW2ldO1xuICAgICAgICBpZiAodmVjdG9yLmxlbmd0aCAhPT0gY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgZ2V0dGluZyBjb25zdGFudCBkYXRhIChvbmUgdmVjdG9yIGhhcyBcIi5jb25jYXQodmVjdG9yLmxlbmd0aCwgXCIgaXRlbXMgaW5zdGVhZCBvZiBcIikuY29uY2F0KGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQsIFwiKVwiKSk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmVjdG9yLmxlbmd0aDsgaisrKSB0aGlzLmNvbnN0YW50QXJyYXlbaSAqIGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQgKyBqXSA9IHZlY3RvcltqXTtcbiAgICAgIH1cbiAgICAgIHRoaXMuU1RSSURFID0gdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFByb2dyYW0sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIGtpbGxQcm9ncmFtKHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgICBpZiAodGhpcy5waWNrUHJvZ3JhbSkge1xuICAgICAgICBraWxsUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5waWNrUHJvZ3JhbSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFByb2dyYW1JbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByb2dyYW1JbmZvKG5hbWUsIGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UsIGZyYWdtZW50U2hhZGVyU291cmNlLCBmcmFtZUJ1ZmZlcikge1xuICAgICAgdmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAvLyBXZWJHTCBidWZmZXJzXG4gICAgICB2YXIgYnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICBpZiAoYnVmZmVyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgV2ViR0wgYnVmZmVyLlwiKTtcblxuICAgICAgLy8gU2hhZGVycyBhbmQgcHJvZ3JhbVxuICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGxvYWRWZXJ0ZXhTaGFkZXIoZ2wsIHZlcnRleFNoYWRlclNvdXJjZSk7XG4gICAgICB2YXIgZnJhZ21lbnRTaGFkZXIgPSBsb2FkRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgIHZhciBwcm9ncmFtID0gbG9hZFByb2dyYW0oZ2wsIFt2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyXSk7XG5cbiAgICAgIC8vIEluaXRpYWxpemluZyBsb2NhdGlvbnNcbiAgICAgIHZhciB1bmlmb3JtTG9jYXRpb25zID0ge307XG4gICAgICBkZWYuVU5JRk9STVMuZm9yRWFjaChmdW5jdGlvbiAodW5pZm9ybU5hbWUpIHtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICAgICAgaWYgKGxvY2F0aW9uKSB1bmlmb3JtTG9jYXRpb25zW3VuaWZvcm1OYW1lXSA9IGxvY2F0aW9uO1xuICAgICAgfSk7XG4gICAgICB2YXIgYXR0cmlidXRlTG9jYXRpb25zID0ge307XG4gICAgICBkZWYuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0ci5uYW1lKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGb3IgaW5zdGFuY2VkIHByb2dyYW1zOlxuICAgICAgdmFyIGNvbnN0YW50QnVmZmVyO1xuICAgICAgaWYgKFwiQ09OU1RBTlRfQVRUUklCVVRFU1wiIGluIGRlZikge1xuICAgICAgICBkZWYuQ09OU1RBTlRfQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zW2F0dHIubmFtZV0gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3RhbnRCdWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKGNvbnN0YW50QnVmZmVyID09PSBudWxsKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgV2ViR0wgY29uc3RhbnQgYnVmZmVyLlwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIHByb2dyYW06IHByb2dyYW0sXG4gICAgICAgIGdsOiBnbCxcbiAgICAgICAgZnJhbWVCdWZmZXI6IGZyYW1lQnVmZmVyLFxuICAgICAgICBidWZmZXI6IGJ1ZmZlcixcbiAgICAgICAgY29uc3RhbnRCdWZmZXI6IGNvbnN0YW50QnVmZmVyIHx8IHt9LFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnM6IGF0dHJpYnV0ZUxvY2F0aW9ucyxcbiAgICAgICAgaXNQaWNraW5nOiBuYW1lID09PSBcInBpY2tcIixcbiAgICAgICAgdmVydGV4U2hhZGVyOiB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyOiBmcmFnbWVudFNoYWRlclxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZFByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbS5nbCxcbiAgICAgICAgYnVmZmVyID0gcHJvZ3JhbS5idWZmZXI7XG4gICAgICBpZiAoIXRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCArPSBfdGhpcy5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCk7XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hcnJheSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEhhbmRsZSBjb25zdGFudCBkYXRhICh0aGluZ3MgdGhhdCByZW1haW4gdW5jaGFuZ2VkIGZvciBhbGwgaXRlbXMpOlxuICAgICAgICBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgcHJvZ3JhbS5jb25zdGFudEJ1ZmZlcik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCArPSBfdGhpcy5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuY29uc3RhbnRBcnJheSwgZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgIC8vIEhhbmRsZSBcImluc3RhbmNlIHNwZWNpZmljXCIgZGF0YSAodGhpbmdzIHRoYXQgdmFyeSBmb3IgZWFjaCBpdGVtKTpcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHByb2dyYW0uYnVmZmVyKTtcbiAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gb2Zmc2V0ICs9IF90aGlzLmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgb2Zmc2V0LCB0cnVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmFycmF5LCBnbC5EWU5BTUlDX0RSQVcpO1xuICAgICAgfVxuICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIG51bGwpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZFByb2dyYW0ocHJvZ3JhbSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgICAgdGhpcy5BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi51bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJiaW5kQXR0cmlidXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgb2Zmc2V0LCBzZXREaXZpc29yKSB7XG4gICAgICB2YXIgc2l6ZUZhY3RvciA9IFNJWkVfRkFDVE9SX1BFUl9BVFRSSUJVVEVfVFlQRVthdHRyLnR5cGVdO1xuICAgICAgaWYgKHR5cGVvZiBzaXplRmFjdG9yICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtLmJpbmQ6IHlldCB1bnN1cHBvcnRlZCBhdHRyaWJ1dGUgdHlwZSBcXFwiXCIuY29uY2F0KGF0dHIudHlwZSwgXCJcXFwiXCIpKTtcbiAgICAgIHZhciBsb2NhdGlvbiA9IHByb2dyYW0uYXR0cmlidXRlTG9jYXRpb25zW2F0dHIubmFtZV07XG4gICAgICB2YXIgZ2wgPSBwcm9ncmFtLmdsO1xuICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIHZhciBzdHJpZGUgPSAhdGhpcy5pc0luc3RhbmNlZCA/IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCAqIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCA6IChzZXREaXZpc29yID8gdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UIDogZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQodGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTKSkgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQ7XG4gICAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jYXRpb24sIGF0dHIuc2l6ZSwgYXR0ci50eXBlLCBhdHRyLm5vcm1hbGl6ZWQgfHwgZmFsc2UsIHN0cmlkZSwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgc2V0RGl2aXNvcikge1xuICAgICAgICAgIGlmIChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICAgIGlmIChleHQpIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUobG9jYXRpb24sIDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHIuc2l6ZSAqIHNpemVGYWN0b3I7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSwgdW5zZXREaXZpc29yKSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdO1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbS5nbDtcbiAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgZ2wuZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY2F0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQgJiYgdW5zZXREaXZpc29yKSB7XG4gICAgICAgICAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZ2wudmVydGV4QXR0cmliRGl2aXNvcihsb2NhdGlvbiwgMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgICAgICAgaWYgKGV4dCkgZXh0LnZlcnRleEF0dHJpYkRpdmlzb3JBTkdMRShsb2NhdGlvbiwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlYWxsb2NhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVhbGxvY2F0ZShjYXBhY2l0eSkge1xuICAgICAgLy8gSWYgZGVzaXJlZCBjYXBhY2l0eSBoYXMgbm90IGNoYW5nZWQgd2UgZG8gbm90aGluZ1xuICAgICAgLy8gTk9URTogaXQncyBwb3NzaWJsZSBoZXJlIHRvIGltcGxlbWVudCBtb3JlIHN1YnRsZSByZWFsbG9jYXRpb24gc2NoZW1lc1xuICAgICAgLy8gd2hlbiB0aGUgbnVtYmVyIG9mIHJlbmRlcmVkIGl0ZW1zIGluY3JlYXNlIG9yIGRlY3JlYXNlXG4gICAgICBpZiAoY2FwYWNpdHkgPT09IHRoaXMuY2FwYWNpdHkpIHJldHVybjtcbiAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgIHRoaXMudmVydGljZXNDb3VudCA9IHRoaXMuVkVSVElDRVMgKiBjYXBhY2l0eTtcbiAgICAgIHRoaXMuYXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KCF0aGlzLmlzSW5zdGFuY2VkID8gdGhpcy52ZXJ0aWNlc0NvdW50ICogdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UIDogdGhpcy5jYXBhY2l0eSAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhc05vdGhpbmdUb1JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNOb3RoaW5nVG9SZW5kZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXJ0aWNlc0NvdW50ID09PSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlclByb2dyYW0ocGFyYW1zLCBwcm9ncmFtSW5mbykge1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbUluZm8uZ2wsXG4gICAgICAgIHByb2dyYW0gPSBwcm9ncmFtSW5mby5wcm9ncmFtO1xuXG4gICAgICAvLyBXaXRoIHRoZSBjdXJyZW50IGZpeCBmb3IgIzEzOTcsIHRoZSBhbHBoYSBibGVuZGluZyBpcyBlbmFibGVkIGZvciB0aGVcbiAgICAgIC8vIHBpY2tpbmcgbGF5ZXI6XG4gICAgICBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuXG4gICAgICAvLyBPcmlnaW5hbCBjb2RlOlxuICAgICAgLy8gaWYgKCFpc1BpY2tpbmcpIGdsLmVuYWJsZShnbC5CTEVORCk7XG4gICAgICAvLyBlbHNlIGdsLmRpc2FibGUoZ2wuQkxFTkQpO1xuXG4gICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgdGhpcy5zZXRVbmlmb3JtcyhwYXJhbXMsIHByb2dyYW1JbmZvKTtcbiAgICAgIHRoaXMuZHJhd1dlYkdMKHRoaXMuTUVUSE9ELCBwcm9ncmFtSW5mbyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFyYW1zKSB7XG4gICAgICBpZiAodGhpcy5oYXNOb3RoaW5nVG9SZW5kZXIoKSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMucGlja1Byb2dyYW0pIHtcbiAgICAgICAgdGhpcy5waWNrUHJvZ3JhbS5nbC52aWV3cG9ydCgwLCAwLCBwYXJhbXMud2lkdGggKiBwYXJhbXMucGl4ZWxSYXRpbyAvIHBhcmFtcy5kb3duU2l6aW5nUmF0aW8sIHBhcmFtcy5oZWlnaHQgKiBwYXJhbXMucGl4ZWxSYXRpbyAvIHBhcmFtcy5kb3duU2l6aW5nUmF0aW8pO1xuICAgICAgICB0aGlzLmJpbmRQcm9ncmFtKHRoaXMucGlja1Byb2dyYW0pO1xuICAgICAgICB0aGlzLnJlbmRlclByb2dyYW0oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHBhcmFtcyksIHt9LCB7XG4gICAgICAgICAgcGl4ZWxSYXRpbzogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvXG4gICAgICAgIH0pLCB0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgICAgdGhpcy51bmJpbmRQcm9ncmFtKHRoaXMucGlja1Byb2dyYW0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxQcm9ncmFtLmdsLnZpZXdwb3J0KDAsIDAsIHBhcmFtcy53aWR0aCAqIHBhcmFtcy5waXhlbFJhdGlvLCBwYXJhbXMuaGVpZ2h0ICogcGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgdGhpcy5iaW5kUHJvZ3JhbSh0aGlzLm5vcm1hbFByb2dyYW0pO1xuICAgICAgdGhpcy5yZW5kZXJQcm9ncmFtKHBhcmFtcywgdGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICAgIHRoaXMudW5iaW5kUHJvZ3JhbSh0aGlzLm5vcm1hbFByb2dyYW0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3V2ViR0xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZHJhd1dlYkdMKG1ldGhvZCwgX3JlZikge1xuICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgZnJhbWVCdWZmZXIgPSBfcmVmLmZyYW1lQnVmZmVyO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBpZiAoIXRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgICAgZ2wuZHJhd0FycmF5cyhtZXRob2QsIDAsIHRoaXMudmVydGljZXNDb3VudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgZ2wuZHJhd0FycmF5c0luc3RhbmNlZChtZXRob2QsIDAsIHRoaXMuVkVSVElDRVMsIHRoaXMuY2FwYWNpdHkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBleHQgPSBnbC5nZXRFeHRlbnNpb24oXCJBTkdMRV9pbnN0YW5jZWRfYXJyYXlzXCIpO1xuICAgICAgICAgIGlmIChleHQpIGV4dC5kcmF3QXJyYXlzSW5zdGFuY2VkQU5HTEUobWV0aG9kLCAwLCB0aGlzLlZFUlRJQ0VTLCB0aGlzLmNhcGFjaXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xufSgpO1xuXG52YXIgQWJzdHJhY3ROb2RlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0UHJvZ3JhbSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdE5vZGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdE5vZGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBBYnN0cmFjdE5vZGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhBYnN0cmFjdE5vZGVQcm9ncmFtLCBfQWJzdHJhY3RQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBYnN0cmFjdE5vZGVQcm9ncmFtKTtcbn0oQWJzdHJhY3RQcm9ncmFtKTtcbnZhciBOb2RlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3JlZikge1xuICBmdW5jdGlvbiBOb2RlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE5vZGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhOb2RlUHJvZ3JhbSwgX3JlZik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoTm9kZVByb2dyYW0sIFwia2lsbFwiLCB0aGlzLCAzKShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyhub2RlSW5kZXgsIG9mZnNldCwgZGF0YSkge1xuICAgICAgdmFyIGkgPSBvZmZzZXQgKiB0aGlzLlNUUklERTtcbiAgICAgIC8vIE5PVEU6IGRlYWxpbmcgd2l0aCBoaWRkZW4gaXRlbXMgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGRhdGEuaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBpICsgdGhpcy5TVFJJREU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFycmF5W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzVmlzaWJsZUl0ZW0oaW5kZXhUb0NvbG9yKG5vZGVJbmRleCksIGksIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xufShQcm9ncmFtKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGNvbWJpbmluZyB0d28gb3IgbW9yZSBwcm9ncmFtcyBpbnRvIGEgc2luZ2xlIGNvbXBvdW5kIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG1vcmUgYSBxdWljayAmIGVhc3kgd2F5IHRvIGNvbWJpbmUgcHJvZ3JhbSB0aGFuIGEgcmVhbGx5XG4gKiBwZXJmb3JtYW50IG9wdGlvbi4gTW9yZSBwZXJmb3JtYW50IHByb2dyYW1zIGNhbiBiZSB3cml0dGVuIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBwcm9ncmFtQ2xhc3NlcyAtIFByb2dyYW0gY2xhc3NlcyB0byBjb21iaW5lLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdMYWJlbCAtIEFuIG9wdGlvbmFsIG5vZGUgXCJkcmF3IGxhYmVsXCIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZHJhd0hvdmVyIC0gQW4gb3B0aW9uYWwgbm9kZSBcImRyYXcgaG92ZXJcIiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ29tcG91bmRQcm9ncmFtKHByb2dyYW1DbGFzc2VzLCBkcmF3TGFiZWwsIGRyYXdIb3Zlcikge1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlQ29tcG91bmRQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDb21wb3VuZFByb2dyYW0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0xhYmVsXCIsIGRyYXdMYWJlbCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3SG92ZXJcIiwgZHJhd0hvdmVyKTtcbiAgICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhOb2RlQ29tcG91bmRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcInJlYWxsb2NhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFsbG9jYXRlKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlYWxsb2NhdGUoY2FwYWNpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucHJvY2Vzcyhub2RlSW5kZXgsIG9mZnNldCwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlbmRlcihwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2lsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG59XG5cbnZhciBBYnN0cmFjdEVkZ2VQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RQcm9ncmFtKSB7XG4gIGZ1bmN0aW9uIEFic3RyYWN0RWRnZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFic3RyYWN0RWRnZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEFic3RyYWN0RWRnZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKEFic3RyYWN0RWRnZVByb2dyYW0sIF9BYnN0cmFjdFByb2dyYW0pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFic3RyYWN0RWRnZVByb2dyYW0pO1xufShBYnN0cmFjdFByb2dyYW0pO1xudmFyIEVkZ2VQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIGZ1bmN0aW9uIEVkZ2VQcm9ncmFtKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZVByb2dyYW0pO1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VQcm9ncmFtLCBbXS5jb25jYXQoYXJncykpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkcmF3TGFiZWxcIiwgdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKEVkZ2VQcm9ncmFtLCBfcmVmKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgX3N1cGVyUHJvcEdldChFZGdlUHJvZ3JhbSwgXCJraWxsXCIsIHRoaXMsIDMpKFtdKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGVkZ2VJbmRleCwgb2Zmc2V0LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgaSA9IG9mZnNldCAqIHRoaXMuU1RSSURFO1xuICAgICAgLy8gTk9URTogZGVhbGluZyB3aXRoIGhpZGRlbiBpdGVtcyBhdXRvbWF0aWNhbGx5XG4gICAgICBpZiAoZGF0YS5oaWRkZW4gfHwgc291cmNlRGF0YS5oaWRkZW4gfHwgdGFyZ2V0RGF0YS5oaWRkZW4pIHtcbiAgICAgICAgZm9yICh2YXIgbCA9IGkgKyB0aGlzLlNUUklERTsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHRoaXMuYXJyYXlbaV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NWaXNpYmxlSXRlbShpbmRleFRvQ29sb3IoZWRnZUluZGV4KSwgaSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSk7XG4gICAgfVxuICB9XSk7XG59KFByb2dyYW0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gY29tYmluaW5nIHR3byBvciBtb3JlIHByb2dyYW1zIGludG8gYSBzaW5nbGUgY29tcG91bmQgb25lLlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbW9yZSBhIHF1aWNrICYgZWFzeSB3YXkgdG8gY29tYmluZSBwcm9ncmFtIHRoYW4gYSByZWFsbHlcbiAqIHBlcmZvcm1hbnQgb3B0aW9uLiBNb3JlIHBlcmZvcm1hbnQgcHJvZ3JhbXMgY2FuIGJlIHdyaXR0ZW4gZW50aXJlbHkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9ICAgIHByb2dyYW1DbGFzc2VzIC0gUHJvZ3JhbSBjbGFzc2VzIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZHJhd0xhYmVsIC0gQW4gb3B0aW9uYWwgZWRnZSBcImRyYXcgbGFiZWxcIiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKHByb2dyYW1DbGFzc2VzLCBkcmF3TGFiZWwpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRnZUNvbXBvdW5kUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQ29tcG91bmRQcm9ncmFtKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdMYWJlbFwiLCBkcmF3TGFiZWwpO1xuICAgICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoUHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VDb21wb3VuZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwicmVhbGxvY2F0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVhbGxvY2F0ZShjYXBhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5wcm9jZXNzKGVkZ2VJbmRleCwgb2Zmc2V0LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJraWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oKTtcbn1cblxuZnVuY3Rpb24gZHJhd1N0cmFpZ2h0RWRnZUxhYmVsKGNvbnRleHQsIGVkZ2VEYXRhLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBzZXR0aW5ncykge1xuICB2YXIgc2l6ZSA9IHNldHRpbmdzLmVkZ2VMYWJlbFNpemUsXG4gICAgZm9udCA9IHNldHRpbmdzLmVkZ2VMYWJlbEZvbnQsXG4gICAgd2VpZ2h0ID0gc2V0dGluZ3MuZWRnZUxhYmVsV2VpZ2h0LFxuICAgIGNvbG9yID0gc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuYXR0cmlidXRlID8gZWRnZURhdGFbc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuYXR0cmlidXRlXSB8fCBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5jb2xvciB8fCBcIiMwMDBcIiA6IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmNvbG9yO1xuICB2YXIgbGFiZWwgPSBlZGdlRGF0YS5sYWJlbDtcbiAgaWYgKCFsYWJlbCkgcmV0dXJuO1xuICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICBjb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnQpO1xuXG4gIC8vIENvbXB1dGluZyBwb3NpdGlvbnMgd2l0aG91dCBjb25zaWRlcmluZyBub2RlcyBzaXplczpcbiAgdmFyIHNTaXplID0gc291cmNlRGF0YS5zaXplO1xuICB2YXIgdFNpemUgPSB0YXJnZXREYXRhLnNpemU7XG4gIHZhciBzeCA9IHNvdXJjZURhdGEueDtcbiAgdmFyIHN5ID0gc291cmNlRGF0YS55O1xuICB2YXIgdHggPSB0YXJnZXREYXRhLng7XG4gIHZhciB0eSA9IHRhcmdldERhdGEueTtcbiAgdmFyIGN4ID0gKHN4ICsgdHgpIC8gMjtcbiAgdmFyIGN5ID0gKHN5ICsgdHkpIC8gMjtcbiAgdmFyIGR4ID0gdHggLSBzeDtcbiAgdmFyIGR5ID0gdHkgLSBzeTtcbiAgdmFyIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICBpZiAoZCA8IHNTaXplICsgdFNpemUpIHJldHVybjtcblxuICAvLyBBZGRpbmcgbm9kZXMgc2l6ZXM6XG4gIHN4ICs9IGR4ICogc1NpemUgLyBkO1xuICBzeSArPSBkeSAqIHNTaXplIC8gZDtcbiAgdHggLT0gZHggKiB0U2l6ZSAvIGQ7XG4gIHR5IC09IGR5ICogdFNpemUgLyBkO1xuICBjeCA9IChzeCArIHR4KSAvIDI7XG4gIGN5ID0gKHN5ICsgdHkpIC8gMjtcbiAgZHggPSB0eCAtIHN4O1xuICBkeSA9IHR5IC0gc3k7XG4gIGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gIC8vIEhhbmRsaW5nIGVsbGlwc2lzXG4gIHZhciB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gIGlmICh0ZXh0TGVuZ3RoID4gZCkge1xuICAgIHZhciBlbGxpcHNpcyA9IFwi4oCmXCI7XG4gICAgbGFiZWwgPSBsYWJlbCArIGVsbGlwc2lzO1xuICAgIHRleHRMZW5ndGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICB3aGlsZSAodGV4dExlbmd0aCA+IGQgJiYgbGFiZWwubGVuZ3RoID4gMSkge1xuICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCAtMikgKyBlbGxpcHNpcztcbiAgICAgIHRleHRMZW5ndGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgICB9XG4gICAgaWYgKGxhYmVsLmxlbmd0aCA8IDQpIHJldHVybjtcbiAgfVxuICB2YXIgYW5nbGU7XG4gIGlmIChkeCA+IDApIHtcbiAgICBpZiAoZHkgPiAwKSBhbmdsZSA9IE1hdGguYWNvcyhkeCAvIGQpO2Vsc2UgYW5nbGUgPSBNYXRoLmFzaW4oZHkgLyBkKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZHkgPiAwKSBhbmdsZSA9IE1hdGguYWNvcyhkeCAvIGQpICsgTWF0aC5QSTtlbHNlIGFuZ2xlID0gTWF0aC5hc2luKGR4IC8gZCkgKyBNYXRoLlBJIC8gMjtcbiAgfVxuICBjb250ZXh0LnNhdmUoKTtcbiAgY29udGV4dC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuICBjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAtdGV4dExlbmd0aCAvIDIsIGVkZ2VEYXRhLnNpemUgLyAyICsgc2l6ZSk7XG4gIGNvbnRleHQucmVzdG9yZSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3RGlzY05vZGVMYWJlbChjb250ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICBpZiAoIWRhdGEubGFiZWwpIHJldHVybjtcbiAgdmFyIHNpemUgPSBzZXR0aW5ncy5sYWJlbFNpemUsXG4gICAgZm9udCA9IHNldHRpbmdzLmxhYmVsRm9udCxcbiAgICB3ZWlnaHQgPSBzZXR0aW5ncy5sYWJlbFdlaWdodCxcbiAgICBjb2xvciA9IHNldHRpbmdzLmxhYmVsQ29sb3IuYXR0cmlidXRlID8gZGF0YVtzZXR0aW5ncy5sYWJlbENvbG9yLmF0dHJpYnV0ZV0gfHwgc2V0dGluZ3MubGFiZWxDb2xvci5jb2xvciB8fCBcIiMwMDBcIiA6IHNldHRpbmdzLmxhYmVsQ29sb3IuY29sb3I7XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG4gIGNvbnRleHQuZmlsbFRleHQoZGF0YS5sYWJlbCwgZGF0YS54ICsgZGF0YS5zaXplICsgMywgZGF0YS55ICsgc2l6ZSAvIDMpO1xufVxuXG4vKipcbiAqIERyYXcgYW4gaG92ZXJlZCBub2RlLlxuICogLSBpZiB0aGVyZSBpcyBubyBsYWJlbCA9PiBkaXNwbGF5IGEgc2hhZG93IG9uIHRoZSBub2RlXG4gKiAtIGlmIHRoZSBsYWJlbCBib3ggaXMgYmlnZ2VyIHRoYW4gbm9kZSBzaXplID0+IGRpc3BsYXkgYSBsYWJlbCBib3ggdGhhdCBjb250YWlucyB0aGUgbm9kZSB3aXRoIGEgc2hhZG93XG4gKiAtIGVsc2Ugbm9kZSB3aXRoIHNoYWRvdyBhbmQgdGhlIGxhYmVsIGJveFxuICovXG5mdW5jdGlvbiBkcmF3RGlzY05vZGVIb3Zlcihjb250ZXh0LCBkYXRhLCBzZXR0aW5ncykge1xuICB2YXIgc2l6ZSA9IHNldHRpbmdzLmxhYmVsU2l6ZSxcbiAgICBmb250ID0gc2V0dGluZ3MubGFiZWxGb250LFxuICAgIHdlaWdodCA9IHNldHRpbmdzLmxhYmVsV2VpZ2h0O1xuICBjb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnQpO1xuXG4gIC8vIFRoZW4gd2UgZHJhdyB0aGUgbGFiZWwgYmFja2dyb3VuZFxuICBjb250ZXh0LmZpbGxTdHlsZSA9IFwiI0ZGRlwiO1xuICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICBjb250ZXh0LnNoYWRvd0JsdXIgPSA4O1xuICBjb250ZXh0LnNoYWRvd0NvbG9yID0gXCIjMDAwXCI7XG4gIHZhciBQQURESU5HID0gMjtcbiAgaWYgKHR5cGVvZiBkYXRhLmxhYmVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgdmFyIHRleHRXaWR0aCA9IGNvbnRleHQubWVhc3VyZVRleHQoZGF0YS5sYWJlbCkud2lkdGgsXG4gICAgICBib3hXaWR0aCA9IE1hdGgucm91bmQodGV4dFdpZHRoICsgNSksXG4gICAgICBib3hIZWlnaHQgPSBNYXRoLnJvdW5kKHNpemUgKyAyICogUEFERElORyksXG4gICAgICByYWRpdXMgPSBNYXRoLm1heChkYXRhLnNpemUsIHNpemUgLyAyKSArIFBBRERJTkc7XG4gICAgdmFyIGFuZ2xlUmFkaWFuID0gTWF0aC5hc2luKGJveEhlaWdodCAvIDIgLyByYWRpdXMpO1xuICAgIHZhciB4RGVsdGFDb29yZCA9IE1hdGguc3FydChNYXRoLmFicyhNYXRoLnBvdyhyYWRpdXMsIDIpIC0gTWF0aC5wb3coYm94SGVpZ2h0IC8gMiwgMikpKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQubW92ZVRvKGRhdGEueCArIHhEZWx0YUNvb3JkLCBkYXRhLnkgKyBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyByYWRpdXMgKyBib3hXaWR0aCwgZGF0YS55ICsgYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgcmFkaXVzICsgYm94V2lkdGgsIGRhdGEueSAtIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHhEZWx0YUNvb3JkLCBkYXRhLnkgLSBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmFyYyhkYXRhLngsIGRhdGEueSwgcmFkaXVzLCBhbmdsZVJhZGlhbiwgLWFuZ2xlUmFkaWFuKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoZGF0YS54LCBkYXRhLnksIGRhdGEuc2l6ZSArIFBBRERJTkcsIDAsIE1hdGguUEkgKiAyKTtcbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuZmlsbCgpO1xuICB9XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gIGNvbnRleHQuc2hhZG93Qmx1ciA9IDA7XG5cbiAgLy8gQW5kIGZpbmFsbHkgd2UgZHJhdyB0aGUgbGFiZWxcbiAgZHJhd0Rpc2NOb2RlTGFiZWwoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpO1xufVxuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ2ID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9kaWZmVmVjdG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7XFxuXFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG5jb25zdCB2ZWM0IHRyYW5zcGFyZW50ID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBmbG9hdCBib3JkZXIgPSB1X2NvcnJlY3Rpb25SYXRpbyAqIDIuMDtcXG4gIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9kaWZmVmVjdG9yKSAtIHZfcmFkaXVzICsgYm9yZGVyO1xcblxcbiAgLy8gTm8gYW50aWFsaWFzaW5nIGZvciBwaWNraW5nIG1vZGU6XFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICBpZiAoZGlzdCA+IGJvcmRlcilcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdHJhbnNwYXJlbnQ7XFxuICBlbHNlXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuXFxuICAjZWxzZVxcbiAgZmxvYXQgdCA9IDAuMDtcXG4gIGlmIChkaXN0ID4gYm9yZGVyKVxcbiAgICB0ID0gMS4wO1xcbiAgZWxzZSBpZiAoZGlzdCA+IDAuMClcXG4gICAgdCA9IGRpc3QgLyBib3JkZXI7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBtaXgodl9jb2xvciwgdHJhbnNwYXJlbnQsIHQpO1xcbiAgI2VuZGlmXFxufVxcblwiO1xudmFyIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMiA9IFNIQURFUl9TT1VSQ0UkNjtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNSA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9zaXplO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2FuZ2xlO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfZGlmZlZlY3RvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO1xcbnZhcnlpbmcgZmxvYXQgdl9ib3JkZXI7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgc2l6ZSA9IGFfc2l6ZSAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW8gKiA0LjA7XFxuICB2ZWMyIGRpZmZWZWN0b3IgPSBzaXplICogdmVjMihjb3MoYV9hbmdsZSksIHNpbihhX2FuZ2xlKSk7XFxuICB2ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvbiArIGRpZmZWZWN0b3I7XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEpKS54eSxcXG4gICAgMCxcXG4gICAgMVxcbiAgKTtcXG5cXG4gIHZfZGlmZlZlY3RvciA9IGRpZmZWZWN0b3I7XFxuICB2X3JhZGl1cyA9IHNpemUgLyAyLjA7XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMyA9IFNIQURFUl9TT1VSQ0UkNTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFJDMgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMy5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCQzID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMuRkxPQVQ7XG52YXIgVU5JRk9STVMkMyA9IFtcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X21hdHJpeFwiXTtcbnZhciBOb2RlQ2lyY2xlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVQcm9ncmFtKSB7XG4gIGZ1bmN0aW9uIE5vZGVDaXJjbGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ2lyY2xlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgTm9kZUNpcmNsZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKE5vZGVDaXJjbGVQcm9ncmFtLCBfTm9kZVByb2dyYW0pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5vZGVDaXJjbGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogMyxcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDMsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMixcbiAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICBVTklGT1JNUzogVU5JRk9STVMkMyxcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25cIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDNcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9zaXplXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMyxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMyxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9hbmdsZVwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfREFUQTogW1tOb2RlQ2lyY2xlUHJvZ3JhbS5BTkdMRV8xXSwgW05vZGVDaXJjbGVQcm9ncmFtLkFOR0xFXzJdLCBbTm9kZUNpcmNsZVByb2dyYW0uQU5HTEVfM11dXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKG5vZGVJbmRleCwgc3RhcnRJbmRleCwgZGF0YSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS54O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEueTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnNpemU7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbm9kZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeDtcbiAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgIH1cbiAgfV0pO1xufShOb2RlUHJvZ3JhbSk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfMVwiLCAwKTtcbl9kZWZpbmVQcm9wZXJ0eShOb2RlQ2lyY2xlUHJvZ3JhbSwgXCJBTkdMRV8yXCIsIDIgKiBNYXRoLlBJIC8gMyk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfM1wiLCA0ICogTWF0aC5QSSAvIDMpO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ0ID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDEgPSBTSEFERVJfU09VUkNFJDQ7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDMgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7XFxuYXR0cmlidXRlIHZlYzMgYV9iYXJ5Y2VudHJpYztcXG5cXG4jaWZkZWYgUElDS0lOR19NT0RFXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG4jZWxzZVxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfbWluRWRnZVRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG1pblRoaWNrbmVzcyA9IHVfbWluRWRnZVRoaWNrbmVzcztcXG5cXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChhX25vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBhX25vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFRoZXNlIGZpcnN0IGNvbXB1dGF0aW9ucyBhcmUgdGFrZW4gZnJvbSBlZGdlLnZlcnQuZ2xzbCBhbmRcXG4gIC8vIGVkZ2UuY2xhbXBlZC52ZXJ0Lmdsc2wuIFBsZWFzZSByZWFkIGl0IHRvIGdldCBiZXR0ZXIgY29tbWVudHMgb24gd2hhdCdzXFxuICAvLyBoYXBwZW5pbmc6XFxuICBmbG9hdCBwaXhlbHNUaGlja25lc3MgPSBtYXgobm9ybWFsTGVuZ3RoIC8gdV9zaXplUmF0aW8sIG1pblRoaWNrbmVzcyk7XFxuICBmbG9hdCB3ZWJHTFRoaWNrbmVzcyA9IHBpeGVsc1RoaWNrbmVzcyAqIHVfY29ycmVjdGlvblJhdGlvO1xcbiAgZmxvYXQgd2ViR0xOb2RlUmFkaXVzID0gYV9yYWRpdXMgKiAyLjAgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcbiAgZmxvYXQgd2ViR0xBcnJvd0hlYWRMZW5ndGggPSB3ZWJHTFRoaWNrbmVzcyAqIHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyAqIDIuMDtcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzID0gd2ViR0xUaGlja25lc3MgKiB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcXG5cXG4gIGZsb2F0IGRhID0gYV9iYXJ5Y2VudHJpYy54O1xcbiAgZmxvYXQgZGIgPSBhX2JhcnljZW50cmljLnk7XFxuICBmbG9hdCBkYyA9IGFfYmFyeWNlbnRyaWMuejtcXG5cXG4gIHZlYzIgZGVsdGEgPSB2ZWMyKFxcbiAgICAgIGRhICogKHdlYkdMTm9kZVJhZGl1cyAqIHVuaXROb3JtYWwueSlcXG4gICAgKyBkYiAqICgod2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC55ICsgd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgKiB1bml0Tm9ybWFsLngpXFxuICAgICsgZGMgKiAoKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueSAtIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC54KSxcXG5cXG4gICAgICBkYSAqICgtd2ViR0xOb2RlUmFkaXVzICogdW5pdE5vcm1hbC54KVxcbiAgICArIGRiICogKC0od2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC54ICsgd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgKiB1bml0Tm9ybWFsLnkpXFxuICAgICsgZGMgKiAoLSh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnggLSB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyAqIHVuaXROb3JtYWwueSlcXG4gICk7XFxuXFxuICB2ZWMyIHBvc2l0aW9uID0gKHVfbWF0cml4ICogdmVjMyhhX3Bvc2l0aW9uICsgZGVsdGEsIDEpKS54eTtcXG5cXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChwb3NpdGlvbiwgMCwgMSk7XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMiA9IFNIQURFUl9TT1VSQ0UkMztcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFJDIgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMi5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCQyID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIuRkxPQVQ7XG52YXIgVU5JRk9STVMkMiA9IFtcInVfbWF0cml4XCIsIFwidV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfbWluRWRnZVRoaWNrbmVzc1wiLCBcInVfbGVuZ3RoVG9UaGlja25lc3NSYXRpb1wiLCBcInVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvXCJdO1xudmFyIERFRkFVTFRfRURHRV9BUlJPV19IRUFEX1BST0dSQU1fT1BUSU9OUyA9IHtcbiAgZXh0cmVtaXR5OiBcInRhcmdldFwiLFxuICBsZW5ndGhUb1RoaWNrbmVzc1JhdGlvOiAyLjUsXG4gIHdpZGVuZXNzVG9UaGlja25lc3NSYXRpbzogMlxufTtcbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtKGlucHV0T3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMpLCBpbnB1dE9wdGlvbnMgfHwge30pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgICBmdW5jdGlvbiBFZGdlQXJyb3dIZWFkUHJvZ3JhbSgpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQXJyb3dIZWFkUHJvZ3JhbSk7XG4gICAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2luaGVyaXRzKEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBfRWRnZVByb2dyYW0pO1xuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZUFycm93SGVhZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSQxLFxuICAgICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgICBVTklGT1JNUzogVU5JRk9STVMkMixcbiAgICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3JhZGl1c1wiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDIsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQyLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfYmFyeWNlbnRyaWNcIixcbiAgICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfV0sXG4gICAgICAgICAgQ09OU1RBTlRfREFUQTogW1sxLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgMCwgMV1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuZXh0cmVtaXR5ID09PSBcInNvdXJjZVwiKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBbdGFyZ2V0RGF0YSwgc291cmNlRGF0YV07XG4gICAgICAgICAgc291cmNlRGF0YSA9IF9yZWZbMF07XG4gICAgICAgICAgdGFyZ2V0RGF0YSA9IF9yZWZbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRoaWNrbmVzcyA9IGRhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGFyZ2V0RGF0YS5zaXplIHx8IDE7XG4gICAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcblxuICAgICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciBuMSA9IDA7XG4gICAgICAgIHZhciBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IC1uMTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IC1uMjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHJhZGl1cztcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZjIpIHtcbiAgICAgICAgdmFyIGdsID0gX3JlZjIuZ2wsXG4gICAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYyLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICAgIHZhciB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgICAgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcyxcbiAgICAgICAgICB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyxcbiAgICAgICAgICB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW87XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfY29ycmVjdGlvblJhdGlvLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW8sIG9wdGlvbnMud2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gIH0oRWRnZVByb2dyYW0pO1xufVxudmFyIEVkZ2VBcnJvd0hlYWRQcm9ncmFtID0gY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oKTtcbnZhciBFZGdlQXJyb3dIZWFkUHJvZ3JhbSQxID0gRWRnZUFycm93SGVhZFByb2dyYW07XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDIgPSAvKmdsc2wqL1wiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxudmFyeWluZyBmbG9hdCB2X2ZlYXRoZXI7XFxuXFxuY29uc3QgdmVjNCB0cmFuc3BhcmVudCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgLy8gV2Ugb25seSBoYW5kbGUgYW50aWFsaWFzaW5nIGZvciBub3JtYWwgbW9kZTpcXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuICAjZWxzZVxcbiAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X25vcm1hbCkgKiB2X3RoaWNrbmVzcztcXG5cXG4gIGZsb2F0IHQgPSBzbW9vdGhzdGVwKFxcbiAgICB2X3RoaWNrbmVzcyAtIHZfZmVhdGhlcixcXG4gICAgdl90aGlja25lc3MsXFxuICAgIGRpc3RcXG4gICk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBtaXgodl9jb2xvciwgdHJhbnNwYXJlbnQsIHQpO1xcbiAgI2VuZGlmXFxufVxcblwiO1xudmFyIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgPSBTSEFERVJfU09VUkNFJDI7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDEgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX25vcm1hbENvZWY7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvblN0YXJ0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25FbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcG9zaXRpb25Db2VmO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1cztcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXNDb2VmO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfem9vbVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfbWluRWRnZVRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfZmVhdGhlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBtaW5UaGlja25lc3MgPSB1X21pbkVkZ2VUaGlja25lc3M7XFxuXFxuICBmbG9hdCByYWRpdXMgPSBhX3JhZGl1cyAqIGFfcmFkaXVzQ29lZjtcXG4gIHZlYzIgbm9ybWFsID0gYV9ub3JtYWwgKiBhX25vcm1hbENvZWY7XFxuICB2ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvblN0YXJ0ICogKDEuMCAtIGFfcG9zaXRpb25Db2VmKSArIGFfcG9zaXRpb25FbmQgKiBhX3Bvc2l0aW9uQ29lZjtcXG5cXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0b1xcbiAgLy8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3MgaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zaXplUmF0aW8pO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgLy8gSGVyZSwgd2UgbW92ZSB0aGUgcG9pbnQgdG8gbGVhdmUgc3BhY2UgZm9yIHRoZSBhcnJvdyBoZWFkOlxcbiAgZmxvYXQgZGlyZWN0aW9uID0gc2lnbihyYWRpdXMpO1xcbiAgZmxvYXQgd2ViR0xOb2RlUmFkaXVzID0gZGlyZWN0aW9uICogcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gKiAyLjA7XFxuXFxuICB2ZWMyIGNvbXBlbnNhdGlvblZlY3RvciA9IHZlYzIoLWRpcmVjdGlvbiAqIHVuaXROb3JtYWwueSwgZGlyZWN0aW9uICogdW5pdE5vcm1hbC54KSAqICh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCk7XFxuXFxuICAvLyBIZXJlIGlzIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHZlcnRleFxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24gKyB1bml0Tm9ybWFsICogd2ViR0xUaGlja25lc3MgKyBjb21wZW5zYXRpb25WZWN0b3IsIDEpKS54eSwgMCwgMSk7XFxuXFxuICB2X3RoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzIC8gdV96b29tUmF0aW87XFxuXFxuICB2X25vcm1hbCA9IHVuaXROb3JtYWw7XFxuXFxuICB2X2ZlYXRoZXIgPSB1X2ZlYXRoZXIgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfem9vbVJhdGlvIC8gdV9waXhlbFJhdGlvICogMi4wO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDEgPSBTSEFERVJfU09VUkNFJDE7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMSA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQxID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLkZMT0FUO1xudmFyIFVOSUZPUk1TJDEgPSBbXCJ1X21hdHJpeFwiLCBcInVfem9vbVJhdGlvXCIsIFwidV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfcGl4ZWxSYXRpb1wiLCBcInVfZmVhdGhlclwiLCBcInVfbWluRWRnZVRoaWNrbmVzc1wiLCBcInVfbGVuZ3RoVG9UaGlja25lc3NSYXRpb1wiXTtcbnZhciBERUZBVUxUX0VER0VfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMgPSB7XG4gIGxlbmd0aFRvVGhpY2tuZXNzUmF0aW86IERFRkFVTFRfRURHRV9BUlJPV19IRUFEX1BST0dSQU1fT1BUSU9OUy5sZW5ndGhUb1RoaWNrbmVzc1JhdGlvXG59O1xuZnVuY3Rpb24gY3JlYXRlRWRnZUNsYW1wZWRQcm9ncmFtKGlucHV0T3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0VER0VfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMpLCBpbnB1dE9wdGlvbnMgfHwge30pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgICBmdW5jdGlvbiBFZGdlQ2xhbXBlZFByb2dyYW0oKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUNsYW1wZWRQcm9ncmFtKTtcbiAgICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VDbGFtcGVkUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2luaGVyaXRzKEVkZ2VDbGFtcGVkUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VDbGFtcGVkUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBWRVJUSUNFUzogNixcbiAgICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UkMSxcbiAgICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFLFxuICAgICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgICBVTklGT1JNUzogVU5JRk9STVMkMSxcbiAgICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uU3RhcnRcIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uRW5kXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcmFkaXVzXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFtcbiAgICAgICAgICAvLyBJZiAwLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvblN0YXJ0XG4gICAgICAgICAgLy8gSWYgMSwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25FbmRcbiAgICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25Db2VmXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxDb2VmXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNDb2VmXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH1dLFxuICAgICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMCwgMSwgMF0sIFswLCAtMSwgMF0sIFsxLCAxLCAxXSwgWzEsIDEsIDFdLCBbMCwgLTEsIDBdLCBbMSwgLTEsIC0xXV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKGVkZ2VJbmRleCwgc3RhcnRJbmRleCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcblxuICAgICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgICAgICB2YXIgcmFkaXVzID0gdGFyZ2V0RGF0YS5zaXplIHx8IDE7XG4gICAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgdmFyIG4xID0gMDtcbiAgICAgICAgdmFyIG4yID0gMDtcbiAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgICBuMiA9IGR4ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkxO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4xO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHJhZGl1cztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICAgIHVfem9vbVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3pvb21SYXRpbyxcbiAgICAgICAgICB1X2ZlYXRoZXIgPSB1bmlmb3JtTG9jYXRpb25zLnVfZmVhdGhlcixcbiAgICAgICAgICB1X3BpeGVsUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfcGl4ZWxSYXRpbyxcbiAgICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgICAgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICAgIHVfbWluRWRnZVRoaWNrbmVzcyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9taW5FZGdlVGhpY2tuZXNzLFxuICAgICAgICAgIHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3pvb21SYXRpbywgcGFyYW1zLnpvb21SYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3BpeGVsUmF0aW8sIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfZmVhdGhlciwgcGFyYW1zLmFudGlBbGlhc2luZ0ZlYXRoZXIpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9taW5FZGdlVGhpY2tuZXNzLCBwYXJhbXMubWluRWRnZVRoaWNrbmVzcyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8sIG9wdGlvbnMubGVuZ3RoVG9UaGlja25lc3NSYXRpbyk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KEVkZ2VQcm9ncmFtKTtcbn1cbnZhciBFZGdlQ2xhbXBlZFByb2dyYW0gPSBjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0oKTtcbnZhciBFZGdlQ2xhbXBlZFByb2dyYW0kMSA9IEVkZ2VDbGFtcGVkUHJvZ3JhbTtcblxuZnVuY3Rpb24gY3JlYXRlRWRnZUFycm93UHJvZ3JhbShpbnB1dE9wdGlvbnMpIHtcbiAgcmV0dXJuIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0oW2NyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbShpbnB1dE9wdGlvbnMpLCBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbShpbnB1dE9wdGlvbnMpXSk7XG59XG52YXIgRWRnZUFycm93UHJvZ3JhbSA9IGNyZWF0ZUVkZ2VBcnJvd1Byb2dyYW0oKTtcbnZhciBFZGdlQXJyb3dQcm9ncmFtJDEgPSBFZGdlQXJyb3dQcm9ncmFtO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfbm9ybWFsQ29lZjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uU3RhcnQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbkVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9wb3NpdGlvbkNvZWY7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3pvb21SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9taW5FZGdlVGhpY2tuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdV9mZWF0aGVyO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9mZWF0aGVyO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG1pblRoaWNrbmVzcyA9IHVfbWluRWRnZVRoaWNrbmVzcztcXG5cXG4gIHZlYzIgbm9ybWFsID0gYV9ub3JtYWwgKiBhX25vcm1hbENvZWY7XFxuICB2ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvblN0YXJ0ICogKDEuMCAtIGFfcG9zaXRpb25Db2VmKSArIGFfcG9zaXRpb25FbmQgKiBhX3Bvc2l0aW9uQ29lZjtcXG5cXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gV2UgcmVxdWlyZSBlZGdlcyB0byBiZSBhdCBsZWFzdCBcXFwibWluVGhpY2tuZXNzXFxcIiBwaXhlbHMgdGhpY2sgKm9uIHNjcmVlbipcXG4gIC8vIChzbyB3ZSBuZWVkIHRvIGNvbXBlbnNhdGUgdGhlIHNpemUgcmF0aW8pOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zaXplUmF0aW8pO1xcblxcbiAgLy8gVGhlbiwgd2UgbmVlZCB0byByZXRyaWV2ZSB0aGUgbm9ybWFsaXplZCB0aGlja25lc3Mgb2YgdGhlIGVkZ2UgaW4gdGhlIFdlYkdMXFxuICAvLyByZWZlcmVudGlhbCAoaW4gYSAoWzAsIDFdLCBbMCwgMV0pIHNwYWNlKSwgdXNpbmcgb3VyIFxcXCJtYWdpY1xcXCIgY29ycmVjdGlvblxcbiAgLy8gcmF0aW86XFxuICBmbG9hdCB3ZWJHTFRoaWNrbmVzcyA9IHBpeGVsc1RoaWNrbmVzcyAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuXFxuICAvLyBIZXJlIGlzIHRoZSBwcm9wZXIgcG9zaXRpb24gb2YgdGhlIHZlcnRleFxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24gKyB1bml0Tm9ybWFsICogd2ViR0xUaGlja25lc3MsIDEpKS54eSwgMCwgMSk7XFxuXFxuICAvLyBGb3IgdGhlIGZyYWdtZW50IHNoYWRlciB0aG91Z2gsIHdlIG5lZWQgYSB0aGlja25lc3MgdGhhdCB0YWtlcyB0aGUgXFxcIm1hZ2ljXFxcIlxcbiAgLy8gY29ycmVjdGlvbiByYXRpbyBpbnRvIGFjY291bnQgKGFzIGluIHdlYkdMVGhpY2tuZXNzKSwgYnV0IHNvIHRoYXQgdGhlXFxuICAvLyBhbnRpYWxpYXNpbmcgZWZmZWN0IGRvZXMgbm90IGRlcGVuZCBvbiB0aGUgem9vbSBsZXZlbC4gU28gaGVyZSdzIHlldFxcbiAgLy8gYW5vdGhlciB0aGlja25lc3MgdmVyc2lvbjpcXG4gIHZfdGhpY2tuZXNzID0gd2ViR0xUaGlja25lc3MgLyB1X3pvb21SYXRpbztcXG5cXG4gIHZfbm9ybWFsID0gdW5pdE5vcm1hbDtcXG5cXG4gIHZfZmVhdGhlciA9IHVfZmVhdGhlciAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV96b29tUmF0aW8gLyB1X3BpeGVsUmF0aW8gKiAyLjA7XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UgPSBTSEFERVJfU09VUkNFO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4ID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4LlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4LkZMT0FUO1xudmFyIFVOSUZPUk1TID0gW1widV9tYXRyaXhcIiwgXCJ1X3pvb21SYXRpb1wiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X3BpeGVsUmF0aW9cIiwgXCJ1X2ZlYXRoZXJcIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIl07XG52YXIgRWRnZVJlY3RhbmdsZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlUHJvZ3JhbSkge1xuICBmdW5jdGlvbiBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZVJlY3RhbmdsZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VSZWN0YW5nbGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhFZGdlUmVjdGFuZ2xlUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlUmVjdGFuZ2xlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDYsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICBVTklGT1JNUzogVU5JRk9STVMsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uU3RhcnRcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25FbmRcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgIC8vIElmIDAsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uU3RhcnRcbiAgICAgICAgLy8gSWYgMiwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25FbmRcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkNvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMCwgMV0sIFswLCAtMV0sIFsxLCAxXSwgWzEsIDFdLCBbMCwgLTFdLCBbMSwgLTFdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIHZhciBuMSA9IDA7XG4gICAgICB2YXIgbjIgPSAwO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICBuMiA9IGR4ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZikge1xuICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgIHZhciB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgIHVfem9vbVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3pvb21SYXRpbyxcbiAgICAgICAgdV9mZWF0aGVyID0gdW5pZm9ybUxvY2F0aW9ucy51X2ZlYXRoZXIsXG4gICAgICAgIHVfcGl4ZWxSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLFxuICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9taW5FZGdlVGhpY2tuZXNzID0gdW5pZm9ybUxvY2F0aW9ucy51X21pbkVkZ2VUaGlja25lc3M7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtMWYodV96b29tUmF0aW8sIHBhcmFtcy56b29tUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9waXhlbFJhdGlvLCBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9mZWF0aGVyLCBwYXJhbXMuYW50aUFsaWFzaW5nRmVhdGhlcik7XG4gICAgICBnbC51bmlmb3JtMWYodV9taW5FZGdlVGhpY2tuZXNzLCBwYXJhbXMubWluRWRnZVRoaWNrbmVzcyk7XG4gICAgfVxuICB9XSk7XG59KEVkZ2VQcm9ncmFtKTtcblxuZXhwb3J0IHsgQWJzdHJhY3ROb2RlUHJvZ3JhbSBhcyBBLCBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMgYXMgRCwgRWRnZUFycm93UHJvZ3JhbSQxIGFzIEUsIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgYXMgRiwgTm9kZUNpcmNsZVByb2dyYW0gYXMgTiwgUHJvZ3JhbSBhcyBQLCBfb2JqZWN0U3ByZWFkMiBhcyBfLCBfZGVmaW5lUHJvcGVydHkgYXMgYSwgZHJhd0Rpc2NOb2RlTGFiZWwgYXMgYiwgZHJhd0Rpc2NOb2RlSG92ZXIgYXMgYywgZHJhd1N0cmFpZ2h0RWRnZUxhYmVsIGFzIGQsIEVkZ2VSZWN0YW5nbGVQcm9ncmFtIGFzIGUsIE5vZGVQcm9ncmFtIGFzIGYsIEVkZ2VQcm9ncmFtIGFzIGcsIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0gYXMgaCwgY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0gYXMgaSwgY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbSBhcyBqLCBBYnN0cmFjdEVkZ2VQcm9ncmFtIGFzIGssIEFic3RyYWN0UHJvZ3JhbSBhcyBsLCBFZGdlQXJyb3dIZWFkUHJvZ3JhbSQxIGFzIG0sIEVkZ2VDbGFtcGVkUHJvZ3JhbSQxIGFzIG4sIGNyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbSBhcyBvLCBERUZBVUxUX0VER0VfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMgYXMgcCwgY3JlYXRlRWRnZUFycm93UHJvZ3JhbSBhcyBxLCBnZXRBdHRyaWJ1dGVJdGVtc0NvdW50IGFzIHIsIGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50IGFzIHMsIGxvYWRWZXJ0ZXhTaGFkZXIgYXMgdCwgbG9hZEZyYWdtZW50U2hhZGVyIGFzIHUsIGxvYWRQcm9ncmFtIGFzIHYsIGtpbGxQcm9ncmFtIGFzIHcsIG51bWJlclRvR0xTTEZsb2F0IGFzIHggfTtcbiIsImZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IGkgKyBcIlwiO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpO1xufVxuXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cblxuZXhwb3J0IHsgX2luaGVyaXRzIGFzIF8sIF9jcmVhdGVDbGFzcyBhcyBhLCBfY2xhc3NDYWxsQ2hlY2sgYXMgYiwgX2NhbGxTdXBlciBhcyBjLCBfdG9Qcm9wZXJ0eUtleSBhcyBkLCBfZ2V0UHJvdG90eXBlT2YgYXMgZSB9O1xuIiwiaW1wb3J0IGlzR3JhcGggZnJvbSAnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCc7XG5pbXBvcnQgeyBfIGFzIF9zbGljZWRUb0FycmF5IH0gZnJvbSAnLi9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcblxudmFyIGxpbmVhciA9IGZ1bmN0aW9uIGxpbmVhcihrKSB7XG4gIHJldHVybiBrO1xufTtcbnZhciBxdWFkcmF0aWNJbiA9IGZ1bmN0aW9uIHF1YWRyYXRpY0luKGspIHtcbiAgcmV0dXJuIGsgKiBrO1xufTtcbnZhciBxdWFkcmF0aWNPdXQgPSBmdW5jdGlvbiBxdWFkcmF0aWNPdXQoaykge1xuICByZXR1cm4gayAqICgyIC0gayk7XG59O1xudmFyIHF1YWRyYXRpY0luT3V0ID0gZnVuY3Rpb24gcXVhZHJhdGljSW5PdXQoaykge1xuICBpZiAoKGsgKj0gMikgPCAxKSByZXR1cm4gMC41ICogayAqIGs7XG4gIHJldHVybiAtMC41ICogKC0tayAqIChrIC0gMikgLSAxKTtcbn07XG52YXIgY3ViaWNJbiA9IGZ1bmN0aW9uIGN1YmljSW4oaykge1xuICByZXR1cm4gayAqIGsgKiBrO1xufTtcbnZhciBjdWJpY091dCA9IGZ1bmN0aW9uIGN1YmljT3V0KGspIHtcbiAgcmV0dXJuIC0tayAqIGsgKiBrICsgMTtcbn07XG52YXIgY3ViaWNJbk91dCA9IGZ1bmN0aW9uIGN1YmljSW5PdXQoaykge1xuICBpZiAoKGsgKj0gMikgPCAxKSByZXR1cm4gMC41ICogayAqIGsgKiBrO1xuICByZXR1cm4gMC41ICogKChrIC09IDIpICogayAqIGsgKyAyKTtcbn07XG52YXIgZWFzaW5ncyA9IHtcbiAgbGluZWFyOiBsaW5lYXIsXG4gIHF1YWRyYXRpY0luOiBxdWFkcmF0aWNJbixcbiAgcXVhZHJhdGljT3V0OiBxdWFkcmF0aWNPdXQsXG4gIHF1YWRyYXRpY0luT3V0OiBxdWFkcmF0aWNJbk91dCxcbiAgY3ViaWNJbjogY3ViaWNJbixcbiAgY3ViaWNPdXQ6IGN1YmljT3V0LFxuICBjdWJpY0luT3V0OiBjdWJpY0luT3V0XG59O1xuXG4vKipcbiAqIERlZmF1bHRzLlxuICovXG5cbnZhciBBTklNQVRFX0RFRkFVTFRTID0ge1xuICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgZHVyYXRpb246IDE1MFxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGFuaW1hdGUgdGhlIG5vZGVzLlxuICovXG5mdW5jdGlvbiBhbmltYXRlTm9kZXMoZ3JhcGgsIHRhcmdldHMsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIHZhciBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgQU5JTUFURV9ERUZBVUxUUywgb3B0cyk7XG4gIHZhciBlYXNpbmcgPSB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuZWFzaW5nIDogZWFzaW5nc1tvcHRpb25zLmVhc2luZ107XG4gIHZhciBzdGFydCA9IERhdGUubm93KCk7XG4gIHZhciBzdGFydFBvc2l0aW9ucyA9IHt9O1xuICBmb3IgKHZhciBub2RlIGluIHRhcmdldHMpIHtcbiAgICB2YXIgYXR0cnMgPSB0YXJnZXRzW25vZGVdO1xuICAgIHN0YXJ0UG9zaXRpb25zW25vZGVdID0ge307XG4gICAgZm9yICh2YXIgX2sgaW4gYXR0cnMpIHN0YXJ0UG9zaXRpb25zW25vZGVdW19rXSA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGUobm9kZSwgX2spO1xuICB9XG4gIHZhciBmcmFtZSA9IG51bGw7XG4gIHZhciBfc3RlcCA9IGZ1bmN0aW9uIHN0ZXAoKSB7XG4gICAgZnJhbWUgPSBudWxsO1xuICAgIHZhciBwID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuICAgIGlmIChwID49IDEpIHtcbiAgICAgIC8vIEFuaW1hdGlvbiBpcyBkb25lXG4gICAgICBmb3IgKHZhciBfbm9kZSBpbiB0YXJnZXRzKSB7XG4gICAgICAgIHZhciBfYXR0cnMgPSB0YXJnZXRzW19ub2RlXTtcblxuICAgICAgICAvLyBXZSB1c2UgZ2l2ZW4gdmFsdWVzIHRvIGF2b2lkIHByZWNpc2lvbiBpc3N1ZXMgYW5kIGZvciBjb252ZW5pZW5jZVxuICAgICAgICBmb3IgKHZhciBfazIgaW4gX2F0dHJzKSBncmFwaC5zZXROb2RlQXR0cmlidXRlKF9ub2RlLCBfazIsIF9hdHRyc1tfazJdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikgY2FsbGJhY2soKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcCA9IGVhc2luZyhwKTtcbiAgICBmb3IgKHZhciBfbm9kZTIgaW4gdGFyZ2V0cykge1xuICAgICAgdmFyIF9hdHRyczIgPSB0YXJnZXRzW19ub2RlMl07XG4gICAgICB2YXIgcyA9IHN0YXJ0UG9zaXRpb25zW19ub2RlMl07XG4gICAgICBmb3IgKHZhciBfazMgaW4gX2F0dHJzMikgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShfbm9kZTIsIF9rMywgX2F0dHJzMltfazNdICogcCArIHNbX2szXSAqICgxIC0gcCkpO1xuICAgIH1cbiAgICBmcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfc3RlcCk7XG4gIH07XG4gIF9zdGVwKCk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZyYW1lKSBjYW5jZWxBbmltYXRpb25GcmFtZShmcmFtZSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlkZW50aXR5KCkge1xuICByZXR1cm4gRmxvYXQzMkFycmF5Lm9mKDEsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDEpO1xufVxuXG4vLyBUT0RPOiBvcHRpbWl6ZVxuZnVuY3Rpb24gc2NhbGUobSwgeCwgeSkge1xuICBtWzBdID0geDtcbiAgbVs0XSA9IHR5cGVvZiB5ID09PSBcIm51bWJlclwiID8geSA6IHg7XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gcm90YXRlKG0sIHIpIHtcbiAgdmFyIHMgPSBNYXRoLnNpbihyKSxcbiAgICBjID0gTWF0aC5jb3Mocik7XG4gIG1bMF0gPSBjO1xuICBtWzFdID0gcztcbiAgbVszXSA9IC1zO1xuICBtWzRdID0gYztcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiB0cmFuc2xhdGUobSwgeCwgeSkge1xuICBtWzZdID0geDtcbiAgbVs3XSA9IHk7XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gbXVsdGlwbHkoYSwgYikge1xuICB2YXIgYTAwID0gYVswXSxcbiAgICBhMDEgPSBhWzFdLFxuICAgIGEwMiA9IGFbMl07XG4gIHZhciBhMTAgPSBhWzNdLFxuICAgIGExMSA9IGFbNF0sXG4gICAgYTEyID0gYVs1XTtcbiAgdmFyIGEyMCA9IGFbNl0sXG4gICAgYTIxID0gYVs3XSxcbiAgICBhMjIgPSBhWzhdO1xuICB2YXIgYjAwID0gYlswXSxcbiAgICBiMDEgPSBiWzFdLFxuICAgIGIwMiA9IGJbMl07XG4gIHZhciBiMTAgPSBiWzNdLFxuICAgIGIxMSA9IGJbNF0sXG4gICAgYjEyID0gYls1XTtcbiAgdmFyIGIyMCA9IGJbNl0sXG4gICAgYjIxID0gYls3XSxcbiAgICBiMjIgPSBiWzhdO1xuICBhWzBdID0gYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwO1xuICBhWzFdID0gYjAwICogYTAxICsgYjAxICogYTExICsgYjAyICogYTIxO1xuICBhWzJdID0gYjAwICogYTAyICsgYjAxICogYTEyICsgYjAyICogYTIyO1xuICBhWzNdID0gYjEwICogYTAwICsgYjExICogYTEwICsgYjEyICogYTIwO1xuICBhWzRdID0gYjEwICogYTAxICsgYjExICogYTExICsgYjEyICogYTIxO1xuICBhWzVdID0gYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyO1xuICBhWzZdID0gYjIwICogYTAwICsgYjIxICogYTEwICsgYjIyICogYTIwO1xuICBhWzddID0gYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxO1xuICBhWzhdID0gYjIwICogYTAyICsgYjIxICogYTEyICsgYjIyICogYTIyO1xuICByZXR1cm4gYTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5VmVjMihhLCBiKSB7XG4gIHZhciB6ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiAxO1xuICB2YXIgYTAwID0gYVswXTtcbiAgdmFyIGEwMSA9IGFbMV07XG4gIHZhciBhMTAgPSBhWzNdO1xuICB2YXIgYTExID0gYVs0XTtcbiAgdmFyIGEyMCA9IGFbNl07XG4gIHZhciBhMjEgPSBhWzddO1xuICB2YXIgYjAgPSBiLng7XG4gIHZhciBiMSA9IGIueTtcbiAgcmV0dXJuIHtcbiAgICB4OiBiMCAqIGEwMCArIGIxICogYTEwICsgYTIwICogeixcbiAgICB5OiBiMCAqIGEwMSArIGIxICogYTExICsgYTIxICogelxuICB9O1xufVxuXG4vKipcbiAqIEluIHNpZ21hLCB0aGUgZ3JhcGggaXMgbm9ybWFsaXplZCBpbnRvIGEgWzAsIDFdLCBbMCwgMV0gc3F1YXJlLCBiZWZvcmUgYmVpbmcgZ2l2ZW4gdG8gdGhlIHZhcmlvdXMgcmVuZGVyZXJzLiBUaGlzXG4gKiBoZWxwcyB0byBkZWFsIHdpdGggcXVhZHRyZWUgaW4gcGFydGljdWxhci5cbiAqIEJ1dCBhdCBzb21lIHBvaW50LCB3ZSBuZWVkIHRvIHJlc2NhbGUgaXQgc28gdGhhdCBpdCB0YWtlcyB0aGUgYmVzdCBwbGFjZSBpbiB0aGUgc2NyZWVuLCBpLmUuIHdlIGFsd2F5cyB3YW50IHRvIHNlZSB0d29cbiAqIG5vZGVzIFwidG91Y2hpbmdcIiBvcHBvc2l0ZSBzaWRlcyBvZiB0aGUgZ3JhcGgsIHdpdGggdGhlIGNhbWVyYSBiZWluZyBhdCBpdHMgZGVmYXVsdCBzdGF0ZS5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgdGhpcyByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdGlvblJhdGlvKHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zKSB7XG4gIHZhciB2aWV3cG9ydFJhdGlvID0gdmlld3BvcnREaW1lbnNpb25zLmhlaWdodCAvIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aDtcbiAgdmFyIGdyYXBoUmF0aW8gPSBncmFwaERpbWVuc2lvbnMuaGVpZ2h0IC8gZ3JhcGhEaW1lbnNpb25zLndpZHRoO1xuXG4gIC8vIElmIHRoZSBzdGFnZSBhbmQgdGhlIGdyYXBocyBhcmUgaW4gZGlmZmVyZW50IGRpcmVjdGlvbnMgKHN1Y2ggYXMgdGhlIGdyYXBoIGJlaW5nIHdpZGVyIHRoYXQgdGFsbCB3aGlsZSB0aGUgc3RhZ2VcbiAgLy8gaXMgdGFsbGVyIHRoYW4gd2lkZSksIHdlIGNhbiBzdG9wIGhlcmUgdG8gaGF2ZSBpbmRlZWQgbm9kZXMgdG91Y2hpbmcgb3Bwb3NpdGUgc2lkZXM6XG4gIGlmICh2aWV3cG9ydFJhdGlvIDwgMSAmJiBncmFwaFJhdGlvID4gMSB8fCB2aWV3cG9ydFJhdGlvID4gMSAmJiBncmFwaFJhdGlvIDwgMSkge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gRWxzZSwgd2UgbmVlZCB0byBmaXQgdGhlIGdyYXBoIGluc2lkZSB0aGUgc3RhZ2U6XG4gIC8vIDEuIElmIHRoZSBncmFwaCBpcyBcInNxdWFyZXJcIiAoaS5lLiB3aXRoIGEgcmF0aW8gY2xvc2VyIHRvIDEpLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIGxhcmdlc3Qgc2lkZXMgdG91Y2g7XG4gIC8vIDIuIElmIHRoZSBzdGFnZSBpcyBcInNxdWFyZXJcIiwgd2UgbmVlZCB0byBtYWtlIHRoZSBzbWFsbGVzdCBzaWRlcyB0b3VjaC5cbiAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KGdyYXBoUmF0aW8sIDEgLyBncmFwaFJhdGlvKSwgTWF0aC5tYXgoMSAvIHZpZXdwb3J0UmF0aW8sIHZpZXdwb3J0UmF0aW8pKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgYSBtYXRyaXggZnJvbSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgY2FtZXJhLlxuICovXG5mdW5jdGlvbiBtYXRyaXhGcm9tQ2FtZXJhKHN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZywgaW52ZXJzZSkge1xuICAvLyBUT0RPOiBpdCdzIHBvc3NpYmxlIHRvIG9wdGltaXplIHRoaXMgZHJhc3RpY2FsbHkhXG4gIHZhciBhbmdsZSA9IHN0YXRlLmFuZ2xlLFxuICAgIHJhdGlvID0gc3RhdGUucmF0aW8sXG4gICAgeCA9IHN0YXRlLngsXG4gICAgeSA9IHN0YXRlLnk7XG4gIHZhciB3aWR0aCA9IHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aCxcbiAgICBoZWlnaHQgPSB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0O1xuICB2YXIgbWF0cml4ID0gaWRlbnRpdHkoKTtcbiAgdmFyIHNtYWxsZXN0RGltZW5zaW9uID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLSAyICogcGFkZGluZztcbiAgdmFyIGNvcnJlY3Rpb25SYXRpbyA9IGdldENvcnJlY3Rpb25SYXRpbyh2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucyk7XG4gIGlmICghaW52ZXJzZSkge1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgMiAqIChzbWFsbGVzdERpbWVuc2lvbiAvIHdpZHRoKSAqIGNvcnJlY3Rpb25SYXRpbywgMiAqIChzbWFsbGVzdERpbWVuc2lvbiAvIGhlaWdodCkgKiBjb3JyZWN0aW9uUmF0aW8pKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHJvdGF0ZShpZGVudGl0eSgpLCAtYW5nbGUpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIDEgLyByYXRpbykpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgdHJhbnNsYXRlKGlkZW50aXR5KCksIC14LCAteSkpO1xuICB9IGVsc2Uge1xuICAgIG11bHRpcGx5KG1hdHJpeCwgdHJhbnNsYXRlKGlkZW50aXR5KCksIHgsIHkpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIHJhdGlvKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCByb3RhdGUoaWRlbnRpdHkoKSwgYW5nbGUpKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIHdpZHRoIC8gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gY29ycmVjdGlvblJhdGlvLCBoZWlnaHQgLyBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBjb3JyZWN0aW9uUmF0aW8pKTtcbiAgfVxuICByZXR1cm4gbWF0cml4O1xufVxuXG4vKipcbiAqIEFsbCB0aGVzZSB0cmFuc2Zvcm1hdGlvbnMgd2UgYXBwbHkgb24gdGhlIG1hdHJpeCB0byBnZXQgaXQgcmVzY2FsZSB0aGUgZ3JhcGhcbiAqIGFzIHdlIHdhbnQgbWFrZSBpdCB2ZXJ5IGhhcmQgdG8gZ2V0IHBpeGVsLXBlcmZlY3QgZGlzdGFuY2VzIGluIFdlYkdMLiBUaGlzXG4gKiBmdW5jdGlvbiByZXR1cm5zIGEgZmFjdG9yIHRoYXQgcHJvcGVybHkgY2FuY2VscyB0aGUgbWF0cml4IGVmZmVjdCBvbiBsZW5ndGhzLlxuICpcbiAqIFtqYWNvbXlhbF1cbiAqIFRvIGJlIGZ1bGx5IGhvbmVzdCwgSSBjYW4ndCByZWFsbHkgZXhwbGFpbiBoYXBwZW5zIGhlcmUuLi4gSSBub3RpY2UgdGhhdCB0aGVcbiAqIGZvbGxvd2luZyByYXRpbyB3b3JrcyAoaS5lLiBpdCBjb3JyZWN0bHkgY29tcGVuc2F0ZXMgdGhlIG1hdHJpeCBpbXBhY3Qgb24gYWxsXG4gKiBjYW1lcmEgc3RhdGVzIEkgY291bGQgdHJ5KTpcbiAqID4gYFIgPSBzaXplKFYpIC8gc2l6ZShNICogVikgLyBXYFxuICogYXMgbG9uZyBhcyBgTSAqIFZgIGlzIGluIHRoZSBkaXJlY3Rpb24gb2YgVyAoaWUuIHBhcmFsbGVsIHRvIChPeCkpLiBJdCB3b3Jrc1xuICogYXMgd2VsbCB3aXRoIEggYW5kIGEgdmVjdG9yIHRoYXQgdHJhbnNmb3JtcyBpbnRvIHNvbWV0aGluZyBwYXJhbGxlbCB0byAoT3kpLlxuICpcbiAqIEFsc28sIG5vdGUgdGhhdCB3ZSB1c2UgYGFuZ2xlYCBhbmQgbm90IGAtYW5nbGVgICh0aGF0IHdvdWxkIHNlZW0gbG9naWNhbCxcbiAqIHNpbmNlIHdlIHdhbnQgdG8gYW50aWNpcGF0ZSB0aGUgcm90YXRpb24pLCBiZWNhdXNlIHRoZSBpbWFnZSBpcyB2ZXJ0aWNhbGx5XG4gKiBzd2FwcGVkIGluIFdlYkdMLlxuICovXG5mdW5jdGlvbiBnZXRNYXRyaXhJbXBhY3QobWF0cml4LCBjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zKSB7XG4gIHZhciBfbXVsdGlwbHlWZWMgPSBtdWx0aXBseVZlYzIobWF0cml4LCB7XG4gICAgICB4OiBNYXRoLmNvcyhjYW1lcmFTdGF0ZS5hbmdsZSksXG4gICAgICB5OiBNYXRoLnNpbihjYW1lcmFTdGF0ZS5hbmdsZSlcbiAgICB9LCAwKSxcbiAgICB4ID0gX211bHRpcGx5VmVjLngsXG4gICAgeSA9IF9tdWx0aXBseVZlYy55O1xuICByZXR1cm4gMSAvIE1hdGguc3FydChNYXRoLnBvdyh4LCAyKSArIE1hdGgucG93KHksIDIpKSAvIHZpZXdwb3J0RGltZW5zaW9ucy53aWR0aDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGdyYXBoJ3Mgbm9kZSBleHRlbnQgaW4geCAmIHkuXG4gKi9cbmZ1bmN0aW9uIGdyYXBoRXh0ZW50KGdyYXBoKSB7XG4gIGlmICghZ3JhcGgub3JkZXIpIHJldHVybiB7XG4gICAgeDogWzAsIDFdLFxuICAgIHk6IFswLCAxXVxuICB9O1xuICB2YXIgeE1pbiA9IEluZmluaXR5O1xuICB2YXIgeE1heCA9IC1JbmZpbml0eTtcbiAgdmFyIHlNaW4gPSBJbmZpbml0eTtcbiAgdmFyIHlNYXggPSAtSW5maW5pdHk7XG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChfLCBhdHRyKSB7XG4gICAgdmFyIHggPSBhdHRyLngsXG4gICAgICB5ID0gYXR0ci55O1xuICAgIGlmICh4IDwgeE1pbikgeE1pbiA9IHg7XG4gICAgaWYgKHggPiB4TWF4KSB4TWF4ID0geDtcbiAgICBpZiAoeSA8IHlNaW4pIHlNaW4gPSB5O1xuICAgIGlmICh5ID4geU1heCkgeU1heCA9IHk7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHg6IFt4TWluLCB4TWF4XSxcbiAgICB5OiBbeU1pbiwgeU1heF1cbiAgfTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ3JhcGggdmFyaWFibGUgaXMgYSB2YWxpZCBncmFwaCwgYW5kIGlmIHNpZ21hIGNhbiByZW5kZXIgaXQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlR3JhcGgoZ3JhcGgpIHtcbiAgLy8gY2hlY2sgaWYgaXQncyBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2VcbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGludmFsaWQgZ3JhcGggaW5zdGFuY2UuXCIpO1xuXG4gIC8vIGNoZWNrIGlmIG5vZGVzIGhhdmUgeC95IGF0dHJpYnV0ZXNcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKGtleSwgYXR0cmlidXRlcykge1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGF0dHJpYnV0ZXMueCkgfHwgIU51bWJlci5pc0Zpbml0ZShhdHRyaWJ1dGVzLnkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29vcmRpbmF0ZXMgb2Ygbm9kZSBcIi5jb25jYXQoa2V5LCBcIiBhcmUgaW52YWxpZC4gQSBub2RlIG11c3QgaGF2ZSBhIG51bWVyaWMgJ3gnIGFuZCAneScgYXR0cmlidXRlLlwiKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBET00gZWxlbWVudHMgZWFzaWx5LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgc3R5bGUsIGF0dHJpYnV0ZXMpIHtcbiAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gIGlmIChzdHlsZSkge1xuICAgIGZvciAodmFyIGsgaW4gc3R5bGUpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGVba10gPSBzdHlsZVtrXTtcbiAgICB9XG4gIH1cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBfayBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShfaywgYXR0cmlidXRlc1tfa10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGJyb3dzZXIncyBwaXhlbCByYXRpby5cbiAqL1xuZnVuY3Rpb24gZ2V0UGl4ZWxSYXRpbygpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICByZXR1cm4gMTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBvcmRlcmluZyB0aGUgZ2l2ZW4gZWxlbWVudHMgaW4gcmV2ZXJzZSB6LW9yZGVyIHNvIHRoZXkgZHJhd25cbiAqIHRoZSBjb3JyZWN0IHdheS5cbiAqL1xuZnVuY3Rpb24gekluZGV4T3JkZXJpbmcoX2V4dGVudCwgZ2V0dGVyLCBlbGVtZW50cykge1xuICAvLyBJZiBrIGlzID4gbiwgd2UnbGwgdXNlIGEgc3RhbmRhcmQgc29ydFxuICByZXR1cm4gZWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHZhciB6QSA9IGdldHRlcihhKSB8fCAwLFxuICAgICAgekIgPSBnZXR0ZXIoYikgfHwgMDtcbiAgICBpZiAoekEgPCB6QikgcmV0dXJuIC0xO1xuICAgIGlmICh6QSA+IHpCKSByZXR1cm4gMTtcbiAgICByZXR1cm4gMDtcbiAgfSk7XG5cbiAgLy8gVE9ETzogY291bnRpbmcgc29ydCBvcHRpbWl6YXRpb25cbn1cblxuLyoqXG4gKiBGYWN0b3J5IHJldHVybmluZyBhIGZ1bmN0aW9uIG5vcm1hbGl6aW5nIHRoZSBnaXZlbiBub2RlJ3MgcG9zaXRpb24gJiBzaXplLlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbihleHRlbnQpIHtcbiAgdmFyIF9leHRlbnQkeCA9IF9zbGljZWRUb0FycmF5KGV4dGVudC54LCAyKSxcbiAgICBtaW5YID0gX2V4dGVudCR4WzBdLFxuICAgIG1heFggPSBfZXh0ZW50JHhbMV0sXG4gICAgX2V4dGVudCR5ID0gX3NsaWNlZFRvQXJyYXkoZXh0ZW50LnksIDIpLFxuICAgIG1pblkgPSBfZXh0ZW50JHlbMF0sXG4gICAgbWF4WSA9IF9leHRlbnQkeVsxXTtcbiAgdmFyIHJhdGlvID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKSxcbiAgICBkWCA9IChtYXhYICsgbWluWCkgLyAyLFxuICAgIGRZID0gKG1heFkgKyBtaW5ZKSAvIDI7XG4gIGlmIChyYXRpbyA9PT0gMCB8fCBNYXRoLmFicyhyYXRpbykgPT09IEluZmluaXR5IHx8IGlzTmFOKHJhdGlvKSkgcmF0aW8gPSAxO1xuICBpZiAoaXNOYU4oZFgpKSBkWCA9IDA7XG4gIGlmIChpc05hTihkWSkpIGRZID0gMDtcbiAgdmFyIGZuID0gZnVuY3Rpb24gZm4oZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiAwLjUgKyAoZGF0YS54IC0gZFgpIC8gcmF0aW8sXG4gICAgICB5OiAwLjUgKyAoZGF0YS55IC0gZFkpIC8gcmF0aW9cbiAgICB9O1xuICB9O1xuXG4gIC8vIFRPRE86IHBvc3NpYmlsaXR5IHRvIGFwcGx5IHRoaXMgaW4gYmF0Y2ggb3ZlciBhcnJheSBvZiBpbmRpY2VzXG4gIGZuLmFwcGx5VG8gPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRhdGEueCA9IDAuNSArIChkYXRhLnggLSBkWCkgLyByYXRpbztcbiAgICBkYXRhLnkgPSAwLjUgKyAoZGF0YS55IC0gZFkpIC8gcmF0aW87XG4gIH07XG4gIGZuLmludmVyc2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiB7XG4gICAgICB4OiBkWCArIHJhdGlvICogKGRhdGEueCAtIDAuNSksXG4gICAgICB5OiBkWSArIHJhdGlvICogKGRhdGEueSAtIDAuNSlcbiAgICB9O1xuICB9O1xuICBmbi5yYXRpbyA9IHJhdGlvO1xuICByZXR1cm4gZm47XG59XG5cbmV4cG9ydCB7IEFOSU1BVEVfREVGQVVMVFMgYXMgQSwgZ2V0TWF0cml4SW1wYWN0IGFzIGEsIGNyZWF0ZUVsZW1lbnQgYXMgYiwgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uIGFzIGMsIGdldFBpeGVsUmF0aW8gYXMgZCwgZWFzaW5ncyBhcyBlLCBtdWx0aXBseVZlYzIgYXMgZiwgZ3JhcGhFeHRlbnQgYXMgZywgYW5pbWF0ZU5vZGVzIGFzIGgsIGlkZW50aXR5IGFzIGksIGdldENvcnJlY3Rpb25SYXRpbyBhcyBqLCBxdWFkcmF0aWNPdXQgYXMgaywgbGluZWFyIGFzIGwsIG1hdHJpeEZyb21DYW1lcmEgYXMgbSwgcXVhZHJhdGljSW5PdXQgYXMgbiwgY3ViaWNJbiBhcyBvLCBjdWJpY091dCBhcyBwLCBxdWFkcmF0aWNJbiBhcyBxLCBjdWJpY0luT3V0IGFzIHIsIHNjYWxlIGFzIHMsIHJvdGF0ZSBhcyB0LCB0cmFuc2xhdGUgYXMgdSwgdmFsaWRhdGVHcmFwaCBhcyB2LCBtdWx0aXBseSBhcyB3LCB6SW5kZXhPcmRlcmluZyBhcyB6IH07XG4iLCJpbXBvcnQgeyBfIGFzIF9vYmplY3RTcHJlYWQyLCBhIGFzIF9kZWZpbmVQcm9wZXJ0eSB9IGZyb20gJy4vaW5kZXgtMjM2YzYyYWQuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGMgYXMgX2NhbGxTdXBlciwgZCBhcyBfdG9Qcm9wZXJ0eUtleSB9IGZyb20gJy4vaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCB7IFR5cGVkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdHlwZXMvZGlzdC9zaWdtYS10eXBlcy5lc20uanMnO1xuaW1wb3J0IHsgQSBhcyBBTklNQVRFX0RFRkFVTFRTLCBlIGFzIGVhc2luZ3MsIGcgYXMgZ3JhcGhFeHRlbnQsIGMgYXMgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uLCBtIGFzIG1hdHJpeEZyb21DYW1lcmEsIHogYXMgekluZGV4T3JkZXJpbmcsIGEgYXMgZ2V0TWF0cml4SW1wYWN0LCBiIGFzIGNyZWF0ZUVsZW1lbnQsIGQgYXMgZ2V0UGl4ZWxSYXRpbywgZiBhcyBtdWx0aXBseVZlYzIsIGkgYXMgaWRlbnRpdHksIHYgYXMgdmFsaWRhdGVHcmFwaCB9IGZyb20gJy4vbm9ybWFsaXphdGlvbi1iZTQ0NTUxOC5lc20uanMnO1xuaW1wb3J0IHsgREVGQVVMVF9TRVRUSU5HUywgdmFsaWRhdGVTZXR0aW5ncywgcmVzb2x2ZVNldHRpbmdzIH0gZnJvbSAnLi4vc2V0dGluZ3MvZGlzdC9zaWdtYS1zZXR0aW5ncy5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfc2xpY2VkVG9BcnJheSwgYSBhcyBfYXJyYXlMaWtlVG9BcnJheSwgYiBhcyBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIGcgYXMgZ2V0UGl4ZWxDb2xvciwgYyBhcyBjb2xvclRvSW5kZXggfSBmcm9tICcuL2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfdHlwZW9mLCBlIGFzIGV4dGVuZCB9IGZyb20gJy4vZGF0YS0xMWRmNzEyNC5lc20uanMnO1xuaW1wb3J0ICdldmVudHMnO1xuaW1wb3J0ICdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJztcblxuLyoqXG4gKiBEZWZhdWx0cy5cbiAqL1xudmFyIERFRkFVTFRfWk9PTUlOR19SQVRJTyA9IDEuNTtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuLyoqXG4gKiBDYW1lcmEgY2xhc3NcbiAqL1xudmFyIENhbWVyYSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1R5cGVkRXZlbnRFbWl0dGVyKSB7XG4gIGZ1bmN0aW9uIENhbWVyYSgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhbWVyYSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhbWVyYSk7XG5cbiAgICAvLyBTdGF0ZVxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ4XCIsIDAuNSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInlcIiwgMC41KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiYW5nbGVcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJhdGlvXCIsIDEpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtaW5SYXRpb1wiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWF4UmF0aW9cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRab29taW5nXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkUGFubmluZ1wiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFJvdGF0aW9uXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjbGVhblwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibmV4dEZyYW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwcmV2aW91c1N0YXRlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIF90aGlzLnByZXZpb3VzU3RhdGUgPSBfdGhpcy5nZXRTdGF0ZSgpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGF0aWMgbWV0aG9kIHVzZWQgdG8gY3JlYXRlIGEgQ2FtZXJhIG9iamVjdCB3aXRoIGEgZ2l2ZW4gc3RhdGUuXG4gICAqL1xuICBfaW5oZXJpdHMoQ2FtZXJhLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhbWVyYSwgW3tcbiAgICBrZXk6IFwiZW5hYmxlXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZW5hYmxlIHRoZSBjYW1lcmEuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5hYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGRpc2FibGUgdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkaXNhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBjdXJyZW50IHN0YXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFN0YXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogdGhpcy54LFxuICAgICAgICB5OiB0aGlzLnksXG4gICAgICAgIGFuZ2xlOiB0aGlzLmFuZ2xlLFxuICAgICAgICByYXRpbzogdGhpcy5yYXRpb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBjYW1lcmEgaGFzIHRoZSBnaXZlbiBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoYXNTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYXNTdGF0ZShzdGF0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMueCA9PT0gc3RhdGUueCAmJiB0aGlzLnkgPT09IHN0YXRlLnkgJiYgdGhpcy5yYXRpbyA9PT0gc3RhdGUucmF0aW8gJiYgdGhpcy5hbmdsZSA9PT0gc3RhdGUuYW5nbGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmV0cmlldmUgdGhlIGNhbWVyYSdzIHByZXZpb3VzIHN0YXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFByZXZpb3VzU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0UHJldmlvdXNTdGF0ZSgpIHtcbiAgICAgIHZhciBzdGF0ZSA9IHRoaXMucHJldmlvdXNTdGF0ZTtcbiAgICAgIGlmICghc3RhdGUpIHJldHVybiBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogc3RhdGUueCxcbiAgICAgICAgeTogc3RhdGUueSxcbiAgICAgICAgYW5nbGU6IHN0YXRlLmFuZ2xlLFxuICAgICAgICByYXRpbzogc3RhdGUucmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgbWluUmF0aW8gYW5kIG1heFJhdGlvIHZhbHVlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCb3VuZGVkUmF0aW9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Qm91bmRlZFJhdGlvKHJhdGlvKSB7XG4gICAgICB2YXIgciA9IHJhdGlvO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1pblJhdGlvID09PSBcIm51bWJlclwiKSByID0gTWF0aC5tYXgociwgdGhpcy5taW5SYXRpbyk7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubWF4UmF0aW8gPT09IFwibnVtYmVyXCIpIHIgPSBNYXRoLm1pbihyLCB0aGlzLm1heFJhdGlvKTtcbiAgICAgIHJldHVybiByO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIHZhcmlvdXMgdGhpbmdzIHRvIHJldHVybiBhIGxlZ2l0IHN0YXRlIGNhbmRpZGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2YWxpZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdGUoc3RhdGUpIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRTdGF0ZSA9IHt9O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZFBhbm5pbmcgJiYgdHlwZW9mIHN0YXRlLnggPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLnggPSBzdGF0ZS54O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZFBhbm5pbmcgJiYgdHlwZW9mIHN0YXRlLnkgPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLnkgPSBzdGF0ZS55O1xuICAgICAgaWYgKHRoaXMuZW5hYmxlZFpvb21pbmcgJiYgdHlwZW9mIHN0YXRlLnJhdGlvID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS5yYXRpbyA9IHRoaXMuZ2V0Qm91bmRlZFJhdGlvKHN0YXRlLnJhdGlvKTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRSb3RhdGlvbiAmJiB0eXBlb2Ygc3RhdGUuYW5nbGUgPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLmFuZ2xlID0gc3RhdGUuYW5nbGU7XG4gICAgICByZXR1cm4gdGhpcy5jbGVhbiA/IHRoaXMuY2xlYW4oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIHRoaXMuZ2V0U3RhdGUoKSksIHZhbGlkYXRlZFN0YXRlKSkgOiB2YWxpZGF0ZWRTdGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayB3aGV0aGVyIHRoZSBjYW1lcmEgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzQW5pbWF0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubmV4dEZyYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gS2VlcGluZyB0cmFjayBvZiBsYXN0IHN0YXRlXG4gICAgICB0aGlzLnByZXZpb3VzU3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICB2YXIgdmFsaWRTdGF0ZSA9IHRoaXMudmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueCA9PT0gXCJudW1iZXJcIikgdGhpcy54ID0gdmFsaWRTdGF0ZS54O1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnkgPT09IFwibnVtYmVyXCIpIHRoaXMueSA9IHZhbGlkU3RhdGUueTtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5yYXRpbyA9PT0gXCJudW1iZXJcIikgdGhpcy5yYXRpbyA9IHZhbGlkU3RhdGUucmF0aW87XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUuYW5nbGUgPT09IFwibnVtYmVyXCIpIHRoaXMuYW5nbGUgPSB2YWxpZFN0YXRlLmFuZ2xlO1xuXG4gICAgICAvLyBFbWl0dGluZ1xuICAgICAgaWYgKCF0aGlzLmhhc1N0YXRlKHRoaXMucHJldmlvdXNTdGF0ZSkpIHRoaXMuZW1pdChcInVwZGF0ZWRcIiwgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHVwZGF0ZSB0aGUgY2FtZXJhJ3Mgc3RhdGUgdXNpbmcgYSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZSh1cGRhdGVyKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHVwZGF0ZXIodGhpcy5nZXRTdGF0ZSgpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBhbmltYXRlIHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlKHN0YXRlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBvcHRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKCFjYWxsYmFjaykgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczIuYW5pbWF0ZShzdGF0ZSwgb3B0cywgcmVzb2x2ZSk7XG4gICAgICB9KTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBBTklNQVRFX0RFRkFVTFRTKSwgb3B0cyk7XG4gICAgICB2YXIgdmFsaWRTdGF0ZSA9IHRoaXMudmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICB2YXIgZWFzaW5nID0gdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmVhc2luZyA6IGVhc2luZ3Nbb3B0aW9ucy5lYXNpbmddO1xuXG4gICAgICAvLyBTdGF0ZVxuICAgICAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKSxcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBGdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSBhbmltYXRpb25cbiAgICAgIHZhciBfZm4gPSBmdW5jdGlvbiBmbigpIHtcbiAgICAgICAgdmFyIHQgPSAoRGF0ZS5ub3coKSAtIHN0YXJ0KSAvIG9wdGlvbnMuZHVyYXRpb247XG5cbiAgICAgICAgLy8gVGhlIGFuaW1hdGlvbiBpcyBvdmVyOlxuICAgICAgICBpZiAodCA+PSAxKSB7XG4gICAgICAgICAgX3RoaXMyLm5leHRGcmFtZSA9IG51bGw7XG4gICAgICAgICAgX3RoaXMyLnNldFN0YXRlKHZhbGlkU3RhdGUpO1xuICAgICAgICAgIGlmIChfdGhpczIuYW5pbWF0aW9uQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIF90aGlzMi5hbmltYXRpb25DYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICAgICAgX3RoaXMyLmFuaW1hdGlvbkNhbGxiYWNrID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvZWZmaWNpZW50ID0gZWFzaW5nKHQpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnggPT09IFwibnVtYmVyXCIpIG5ld1N0YXRlLnggPSBpbml0aWFsU3RhdGUueCArICh2YWxpZFN0YXRlLnggLSBpbml0aWFsU3RhdGUueCkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnkgPT09IFwibnVtYmVyXCIpIG5ld1N0YXRlLnkgPSBpbml0aWFsU3RhdGUueSArICh2YWxpZFN0YXRlLnkgLSBpbml0aWFsU3RhdGUueSkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgaWYgKF90aGlzMi5lbmFibGVkUm90YXRpb24gJiYgdHlwZW9mIHZhbGlkU3RhdGUuYW5nbGUgPT09IFwibnVtYmVyXCIpIG5ld1N0YXRlLmFuZ2xlID0gaW5pdGlhbFN0YXRlLmFuZ2xlICsgKHZhbGlkU3RhdGUuYW5nbGUgLSBpbml0aWFsU3RhdGUuYW5nbGUpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5yYXRpbyA9PT0gXCJudW1iZXJcIikgbmV3U3RhdGUucmF0aW8gPSBpbml0aWFsU3RhdGUucmF0aW8gKyAodmFsaWRTdGF0ZS5yYXRpbyAtIGluaXRpYWxTdGF0ZS5yYXRpbykgKiBjb2VmZmljaWVudDtcbiAgICAgICAgX3RoaXMyLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgX3RoaXMyLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfZm4pO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLm5leHRGcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLm5leHRGcmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbkNhbGxiYWNrKSB0aGlzLmFuaW1hdGlvbkNhbGxiYWNrLmNhbGwobnVsbCk7XG4gICAgICAgIHRoaXMubmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF9mbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfZm4oKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0aW9uQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB6b29tIHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZWRab29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVkWm9vbShmYWN0b3JPck9wdGlvbnMpIHtcbiAgICAgIGlmICghZmFjdG9yT3JPcHRpb25zKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gLyBERUZBVUxUX1pPT01JTkdfUkFUSU9cbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3JPck9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAvIGZhY3Rvck9yT3B0aW9uc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gLyAoZmFjdG9yT3JPcHRpb25zLmZhY3RvciB8fCBERUZBVUxUX1pPT01JTkdfUkFUSU8pXG4gICAgICB9LCBmYWN0b3JPck9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHVuem9vbSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkVW56b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVkVW56b29tKGZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgaWYgKCFmYWN0b3JPck9wdGlvbnMpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIERFRkFVTFRfWk9PTUlOR19SQVRJT1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGZhY3Rvck9yT3B0aW9ucyA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvICogZmFjdG9yT3JPcHRpb25zXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIChmYWN0b3JPck9wdGlvbnMuZmFjdG9yIHx8IERFRkFVTFRfWk9PTUlOR19SQVRJTylcbiAgICAgIH0sIGZhY3Rvck9yT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVzZXQgdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlZFJlc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVkUmVzZXQob3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHg6IDAuNSxcbiAgICAgICAgeTogMC41LFxuICAgICAgICByYXRpbzogMSxcbiAgICAgICAgYW5nbGU6IDBcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgQ2FtZXJhIGluc3RhbmNlLCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFzIHRoZSBjdXJyZW50IGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICByZXR1cm4gQ2FtZXJhLmZyb20odGhpcy5nZXRTdGF0ZSgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oc3RhdGUpIHtcbiAgICAgIHZhciBjYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG4gICAgICByZXR1cm4gY2FtZXJhLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENhcHRvciB1dGlscyBmdW5jdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGxvY2FsIFggYW5kIFkgY29vcmRpbmF0ZXMgZnJvbSBhIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC4gSWZcbiAqIGEgRE9NIGVsZW1lbnQgaXMgZ2l2ZW4sIGl0IHVzZXMgdGhpcyBlbGVtZW50J3Mgb2Zmc2V0IHRvIGNvbXB1dGUgdGhlIHBvc2l0aW9uXG4gKiAodGhpcyBhbGxvd3MgdXNpbmcgZXZlbnRzIHRoYXQgYXJlIG5vdCBib3VuZCB0byB0aGUgY29udGFpbmVyIGl0c2VsZiBhbmRcbiAqIHN0aWxsIGhhdmUgYSBwcm9wZXIgcG9zaXRpb24pLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7bnVtYmVyfSAgICAgIFRoZSBsb2NhbCBZIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oZSwgZG9tKSB7XG4gIHZhciBiYm94ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGUuY2xpZW50WCAtIGJib3gubGVmdCxcbiAgICB5OiBlLmNsaWVudFkgLSBiYm94LnRvcFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgbW91c2UgY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb3VzZUNvb3JkcyhlLCBkb20pIHtcbiAgdmFyIHJlcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBnZXRQb3NpdGlvbihlLCBkb20pKSwge30sIHtcbiAgICBzaWdtYURlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICByZXMuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9yaWdpbmFsOiBlXG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIFRha2VzIGEgdG91Y2ggY29vcmRzIG9yIGEgbW91c2UgY29vcmRzLCBhbmQgYWx3YXlzIHJldHVybnMgYSBjbGVhbiBtb3VzZSBjb29yZHMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbGVhbk1vdXNlQ29vcmRzKGUpIHtcbiAgdmFyIHJlcyA9IFwieFwiIGluIGUgPyBlIDogX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGUudG91Y2hlc1swXSB8fCBlLnByZXZpb3VzVG91Y2hlc1swXSksIHt9LCB7XG4gICAgb3JpZ2luYWw6IGUub3JpZ2luYWwsXG4gICAgc2lnbWFEZWZhdWx0UHJldmVudGVkOiBlLnNpZ21hRGVmYXVsdFByZXZlbnRlZCxcbiAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgZS5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgICAgcmVzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG1vdXNlIHdoZWVsIGV2ZW50IGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgd2hlZWwgbW91c2UgZXZlbnQuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRXaGVlbENvb3JkcyhlLCBkb20pIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBnZXRNb3VzZUNvb3JkcyhlLCBkb20pKSwge30sIHtcbiAgICBkZWx0YTogZ2V0V2hlZWxEZWx0YShlKVxuICB9KTtcbn1cbnZhciBNQVhfVE9VQ0hFUyA9IDI7XG5mdW5jdGlvbiBnZXRUb3VjaGVzQXJyYXkodG91Y2hlcykge1xuICB2YXIgYXJyID0gW107XG4gIGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4odG91Y2hlcy5sZW5ndGgsIE1BWF9UT1VDSEVTKTsgaSA8IGw7IGkrKykgYXJyLnB1c2godG91Y2hlc1tpXSk7XG4gIHJldHVybiBhcnI7XG59XG5cbi8qKlxuICogQ29udmVydCB0b3VjaCBjb29yZHMgdG8gc2lnbWEgY29vcmRzLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlICAgICAgICAgICAgICAgLSBBIHRvdWNoIGV2ZW50LlxuICogQHBhcmFtICB7VG91Y2hbXX0gICAgIHByZXZpb3VzVG91Y2hlcyAtIEFuIGFycmF5IG9mIHRoZSBwcmV2aW91c2x5IHN0b3JlZCB0b3VjaGVzLlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAgICAgICAgICAgICAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0VG91Y2hDb29yZHMoZSwgcHJldmlvdXNUb3VjaGVzLCBkb20pIHtcbiAgdmFyIHJlcyA9IHtcbiAgICB0b3VjaGVzOiBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKS5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIGRvbSk7XG4gICAgfSksXG4gICAgcHJldmlvdXNUb3VjaGVzOiBwcmV2aW91c1RvdWNoZXMubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBkb20pO1xuICAgIH0pLFxuICAgIHNpZ21hRGVmYXVsdFByZXZlbnRlZDogZmFsc2UsXG4gICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgIHJlcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH0sXG4gICAgb3JpZ2luYWw6IGVcbiAgfTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgZSAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIHdoZWVsIGRlbHRhIG9mIHRoZSBtb3VzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XG4gIC8vIFRPRE86IGNoZWNrIHRob3NlIHJhdGlvcyBhZ2FpbiB0byBlbnN1cmUgYSBjbGVhbiBDaHJvbWUvRmlyZWZveCBjb21wYXRcbiAgaWYgKHR5cGVvZiBlLmRlbHRhWSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGUuZGVsdGFZICogLTMgLyAzNjA7XG4gIGlmICh0eXBlb2YgZS5kZXRhaWwgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBlLmRldGFpbCAvIC05O1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDYXB0b3I6IGNvdWxkIG5vdCBleHRyYWN0IGRlbHRhIGZyb20gZXZlbnQuXCIpO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHJlcHJlc2VudGluZyBhIGNhcHRvciBsaWtlIHRoZSB1c2VyJ3MgbW91c2Ugb3IgdG91Y2ggY29udHJvbHMuXG4gKi9cbnZhciBDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBmdW5jdGlvbiBDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdG9yKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ2FwdG9yKTtcbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIF90aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhDYXB0b3IsIF9UeXBlZEV2ZW50RW1pdHRlcik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2FwdG9yKTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG52YXIgTU9VU0VfU0VUVElOR1NfS0VZUyA9IFtcImRvdWJsZUNsaWNrVGltZW91dFwiLCBcImRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uXCIsIFwiZG91YmxlQ2xpY2tab29taW5nUmF0aW9cIiwgXCJkcmFnVGltZW91dFwiLCBcImRyYWdnZWRFdmVudHNUb2xlcmFuY2VcIiwgXCJpbmVydGlhRHVyYXRpb25cIiwgXCJpbmVydGlhUmF0aW9cIiwgXCJ6b29tRHVyYXRpb25cIiwgXCJ6b29taW5nUmF0aW9cIl07XG52YXIgREVGQVVMVF9NT1VTRV9TRVRUSU5HUyA9IE1PVVNFX1NFVFRJTkdTX0tFWVMucmVkdWNlKGZ1bmN0aW9uIChpdGVyLCBrZXkpIHtcbiAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBpdGVyKSwge30sIF9kZWZpbmVQcm9wZXJ0eSh7fSwga2V5LCBERUZBVUxUX1NFVFRJTkdTW2tleV0pKTtcbn0sIHt9KTtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuLyoqXG4gKiBNb3VzZSBjYXB0b3IgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBNb3VzZUNhcHRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NhcHRvcikge1xuICBmdW5jdGlvbiBNb3VzZUNhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNb3VzZUNhcHRvcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIE1vdXNlQ2FwdG9yLCBbY29udGFpbmVyLCByZW5kZXJlcl0pO1xuXG4gICAgLy8gQmluZGluZyBtZXRob2RzXG4gICAgLy8gU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZHJhZ2dlZEV2ZW50c1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZG93blN0YXJ0VGltZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdE1vdXNlWFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdE1vdXNlWVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXNNb3VzZURvd25cIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJpc01vdmluZ1wiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1vdmluZ1RpbWVvdXRcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXJ0Q2FtZXJhU3RhdGVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNsaWNrc1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZG91YmxlQ2xpY2tUaW1lb3V0XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjdXJyZW50V2hlZWxEaXJlY3Rpb25cIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInNldHRpbmdzXCIsIERFRkFVTFRfTU9VU0VfU0VUVElOR1MpO1xuICAgIF90aGlzLmhhbmRsZUNsaWNrID0gX3RoaXMuaGFuZGxlQ2xpY2suYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlUmlnaHRDbGljayA9IF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2suYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlRG93biA9IF90aGlzLmhhbmRsZURvd24uYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlVXAgPSBfdGhpcy5oYW5kbGVVcC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVNb3ZlID0gX3RoaXMuaGFuZGxlTW92ZS5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVXaGVlbCA9IF90aGlzLmhhbmRsZVdoZWVsLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZUxlYXZlID0gX3RoaXMuaGFuZGxlTGVhdmUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlRW50ZXIgPSBfdGhpcy5oYW5kbGVFbnRlci5iaW5kKF90aGlzKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfdGhpcy5oYW5kbGVDbGljaywge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgX3RoaXMuaGFuZGxlRG93biwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIF90aGlzLmhhbmRsZVdoZWVsLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCBfdGhpcy5oYW5kbGVMZWF2ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgX3RoaXMuaGFuZGxlRW50ZXIsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5oYW5kbGVNb3ZlLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIF90aGlzLmhhbmRsZVVwLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoTW91c2VDYXB0b3IsIF9DYXB0b3IpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE1vdXNlQ2FwdG9yLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCB0aGlzLmhhbmRsZVJpZ2h0Q2xpY2spO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVEb3duKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5oYW5kbGVXaGVlbCk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy5oYW5kbGVFbnRlcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZVVwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbGlja3MrKztcbiAgICAgIGlmICh0aGlzLmNsaWNrcyA9PT0gMikge1xuICAgICAgICB0aGlzLmNsaWNrcyA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kb3VibGVDbGlja1RpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEb3VibGVDbGljayhlKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY2xpY2tzID0gMDtcbiAgICAgICAgX3RoaXMyLmRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICB9LCB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCk7XG5cbiAgICAgIC8vIE5PVEU6IHRoaXMgaXMgaGVyZSB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyBvbiBkcmFnXG4gICAgICBpZiAodGhpcy5kcmFnZ2VkRXZlbnRzIDwgdGhpcy5zZXR0aW5ncy5kcmFnZ2VkRXZlbnRzVG9sZXJhbmNlKSB0aGlzLmVtaXQoXCJjbGlja1wiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVSaWdodENsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJpZ2h0Q2xpY2soZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHRoaXMuZW1pdChcInJpZ2h0Q2xpY2tcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRG91YmxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2soZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgbW91c2VDb29yZHMgPSBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJkb3VibGVDbGlja1wiLCBtb3VzZUNvb3Jkcyk7XG4gICAgICBpZiAobW91c2VDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhjYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAvIHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nUmF0aW8pO1xuICAgICAgY2FtZXJhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRWaWV3cG9ydFpvb21lZFN0YXRlKGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSwgbmV3UmF0aW8pLCB7XG4gICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNJbk91dFwiLFxuICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURvd25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRG93bihlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBXZSBvbmx5IHN0YXJ0IGRyYWdnaW5nIG9uIGxlZnQgYnV0dG9uXG4gICAgICBpZiAoZS5idXR0b24gPT09IDApIHtcbiAgICAgICAgdGhpcy5zdGFydENhbWVyYVN0YXRlID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgX2dldFBvc2l0aW9uID0gZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLFxuICAgICAgICAgIHggPSBfZ2V0UG9zaXRpb24ueCxcbiAgICAgICAgICB5ID0gX2dldFBvc2l0aW9uLnk7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWCA9IHg7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWSA9IHk7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEV2ZW50cyA9IDA7XG4gICAgICAgIHRoaXMuZG93blN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICAgIHRoaXMuaXNNb3VzZURvd24gPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwibW91c2Vkb3duXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVVwXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVVwKGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuaXNNb3VzZURvd24pIHJldHVybjtcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgdGhpcy5pc01vdXNlRG93biA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1vdmluZ1RpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX2dldFBvc2l0aW9uMiA9IGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgeCA9IF9nZXRQb3NpdGlvbjIueCxcbiAgICAgICAgeSA9IF9nZXRQb3NpdGlvbjIueTtcbiAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRTdGF0ZSgpLFxuICAgICAgICBwcmV2aW91c0NhbWVyYVN0YXRlID0gY2FtZXJhLmdldFByZXZpb3VzU3RhdGUoKSB8fCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH07XG4gICAgICBpZiAodGhpcy5pc01vdmluZykge1xuICAgICAgICBjYW1lcmEuYW5pbWF0ZSh7XG4gICAgICAgICAgeDogY2FtZXJhU3RhdGUueCArIHRoaXMuc2V0dGluZ3MuaW5lcnRpYVJhdGlvICogKGNhbWVyYVN0YXRlLnggLSBwcmV2aW91c0NhbWVyYVN0YXRlLngpLFxuICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnkgKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS55IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS55KVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3MuaW5lcnRpYUR1cmF0aW9uLFxuICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5sYXN0TW91c2VYICE9PSB4IHx8IHRoaXMubGFzdE1vdXNlWSAhPT0geSkge1xuICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLngsXG4gICAgICAgICAgeTogY2FtZXJhU3RhdGUueVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hvdWxkUmVmcmVzaCA9IF90aGlzMy5kcmFnZ2VkRXZlbnRzID4gMDtcbiAgICAgICAgX3RoaXMzLmRyYWdnZWRFdmVudHMgPSAwO1xuXG4gICAgICAgIC8vIE5PVEU6IHRoaXMgcmVmcmVzaCBpcyBoZXJlIHRvIG1ha2Ugc3VyZSBgaGlkZUVkZ2VzT25Nb3ZlYCBjYW4gd29ya1xuICAgICAgICAvLyB3aGVuIHNvbWVvbmUgcmVsZWFzZXMgY2FtZXJhIHBhbiBkcmFnIGFmdGVyIGhhdmluZyBzdG9wcGVkIG1vdmluZy5cbiAgICAgICAgLy8gU2VlIGNvbW1pdDogaHR0cHM6Ly9naXRodWIuY29tL2phY29teWFsL3NpZ21hLmpzL2NvbW1pdC9jZmQ5MTk3ZjcwMzE5MTA5ZGI2YjY3NWRkN2M4MmJlNDkzY2E5NWEyXG4gICAgICAgIC8vIFNlZSBhbHNvIGlzc3VlOiBodHRwczovL2dpdGh1Yi5jb20vamFjb215YWwvc2lnbWEuanMvaXNzdWVzLzEyOTBcbiAgICAgICAgLy8gSXQgY291bGQgYmUgcG9zc2libGUgdG8gcmVuZGVyIGluc3RlYWQgb2Ygc2NoZWR1bGluZyBhIHJlZnJlc2ggYnV0IGZvclxuICAgICAgICAvLyBub3cgaXQgc2VlbXMgZ29vZCBlbm91Z2guXG4gICAgICAgIGlmIChzaG91bGRSZWZyZXNoICYmIF90aGlzMy5yZW5kZXJlci5nZXRTZXR0aW5nKFwiaGlkZUVkZ2VzT25Nb3ZlXCIpKSBfdGhpczMucmVuZGVyZXIucmVmcmVzaCgpO1xuICAgICAgfSwgMCk7XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZXVwXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW92ZShlKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICB2YXIgbW91c2VDb29yZHMgPSBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcik7XG5cbiAgICAgIC8vIEFsd2F5cyB0cmlnZ2VyIGEgXCJtb3VzZW1vdmVib2R5XCIgZXZlbnQsIHNvIHRoYXQgaXQgaXMgcG9zc2libGUgdG8gZGV2ZWxvcFxuICAgICAgLy8gYSBkcmFnLWFuZC1kcm9wIGVmZmVjdCB0aGF0IHdvcmtzIGV2ZW4gd2hlbiB0aGUgbW91c2UgaXMgb3V0IG9mIHRoZVxuICAgICAgLy8gY29udGFpbmVyOlxuICAgICAgdGhpcy5lbWl0KFwibW91c2Vtb3ZlYm9keVwiLCBtb3VzZUNvb3Jkcyk7XG5cbiAgICAgIC8vIE9ubHkgdHJpZ2dlciB0aGUgXCJtb3VzZW1vdmVcIiBldmVudCB3aGVuIHRoZSBtb3VzZSBpcyBhY3R1YWxseSBob3ZlcmluZ1xuICAgICAgLy8gdGhlIGNvbnRhaW5lciwgdG8gYXZvaWQgd2VpcmRseSBob3ZlcmluZyBub2RlcyBhbmQvb3IgZWRnZXMgd2hlbiB0aGVcbiAgICAgIC8vIG1vdXNlIGlzIG5vdCBob3ZlciB0aGUgY29udGFpbmVyOlxuICAgICAgaWYgKGUudGFyZ2V0ID09PSB0aGlzLmNvbnRhaW5lciB8fCBlLmNvbXBvc2VkUGF0aCgpWzBdID09PSB0aGlzLmNvbnRhaW5lcikge1xuICAgICAgICB0aGlzLmVtaXQoXCJtb3VzZW1vdmVcIiwgbW91c2VDb29yZHMpO1xuICAgICAgfVxuICAgICAgaWYgKG1vdXNlQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBIYW5kbGUgdGhlIGNhc2Ugd2hlbiBcImlzTW91c2VEb3duXCIgYWxsIHRoZSB0aW1lLCB0byBhbGxvdyBkcmFnZ2luZyB0aGVcbiAgICAgIC8vIHN0YWdlIHdoaWxlIHRoZSBtb3VzZSBpcyBub3QgaG92ZXIgdGhlIGNvbnRhaW5lcjpcbiAgICAgIGlmICh0aGlzLmlzTW91c2VEb3duKSB7XG4gICAgICAgIHRoaXMuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmRyYWdnZWRFdmVudHMrKztcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm1vdmluZ1RpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdmluZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXM0Lm1vdmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgICAgIF90aGlzNC5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICB9LCB0aGlzLnNldHRpbmdzLmRyYWdUaW1lb3V0KTtcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24zID0gZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLFxuICAgICAgICAgIGVYID0gX2dldFBvc2l0aW9uMy54LFxuICAgICAgICAgIGVZID0gX2dldFBvc2l0aW9uMy55O1xuICAgICAgICB2YXIgbGFzdE1vdXNlID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IHRoaXMubGFzdE1vdXNlWCxcbiAgICAgICAgICB5OiB0aGlzLmxhc3RNb3VzZVlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtb3VzZSA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiBlWCxcbiAgICAgICAgICB5OiBlWVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBsYXN0TW91c2UueCAtIG1vdXNlLngsXG4gICAgICAgICAgb2Zmc2V0WSA9IGxhc3RNb3VzZS55IC0gbW91c2UueTtcbiAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciB4ID0gY2FtZXJhU3RhdGUueCArIG9mZnNldFgsXG4gICAgICAgICAgeSA9IGNhbWVyYVN0YXRlLnkgKyBvZmZzZXRZO1xuICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VYID0gZVg7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWSA9IGVZO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUxlYXZlKGUpIHtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlbGVhdmVcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRW50ZXIoZSkge1xuICAgICAgdGhpcy5lbWl0KFwibW91c2VlbnRlclwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVXaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVXaGVlbChlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIWNhbWVyYS5lbmFibGVkWm9vbWluZykgcmV0dXJuO1xuICAgICAgdmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcbiAgICAgIGlmICghZGVsdGEpIHJldHVybjtcbiAgICAgIHZhciB3aGVlbENvb3JkcyA9IGdldFdoZWVsQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZW1pdChcIndoZWVsXCIsIHdoZWVsQ29vcmRzKTtcbiAgICAgIGlmICh3aGVlbENvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3JcbiAgICAgIHZhciBjdXJyZW50UmF0aW8gPSBjYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbztcbiAgICAgIHZhciByYXRpb0RpZmYgPSBkZWx0YSA+IDAgPyAxIC8gdGhpcy5zZXR0aW5ncy56b29taW5nUmF0aW8gOiB0aGlzLnNldHRpbmdzLnpvb21pbmdSYXRpbztcbiAgICAgIHZhciBuZXdSYXRpbyA9IGNhbWVyYS5nZXRCb3VuZGVkUmF0aW8oY3VycmVudFJhdGlvICogcmF0aW9EaWZmKTtcbiAgICAgIHZhciB3aGVlbERpcmVjdGlvbiA9IGRlbHRhID4gMCA/IDEgOiAtMTtcbiAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IHdpdGhvdXQgcHJldmVudGluZyBkZWZhdWx0IGJlaGF2aW9yIHdoZW4gcmF0aW8gZG9lc24ndCBjaGFuZ2U6XG4gICAgICBpZiAoY3VycmVudFJhdGlvID09PSBuZXdSYXRpbykgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgLy8gQ2FuY2VsIGV2ZW50cyB0aGF0IGFyZSB0b28gY2xvc2UgZWFjaCBvdGhlciBhbmQgaW4gdGhlIHNhbWUgZGlyZWN0aW9uOlxuICAgICAgaWYgKHRoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID09PSB3aGVlbERpcmVjdGlvbiAmJiB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lICYmIG5vdyAtIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgPCB0aGlzLnNldHRpbmdzLnpvb21EdXJhdGlvbiAvIDUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FtZXJhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRWaWV3cG9ydFpvb21lZFN0YXRlKGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSwgbmV3UmF0aW8pLCB7XG4gICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3Muem9vbUR1cmF0aW9uXG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzNS5jdXJyZW50V2hlZWxEaXJlY3Rpb24gPSAwO1xuICAgICAgfSk7XG4gICAgICB0aGlzLmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9IHdoZWVsRGlyZWN0aW9uO1xuICAgICAgdGhpcy5sYXN0V2hlZWxUcmlnZ2VyVGltZSA9IG5vdztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0U2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICB9XG4gIH1dKTtcbn0oQ2FwdG9yKTtcblxudmFyIFRPVUNIX1NFVFRJTkdTX0tFWVMgPSBbXCJkcmFnVGltZW91dFwiLCBcImluZXJ0aWFEdXJhdGlvblwiLCBcImluZXJ0aWFSYXRpb1wiLCBcImRvdWJsZUNsaWNrVGltZW91dFwiLCBcImRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvXCIsIFwiZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb25cIiwgXCJ0YXBNb3ZlVG9sZXJhbmNlXCJdO1xudmFyIERFRkFVTFRfVE9VQ0hfU0VUVElOR1MgPSBUT1VDSF9TRVRUSU5HU19LRVlTLnJlZHVjZShmdW5jdGlvbiAoaXRlciwga2V5KSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaXRlciksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgREVGQVVMVF9TRVRUSU5HU1trZXldKSk7XG59LCB7fSk7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogVG91Y2ggY2FwdG9yIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgVG91Y2hDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DYXB0b3IpIHtcbiAgZnVuY3Rpb24gVG91Y2hDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVG91Y2hDYXB0b3IpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUb3VjaENhcHRvciwgW2NvbnRhaW5lciwgcmVuZGVyZXJdKTtcblxuICAgIC8vIEJpbmRpbmcgbWV0aG9kczpcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXNNb3ZpbmdcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoYXNNb3ZlZFwiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInRvdWNoTW9kZVwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic3RhcnRUb3VjaGVzUG9zaXRpb25zXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdFRvdWNoZXNcIiwgW10pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYXN0VGFwXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzZXR0aW5nc1wiLCBERUZBVUxUX1RPVUNIX1NFVFRJTkdTKTtcbiAgICBfdGhpcy5oYW5kbGVTdGFydCA9IF90aGlzLmhhbmRsZVN0YXJ0LmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZUxlYXZlID0gX3RoaXMuaGFuZGxlTGVhdmUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlTW92ZSA9IF90aGlzLmhhbmRsZU1vdmUuYmluZChfdGhpcyk7XG5cbiAgICAvLyBCaW5kaW5nIGV2ZW50c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCBfdGhpcy5oYW5kbGVTdGFydCwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIF90aGlzLmhhbmRsZUxlYXZlLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5oYW5kbGVMZWF2ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgX3RoaXMuaGFuZGxlTW92ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2UsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoVG91Y2hDYXB0b3IsIF9DYXB0b3IpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRvdWNoQ2FwdG9yLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgdGhpcy5oYW5kbGVTdGFydCk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoY2FuY2VsXCIsIHRoaXMuaGFuZGxlTGVhdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIHRoaXMuaGFuZGxlTGVhdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmhhbmRsZU1vdmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVTdGFydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTdGFydChlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB2YXIgdG91Y2hlcyA9IGdldFRvdWNoZXNBcnJheShlLnRvdWNoZXMpO1xuICAgICAgdGhpcy50b3VjaE1vZGUgPSB0b3VjaGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCkuZ2V0U3RhdGUoKTtcbiAgICAgIHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zID0gdG91Y2hlcy5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgX3RoaXMyLmNvbnRhaW5lcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gV2hlbiB0aGVyZSBhcmUgdHdvIHRvdWNoZXMgZG93biwgbGV0J3MgcmVjb3JkIGRpc3RhbmNlIGFuZCBhbmdsZSBhcyB3ZWxsOlxuICAgICAgaWYgKHRoaXMudG91Y2hNb2RlID09PSAyKSB7XG4gICAgICAgIHZhciBfdGhpcyRzdGFydFRvdWNoZXNQb3MgPSBfc2xpY2VkVG9BcnJheSh0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucywgMiksXG4gICAgICAgICAgX3RoaXMkc3RhcnRUb3VjaGVzUG9zMiA9IF90aGlzJHN0YXJ0VG91Y2hlc1Bvc1swXSxcbiAgICAgICAgICB4MCA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczIueCxcbiAgICAgICAgICB5MCA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczIueSxcbiAgICAgICAgICBfdGhpcyRzdGFydFRvdWNoZXNQb3MzID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zWzFdLFxuICAgICAgICAgIHgxID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zMy54LFxuICAgICAgICAgIHkxID0gX3RoaXMkc3RhcnRUb3VjaGVzUG9zMy55O1xuICAgICAgICB0aGlzLnN0YXJ0VG91Y2hlc0FuZ2xlID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKTtcbiAgICAgICAgdGhpcy5zdGFydFRvdWNoZXNEaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4MSAtIHgwLCAyKSArIE1hdGgucG93KHkxIC0geTAsIDIpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcInRvdWNoZG93blwiLCBnZXRUb3VjaENvb3JkcyhlLCB0aGlzLmxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcyA9IHRvdWNoZXM7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUxlYXZlKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgIGlmIChlLmNhbmNlbGFibGUpIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGlmICh0aGlzLm1vdmluZ1RpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy50b3VjaE1vZGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGFydChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcpIHtcbiAgICAgICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCksXG4gICAgICAgICAgICAgIHByZXZpb3VzQ2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0UHJldmlvdXNTdGF0ZSgpIHx8IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDBcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbWVyYS5hbmltYXRlKHtcbiAgICAgICAgICAgICAgeDogY2FtZXJhU3RhdGUueCArIHRoaXMuc2V0dGluZ3MuaW5lcnRpYVJhdGlvICogKGNhbWVyYVN0YXRlLnggLSBwcmV2aW91c0NhbWVyYVN0YXRlLngpLFxuICAgICAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55ICsgdGhpcy5zZXR0aW5ncy5pbmVydGlhUmF0aW8gKiAoY2FtZXJhU3RhdGUueSAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueSlcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3MuaW5lcnRpYUR1cmF0aW9uLFxuICAgICAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhc01vdmVkID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMudG91Y2hNb2RlID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcInRvdWNodXBcIiwgZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpKTtcblxuICAgICAgLy8gV2hlbiB0aGUgbGFzdCB0b3VjaCBlbmRzIGFuZCB0aGVyZSBoYXNuJ3QgYmVlbiB0b28gbXVjaCBtb3ZlbWVudCwgdHJpZ2dlciBhIFwidGFwXCIgb3IgXCJkb3VibGV0YXBcIiBldmVudDpcbiAgICAgIGlmICghZS50b3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBnZXRQb3NpdGlvbih0aGlzLmxhc3RUb3VjaGVzWzBdLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHZhciBkb3duUG9zaXRpb24gPSB0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1swXTtcbiAgICAgICAgdmFyIGRTcXVhcmUgPSBNYXRoLnBvdyhwb3NpdGlvbi54IC0gZG93blBvc2l0aW9uLngsIDIpICsgTWF0aC5wb3cocG9zaXRpb24ueSAtIGRvd25Qb3NpdGlvbi55LCAyKTtcbiAgICAgICAgaWYgKCFlLnRvdWNoZXMubGVuZ3RoICYmIGRTcXVhcmUgPCBNYXRoLnBvdyh0aGlzLnNldHRpbmdzLnRhcE1vdmVUb2xlcmFuY2UsIDIpKSB7XG4gICAgICAgICAgLy8gT25seSB0cmlnZ2VyIFwiZG91YmxldGFwXCIgd2hlbiB0aGUgbGFzdCB0YXAgaXMgcmVjZW50IGVub3VnaDpcbiAgICAgICAgICBpZiAodGhpcy5sYXN0VGFwICYmIERhdGUubm93KCkgLSB0aGlzLmxhc3RUYXAudGltZSA8IHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgdG91Y2hDb29yZHMgPSBnZXRUb3VjaENvb3JkcyhlLCB0aGlzLmxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkb3VibGV0YXBcIiwgdG91Y2hDb29yZHMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGFwID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghdG91Y2hDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgICAgICAgIHZhciBfY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgICAgICAgdmFyIG5ld1JhdGlvID0gX2NhbWVyYS5nZXRCb3VuZGVkUmF0aW8oX2NhbWVyYS5nZXRTdGF0ZSgpLnJhdGlvIC8gdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1pvb21pbmdSYXRpbyk7XG4gICAgICAgICAgICAgIF9jYW1lcmEuYW5pbWF0ZSh0aGlzLnJlbmRlcmVyLmdldFZpZXdwb3J0Wm9vbWVkU3RhdGUocG9zaXRpb24sIG5ld1JhdGlvKSwge1xuICAgICAgICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNJbk91dFwiLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBFbHNlLCB0cmlnZ2VyIGEgbm9ybWFsIFwidGFwXCIgZXZlbnQ6XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgX3RvdWNoQ29vcmRzID0gZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwidGFwXCIsIF90b3VjaENvb3Jkcyk7XG4gICAgICAgICAgICB0aGlzLmxhc3RUYXAgPSB7XG4gICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgIHBvc2l0aW9uOiBfdG91Y2hDb29yZHMudG91Y2hlc1swXSB8fCBfdG91Y2hDb29yZHMucHJldmlvdXNUb3VjaGVzWzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5sYXN0VG91Y2hlcyA9IGdldFRvdWNoZXNBcnJheShlLnRvdWNoZXMpO1xuICAgICAgdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgPSBbXTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3ZlKGUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgIXRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zLmxlbmd0aCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHZhciB0b3VjaGVzUG9zaXRpb25zID0gdG91Y2hlcy5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgX3RoaXMzLmNvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0VG91Y2hlcyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzID0gdG91Y2hlcztcbiAgICAgIHRoaXMubGFzdFRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzUG9zaXRpb25zO1xuICAgICAgdmFyIHRvdWNoQ29vcmRzID0gZ2V0VG91Y2hDb29yZHMoZSwgbGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZW1pdChcInRvdWNobW92ZVwiLCB0b3VjaENvb3Jkcyk7XG4gICAgICBpZiAodG91Y2hDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIC8vIElmIGEgbW92ZSB3YXMgaW5pdGlhdGVkIGF0IHNvbWUgcG9pbnQsIGFuZCB3ZSBnZXQgYmFjayB0byBzdGFydCBwb2ludCxcbiAgICAgIC8vIHdlIHNob3VsZCBzdGlsbCBjb25zaWRlciB0aGF0IHdlIGRpZCBtb3ZlICh3aGljaCBhbHNvIGhhcHBlbnMgYWZ0ZXIgYVxuICAgICAgLy8gbXVsdGlwbGUgdG91Y2ggd2hlbiBvbmx5IG9uZSB0b3VjaCByZW1haW5zIGluIHdoaWNoIGNhc2UgaGFuZGxlU3RhcnRcbiAgICAgIC8vIGlzIHJlY2FsbGVkIHdpdGhpbiBoYW5kbGVMZWF2ZSkuXG4gICAgICAvLyBOb3csIHNvbWUgbW9iaWxlIGJyb3dzZXJzIHJlcG9ydCB6ZXJvLWRpc3RhbmNlIG1vdmVzIHNvIHdlIGFsc28gY2hlY2sgdGhhdFxuICAgICAgLy8gb25lIG9mIHRoZSB0b3VjaGVzIGRpZCBhY3R1YWxseSBtb3ZlIGZyb20gdGhlIG9yaWdpbiBwb3NpdGlvbi5cbiAgICAgIHRoaXMuaGFzTW92ZWQgfHwgKHRoaXMuaGFzTW92ZWQgPSB0b3VjaGVzUG9zaXRpb25zLnNvbWUoZnVuY3Rpb24gKHBvc2l0aW9uLCBpZHgpIHtcbiAgICAgICAgdmFyIHN0YXJ0UG9zaXRpb24gPSBfdGhpczMuc3RhcnRUb3VjaGVzUG9zaXRpb25zW2lkeF07XG4gICAgICAgIHJldHVybiBzdGFydFBvc2l0aW9uICYmIChwb3NpdGlvbi54ICE9PSBzdGFydFBvc2l0aW9uLnggfHwgcG9zaXRpb24ueSAhPT0gc3RhcnRQb3NpdGlvbi55KTtcbiAgICAgIH0pKTtcblxuICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIG1vdmUsIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIG1vdmVzIGJlaGF2aW9yXG4gICAgICBpZiAoIXRoaXMuaGFzTW92ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5tb3ZpbmdUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICB9LCB0aGlzLnNldHRpbmdzLmRyYWdUaW1lb3V0KTtcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgdmFyIHN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGU7XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMucmVuZGVyZXIuZ2V0U2V0dGluZyhcInN0YWdlUGFkZGluZ1wiKTtcbiAgICAgIHN3aXRjaCAodGhpcy50b3VjaE1vZGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRyZW5kZXJlciR2aWV3cG8gPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCgodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgfHwgW10pWzBdKSxcbiAgICAgICAgICAgICAgeFN0YXJ0ID0gX3RoaXMkcmVuZGVyZXIkdmlld3BvLngsXG4gICAgICAgICAgICAgIHlTdGFydCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwby55O1xuICAgICAgICAgICAgdmFyIF90aGlzJHJlbmRlcmVyJHZpZXdwbzIgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh0b3VjaGVzUG9zaXRpb25zWzBdKSxcbiAgICAgICAgICAgICAgeCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwbzIueCxcbiAgICAgICAgICAgICAgeSA9IF90aGlzJHJlbmRlcmVyJHZpZXdwbzIueTtcbiAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIHg6IHN0YXJ0Q2FtZXJhU3RhdGUueCArIHhTdGFydCAtIHgsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0Q2FtZXJhU3RhdGUueSArIHlTdGFydCAtIHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZXJlIGlzIHRoZSB0aGlua2luZyBoZXJlOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDEuIFdlIGNhbiBmaW5kIHRoZSBuZXcgYW5nbGUgYW5kIHJhdGlvLCBieSBjb21wYXJpbmcgdGhlIHZlY3RvciBmcm9tIFwidG91Y2ggb25lXCIgdG8gXCJ0b3VjaCB0d29cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgICAqICAgIG9mIHRoZSBkJ24nZCBhbmQgbm93XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogMi4gV2UgY2FuIHVzZSBgQ2FtZXJhI3ZpZXdwb3J0VG9HcmFwaGAgaW5zaWRlIGZvcm11bGEgdG8gcmV0cmlldmUgdGhlIG5ldyBjYW1lcmEgcG9zaXRpb24sIHVzaW5nIHRoZSBncmFwaFxuICAgICAgICAgICAgICogICAgcG9zaXRpb24gb2YgYSB0b3VjaCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkJ24nZCAodXNpbmcgYHN0YXJ0Q2FtZXJhLnZpZXdwb3J0VG9HcmFwaGApIGFuZCB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgICAqICAgIHBvc2l0aW9uIG9mIHRoaXMgc2FtZSB0b3VjaCBub3dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG5ld0NhbWVyYVN0YXRlID0ge1xuICAgICAgICAgICAgICB4OiAwLjUsXG4gICAgICAgICAgICAgIHk6IDAuNSxcbiAgICAgICAgICAgICAgYW5nbGU6IDAsXG4gICAgICAgICAgICAgIHJhdGlvOiAxXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIF90b3VjaGVzUG9zaXRpb25zJCA9IHRvdWNoZXNQb3NpdGlvbnNbMF0sXG4gICAgICAgICAgICAgIHgwID0gX3RvdWNoZXNQb3NpdGlvbnMkLngsXG4gICAgICAgICAgICAgIHkwID0gX3RvdWNoZXNQb3NpdGlvbnMkLnk7XG4gICAgICAgICAgICB2YXIgX3RvdWNoZXNQb3NpdGlvbnMkMiA9IHRvdWNoZXNQb3NpdGlvbnNbMV0sXG4gICAgICAgICAgICAgIHgxID0gX3RvdWNoZXNQb3NpdGlvbnMkMi54LFxuICAgICAgICAgICAgICB5MSA9IF90b3VjaGVzUG9zaXRpb25zJDIueTtcbiAgICAgICAgICAgIHZhciBhbmdsZURpZmYgPSBNYXRoLmF0YW4yKHkxIC0geTAsIHgxIC0geDApIC0gdGhpcy5zdGFydFRvdWNoZXNBbmdsZTtcbiAgICAgICAgICAgIHZhciByYXRpb0RpZmYgPSBNYXRoLmh5cG90KHkxIC0geTAsIHgxIC0geDApIC8gdGhpcy5zdGFydFRvdWNoZXNEaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gMS5cbiAgICAgICAgICAgIHZhciBuZXdSYXRpbyA9IGNhbWVyYS5nZXRCb3VuZGVkUmF0aW8oc3RhcnRDYW1lcmFTdGF0ZS5yYXRpbyAvIHJhdGlvRGlmZik7XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS5yYXRpbyA9IG5ld1JhdGlvO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUuYW5nbGUgPSBzdGFydENhbWVyYVN0YXRlLmFuZ2xlICsgYW5nbGVEaWZmO1xuXG4gICAgICAgICAgICAvLyAyLlxuICAgICAgICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHZhciB0b3VjaEdyYXBoUG9zaXRpb24gPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCgodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgfHwgW10pWzBdLCB7XG4gICAgICAgICAgICAgIGNhbWVyYVN0YXRlOiBzdGFydENhbWVyYVN0YXRlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBzbWFsbGVzdERpbWVuc2lvbiA9IE1hdGgubWluKGRpbWVuc2lvbnMud2lkdGgsIGRpbWVuc2lvbnMuaGVpZ2h0KSAtIDIgKiBwYWRkaW5nO1xuICAgICAgICAgICAgdmFyIGR4ID0gc21hbGxlc3REaW1lbnNpb24gLyBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgdmFyIGR5ID0gc21hbGxlc3REaW1lbnNpb24gLyBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IG5ld1JhdGlvIC8gc21hbGxlc3REaW1lbnNpb247XG5cbiAgICAgICAgICAgIC8vIEFsaWduIHdpdGggY2VudGVyIG9mIHRoZSBncmFwaDpcbiAgICAgICAgICAgIHZhciBfeCA9IHgwIC0gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gZHg7XG4gICAgICAgICAgICB2YXIgX3kgPSB5MCAtIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGR5O1xuXG4gICAgICAgICAgICAvLyBSb3RhdGU6XG4gICAgICAgICAgICB2YXIgX3JlZiA9IFtfeCAqIE1hdGguY29zKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSkgLSBfeSAqIE1hdGguc2luKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSksIF95ICogTWF0aC5jb3MoLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSArIF94ICogTWF0aC5zaW4oLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKV07XG4gICAgICAgICAgICBfeCA9IF9yZWZbMF07XG4gICAgICAgICAgICBfeSA9IF9yZWZbMV07XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS54ID0gdG91Y2hHcmFwaFBvc2l0aW9uLnggLSBfeCAqIHJhdGlvO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUueSA9IHRvdWNoR3JhcGhQb3NpdGlvbi55ICsgX3kgKiByYXRpbztcbiAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuICB9XSk7XG59KENhcHRvcik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkocik7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkocikge1xuICBpZiAoXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIG51bGwgIT0gcltTeW1ib2wuaXRlcmF0b3JdIHx8IG51bGwgIT0gcltcIkBAaXRlcmF0b3JcIl0pIHJldHVybiBBcnJheS5mcm9tKHIpO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkocikge1xuICByZXR1cm4gX2FycmF5V2l0aG91dEhvbGVzKHIpIHx8IF9pdGVyYWJsZVRvQXJyYXkocikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KHIpIHx8IF9ub25JdGVyYWJsZVNwcmVhZCgpO1xufVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShyLCBlKSB7XG4gIGlmIChudWxsID09IHIpIHJldHVybiB7fTtcbiAgdmFyIHQgPSB7fTtcbiAgZm9yICh2YXIgbiBpbiByKSBpZiAoe30uaGFzT3duUHJvcGVydHkuY2FsbChyLCBuKSkge1xuICAgIGlmICgtMSAhPT0gZS5pbmRleE9mKG4pKSBjb250aW51ZTtcbiAgICB0W25dID0gcltuXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGUsIHQpIHtcbiAgaWYgKG51bGwgPT0gZSkgcmV0dXJuIHt9O1xuICB2YXIgbyxcbiAgICByLFxuICAgIGkgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZShlLCB0KTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgZm9yIChyID0gMDsgciA8IG4ubGVuZ3RoOyByKyspIG8gPSBuW3JdLCAtMSA9PT0gdC5pbmRleE9mKG8pICYmIHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSwgbykgJiYgKGlbb10gPSBlW29dKTtcbiAgfVxuICByZXR1cm4gaTtcbn1cblxuLyoqXG4gKiBTaWdtYS5qcyBMYWJlbHMgSGV1cmlzdGljc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTWlzY2VsbGFuZW91cyBoZXVyaXN0aWNzIHJlbGF0ZWQgdG8gbGFiZWwgZGlzcGxheS5cbiAqIEBtb2R1bGVcbiAqL1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzaW5nbGUgY2FuZGlkYXRlIGZvciB0aGUgbGFiZWwgZ3JpZCBzZWxlY3Rpb24uXG4gKlxuICogSXQgYWxzbyBkZXNjcmliZXMgYSBkZXRlcm1pbmlzdGljIHdheSB0byBjb21wYXJlIHR3byBjYW5kaWRhdGVzIHRvIGFzc2Vzc1xuICogd2hpY2ggb25lIGlzIGJldHRlci5cbiAqL1xudmFyIExhYmVsQ2FuZGlkYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFiZWxDYW5kaWRhdGUoa2V5LCBzaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsQ2FuZGlkYXRlKTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTGFiZWxDYW5kaWRhdGUsIG51bGwsIFt7XG4gICAga2V5OiBcImNvbXBhcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGFyZShmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBjb21wYXJlIGJ5IHNpemVcbiAgICAgIGlmIChmaXJzdC5zaXplID4gc2Vjb25kLnNpemUpIHJldHVybiAtMTtcbiAgICAgIGlmIChmaXJzdC5zaXplIDwgc2Vjb25kLnNpemUpIHJldHVybiAxO1xuXG4gICAgICAvLyBUaGVuIHNpbmNlIG5vIHR3byBub2RlcyBjYW4gaGF2ZSB0aGUgc2FtZSBrZXksIHdlIHVzZSBpdCB0b1xuICAgICAgLy8gZGV0ZXJtaW5pc3RpY2FsbHkgdGllLWJyZWFrIGJ5IGtleVxuICAgICAgaWYgKGZpcnN0LmtleSA+IHNlY29uZC5rZXkpIHJldHVybiAxO1xuXG4gICAgICAvLyBOT1RFOiB0aGlzIGNvbXBhcmF0b3IgY2Fubm90IHJldHVybiAwXG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICB9XSk7XG59KCk7XG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIDJEIHNwYXRpYWwgZ3JpZCBkaXZpZGVkIGludG8gY29uc3RhbnQtc2l6ZSBjZWxscy5cbiAqL1xudmFyIExhYmVsR3JpZCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhYmVsR3JpZCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTGFiZWxHcmlkKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ3aWR0aFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJoZWlnaHRcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY2VsbFNpemVcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29sdW1uc1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJyb3dzXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbGxzXCIsIHt9KTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExhYmVsR3JpZCwgW3tcbiAgICBrZXk6IFwicmVzaXplQW5kQ2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplQW5kQ2xlYXIoZGltZW5zaW9ucywgY2VsbFNpemUpIHtcbiAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIHRoaXMuY2VsbFNpemUgPSBjZWxsU2l6ZTtcbiAgICAgIHRoaXMuY29sdW1ucyA9IE1hdGguY2VpbChkaW1lbnNpb25zLndpZHRoIC8gY2VsbFNpemUpO1xuICAgICAgdGhpcy5yb3dzID0gTWF0aC5jZWlsKGRpbWVuc2lvbnMuaGVpZ2h0IC8gY2VsbFNpemUpO1xuICAgICAgdGhpcy5jZWxscyA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleChwb3MpIHtcbiAgICAgIHZhciB4SW5kZXggPSBNYXRoLmZsb29yKHBvcy54IC8gdGhpcy5jZWxsU2l6ZSk7XG4gICAgICB2YXIgeUluZGV4ID0gTWF0aC5mbG9vcihwb3MueSAvIHRoaXMuY2VsbFNpemUpO1xuICAgICAgcmV0dXJuIHlJbmRleCAqIHRoaXMuY29sdW1ucyArIHhJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHNpemUsIHBvcykge1xuICAgICAgdmFyIGNhbmRpZGF0ZSA9IG5ldyBMYWJlbENhbmRpZGF0ZShrZXksIHNpemUpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleChwb3MpO1xuICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICBjZWxsID0gW107XG4gICAgICAgIHRoaXMuY2VsbHNbaW5kZXhdID0gY2VsbDtcbiAgICAgIH1cbiAgICAgIGNlbGwucHVzaChjYW5kaWRhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcmdhbml6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcmdhbml6ZSgpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5jZWxscykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNba107XG4gICAgICAgIGNlbGwuc29ydChMYWJlbENhbmRpZGF0ZS5jb21wYXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxzVG9EaXNwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsc1RvRGlzcGxheShyYXRpbywgZGVuc2l0eSkge1xuICAgICAgLy8gVE9ETzogd29yayBvbiB2aXNpYmxlIG5vZGVzIHRvIG9wdGltaXplPyBeIC0+IHRocmVzaG9sZCBvdXRzaWRlIHNvIHRoYXQgbWVtb2l6YXRpb24gd29ya3M/XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgdGhyZXNob2xkIGxvd2VyLCBidXQgaW5jcmVhc2UgY2VsbHMgYSBiaXQ/XG4gICAgICAvLyBUT0RPOiBodW50IGZvciBnZW9tIGlzc3VlIGluIGRpc2d1aXNlXG4gICAgICAvLyBUT0RPOiBtZW1vaXplIHdoaWxlIHJhdGlvIGRvZXMgbm90IG1vdmUuIG1ldGhvZCB0byBmb3JjZSByZWNvbXB1dGVcbiAgICAgIHZhciBjZWxsQXJlYSA9IHRoaXMuY2VsbFNpemUgKiB0aGlzLmNlbGxTaXplO1xuICAgICAgdmFyIHNjYWxlZENlbGxBcmVhID0gY2VsbEFyZWEgLyByYXRpbyAvIHJhdGlvO1xuICAgICAgdmFyIHNjYWxlZERlbnNpdHkgPSBzY2FsZWRDZWxsQXJlYSAqIGRlbnNpdHkgLyBjZWxsQXJlYTtcbiAgICAgIHZhciBsYWJlbHNUb0Rpc3BsYXlQZXJDZWxsID0gTWF0aC5jZWlsKHNjYWxlZERlbnNpdHkpO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLmNlbGxzKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihsYWJlbHNUb0Rpc3BsYXlQZXJDZWxsLCBjZWxsLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgIGxhYmVscy5wdXNoKGNlbGxbaV0ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqXG4gKiBMYWJlbCBoZXVyaXN0aWMgc2VsZWN0aW5nIGVkZ2UgbGFiZWxzIHRvIGRpc3BsYXksIGJhc2VkIG9uIGRpc3BsYXllZCBub2RlXG4gKiBsYWJlbHNcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgICAgICAgICAgICAgICAgLSBQYXJhbWV0ZXJzOlxuICogQHBhcmFtICB7U2V0fSAgICAgIGRpc3BsYXllZE5vZGVMYWJlbHMgIC0gQ3VycmVudGx5IGRpc3BsYXllZCBub2RlIGxhYmVscy5cbiAqIEBwYXJhbSAge1NldH0gICAgICBoaWdobGlnaHRlZE5vZGVzICAgICAtIEhpZ2hsaWdodGVkIG5vZGVzLlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgICAgICAgIC0gVGhlIHJlbmRlcmVkIGdyYXBoLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGhvdmVyZWROb2RlICAgICAgICAgIC0gSG92ZXJlZCBub2RlIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBzZWxlY3RlZCBsYWJlbHMuXG4gKi9cbmZ1bmN0aW9uIGVkZ2VMYWJlbHNUb0Rpc3BsYXlGcm9tTm9kZXMocGFyYW1zKSB7XG4gIHZhciBncmFwaCA9IHBhcmFtcy5ncmFwaCxcbiAgICBob3ZlcmVkTm9kZSA9IHBhcmFtcy5ob3ZlcmVkTm9kZSxcbiAgICBoaWdobGlnaHRlZE5vZGVzID0gcGFyYW1zLmhpZ2hsaWdodGVkTm9kZXMsXG4gICAgZGlzcGxheWVkTm9kZUxhYmVscyA9IHBhcmFtcy5kaXNwbGF5ZWROb2RlTGFiZWxzO1xuICB2YXIgd29ydGh5RWRnZXMgPSBbXTtcblxuICAvLyBUT0RPOiB0aGUgY29kZSBiZWxvdyBjYW4gYmUgb3B0aW1pemVkIHVzaW5nICMuZm9yRWFjaCBhbmQgYmF0Y2hpbmcgdGhlIGNvZGUgcGVyIGFkalxuXG4gIC8vIFdlIHNob3VsZCBkaXNwbGF5IGFuIGVkZ2UncyBsYWJlbCBpZjpcbiAgLy8gICAtIEFueSBvZiBpdHMgZXh0cmVtaXRpZXMgaXMgaGlnaGxpZ2h0ZWQgb3IgaG92ZXJlZFxuICAvLyAgIC0gQm90aCBvZiBpdHMgZXh0cmVtaXRpZXMgaGFzIGl0cyBsYWJlbCBzaG93blxuICBncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgXywgc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoc291cmNlID09PSBob3ZlcmVkTm9kZSB8fCB0YXJnZXQgPT09IGhvdmVyZWROb2RlIHx8IGhpZ2hsaWdodGVkTm9kZXMuaGFzKHNvdXJjZSkgfHwgaGlnaGxpZ2h0ZWROb2Rlcy5oYXModGFyZ2V0KSB8fCBkaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyhzb3VyY2UpICYmIGRpc3BsYXllZE5vZGVMYWJlbHMuaGFzKHRhcmdldCkpIHtcbiAgICAgIHdvcnRoeUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHdvcnRoeUVkZ2VzO1xufVxuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xudmFyIFhfTEFCRUxfTUFSR0lOID0gMTUwO1xudmFyIFlfTEFCRUxfTUFSR0lOID0gNTA7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEltcG9ydGFudCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Tm9kZURlZmF1bHRzKHNldHRpbmdzLCBrZXksIGRhdGEpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwieFwiKSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcInlcIikpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHZhbGlkIHBvc2l0aW9uICh4LCB5KSBmb3Igbm9kZSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiLiBBbGwgeW91ciBub2RlcyBtdXN0IGhhdmUgYSBudW1iZXIgXFxcInhcXFwiIGFuZCBcXFwieVxcXCIuIE1heWJlIHlvdXIgZm9yZ290IHRvIGFwcGx5IGEgbGF5b3V0IG9yIHlvdXIgXFxcIm5vZGVSZWR1Y2VyXFxcIiBpcyBub3QgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IGRhdGE/XCIpKTtcbiAgaWYgKCFkYXRhLmNvbG9yKSBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdE5vZGVDb2xvcjtcbiAgaWYgKCFkYXRhLmxhYmVsICYmIGRhdGEubGFiZWwgIT09IFwiXCIpIGRhdGEubGFiZWwgPSBudWxsO1xuICBpZiAoZGF0YS5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIGRhdGEubGFiZWwgIT09IG51bGwpIGRhdGEubGFiZWwgPSBcIlwiICsgZGF0YS5sYWJlbDtlbHNlIGRhdGEubGFiZWwgPSBudWxsO1xuICBpZiAoIWRhdGEuc2l6ZSkgZGF0YS5zaXplID0gMjtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlkZGVuXCIpKSBkYXRhLmhpZGRlbiA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJoaWdobGlnaHRlZFwiKSkgZGF0YS5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJmb3JjZUxhYmVsXCIpKSBkYXRhLmZvcmNlTGFiZWwgPSBmYWxzZTtcbiAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSBcIlwiKSBkYXRhLnR5cGUgPSBzZXR0aW5ncy5kZWZhdWx0Tm9kZVR5cGU7XG4gIGlmICghZGF0YS56SW5kZXgpIGRhdGEuekluZGV4ID0gMDtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBhcHBseUVkZ2VEZWZhdWx0cyhzZXR0aW5ncywgX2tleSwgZGF0YSkge1xuICBpZiAoIWRhdGEuY29sb3IpIGRhdGEuY29sb3IgPSBzZXR0aW5ncy5kZWZhdWx0RWRnZUNvbG9yO1xuICBpZiAoIWRhdGEubGFiZWwpIGRhdGEubGFiZWwgPSBcIlwiO1xuICBpZiAoIWRhdGEuc2l6ZSkgZGF0YS5zaXplID0gMC41O1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJoaWRkZW5cIikpIGRhdGEuaGlkZGVuID0gZmFsc2U7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImZvcmNlTGFiZWxcIikpIGRhdGEuZm9yY2VMYWJlbCA9IGZhbHNlO1xuICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IFwiXCIpIGRhdGEudHlwZSA9IHNldHRpbmdzLmRlZmF1bHRFZGdlVHlwZTtcbiAgaWYgKCFkYXRhLnpJbmRleCkgZGF0YS56SW5kZXggPSAwO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNYWluIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtHcmFwaH0gICAgICAgZ3JhcGggICAgIC0gR3JhcGggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gRE9NIGNvbnRhaW5lciBpbiB3aGljaCB0byByZW5kZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gICAgICBzZXR0aW5ncyAgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqL1xudmFyIFNpZ21hJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBmdW5jdGlvbiBTaWdtYShncmFwaCwgY29udGFpbmVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIHZhciBzZXR0aW5ncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNpZ21hKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgU2lnbWEpO1xuXG4gICAgLy8gUmVzb2x2aW5nIHNldHRpbmdzXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVsZW1lbnRzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2FudmFzQ29udGV4dHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ3ZWJHTENvbnRleHRzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicGlja2luZ0xheWVyc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0ZXh0dXJlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImZyYW1lQnVmZmVyc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFjdGl2ZUxpc3RlbmVyc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhYmVsR3JpZFwiLCBuZXcgTGFiZWxHcmlkKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlRGF0YUNhY2hlXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZURhdGFDYWNoZVwiLCB7fSk7XG4gICAgLy8gSW5kaWNlcyB0byBrZWVwIHRyYWNrIG9mIHRoZSBpbmRleCBvZiB0aGUgaXRlbSBpbnNpZGUgcHJvZ3JhbXNcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZVByb2dyYW1JbmRleFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VQcm9ncmFtSW5kZXhcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2Rlc1dpdGhGb3JjZWRMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZXNXaXRoRm9yY2VkTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVFeHRlbnRcIiwge1xuICAgICAgeDogWzAsIDFdLFxuICAgICAgeTogWzAsIDFdXG4gICAgfSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVaRXh0ZW50XCIsIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VaRXh0ZW50XCIsIFtJbmZpbml0eSwgLUluZmluaXR5XSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1hdHJpeFwiLCBpZGVudGl0eSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaW52TWF0cml4XCIsIGlkZW50aXR5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjb3JyZWN0aW9uUmF0aW9cIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImN1c3RvbUJCb3hcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vcm1hbGl6YXRpb25GdW5jdGlvblwiLCBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24oe1xuICAgICAgeDogWzAsIDFdLFxuICAgICAgeTogWzAsIDFdXG4gICAgfSkpO1xuICAgIC8vIENhY2hlOlxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJncmFwaFRvVmlld3BvcnRSYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXRlbUlEc0luZGV4XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZUluZGljZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlSW5kaWNlc1wiLCB7fSk7XG4gICAgLy8gU3RhcnRpbmcgZGltZW5zaW9ucyBhbmQgcGl4ZWwgcmF0aW9cbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwid2lkdGhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhlaWdodFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicGl4ZWxSYXRpb1wiLCBnZXRQaXhlbFJhdGlvKCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJwaWNraW5nRG93blNpemluZ1JhdGlvXCIsIDIgKiBfdGhpcy5waXhlbFJhdGlvKTtcbiAgICAvLyBHcmFwaCBTdGF0ZVxuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkaXNwbGF5ZWROb2RlTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRpc3BsYXllZEVkZ2VMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGlnaGxpZ2h0ZWROb2Rlc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJob3ZlcmVkTm9kZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaG92ZXJlZEVkZ2VcIiwgbnVsbCk7XG4gICAgLy8gSW50ZXJuYWwgc3RhdGVzXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInJlbmRlckZyYW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5lZWRUb1Byb2Nlc3NcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjaGVja0VkZ2VzRXZlbnRzRnJhbWVcIiwgbnVsbCk7XG4gICAgLy8gUHJvZ3JhbXNcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZVByb2dyYW1zXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZUhvdmVyUHJvZ3JhbXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlUHJvZ3JhbXNcIiwge30pO1xuICAgIF90aGlzLnNldHRpbmdzID0gcmVzb2x2ZVNldHRpbmdzKHNldHRpbmdzKTtcblxuICAgIC8vIFZhbGlkYXRpbmdcbiAgICB2YWxpZGF0ZVNldHRpbmdzKF90aGlzLnNldHRpbmdzKTtcbiAgICB2YWxpZGF0ZUdyYXBoKGdyYXBoKTtcbiAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb250YWluZXIgc2hvdWxkIGJlIGFuIGh0bWwgZWxlbWVudC5cIik7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgX3RoaXMuZ3JhcGggPSBncmFwaDtcbiAgICBfdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG5cbiAgICAvLyBJbml0aWFsaXppbmcgY29udGV4dHNcbiAgICBfdGhpcy5jcmVhdGVXZWJHTENvbnRleHQoXCJlZGdlc1wiLCB7XG4gICAgICBwaWNraW5nOiBzZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzXG4gICAgfSk7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcImVkZ2VMYWJlbHNcIik7XG4gICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwibm9kZXNcIiwge1xuICAgICAgcGlja2luZzogdHJ1ZVxuICAgIH0pO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJsYWJlbHNcIik7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcImhvdmVyc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVXZWJHTENvbnRleHQoXCJob3Zlck5vZGVzXCIpO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJtb3VzZVwiLCB7XG4gICAgICBzdHlsZToge1xuICAgICAgICB0b3VjaEFjdGlvbjogXCJub25lXCIsXG4gICAgICAgIHVzZXJTZWxlY3Q6IFwibm9uZVwiXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBJbml0aWFsIHJlc2l6ZVxuICAgIF90aGlzLnJlc2l6ZSgpO1xuXG4gICAgLy8gTG9hZGluZyBwcm9ncmFtc1xuICAgIGZvciAodmFyIHR5cGUgaW4gX3RoaXMuc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICBfdGhpcy5yZWdpc3Rlck5vZGVQcm9ncmFtKHR5cGUsIF90aGlzLnNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1t0eXBlXSwgX3RoaXMuc2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXNbdHlwZV0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfdHlwZSBpbiBfdGhpcy5zZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgIF90aGlzLnJlZ2lzdGVyRWRnZVByb2dyYW0oX3R5cGUsIF90aGlzLnNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1tfdHlwZV0pO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgY2FtZXJhXG4gICAgX3RoaXMuY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuXG4gICAgLy8gQmluZGluZyBjYW1lcmEgZXZlbnRzXG4gICAgX3RoaXMuYmluZENhbWVyYUhhbmRsZXJzKCk7XG5cbiAgICAvLyBJbml0aWFsaXppbmcgY2FwdG9yc1xuICAgIF90aGlzLm1vdXNlQ2FwdG9yID0gbmV3IE1vdXNlQ2FwdG9yKF90aGlzLmVsZW1lbnRzLm1vdXNlLCBfdGhpcyk7XG4gICAgX3RoaXMubW91c2VDYXB0b3Iuc2V0U2V0dGluZ3MoX3RoaXMuc2V0dGluZ3MpO1xuICAgIF90aGlzLnRvdWNoQ2FwdG9yID0gbmV3IFRvdWNoQ2FwdG9yKF90aGlzLmVsZW1lbnRzLm1vdXNlLCBfdGhpcyk7XG4gICAgX3RoaXMudG91Y2hDYXB0b3Iuc2V0U2V0dGluZ3MoX3RoaXMuc2V0dGluZ3MpO1xuXG4gICAgLy8gQmluZGluZyBldmVudCBoYW5kbGVyc1xuICAgIF90aGlzLmJpbmRFdmVudEhhbmRsZXJzKCk7XG5cbiAgICAvLyBCaW5kaW5nIGdyYXBoIGhhbmRsZXJzXG4gICAgX3RoaXMuYmluZEdyYXBoSGFuZGxlcnMoKTtcblxuICAgIC8vIFRyaWdnZXIgZXZlbnR1YWwgc2V0dGluZ3MtcmVsYXRlZCB0aGluZ3NcbiAgICBfdGhpcy5oYW5kbGVTZXR0aW5nc1VwZGF0ZSgpO1xuXG4gICAgLy8gUHJvY2Vzc2luZyBkYXRhIGZvciB0aGUgZmlyc3QgdGltZSAmIHJlbmRlclxuICAgIF90aGlzLnJlZnJlc2goKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogSW50ZXJuYWwgbWV0aG9kcy5cbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHJlZ2lzdGVyIGEgbm9kZSBwcm9ncmFtXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgICAgIGtleSAgICAgICAgICAgICAgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgbm9kZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgKiBAcGFyYW0gIHtOb2RlUHJvZ3JhbVR5cGV9ICBOb2RlUHJvZ3JhbUNsYXNzIC0gQSBub2RlcyBwcm9ncmFtIGNsYXNzLlxuICAgKiBAcGFyYW0gIHtOb2RlUHJvZ3JhbVR5cGU/fSBOb2RlSG92ZXJQcm9ncmFtIC0gQSBub2RlcyBwcm9ncmFtIGNsYXNzIHRvIHJlbmRlciBob3ZlcmVkIG5vZGVzIChvcHRpb25hbCkuXG4gICAqIEByZXR1cm4ge1NpZ21hfVxuICAgKi9cbiAgX2luaGVyaXRzKFNpZ21hLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFNpZ21hLCBbe1xuICAgIGtleTogXCJyZWdpc3Rlck5vZGVQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZ2lzdGVyTm9kZVByb2dyYW0oa2V5LCBOb2RlUHJvZ3JhbUNsYXNzLCBOb2RlSG92ZXJQcm9ncmFtKSB7XG4gICAgICBpZiAodGhpcy5ub2RlUHJvZ3JhbXNba2V5XSkgdGhpcy5ub2RlUHJvZ3JhbXNba2V5XS5raWxsKCk7XG4gICAgICBpZiAodGhpcy5ub2RlSG92ZXJQcm9ncmFtc1trZXldKSB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW2tleV0ua2lsbCgpO1xuICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNba2V5XSA9IG5ldyBOb2RlUHJvZ3JhbUNsYXNzKHRoaXMud2ViR0xDb250ZXh0cy5ub2RlcywgdGhpcy5mcmFtZUJ1ZmZlcnMubm9kZXMsIHRoaXMpO1xuICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1trZXldID0gbmV3IChOb2RlSG92ZXJQcm9ncmFtIHx8IE5vZGVQcm9ncmFtQ2xhc3MpKHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLCBudWxsLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gcmVnaXN0ZXIgYW4gZWRnZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgIGtleSAgICAgICAgICAgICAgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgZWRnZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgICAqIEBwYXJhbSAge0VkZ2VQcm9ncmFtVHlwZX0gRWRnZVByb2dyYW1DbGFzcyAtIEFuIGVkZ2VzIHByb2dyYW0gY2xhc3MuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJFZGdlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3RlckVkZ2VQcm9ncmFtKGtleSwgRWRnZVByb2dyYW1DbGFzcykge1xuICAgICAgaWYgKHRoaXMuZWRnZVByb2dyYW1zW2tleV0pIHRoaXMuZWRnZVByb2dyYW1zW2tleV0ua2lsbCgpO1xuICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNba2V5XSA9IG5ldyBFZGdlUHJvZ3JhbUNsYXNzKHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcywgdGhpcy5mcmFtZUJ1ZmZlcnMuZWRnZXMsIHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1bnJlZ2lzdGVyIGEgbm9kZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBwcm9ncmFtJ3Mga2V5LCBtYXRjaGluZyB0aGUgcmVsYXRlZCBub2RlcyBcInR5cGVcIiB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5yZWdpc3Rlck5vZGVQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXJOb2RlUHJvZ3JhbShrZXkpIHtcbiAgICAgIGlmICh0aGlzLm5vZGVQcm9ncmFtc1trZXldKSB7XG4gICAgICAgIHZhciBfdGhpcyRub2RlUHJvZ3JhbXMgPSB0aGlzLm5vZGVQcm9ncmFtcyxcbiAgICAgICAgICBwcm9ncmFtID0gX3RoaXMkbm9kZVByb2dyYW1zW2tleV0sXG4gICAgICAgICAgcHJvZ3JhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkbm9kZVByb2dyYW1zLCBba2V5XS5tYXAoX3RvUHJvcGVydHlLZXkpKTtcbiAgICAgICAgcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zID0gcHJvZ3JhbXM7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ub2RlSG92ZXJQcm9ncmFtc1trZXldKSB7XG4gICAgICAgIHZhciBfdGhpcyRub2RlSG92ZXJQcm9ncmEgPSB0aGlzLm5vZGVIb3ZlclByb2dyYW1zLFxuICAgICAgICAgIF9wcm9ncmFtID0gX3RoaXMkbm9kZUhvdmVyUHJvZ3JhW2tleV0sXG4gICAgICAgICAgX3Byb2dyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJG5vZGVIb3ZlclByb2dyYSwgW2tleV0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICAgIF9wcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXMgPSBfcHJvZ3JhbXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHVucmVnaXN0ZXIgYW4gZWRnZSBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBwcm9ncmFtJ3Mga2V5LCBtYXRjaGluZyB0aGUgcmVsYXRlZCBlZGdlcyBcInR5cGVcIiB2YWx1ZXMuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5yZWdpc3RlckVkZ2VQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVucmVnaXN0ZXJFZGdlUHJvZ3JhbShrZXkpIHtcbiAgICAgIGlmICh0aGlzLmVkZ2VQcm9ncmFtc1trZXldKSB7XG4gICAgICAgIHZhciBfdGhpcyRlZGdlUHJvZ3JhbXMgPSB0aGlzLmVkZ2VQcm9ncmFtcyxcbiAgICAgICAgICBwcm9ncmFtID0gX3RoaXMkZWRnZVByb2dyYW1zW2tleV0sXG4gICAgICAgICAgcHJvZ3JhbXMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3RoaXMkZWRnZVByb2dyYW1zLCBba2V5XS5tYXAoX3RvUHJvcGVydHlLZXkpKTtcbiAgICAgICAgcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIHRoaXMuZWRnZVByb2dyYW1zID0gcHJvZ3JhbXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgKHJlKWJpbmRpbmcgV2ViR0wgdGV4dHVyZSAoZm9yIHBpY2tpbmcpLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzZXRXZWJHTFRleHR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzZXRXZWJHTFRleHR1cmUoaWQpIHtcbiAgICAgIHZhciBnbCA9IHRoaXMud2ViR0xDb250ZXh0c1tpZF07XG4gICAgICB2YXIgZnJhbWVCdWZmZXIgPSB0aGlzLmZyYW1lQnVmZmVyc1tpZF07XG4gICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB0aGlzLnRleHR1cmVzW2lkXTtcbiAgICAgIGlmIChjdXJyZW50VGV4dHVyZSkgZ2wuZGVsZXRlVGV4dHVyZShjdXJyZW50VGV4dHVyZSk7XG4gICAgICB2YXIgcGlja2luZ1RleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHBpY2tpbmdUZXh0dXJlKTtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCBwaWNraW5nVGV4dHVyZSwgMCk7XG4gICAgICB0aGlzLnRleHR1cmVzW2lkXSA9IHBpY2tpbmdUZXh0dXJlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGJpbmRpbmcgY2FtZXJhIGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZENhbWVyYUhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRDYW1lcmFIYW5kbGVycygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2FtZXJhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmNhbWVyYS5vbihcInVwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2FtZXJhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1bmJpbmRpbmcgY2FtZXJhIGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kQ2FtZXJhSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kQ2FtZXJhSGFuZGxlcnMoKSB7XG4gICAgICB0aGlzLmNhbWVyYS5yZW1vdmVMaXN0ZW5lcihcInVwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2FtZXJhKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IHJldHVybnMgdGhlIGNsb3Nlc3Qgbm9kZSB0byBhIGdpdmVuIHBvc2l0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVBdFBvc2l0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVBdFBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgICB2YXIgeCA9IHBvc2l0aW9uLngsXG4gICAgICAgIHkgPSBwb3NpdGlvbi55O1xuICAgICAgdmFyIGNvbG9yID0gZ2V0UGl4ZWxDb2xvcih0aGlzLndlYkdMQ29udGV4dHMubm9kZXMsIHRoaXMuZnJhbWVCdWZmZXJzLm5vZGVzLCB4LCB5LCB0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGlja2luZ0Rvd25TaXppbmdSYXRpbyk7XG4gICAgICB2YXIgaW5kZXggPSBjb2xvclRvSW5kZXguYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sb3IpKTtcbiAgICAgIHZhciBpdGVtQXQgPSB0aGlzLml0ZW1JRHNJbmRleFtpbmRleF07XG4gICAgICByZXR1cm4gaXRlbUF0ICYmIGl0ZW1BdC50eXBlID09PSBcIm5vZGVcIiA/IGl0ZW1BdC5pZCA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGJpbmRpbmcgZXZlbnQgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJiaW5kRXZlbnRIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kRXZlbnRIYW5kbGVycygpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgLy8gSGFuZGxpbmcgd2luZG93IHJlc2l6ZVxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBuZWVkIHRvIGNhbGwgYSByZWZyZXNoIHRvIHJlYnVpbGQgdGhlIGxhYmVsZ3JpZFxuICAgICAgICBfdGhpczMuc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplKTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgbW92ZVxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9kZVRvSG92ZXIgPSBfdGhpczMuZ2V0Tm9kZUF0UG9zaXRpb24oZXZlbnQpO1xuICAgICAgICBpZiAobm9kZVRvSG92ZXIgJiYgX3RoaXMzLmhvdmVyZWROb2RlICE9PSBub2RlVG9Ib3ZlciAmJiAhX3RoaXMzLm5vZGVEYXRhQ2FjaGVbbm9kZVRvSG92ZXJdLmhpZGRlbikge1xuICAgICAgICAgIC8vIEhhbmRsaW5nIHBhc3NpbmcgZnJvbSBvbmUgbm9kZSB0byB0aGUgb3RoZXIgZGlyZWN0bHlcbiAgICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWROb2RlKSBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIG5vZGU6IF90aGlzMy5ob3ZlcmVkTm9kZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuaG92ZXJlZE5vZGUgPSBub2RlVG9Ib3ZlcjtcbiAgICAgICAgICBfdGhpczMuZW1pdChcImVudGVyTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIG5vZGU6IG5vZGVUb0hvdmVyXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVja2luZyBpZiB0aGUgaG92ZXJlZCBub2RlIGlzIHN0aWxsIGhvdmVyZWRcbiAgICAgICAgaWYgKF90aGlzMy5ob3ZlcmVkTm9kZSkge1xuICAgICAgICAgIGlmIChfdGhpczMuZ2V0Tm9kZUF0UG9zaXRpb24oZXZlbnQpICE9PSBfdGhpczMuaG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX3RoaXMzLmhvdmVyZWROb2RlO1xuICAgICAgICAgICAgX3RoaXMzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzMy5lbWl0KFwibGVhdmVOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBub2RlOiBub2RlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50cykge1xuICAgICAgICAgIHZhciBlZGdlVG9Ib3ZlciA9IF90aGlzMy5ob3ZlcmVkTm9kZSA/IG51bGwgOiBfdGhpczMuZ2V0RWRnZUF0UG9pbnQoYmFzZUV2ZW50LmV2ZW50LngsIGJhc2VFdmVudC5ldmVudC55KTtcbiAgICAgICAgICBpZiAoZWRnZVRvSG92ZXIgIT09IF90aGlzMy5ob3ZlcmVkRWRnZSkge1xuICAgICAgICAgICAgaWYgKF90aGlzMy5ob3ZlcmVkRWRnZSkgX3RoaXMzLmVtaXQoXCJsZWF2ZUVkZ2VcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGVkZ2U6IF90aGlzMy5ob3ZlcmVkRWRnZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKGVkZ2VUb0hvdmVyKSBfdGhpczMuZW1pdChcImVudGVyRWRnZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgZWRnZTogZWRnZVRvSG92ZXJcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIF90aGlzMy5ob3ZlcmVkRWRnZSA9IGVkZ2VUb0hvdmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgbW92ZSBvdmVyIGJvZHkgKG9ubHkgdG8gZGlzcGF0Y2ggdGhlIHByb3BlciBldmVudCk6XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlQm9keSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgIF90aGlzMy5lbWl0KFwibW92ZUJvZHlcIiwge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBIYW5kbGluZyBtb3VzZSBsZWF2ZSBzdGFnZTpcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUxlYXZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY2xlYW5Nb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIG5vZGU6IF90aGlzMy5ob3ZlcmVkTm9kZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzICYmIF90aGlzMy5ob3ZlcmVkRWRnZSkge1xuICAgICAgICAgIF90aGlzMy5lbWl0KFwibGVhdmVFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgZWRnZTogX3RoaXMzLmhvdmVyZWRFZGdlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlU3RhZ2VcIiwgX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCkpO1xuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgZW50ZXIgc3RhZ2U6XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpczMuZW1pdChcImVudGVyU3RhZ2VcIiwgX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCkpO1xuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgY2xpY2tcbiAgICAgIHZhciBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyID0gZnVuY3Rpb24gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihldmVudFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgdmFyIGV2ZW50ID0gY2xlYW5Nb3VzZUNvb3JkcyhlKTtcbiAgICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIG5vZGVBdFBvc2l0aW9uID0gX3RoaXMzLmdldE5vZGVBdFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgICBpZiAobm9kZUF0UG9zaXRpb24pIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiTm9kZVwiKSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBub2RlQXRQb3NpdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMzLmdldEVkZ2VBdFBvaW50KGV2ZW50LngsIGV2ZW50LnkpO1xuICAgICAgICAgICAgaWYgKGVkZ2UpIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiRWRnZVwiKSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGVkZ2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF90aGlzMy5lbWl0KFwiXCIuY29uY2F0KGV2ZW50VHlwZSwgXCJTdGFnZVwiKSwgYmFzZUV2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVDbGljayA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJjbGlja1wiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJpZ2h0Q2xpY2sgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwicmlnaHRDbGlja1wiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcImRvdWJsZUNsaWNrXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlV2hlZWwgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwid2hlZWxcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3duID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcImRvd25cIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVVcCA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJ1cFwiKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZW1vdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZSk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vtb3ZlYm9keVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlQm9keSk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwiY2xpY2tcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlQ2xpY2spO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcInJpZ2h0Q2xpY2tcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmlnaHRDbGljayk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwiZG91YmxlQ2xpY2tcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG91YmxlQ2xpY2spO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIndoZWVsXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVdoZWVsKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJtb3VzZWRvd25cIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93bik7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2V1cFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVVcCk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2VsZWF2ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVMZWF2ZSk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2VlbnRlclwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVFbnRlcik7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2hkb3duXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24pO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNoZG93blwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaHVwXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVVwKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaG1vdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZSk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidGFwXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJkb3VibGV0YXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG91YmxlQ2xpY2spO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNobW92ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlQm9keSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEdyYXBoSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyYXBoSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICB2YXIgTEFZT1VUX0lNUEFDVElOR19GSUVMRFMgPSBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwiekluZGV4XCIsIFwidHlwZVwiXSk7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2UkaGludHM7XG4gICAgICAgIHZhciB1cGRhdGVkRmllbGRzID0gKF9lJGhpbnRzID0gZS5oaW50cykgPT09IG51bGwgfHwgX2UkaGludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJGhpbnRzLmF0dHJpYnV0ZXM7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgYWxsIG5vZGVzXG4gICAgICAgIF90aGlzNC5ncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQudXBkYXRlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgY29vcmQsIHR5cGUgb3IgekluZGV4IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIHJlbmRlclxuICAgICAgICAvLyAoekluZGV4IGZvciB0aGUgcHJvZ3JhbUluZGV4KVxuICAgICAgICB2YXIgbGF5b3V0Q2hhbmdlZCA9ICF1cGRhdGVkRmllbGRzIHx8IHVwZGF0ZWRGaWVsZHMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBMQVlPVVRfSU1QQUNUSU5HX0ZJRUxEUy5oYXMoZik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogZ3JhcGgubm9kZXMoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246ICFsYXlvdXRDaGFuZ2VkLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfZSRoaW50czI7XG4gICAgICAgIHZhciB1cGRhdGVkRmllbGRzID0gKF9lJGhpbnRzMiA9IGUuaGludHMpID09PSBudWxsIHx8IF9lJGhpbnRzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UkaGludHMyLmF0dHJpYnV0ZXM7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgYWxsIGVkZ2VzXG4gICAgICAgIF90aGlzNC5ncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQudXBkYXRlRWRnZShlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXlvdXRDaGFuZ2VkID0gdXBkYXRlZEZpZWxkcyAmJiBbXCJ6SW5kZXhcIiwgXCJ0eXBlXCJdLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlZEZpZWxkcyA9PT0gbnVsbCB8fCB1cGRhdGVkRmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cGRhdGVkRmllbGRzLmluY2x1ZGVzKGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IGdyYXBoLmVkZ2VzKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiAhbGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGFkZCBub2RlLCB3ZSBhZGQgdGhlIG5vZGUgaW4gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlbmRlclxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgbm9kZVxuICAgICAgICBfdGhpczQuYWRkTm9kZShub2RlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIHVwZGF0ZSBub2RlLCB3ZSB1cGRhdGUgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlbmRlclxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGRyb3Agbm9kZSwgd2UgcmVtb3ZlIHRoZSBub2RlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgZXZlcnl0aGluZ1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBhZGQgZWRnZSwgd2UgcmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZEVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LmFkZEVkZ2UoZWRnZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgZWRnZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBlZGdlczogW2VkZ2VdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIHVwZGF0ZSBlZGdlLCB3ZSB1cGRhdGUgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZUVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVwYWludCBmb3IgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IFtlZGdlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246IGZhbHNlLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gZHJvcCBlZGdlLCB3ZSByZW1vdmUgdGhlIGVkZ2UgZnJvbSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlbW92ZUVkZ2UoZWRnZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGwgZWRnZXNcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gY2xlYXIgZWRnZXMsIHdlIGNsZWFyIHRoZSBlZGdlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIGNsZWFyIHRoZSBlZGdlIGRhdGEgc3RydWN0dXJlc1xuICAgICAgICBfdGhpczQuY2xlYXJFZGdlU3RhdGUoKTtcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGFsbCBlZGdlc1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBncmFwaCBjbGVhciwgd2UgY2xlYXIgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNsZWFyIGdyYXBoIHN0YXRlXG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VTdGF0ZSgpO1xuICAgICAgICBfdGhpczQuY2xlYXJOb2RlU3RhdGUoKTtcblxuICAgICAgICAvLyBjbGVhciBncmFwaCBpbmRpY2VzXG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICAgIF90aGlzNC5jbGVhck5vZGVJbmRpY2VzKCk7XG5cbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGFsbFxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZ3JhcGgub24oXCJub2RlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwibm9kZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcIm5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGRFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZUVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZXNDbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyRWRnZXNHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImNsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJHcmFwaFVwZGF0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1bmJpbmQgaGFuZGxlcnMgZnJvbSB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kR3JhcGhIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRHcmFwaEhhbmRsZXJzKCkge1xuICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VzQ2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJjbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBsb29raW5nIGZvciBhbiBlZGdlIGNvbGxpZGluZyB3aXRoIGEgZ2l2ZW4gcG9pbnQgYXQgKHgsIHkpLiBSZXR1cm5zXG4gICAgICogdGhlIGtleSBvZiB0aGUgZWRnZSBpZiBhbnksIG9yIG51bGwgZWxzZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlQXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlQXRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgY29sb3IgPSBnZXRQaXhlbENvbG9yKHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcywgdGhpcy5mcmFtZUJ1ZmZlcnMuZWRnZXMsIHgsIHksIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvKTtcbiAgICAgIHZhciBpbmRleCA9IGNvbG9yVG9JbmRleC5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjb2xvcikpO1xuICAgICAgdmFyIGl0ZW1BdCA9IHRoaXMuaXRlbUlEc0luZGV4W2luZGV4XTtcbiAgICAgIHJldHVybiBpdGVtQXQgJiYgaXRlbUF0LnR5cGUgPT09IFwiZWRnZVwiID8gaXRlbUF0LmlkIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBwcm9jZXNzIHRoZSB3aG9sZSBncmFwaCdzIGRhdGEuXG4gICAgICogIC0gZXh0ZW50XG4gICAgICogIC0gbm9ybWFsaXphdGlvbkZ1bmN0aW9uXG4gICAgICogIC0gY29tcHV0ZSBub2RlJ3MgY29vcmRpbmF0ZVxuICAgICAqICAtIGxhYmVsZ3JpZFxuICAgICAqICAtIHByb2dyYW0gZGF0YSBhbGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB0aGlzLmVtaXQoXCJiZWZvcmVQcm9jZXNzXCIpO1xuICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuXG4gICAgICAvL1xuICAgICAgLy8gTk9ERVNcbiAgICAgIC8vXG4gICAgICB0aGlzLm5vZGVFeHRlbnQgPSBncmFwaEV4dGVudCh0aGlzLmdyYXBoKTtcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5hdXRvUmVzY2FsZSkge1xuICAgICAgICB2YXIgd2lkdGggPSBkaW1lbnNpb25zLndpZHRoLFxuICAgICAgICAgIGhlaWdodCA9IGRpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgICB2YXIgX3RoaXMkbm9kZUV4dGVudCA9IHRoaXMubm9kZUV4dGVudCxcbiAgICAgICAgICB4ID0gX3RoaXMkbm9kZUV4dGVudC54LFxuICAgICAgICAgIHkgPSBfdGhpcyRub2RlRXh0ZW50Lnk7XG4gICAgICAgIHRoaXMubm9kZUV4dGVudCA9IHtcbiAgICAgICAgICB4OiBbKHhbMF0gKyB4WzFdKSAvIDIgLSB3aWR0aCAvIDIsICh4WzBdICsgeFsxXSkgLyAyICsgd2lkdGggLyAyXSxcbiAgICAgICAgICB5OiBbKHlbMF0gKyB5WzFdKSAvIDIgLSBoZWlnaHQgLyAyLCAoeVswXSArIHlbMV0pIC8gMiArIGhlaWdodCAvIDJdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbiA9IGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbih0aGlzLmN1c3RvbUJCb3ggfHwgdGhpcy5ub2RlRXh0ZW50KTtcblxuICAgICAgLy8gTk9URTogaXQgaXMgaW1wb3J0YW50IHRvIGNvbXB1dGUgdGhpcyBtYXRyaXggYWZ0ZXIgY29tcHV0aW5nIHRoZSBub2RlJ3MgZXh0ZW50XG4gICAgICAvLyBiZWNhdXNlICMuZ2V0R3JhcGhEaW1lbnNpb25zIHJlbGllcyBvbiBpdFxuICAgICAgdmFyIG51bGxDYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG4gICAgICB2YXIgbnVsbENhbWVyYU1hdHJpeCA9IG1hdHJpeEZyb21DYW1lcmEobnVsbENhbWVyYS5nZXRTdGF0ZSgpLCBkaW1lbnNpb25zLCB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpLCB0aGlzLmdldFN0YWdlUGFkZGluZygpKTtcbiAgICAgIC8vIFJlc2V0dGluZyB0aGUgbGFiZWwgZ3JpZFxuICAgICAgLy8gVE9ETzogaXQncyBwcm9iYWJseSBiZXR0ZXIgdG8gZG8gdGhpcyBleHBsaWNpdGx5IG9yIG9uIHJlc2l6ZXMgZm9yIGxheW91dCBhbmQgYW5pbXNcbiAgICAgIHRoaXMubGFiZWxHcmlkLnJlc2l6ZUFuZENsZWFyKGRpbWVuc2lvbnMsIHNldHRpbmdzLmxhYmVsR3JpZENlbGxTaXplKTtcbiAgICAgIHZhciBub2Rlc1BlclByb2dyYW1zID0ge307XG4gICAgICB2YXIgbm9kZUluZGljZXMgPSB7fTtcbiAgICAgIHZhciBlZGdlSW5kaWNlcyA9IHt9O1xuICAgICAgdmFyIGl0ZW1JRHNJbmRleCA9IHt9O1xuICAgICAgdmFyIGluY3JJRCA9IDE7XG4gICAgICB2YXIgbm9kZXMgPSBncmFwaC5ub2RlcygpO1xuXG4gICAgICAvLyBEbyBzb21lIGluZGV4YXRpb24gb24gdGhlIHdob2xlIGdyYXBoXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICB2YXIgZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtub2RlXTtcblxuICAgICAgICAvLyBHZXQgaW5pdGlhbCBjb29yZGluYXRlc1xuICAgICAgICB2YXIgYXR0cnMgPSBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhub2RlKTtcbiAgICAgICAgZGF0YS54ID0gYXR0cnMueDtcbiAgICAgICAgZGF0YS55ID0gYXR0cnMueTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24uYXBwbHlUbyhkYXRhKTtcblxuICAgICAgICAvLyBsYWJlbGdyaWRcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhLmxhYmVsID09PSBcInN0cmluZ1wiICYmICFkYXRhLmhpZGRlbikgdGhpcy5sYWJlbEdyaWQuYWRkKG5vZGUsIGRhdGEuc2l6ZSwgdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSwge1xuICAgICAgICAgIG1hdHJpeDogbnVsbENhbWVyYU1hdHJpeFxuICAgICAgICB9KSk7XG5cbiAgICAgICAgLy8gdXBkYXRlIGNvdW50IHBlciBwcm9ncmFtXG4gICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSA9IChub2Rlc1BlclByb2dyYW1zW2RhdGEudHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgICAgdGhpcy5sYWJlbEdyaWQub3JnYW5pemUoKTtcblxuICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5IHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLm5vZGVQcm9ncmFtcywgdHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBub2RlIHR5cGUgXFxcIlwiLmNvbmNhdCh0eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVQcm9ncmFtc1t0eXBlXS5yZWFsbG9jYXRlKG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gfHwgMCk7XG4gICAgICAgIC8vIFdlIHJlc2V0IHRoYXQgY291bnQgaGVyZSwgc28gdGhhdCB3ZSBjYW4gcmV1c2UgaXQgd2hpbGUgY2FsbGluZyB0aGUgUHJvZ3JhbSNwcm9jZXNzIG1ldGhvZHM6XG4gICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBPcmRlciBub2RlcyBieSB6SW5kZXggYmVmb3JlIHRvIGFkZCB0aGVtIHRvIHByb2dyYW1cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCAmJiB0aGlzLm5vZGVaRXh0ZW50WzBdICE9PSB0aGlzLm5vZGVaRXh0ZW50WzFdKSBub2RlcyA9IHpJbmRleE9yZGVyaW5nKHRoaXMubm9kZVpFeHRlbnQsIGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUubm9kZURhdGFDYWNoZVtub2RlXS56SW5kZXg7XG4gICAgICB9LCBub2Rlcyk7XG5cbiAgICAgIC8vIEFkZCBkYXRhIHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9sID0gbm9kZXMubGVuZ3RoOyBfaSA8IF9sOyBfaSsrKSB7XG4gICAgICAgIHZhciBfbm9kZSA9IG5vZGVzW19pXTtcbiAgICAgICAgbm9kZUluZGljZXNbX25vZGVdID0gaW5jcklEO1xuICAgICAgICBpdGVtSURzSW5kZXhbbm9kZUluZGljZXNbX25vZGVdXSA9IHtcbiAgICAgICAgICB0eXBlOiBcIm5vZGVcIixcbiAgICAgICAgICBpZDogX25vZGVcbiAgICAgICAgfTtcbiAgICAgICAgaW5jcklEKys7XG4gICAgICAgIHZhciBfZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtfbm9kZV07XG4gICAgICAgIHRoaXMuYWRkTm9kZVRvUHJvZ3JhbShfbm9kZSwgbm9kZUluZGljZXNbX25vZGVdLCBub2Rlc1BlclByb2dyYW1zW19kYXRhLnR5cGVdKyspO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRURHRVNcbiAgICAgIC8vXG5cbiAgICAgIHZhciBlZGdlc1BlclByb2dyYW1zID0ge307XG4gICAgICB2YXIgZWRnZXMgPSBncmFwaC5lZGdlcygpO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBtZW1vcnkgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIF9pMiA9IDAsIF9sMiA9IGVkZ2VzLmxlbmd0aDsgX2kyIDwgX2wyOyBfaTIrKykge1xuICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pMl07XG4gICAgICAgIHZhciBfZGF0YTIgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG4gICAgICAgIGVkZ2VzUGVyUHJvZ3JhbXNbX2RhdGEyLnR5cGVdID0gKGVkZ2VzUGVyUHJvZ3JhbXNbX2RhdGEyLnR5cGVdIHx8IDApICsgMTtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZXIgZWRnZXMgYnkgekluZGV4IGJlZm9yZSB0byBhZGQgdGhlbSB0byBwcm9ncmFtXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXggJiYgdGhpcy5lZGdlWkV4dGVudFswXSAhPT0gdGhpcy5lZGdlWkV4dGVudFsxXSkgZWRnZXMgPSB6SW5kZXhPcmRlcmluZyh0aGlzLmVkZ2VaRXh0ZW50LCBmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICByZXR1cm4gX3RoaXM1LmVkZ2VEYXRhQ2FjaGVbZWRnZV0uekluZGV4O1xuICAgICAgfSwgZWRnZXMpO1xuICAgICAgZm9yICh2YXIgX3R5cGUyIGluIHRoaXMuZWRnZVByb2dyYW1zKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLmVkZ2VQcm9ncmFtcywgX3R5cGUyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIGVkZ2UgdHlwZSBcXFwiXCIuY29uY2F0KF90eXBlMiwgXCJcXFwiIVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbX3R5cGUyXS5yZWFsbG9jYXRlKGVkZ2VzUGVyUHJvZ3JhbXNbX3R5cGUyXSB8fCAwKTtcbiAgICAgICAgLy8gV2UgcmVzZXQgdGhhdCBjb3VudCBoZXJlLCBzbyB0aGF0IHdlIGNhbiByZXVzZSBpdCB3aGlsZSBjYWxsaW5nIHRoZSBQcm9ncmFtI3Byb2Nlc3MgbWV0aG9kczpcbiAgICAgICAgZWRnZXNQZXJQcm9ncmFtc1tfdHlwZTJdID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIGRhdGEgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIF9pMyA9IDAsIF9sMyA9IGVkZ2VzLmxlbmd0aDsgX2kzIDwgX2wzOyBfaTMrKykge1xuICAgICAgICB2YXIgX2VkZ2UgPSBlZGdlc1tfaTNdO1xuICAgICAgICBlZGdlSW5kaWNlc1tfZWRnZV0gPSBpbmNySUQ7XG4gICAgICAgIGl0ZW1JRHNJbmRleFtlZGdlSW5kaWNlc1tfZWRnZV1dID0ge1xuICAgICAgICAgIHR5cGU6IFwiZWRnZVwiLFxuICAgICAgICAgIGlkOiBfZWRnZVxuICAgICAgICB9O1xuICAgICAgICBpbmNySUQrKztcbiAgICAgICAgdmFyIF9kYXRhMyA9IHRoaXMuZWRnZURhdGFDYWNoZVtfZWRnZV07XG4gICAgICAgIHRoaXMuYWRkRWRnZVRvUHJvZ3JhbShfZWRnZSwgZWRnZUluZGljZXNbX2VkZ2VdLCBlZGdlc1BlclByb2dyYW1zW19kYXRhMy50eXBlXSsrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXRlbUlEc0luZGV4ID0gaXRlbUlEc0luZGV4O1xuICAgICAgdGhpcy5ub2RlSW5kaWNlcyA9IG5vZGVJbmRpY2VzO1xuICAgICAgdGhpcy5lZGdlSW5kaWNlcyA9IGVkZ2VJbmRpY2VzO1xuICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJQcm9jZXNzXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgYmFja3BvcnRzIHBvdGVudGlhbCBzZXR0aW5ncyB1cGRhdGVzIHdoZXJlIGl0J3MgbmVlZGVkLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU2V0dGluZ3NVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU2V0dGluZ3NVcGRhdGUob2xkU2V0dGluZ3MpIHtcbiAgICAgIHZhciBfdGhpczYgPSB0aGlzO1xuICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIHRoaXMuY2FtZXJhLm1pblJhdGlvID0gc2V0dGluZ3MubWluQ2FtZXJhUmF0aW87XG4gICAgICB0aGlzLmNhbWVyYS5tYXhSYXRpbyA9IHNldHRpbmdzLm1heENhbWVyYVJhdGlvO1xuICAgICAgdGhpcy5jYW1lcmEuZW5hYmxlZFpvb21pbmcgPSBzZXR0aW5ncy5lbmFibGVDYW1lcmFab29taW5nO1xuICAgICAgdGhpcy5jYW1lcmEuZW5hYmxlZFBhbm5pbmcgPSBzZXR0aW5ncy5lbmFibGVDYW1lcmFQYW5uaW5nO1xuICAgICAgdGhpcy5jYW1lcmEuZW5hYmxlZFJvdGF0aW9uID0gc2V0dGluZ3MuZW5hYmxlQ2FtZXJhUm90YXRpb247XG4gICAgICBpZiAoc2V0dGluZ3MuY2FtZXJhUGFuQm91bmRhcmllcykge1xuICAgICAgICB0aGlzLmNhbWVyYS5jbGVhbiA9IGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczYuY2xlYW5DYW1lcmFTdGF0ZShzdGF0ZSwgc2V0dGluZ3MuY2FtZXJhUGFuQm91bmRhcmllcyAmJiBfdHlwZW9mKHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMpID09PSBcIm9iamVjdFwiID8gc2V0dGluZ3MuY2FtZXJhUGFuQm91bmRhcmllcyA6IHt9KTtcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY2FtZXJhLmNsZWFuID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FtZXJhLnNldFN0YXRlKHRoaXMuY2FtZXJhLnZhbGlkYXRlU3RhdGUodGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSkpO1xuICAgICAgaWYgKG9sZFNldHRpbmdzKSB7XG4gICAgICAgIC8vIENoZWNrIGVkZ2UgcHJvZ3JhbXM6XG4gICAgICAgIGlmIChvbGRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMgIT09IHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgIGZvciAodmFyIHR5cGUgaW4gc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW3R5cGVdICE9PSBvbGRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlckVkZ2VQcm9ncmFtKHR5cGUsIHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1t0eXBlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF90eXBlMyBpbiBvbGRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW190eXBlM10pIHRoaXMudW5yZWdpc3RlckVkZ2VQcm9ncmFtKF90eXBlMyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2sgbm9kZSBwcm9ncmFtczpcbiAgICAgICAgaWYgKG9sZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3NlcyAhPT0gc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzIHx8IG9sZFNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzICE9PSBzZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgIGZvciAodmFyIF90eXBlNCBpbiBzZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSAhPT0gb2xkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNF0gfHwgc2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSAhPT0gb2xkU2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSkge1xuICAgICAgICAgICAgICB0aGlzLnJlZ2lzdGVyTm9kZVByb2dyYW0oX3R5cGU0LCBzZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSwgc2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXNbX3R5cGU0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAodmFyIF90eXBlNSBpbiBvbGRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICAgIGlmICghc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNV0pIHRoaXMudW5yZWdpc3Rlck5vZGVQcm9ncmFtKF90eXBlNSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFVwZGF0ZSBjYXB0b3JzIHNldHRpbmdzOlxuICAgICAgdGhpcy5tb3VzZUNhcHRvci5zZXRTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iuc2V0U2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYW5DYW1lcmFTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhbkNhbWVyYVN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge30sXG4gICAgICAgIF9yZWYkdG9sZXJhbmNlID0gX3JlZi50b2xlcmFuY2UsXG4gICAgICAgIHRvbGVyYW5jZSA9IF9yZWYkdG9sZXJhbmNlID09PSB2b2lkIDAgPyAwIDogX3JlZiR0b2xlcmFuY2UsXG4gICAgICAgIGJvdW5kYXJpZXMgPSBfcmVmLmJvdW5kYXJpZXM7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBfb2JqZWN0U3ByZWFkMih7fSwgc3RhdGUpO1xuXG4gICAgICAvLyBFeHRyYWN0IG5lY2Vzc2FyeSBwcm9wZXJ0aWVzXG4gICAgICB2YXIgX3JlZjIgPSBib3VuZGFyaWVzIHx8IHRoaXMubm9kZUV4dGVudCxcbiAgICAgICAgX3JlZjIkeCA9IF9zbGljZWRUb0FycmF5KF9yZWYyLngsIDIpLFxuICAgICAgICB4TWluR3JhcGggPSBfcmVmMiR4WzBdLFxuICAgICAgICB4TWF4R3JhcGggPSBfcmVmMiR4WzFdLFxuICAgICAgICBfcmVmMiR5ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjIueSwgMiksXG4gICAgICAgIHlNaW5HcmFwaCA9IF9yZWYyJHlbMF0sXG4gICAgICAgIHlNYXhHcmFwaCA9IF9yZWYyJHlbMV07XG5cbiAgICAgIC8vIFRyYW5zZm9ybSB0aGUgZm91ciBjb3JuZXJzIG9mIHRoZSBncmFwaCByZWN0YW5nbGUgdXNpbmcgdGhlIHByb3ZpZGVkIGNhbWVyYSBzdGF0ZVxuICAgICAgdmFyIGNvcm5lcnMgPSBbdGhpcy5ncmFwaFRvVmlld3BvcnQoe1xuICAgICAgICB4OiB4TWluR3JhcGgsXG4gICAgICAgIHk6IHlNaW5HcmFwaFxuICAgICAgfSwge1xuICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgIH0pLCB0aGlzLmdyYXBoVG9WaWV3cG9ydCh7XG4gICAgICAgIHg6IHhNYXhHcmFwaCxcbiAgICAgICAgeTogeU1pbkdyYXBoXG4gICAgICB9LCB7XG4gICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgfSksIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1pbkdyYXBoLFxuICAgICAgICB5OiB5TWF4R3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KSwgdGhpcy5ncmFwaFRvVmlld3BvcnQoe1xuICAgICAgICB4OiB4TWF4R3JhcGgsXG4gICAgICAgIHk6IHlNYXhHcmFwaFxuICAgICAgfSwge1xuICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgIH0pXTtcblxuICAgICAgLy8gTG9vayBmb3IgbmV3IGV4dGVudHMsIGJhc2VkIG9uIHRoZXNlIGZvdXIgY29ybmVyc1xuICAgICAgdmFyIHhNaW4gPSBJbmZpbml0eSxcbiAgICAgICAgeE1heCA9IC1JbmZpbml0eSxcbiAgICAgICAgeU1pbiA9IEluZmluaXR5LFxuICAgICAgICB5TWF4ID0gLUluZmluaXR5O1xuICAgICAgY29ybmVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMykge1xuICAgICAgICB2YXIgeCA9IF9yZWYzLngsXG4gICAgICAgICAgeSA9IF9yZWYzLnk7XG4gICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLCB4KTtcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIHgpO1xuICAgICAgICB5TWluID0gTWF0aC5taW4oeU1pbiwgeSk7XG4gICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LCB5KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBGb3IgZWFjaCBkaW1lbnNpb24sIGNvbnN0cmFpbnQgdGhlIHNtYWxsZXIgZWxlbWVudCAoY2FtZXJhIG9yIGdyYXBoKSB0byBmaXQgaW4gdGhlIGxhcmdlciBvbmU6XG4gICAgICB2YXIgZ3JhcGhXaWR0aCA9IHhNYXggLSB4TWluO1xuICAgICAgdmFyIGdyYXBoSGVpZ2h0ID0geU1heCAtIHlNaW47XG4gICAgICB2YXIgX3RoaXMkZ2V0RGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpLFxuICAgICAgICB3aWR0aCA9IF90aGlzJGdldERpbWVuc2lvbnMud2lkdGgsXG4gICAgICAgIGhlaWdodCA9IF90aGlzJGdldERpbWVuc2lvbnMuaGVpZ2h0O1xuICAgICAgdmFyIGR4ID0gMDtcbiAgICAgIHZhciBkeSA9IDA7XG4gICAgICBpZiAoZ3JhcGhXaWR0aCA+PSB3aWR0aCkge1xuICAgICAgICBpZiAoeE1heCA8IHdpZHRoIC0gdG9sZXJhbmNlKSBkeCA9IHhNYXggLSAod2lkdGggLSB0b2xlcmFuY2UpO2Vsc2UgaWYgKHhNaW4gPiB0b2xlcmFuY2UpIGR4ID0geE1pbiAtIHRvbGVyYW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh4TWF4ID4gd2lkdGggKyB0b2xlcmFuY2UpIGR4ID0geE1heCAtICh3aWR0aCArIHRvbGVyYW5jZSk7ZWxzZSBpZiAoeE1pbiA8IC10b2xlcmFuY2UpIGR4ID0geE1pbiArIHRvbGVyYW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChncmFwaEhlaWdodCA+PSBoZWlnaHQpIHtcbiAgICAgICAgaWYgKHlNYXggPCBoZWlnaHQgLSB0b2xlcmFuY2UpIGR5ID0geU1heCAtIChoZWlnaHQgLSB0b2xlcmFuY2UpO2Vsc2UgaWYgKHlNaW4gPiB0b2xlcmFuY2UpIGR5ID0geU1pbiAtIHRvbGVyYW5jZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh5TWF4ID4gaGVpZ2h0ICsgdG9sZXJhbmNlKSBkeSA9IHlNYXggLSAoaGVpZ2h0ICsgdG9sZXJhbmNlKTtlbHNlIGlmICh5TWluIDwgLXRvbGVyYW5jZSkgZHkgPSB5TWluICsgdG9sZXJhbmNlO1xuICAgICAgfVxuICAgICAgaWYgKGR4IHx8IGR5KSB7XG4gICAgICAgIC8vIFRyYW5zZm9ybSBbZHgsIGR5XSBmcm9tIHZpZXdwb3J0IHRvIGdyYXBoICh1c2luZyB0d28gZGlmZmVyZW50IHBvaW50IHRvIHRyYW5zZm9ybSB0aGF0IHZlY3Rvcik6XG4gICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBkZWx0YSA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiBkeCxcbiAgICAgICAgICB5OiBkeVxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgICBkeCA9IGRlbHRhLnggLSBvcmlnaW4ueDtcbiAgICAgICAgZHkgPSBkZWx0YS55IC0gb3JpZ2luLnk7XG4gICAgICAgIG5ld1N0YXRlLnggKz0gZHg7XG4gICAgICAgIG5ld1N0YXRlLnkgKz0gZHk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYWJlbHMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmVuZGVyTGFiZWxzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNlbGVjdGluZyBsYWJlbHMgdG8gZHJhd1xuICAgICAgdmFyIGxhYmVsc1RvRGlzcGxheSA9IHRoaXMubGFiZWxHcmlkLmdldExhYmVsc1RvRGlzcGxheShjYW1lcmFTdGF0ZS5yYXRpbywgdGhpcy5zZXR0aW5ncy5sYWJlbERlbnNpdHkpO1xuICAgICAgZXh0ZW5kKGxhYmVsc1RvRGlzcGxheSwgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyBEcmF3aW5nIGxhYmVsc1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHRzLmxhYmVscztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGFiZWxzVG9EaXNwbGF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGxhYmVsc1RvRGlzcGxheVtpXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG5cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgd2FzIGFscmVhZHkgZHJhd24gKGxpa2UgaWYgaXQgaXMgZWxpZ2libGUgQU5EIGhhc1xuICAgICAgICAvLyBgZm9yY2VMYWJlbGApLCB3ZSBkb24ndCB3YW50IHRvIGRyYXcgaXQgYWdhaW5cbiAgICAgICAgLy8gTk9URTogd2UgY2FuIGRvIGJldHRlciBwcm9iYWJseVxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyhub2RlKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgaGlkZGVuLCB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgaXRzIGxhYmVsIG9idmlvdXNseVxuICAgICAgICBpZiAoZGF0YS5oaWRkZW4pIGNvbnRpbnVlO1xuICAgICAgICB2YXIgX3RoaXMkZnJhbWVkR3JhcGhUb1ZpID0gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSksXG4gICAgICAgICAgeCA9IF90aGlzJGZyYW1lZEdyYXBoVG9WaS54LFxuICAgICAgICAgIHkgPSBfdGhpcyRmcmFtZWRHcmFwaFRvVmkueTtcblxuICAgICAgICAvLyBOT1RFOiB3ZSBjYW4gY2FjaGUgdGhlIGxhYmVscyB3ZSBuZWVkIHRvIHJlbmRlciB1bnRpbCB0aGUgY2FtZXJhJ3MgcmF0aW8gY2hhbmdlc1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2NhbGVTaXplKGRhdGEuc2l6ZSk7XG5cbiAgICAgICAgLy8gSXMgbm9kZSBiaWcgZW5vdWdoP1xuICAgICAgICBpZiAoIWRhdGEuZm9yY2VMYWJlbCAmJiBzaXplIDwgdGhpcy5zZXR0aW5ncy5sYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gSXMgbm9kZSBhY3R1YWxseSBvbiBzY3JlZW4gKHdpdGggc29tZSBtYXJnaW4pXG4gICAgICAgIC8vIE5PVEU6IHdlIHVzZWQgdG8gcmVseSBvbiB0aGUgcXVhZHRyZWUgZm9yIHRoaXMsIGJ1dCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gY29udmVyc2lvbiBtYWtlIGl0IHVucmVsaWFibGUgYW5kIGF0IHRoYXQgcG9pbnQgd2UgYWxyZWFkeSBjb252ZXJ0ZWRcbiAgICAgICAgLy8gdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMgYW5kIHNpbmNlIHRoZSBsYWJlbCBncmlkIGFscmVhZHkgY3VsbHMgdGhlXG4gICAgICAgIC8vIG51bWJlciBvZiBwb3RlbnRpYWwgbGFiZWxzIHRvIGRpc3BsYXkgdGhpcyBsb29rcyBsaWtlIGEgZ29vZFxuICAgICAgICAvLyBwZXJmb3JtYW5jZSBjb21wcm9taXNlLlxuICAgICAgICAvLyBOT1RFOiBsYWJlbEdyaWQuZ2V0TGFiZWxzVG9EaXNwbGF5IGNvdWxkIHByb2JhYmx5IG9wdGltaXplIGJ5IG5vdFxuICAgICAgICAvLyBjb25zaWRlcmluZyBjZWxscyBvYnZpb3VzbHkgb3V0c2lkZSBvZiB0aGUgcmFuZ2Ugb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gdmlldyByZWN0YW5nbGUuXG4gICAgICAgIGlmICh4IDwgLVhfTEFCRUxfTUFSR0lOIHx8IHggPiB0aGlzLndpZHRoICsgWF9MQUJFTF9NQVJHSU4gfHwgeSA8IC1ZX0xBQkVMX01BUkdJTiB8fCB5ID4gdGhpcy5oZWlnaHQgKyBZX0xBQkVMX01BUkdJTikgY29udGludWU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBkaXNwbGF5ZWQgZWRnZSBsYWJlbHMgZGVwZW5kIGRpcmVjdGx5IG9uIGFjdHVhbGx5IHJlbmRlcmVkIG5vZGVcbiAgICAgICAgLy8gbGFiZWxzLCB3ZSBuZWVkIHRvIG9ubHkgYWRkIHRvIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyBub2RlcyB3aG9zZSBsYWJlbFxuICAgICAgICAvLyBpcyByZW5kZXJlZC5cbiAgICAgICAgLy8gVGhpcyBtYWtlcyB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgZGVwZW5kIG9uIHZpZXdwb3J0LCB3aGljaCBtaWdodCBiZWNvbWVcbiAgICAgICAgLy8gYW4gaXNzdWUgb25jZSB3ZSBzdGFydCBtZW1vaXppbmcgZ2V0TGFiZWxzVG9EaXNwbGF5LlxuICAgICAgICB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMuYWRkKG5vZGUpO1xuICAgICAgICB2YXIgZGVmYXVsdERyYXdOb2RlTGFiZWwgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHREcmF3Tm9kZUxhYmVsO1xuICAgICAgICB2YXIgbm9kZVByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgICB2YXIgZHJhd0xhYmVsID0gKG5vZGVQcm9ncmFtID09PSBudWxsIHx8IG5vZGVQcm9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvZ3JhbS5kcmF3TGFiZWwpIHx8IGRlZmF1bHREcmF3Tm9kZUxhYmVsO1xuICAgICAgICBkcmF3TGFiZWwoY29udGV4dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogbm9kZVxuICAgICAgICB9LCBkYXRhKSwge30sIHtcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIgZWRnZSBsYWJlbHMsIGJhc2VkIG9uIHdoaWNoIG5vZGUgbGFiZWxzIHdlcmVcbiAgICAgKiByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckVkZ2VMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRWRnZUxhYmVscygpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yZW5kZXJFZGdlTGFiZWxzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzO1xuXG4gICAgICAvLyBDbGVhcmluZ1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdmFyIGVkZ2VMYWJlbHNUb0Rpc3BsYXkgPSBlZGdlTGFiZWxzVG9EaXNwbGF5RnJvbU5vZGVzKHtcbiAgICAgICAgZ3JhcGg6IHRoaXMuZ3JhcGgsXG4gICAgICAgIGhvdmVyZWROb2RlOiB0aGlzLmhvdmVyZWROb2RlLFxuICAgICAgICBkaXNwbGF5ZWROb2RlTGFiZWxzOiB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMsXG4gICAgICAgIGhpZ2hsaWdodGVkTm9kZXM6IHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1xuICAgICAgfSk7XG4gICAgICBleHRlbmQoZWRnZUxhYmVsc1RvRGlzcGxheSwgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMpO1xuICAgICAgdmFyIGRpc3BsYXllZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZUxhYmVsc1RvRGlzcGxheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlTGFiZWxzVG9EaXNwbGF5W2ldLFxuICAgICAgICAgIGV4dHJlbWl0aWVzID0gdGhpcy5ncmFwaC5leHRyZW1pdGllcyhlZGdlKSxcbiAgICAgICAgICBzb3VyY2VEYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzBdXSxcbiAgICAgICAgICB0YXJnZXREYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzFdXSxcbiAgICAgICAgICBlZGdlRGF0YSA9IHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXTtcblxuICAgICAgICAvLyBJZiB0aGUgZWRnZSB3YXMgYWxyZWFkeSBkcmF3biAobGlrZSBpZiBpdCBpcyBlbGlnaWJsZSBBTkQgaGFzXG4gICAgICAgIC8vIGBmb3JjZUxhYmVsYCksIHdlIGRvbid0IHdhbnQgdG8gZHJhdyBpdCBhZ2FpblxuICAgICAgICBpZiAoZGlzcGxheWVkTGFiZWxzLmhhcyhlZGdlKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVkZ2UgaXMgaGlkZGVuIHdlIGRvbid0IG5lZWQgdG8gZGlzcGxheSBpdHMgbGFiZWxcbiAgICAgICAgLy8gTk9URTogdGhlIHRlc3Qgb24gc291cmNlRGF0YSAmIHRhcmdldERhdGEgaXMgcHJvYmFibHkgcGFyYW5vaWQgYXQgdGhpcyBwb2ludD9cbiAgICAgICAgaWYgKGVkZ2VEYXRhLmhpZGRlbiB8fCBzb3VyY2VEYXRhLmhpZGRlbiB8fCB0YXJnZXREYXRhLmhpZGRlbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0RHJhd0VkZ2VMYWJlbCA9IHRoaXMuc2V0dGluZ3MuZGVmYXVsdERyYXdFZGdlTGFiZWw7XG4gICAgICAgIHZhciBlZGdlUHJvZ3JhbSA9IHRoaXMuZWRnZVByb2dyYW1zW2VkZ2VEYXRhLnR5cGVdO1xuICAgICAgICB2YXIgZHJhd0xhYmVsID0gKGVkZ2VQcm9ncmFtID09PSBudWxsIHx8IGVkZ2VQcm9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGdlUHJvZ3JhbS5kcmF3TGFiZWwpIHx8IGRlZmF1bHREcmF3RWRnZUxhYmVsO1xuICAgICAgICBkcmF3TGFiZWwoY29udGV4dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogZWRnZVxuICAgICAgICB9LCBlZGdlRGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUoZWRnZURhdGEuc2l6ZSlcbiAgICAgICAgfSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGV4dHJlbWl0aWVzWzBdXG4gICAgICAgIH0sIHNvdXJjZURhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChzb3VyY2VEYXRhKSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUoc291cmNlRGF0YS5zaXplKVxuICAgICAgICB9KSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogZXh0cmVtaXRpZXNbMV1cbiAgICAgICAgfSwgdGFyZ2V0RGF0YSksIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHRhcmdldERhdGEpKSwge30sIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnNjYWxlU2l6ZSh0YXJnZXREYXRhLnNpemUpXG4gICAgICAgIH0pLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgZGlzcGxheWVkTGFiZWxzLmFkZChlZGdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyA9IGRpc3BsYXllZExhYmVscztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciB0aGUgaGlnaGxpZ2h0ZWQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJIaWdobGlnaHRlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKSB7XG4gICAgICB2YXIgX3RoaXM3ID0gdGhpcztcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5ob3ZlcnM7XG5cbiAgICAgIC8vIENsZWFyaW5nXG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgIC8vIFJlbmRlcmluZ1xuICAgICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM3Lm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgIHZhciBfdGhpczckZnJhbWVkR3JhcGhUb1YgPSBfdGhpczcuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEpLFxuICAgICAgICAgIHggPSBfdGhpczckZnJhbWVkR3JhcGhUb1YueCxcbiAgICAgICAgICB5ID0gX3RoaXM3JGZyYW1lZEdyYXBoVG9WLnk7XG4gICAgICAgIHZhciBzaXplID0gX3RoaXM3LnNjYWxlU2l6ZShkYXRhLnNpemUpO1xuICAgICAgICB2YXIgZGVmYXVsdERyYXdOb2RlSG92ZXIgPSBfdGhpczcuc2V0dGluZ3MuZGVmYXVsdERyYXdOb2RlSG92ZXI7XG4gICAgICAgIHZhciBub2RlUHJvZ3JhbSA9IF90aGlzNy5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdIb3ZlciA9IChub2RlUHJvZ3JhbSA9PT0gbnVsbCB8fCBub2RlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2dyYW0uZHJhd0hvdmVyKSB8fCBkZWZhdWx0RHJhd05vZGVIb3ZlcjtcbiAgICAgICAgZHJhd0hvdmVyKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IG5vZGVcbiAgICAgICAgfSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksIF90aGlzNy5zZXR0aW5ncyk7XG4gICAgICB9O1xuICAgICAgdmFyIG5vZGVzVG9SZW5kZXIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmhvdmVyZWROb2RlICYmICF0aGlzLm5vZGVEYXRhQ2FjaGVbdGhpcy5ob3ZlcmVkTm9kZV0uaGlkZGVuKSB7XG4gICAgICAgIG5vZGVzVG9SZW5kZXIucHVzaCh0aGlzLmhvdmVyZWROb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIFRoZSBob3ZlcmVkIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBoaWdobGlnaHRlZFxuICAgICAgICBpZiAobm9kZSAhPT0gX3RoaXM3LmhvdmVyZWROb2RlKSBub2Rlc1RvUmVuZGVyLnB1c2gobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRHJhdyBsYWJlbHM6XG4gICAgICBub2Rlc1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihub2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEcmF3IFdlYkdMIG5vZGVzIG9uIHRvcCBvZiB0aGUgbGFiZWxzOlxuICAgICAgdmFyIG5vZGVzUGVyUHJvZ3JhbXMgPSB7fTtcblxuICAgICAgLy8gMS4gQ291bnQgbm9kZXMgcGVyIHR5cGU6XG4gICAgICBub2Rlc1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfdGhpczcubm9kZURhdGFDYWNoZVtub2RlXS50eXBlO1xuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gKG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfSk7XG4gICAgICAvLyAyLiBBbGxvY2F0ZSBmb3IgZWFjaCB0eXBlIGZvciB0aGUgcHJvcGVyIG51bWJlciBvZiBub2Rlc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVIb3ZlclByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbdHlwZV0ucmVhbGxvY2F0ZShub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApO1xuICAgICAgICAvLyBBbHNvIHJlc2V0IGNvdW50LCB0byB1c2Ugd2hlbiByZW5kZXJpbmc6XG4gICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gMy4gUHJvY2VzcyBhbGwgbm9kZXMgdG8gcmVuZGVyOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM3Lm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgIF90aGlzNy5ub2RlSG92ZXJQcm9ncmFtc1tkYXRhLnR5cGVdLnByb2Nlc3MoMCwgbm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdKyssIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICAvLyA0LiBDbGVhciBob3ZlcmVkIG5vZGVzIGxheWVyOlxuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMuY2xlYXIodGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAvLyA1LiBSZW5kZXI6XG4gICAgICB2YXIgcmVuZGVyUGFyYW1zID0gdGhpcy5nZXRSZW5kZXJQYXJhbXMoKTtcbiAgICAgIGZvciAodmFyIF90eXBlNiBpbiB0aGlzLm5vZGVIb3ZlclByb2dyYW1zKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1tfdHlwZTZdO1xuICAgICAgICBwcm9ncmFtLnJlbmRlcihyZW5kZXJQYXJhbXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgaG92ZXIgcmVuZGVyLlxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgaWYgKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lIHx8IHRoaXMucmVuZGVyRnJhbWUpIHJldHVybjtcbiAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzZXR0aW5nIHN0YXRlXG4gICAgICAgIF90aGlzOC5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuXG4gICAgICAgIC8vIFJlbmRlcmluZ1xuICAgICAgICBfdGhpczgucmVuZGVySGlnaGxpZ2h0ZWROb2RlcygpO1xuICAgICAgICBfdGhpczgucmVuZGVyRWRnZUxhYmVscygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgICAgdmFyIGV4aXRSZW5kZXIgPSBmdW5jdGlvbiBleGl0UmVuZGVyKCkge1xuICAgICAgICBfdGhpczkuZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM5O1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgYSByZW5kZXIgd2FzIHNjaGVkdWxlZCwgd2UgY2FuY2VsIGl0XG4gICAgICBpZiAodGhpcy5yZW5kZXJGcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gcmVzaXplXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlcHJvY2VzcyBkYXRhP1xuICAgICAgaWYgKHRoaXMubmVlZFRvUHJvY2VzcykgdGhpcy5wcm9jZXNzKCk7XG4gICAgICB0aGlzLm5lZWRUb1Byb2Nlc3MgPSBmYWxzZTtcblxuICAgICAgLy8gQ2xlYXJpbmcgdGhlIGNhbnZhc2VzXG4gICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHRleHR1cmVzXG4gICAgICB0aGlzLnBpY2tpbmdMYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOS5yZXNldFdlYkdMVGV4dHVyZShsYXllcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBubyBub2RlcyB3ZSBjYW4gc3RvcCByaWdodCB0aGVyZVxuICAgICAgaWYgKCF0aGlzLmdyYXBoLm9yZGVyKSByZXR1cm4gZXhpdFJlbmRlcigpO1xuXG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIHRoaXMgaGV1cmlzdGljIG9yIG1vdmUgdG8gdGhlIGNhcHRvciBpdHNlbGY/XG4gICAgICAvLyBUT0RPOiBkZWFsIHdpdGggdGhlIHRvdWNoIGNhcHRvciBoZXJlIGFzIHdlbGxcbiAgICAgIHZhciBtb3VzZUNhcHRvciA9IHRoaXMubW91c2VDYXB0b3I7XG4gICAgICB2YXIgbW92aW5nID0gdGhpcy5jYW1lcmEuaXNBbmltYXRlZCgpIHx8IG1vdXNlQ2FwdG9yLmlzTW92aW5nIHx8IG1vdXNlQ2FwdG9yLmRyYWdnZWRFdmVudHMgfHwgbW91c2VDYXB0b3IuY3VycmVudFdoZWVsRGlyZWN0aW9uO1xuXG4gICAgICAvLyBUaGVuIHdlIG5lZWQgdG8gZXh0cmFjdCBhIG1hdHJpeCBmcm9tIHRoZSBjYW1lcmFcbiAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG4gICAgICB2YXIgZ3JhcGhEaW1lbnNpb25zID0gdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKTtcbiAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXRTdGFnZVBhZGRpbmcoKTtcbiAgICAgIHRoaXMubWF0cml4ID0gbWF0cml4RnJvbUNhbWVyYShjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMsIHBhZGRpbmcpO1xuICAgICAgdGhpcy5pbnZNYXRyaXggPSBtYXRyaXhGcm9tQ2FtZXJhKGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucywgcGFkZGluZywgdHJ1ZSk7XG4gICAgICB0aGlzLmNvcnJlY3Rpb25SYXRpbyA9IGdldE1hdHJpeEltcGFjdCh0aGlzLm1hdHJpeCwgY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucyk7XG4gICAgICB0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvID0gdGhpcy5nZXRHcmFwaFRvVmlld3BvcnRSYXRpbygpO1xuXG4gICAgICAvLyBbamFjb215YWxdXG4gICAgICAvLyBUaGlzIGNvbW1lbnQgaXMgcmVsYXRlZCB0byB0aGUgb25lIGFib3ZlIHRoZSBgZ2V0TWF0cml4SW1wYWN0YCBkZWZpbml0aW9uOlxuICAgICAgLy8gLSBgdGhpcy5jb3JyZWN0aW9uUmF0aW9gIGlzIHNvbWVob3cgbm90IGNvbXBsZXRlbHkgZXhwbGFpbmVkXG4gICAgICAvLyAtIGB0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvYCBpcyB0aGUgcmF0aW8gb2YgYSBkaXN0YW5jZSBpbiB0aGUgdmlld3BvcnQgZGl2aWRlZCBieSB0aGUgc2FtZSBkaXN0YW5jZSBpbiB0aGVcbiAgICAgIC8vICAgZ3JhcGhcbiAgICAgIC8vIC0gYHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLnJhdGlvYCBpcyBiYXNpY2FsbHkgYE1hdGgubWF4KGdyYXBoRFgsIGdyYXBoRFkpYFxuICAgICAgLy8gQW5kIG5vdywgSSBvYnNlcnZlIHRoYXQgaWYgSSBtdWx0aXBseSB0aGVzZSB0aHJlZSByYXRpb3MsIEkgaGF2ZSBzb21ldGhpbmcgY29uc3RhbnQsIHdoaWNoIHZhbHVlIHJlbWFpbnMgMiwgZXZlblxuICAgICAgLy8gd2hlbiBJIGNoYW5nZSB0aGUgZ3JhcGgsIHRoZSB2aWV3cG9ydCBvciB0aGUgY2FtZXJhLiBJdCBtaWdodCBiZSB1c2VmdWwgbGF0ZXIsIHNvIEkgcHJlZmVyIHRvIGxldCB0aGlzIGNvbW1lbnQ6XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvICogdGhpcy5jb3JyZWN0aW9uUmF0aW8gKiB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5yYXRpbyAqIDIpO1xuXG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy5nZXRSZW5kZXJQYXJhbXMoKTtcblxuICAgICAgLy8gRHJhd2luZyBub2Rlc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVQcm9ncmFtcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZVByb2dyYW1zW3R5cGVdO1xuICAgICAgICBwcm9ncmFtLnJlbmRlcihwYXJhbXMpO1xuICAgICAgfVxuXG4gICAgICAvLyBEcmF3aW5nIGVkZ2VzXG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuaGlkZUVkZ2VzT25Nb3ZlIHx8ICFtb3ZpbmcpIHtcbiAgICAgICAgZm9yICh2YXIgX3R5cGU3IGluIHRoaXMuZWRnZVByb2dyYW1zKSB7XG4gICAgICAgICAgdmFyIF9wcm9ncmFtMiA9IHRoaXMuZWRnZVByb2dyYW1zW190eXBlN107XG4gICAgICAgICAgX3Byb2dyYW0yLnJlbmRlcihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG5vdCBkaXNwbGF5IGxhYmVscyBvbiBtb3ZlIHBlciBzZXR0aW5nXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5oaWRlTGFiZWxzT25Nb3ZlICYmIG1vdmluZykgcmV0dXJuIGV4aXRSZW5kZXIoKTtcbiAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICB0aGlzLnJlbmRlckVkZ2VMYWJlbHMoKTtcbiAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2RlcygpO1xuICAgICAgcmV0dXJuIGV4aXRSZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIGluIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZShrZXkpIHtcbiAgICAgIC8vIE5vZGUgZGlzcGxheSBkYXRhIHJlc29sdXRpb246XG4gICAgICAvLyAgMS4gRmlyc3Qgd2UgZ2V0IHRoZSBub2RlJ3MgYXR0cmlidXRlc1xuICAgICAgLy8gIDIuIFdlIG9wdGlvbmFsbHkgcmVkdWNlIHRoZW0gdXNpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAvLyAgICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSB0b3RhbCBvYmplY3QgYW5kIHdvbid0IGJlIG1lcmdlZFxuICAgICAgLy8gIDMuIFdlIGFwcGx5IG91ciBkZWZhdWx0cywgd2hpbGUgcnVubmluZyBzb21lIHZpdGFsIGNoZWNrc1xuICAgICAgLy8gIDQuIFdlIGFwcGx5IHRoZSBub3JtYWxpemF0aW9uIGZ1bmN0aW9uXG4gICAgICAvLyBXZSBzaGFsbG93IGNvcHkgbm9kZSBkYXRhIHRvIGF2b2lkIGRhbmdlcm91cyBiZWhhdmlvcnMgZnJvbSByZWR1Y2Vyc1xuICAgICAgdmFyIGF0dHIgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKGtleSkpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mubm9kZVJlZHVjZXIpIGF0dHIgPSB0aGlzLnNldHRpbmdzLm5vZGVSZWR1Y2VyKGtleSwgYXR0cik7XG4gICAgICB2YXIgZGF0YSA9IGFwcGx5Tm9kZURlZmF1bHRzKHRoaXMuc2V0dGluZ3MsIGtleSwgYXR0cik7XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XSA9IGRhdGE7XG5cbiAgICAgIC8vIExhYmVsOlxuICAgICAgLy8gV2UgZGVsZXRlIGFuZCBhZGQgaWYgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgZnJvbVxuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuZm9yY2VMYWJlbCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzLmFkZChrZXkpO1xuXG4gICAgICAvLyBIaWdobGlnaHRlZDpcbiAgICAgIC8vIFdlIHJlbW92ZSBhbmQgcmUgYWRkIGlmIG5lZWRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIGZyb21cbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICBpZiAoZGF0YS5oaWdobGlnaHRlZCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5hZGQoa2V5KTtcblxuICAgICAgLy8gekluZGV4XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXgpIHtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4IDwgdGhpcy5ub2RlWkV4dGVudFswXSkgdGhpcy5ub2RlWkV4dGVudFswXSA9IGRhdGEuekluZGV4O1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPiB0aGlzLm5vZGVaRXh0ZW50WzFdKSB0aGlzLm5vZGVaRXh0ZW50WzFdID0gZGF0YS56SW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgbm9kZSB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vZGUoa2V5KSB7XG4gICAgICB0aGlzLmFkZE5vZGUoa2V5KTtcblxuICAgICAgLy8gUmUtYXBwbHkgbm9ybWFsaXphdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmFwcGx5VG8oZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTm9kZShrZXkpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIG5vZGUgY2FjaGVcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIG5vZGUgcHJvZ3JhbSBpbmRleFxuICAgICAgZGVsZXRlIHRoaXMubm9kZVByb2dyYW1JbmRleFtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaGlnbGlnaHRlZCBub2Rlc1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBob3ZlcmVkXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSA9PT0ga2V5KSB0aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGZvcmNlZCBsYWJlbFxuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWRnZSBpbnRvIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZShrZXkpIHtcbiAgICAgIC8vIEVkZ2UgZGlzcGxheSBkYXRhIHJlc29sdXRpb246XG4gICAgICAvLyAgMS4gRmlyc3Qgd2UgZ2V0IHRoZSBlZGdlJ3MgYXR0cmlidXRlc1xuICAgICAgLy8gIDIuIFdlIG9wdGlvbmFsbHkgcmVkdWNlIHRoZW0gdXNpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAvLyAgMy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSB0b3RhbCBvYmplY3QgYW5kIHdvbid0IGJlIG1lcmdlZFxuICAgICAgLy8gIDQuIFdlIGFwcGx5IG91ciBkZWZhdWx0cywgd2hpbGUgcnVubmluZyBzb21lIHZpdGFsIGNoZWNrc1xuICAgICAgLy8gV2Ugc2hhbGxvdyBjb3B5IGVkZ2UgZGF0YSB0byBhdm9pZCBkYW5nZXJvdXMgYmVoYXZpb3JzIGZyb20gcmVkdWNlcnNcbiAgICAgIHZhciBhdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ncmFwaC5nZXRFZGdlQXR0cmlidXRlcyhrZXkpKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVkZ2VSZWR1Y2VyKSBhdHRyID0gdGhpcy5zZXR0aW5ncy5lZGdlUmVkdWNlcihrZXksIGF0dHIpO1xuICAgICAgdmFyIGRhdGEgPSBhcHBseUVkZ2VEZWZhdWx0cyh0aGlzLnNldHRpbmdzLCBrZXksIGF0dHIpO1xuICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlW2tleV0gPSBkYXRhO1xuXG4gICAgICAvLyBGb3JjZWQgbGFiZWxcbiAgICAgIC8vIHdlIGZpbHRlciBhbmQgcmUgcHVzaCBpZiBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCBmcm9tXG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICBpZiAoZGF0YS5mb3JjZUxhYmVsICYmICFkYXRhLmhpZGRlbikgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMuYWRkKGtleSk7XG5cbiAgICAgIC8vIENoZWNrIHpJbmRleFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA8IHRoaXMuZWRnZVpFeHRlbnRbMF0pIHRoaXMuZWRnZVpFeHRlbnRbMF0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4ID4gdGhpcy5lZGdlWkV4dGVudFsxXSkgdGhpcy5lZGdlWkV4dGVudFsxXSA9IGRhdGEuekluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBlZGdlIGluIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZShrZXkpIHtcbiAgICAgIHRoaXMuYWRkRWRnZShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBlZGdlIGZyb20gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFZGdlKGtleSkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gZWRnZSBjYWNoZVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZURhdGFDYWNoZVtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gcHJvZ3JhbUlkIGluZGV4XG4gICAgICBkZWxldGUgdGhpcy5lZGdlUHJvZ3JhbUluZGV4W2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBob3ZlcmVkXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSA9PT0ga2V5KSB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGZvcmNlZCBsYWJlbFxuICAgICAgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcyByZWxhdGVkIHRvIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJOb2RlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhck5vZGVJbmRpY2VzKCkge1xuICAgICAgLy8gTGFiZWxHcmlkICYgbm9kZUV4dGVudCBhcmUgb25seSBtYW5hZ2UvcG9wdWxhdGVkIGluIHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICB0aGlzLmxhYmVsR3JpZCA9IG5ldyBMYWJlbEdyaWQoKTtcbiAgICAgIHRoaXMubm9kZUV4dGVudCA9IHtcbiAgICAgICAgeDogWzAsIDFdLFxuICAgICAgICB5OiBbMCwgMV1cbiAgICAgIH07XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1JbmRleCA9IHt9O1xuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm5vZGVaRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBpbmRpY2VzIHJlbGF0ZWQgdG8gZWRnZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckVkZ2VJbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRWRnZUluZGljZXMoKSB7XG4gICAgICB0aGlzLmVkZ2VEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1JbmRleCA9IHt9O1xuICAgICAgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmVkZ2VaRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBpbmRpY2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJJbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFySW5kaWNlcygpIHtcbiAgICAgIHRoaXMuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgdGhpcy5jbGVhck5vZGVJbmRpY2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoIHN0YXRlIHJlbGF0ZWQgdG8gbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhck5vZGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhck5vZGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncmFwaCBzdGF0ZSByZWxhdGVkIHRvIGVkZ2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJFZGdlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJFZGdlU3RhdGUoKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZEVkZ2VMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGggc3RhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyU3RhdGUoKSB7XG4gICAgICB0aGlzLmNsZWFyRWRnZVN0YXRlKCk7XG4gICAgICB0aGlzLmNsZWFyTm9kZVN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGRhdGEgdG8gaXRzIHByb2dyYW0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKiBAcGFyYW0gZmluZ2VycHJpbnQgQSBmaW5nZXJwcmludCB1c2VkIHRvIGlkZW50aXR5IHRoZSBub2RlIHdpdGggcGlja2luZ1xuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgaW5kZXggd2hlcmUgdG8gcGxhY2UgdGhlIG5vZGUgaW4gdGhlIHByb2dyYW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlVG9Qcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVUb1Byb2dyYW0obm9kZSwgZmluZ2VycHJpbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtub2RlXTtcbiAgICAgIHZhciBub2RlUHJvZ3JhbSA9IHRoaXMubm9kZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICBpZiAoIW5vZGVQcm9ncmFtKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBub2RlIHR5cGUgXFxcIlwiLmNvbmNhdChkYXRhLnR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgbm9kZVByb2dyYW0ucHJvY2VzcyhmaW5nZXJwcmludCwgcG9zaXRpb24sIGRhdGEpO1xuICAgICAgLy8gU2F2aW5nIHByb2dyYW0gaW5kZXhcbiAgICAgIHRoaXMubm9kZVByb2dyYW1JbmRleFtub2RlXSA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZWRnZSBkYXRhIHRvIGl0cyBwcm9ncmFtLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGVkZ2UgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICogQHBhcmFtIGZpbmdlcnByaW50IEEgZmluZ2VycHJpbnQgdXNlZCB0byBpZGVudGl0eSB0aGUgZWRnZSB3aXRoIHBpY2tpbmdcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIGluZGV4IHdoZXJlIHRvIHBsYWNlIHRoZSBlZGdlIGluIHRoZSBwcm9ncmFtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZVRvUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlVG9Qcm9ncmFtKGVkZ2UsIGZpbmdlcnByaW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG4gICAgICB2YXIgZWRnZVByb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgaWYgKCFlZGdlUHJvZ3JhbSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3IgZWRnZSB0eXBlIFxcXCJcIi5jb25jYXQoZGF0YS50eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgIHZhciBleHRyZW1pdGllcyA9IHRoaXMuZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSksXG4gICAgICAgIHNvdXJjZURhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMF1dLFxuICAgICAgICB0YXJnZXREYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzFdXTtcbiAgICAgIGVkZ2VQcm9ncmFtLnByb2Nlc3MoZmluZ2VycHJpbnQsIHBvc2l0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKTtcbiAgICAgIC8vIFNhdmluZyBwcm9ncmFtIGluZGV4XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXhbZWRnZV0gPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBQdWJsaWMgQVBJLlxuICAgICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBnZXQgdGhlIHJlbmRlciBwYXJhbXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtSZW5kZXJQYXJhbXN9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVuZGVyUGFyYW1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlbmRlclBhcmFtcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXgsXG4gICAgICAgIGludk1hdHJpeDogdGhpcy5pbnZNYXRyaXgsXG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0LFxuICAgICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgIHpvb21SYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgIGNhbWVyYUFuZ2xlOiB0aGlzLmNhbWVyYS5hbmdsZSxcbiAgICAgICAgc2l6ZVJhdGlvOiAxIC8gdGhpcy5zY2FsZVNpemUoKSxcbiAgICAgICAgY29ycmVjdGlvblJhdGlvOiB0aGlzLmNvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgZG93blNpemluZ1JhdGlvOiB0aGlzLnBpY2tpbmdEb3duU2l6aW5nUmF0aW8sXG4gICAgICAgIG1pbkVkZ2VUaGlja25lc3M6IHRoaXMuc2V0dGluZ3MubWluRWRnZVRoaWNrbmVzcyxcbiAgICAgICAgYW50aUFsaWFzaW5nRmVhdGhlcjogdGhpcy5zZXR0aW5ncy5hbnRpQWxpYXNpbmdGZWF0aGVyXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gcmV0cmlldmUgdGhlIGFjdHVhbCBzdGFnZSBwYWRkaW5nIHZhbHVlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFN0YWdlUGFkZGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGFnZVBhZGRpbmcoKSB7XG4gICAgICB2YXIgX3RoaXMkc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICBzdGFnZVBhZGRpbmcgPSBfdGhpcyRzZXR0aW5ncy5zdGFnZVBhZGRpbmcsXG4gICAgICAgIGF1dG9SZXNjYWxlID0gX3RoaXMkc2V0dGluZ3MuYXV0b1Jlc2NhbGU7XG4gICAgICByZXR1cm4gYXV0b1Jlc2NhbGUgPyBzdGFnZVBhZGRpbmcgfHwgMCA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBsYXllciBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgLSBUaGUgSFRNTCB0YWcgdG8gdXNlLlxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlTGF5ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlTGF5ZXIoaWQsIHRhZykge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaWRdKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogYSBsYXllciBuYW1lZCBcXFwiXCIuY29uY2F0KGlkLCBcIlxcXCIgYWxyZWFkeSBleGlzdHNcIikpO1xuICAgICAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHRhZywge1xuICAgICAgICBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiXG4gICAgICB9LCB7XG4gICAgICAgIFwiY2xhc3NcIjogXCJzaWdtYS1cIi5jb25jYXQoaWQpXG4gICAgICB9KTtcbiAgICAgIGlmIChvcHRpb25zLnN0eWxlKSBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIG9wdGlvbnMuc3R5bGUpO1xuICAgICAgdGhpcy5lbGVtZW50c1tpZF0gPSBlbGVtZW50O1xuICAgICAgaWYgKFwiYmVmb3JlTGF5ZXJcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuYmVmb3JlTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tvcHRpb25zLmJlZm9yZUxheWVyXS5iZWZvcmUoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKFwiYWZ0ZXJMYXllclwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5hZnRlckxheWVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbb3B0aW9ucy5hZnRlckxheWVyXS5hZnRlcihlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBjYW52YXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIENvbnRleHQncyBpZC5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMoaWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxheWVyKGlkLCBcImNhbnZhc1wiLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIGNhbnZhcyBjb250ZXh0IGFuZCBhZGQgdGhlIHJlbGV2YW50IERPTSBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gaWQgLSBDb250ZXh0J3MgaWQuXG4gICAgICogQHBhcmFtICBvcHRpb25zXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQ2FudmFzQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDYW52YXNDb250ZXh0KGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2FudmFzID0gdGhpcy5jcmVhdGVDYW52YXMoaWQsIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0ge1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICB9O1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0c1tpZF0gPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgV2ViR0wgY29udGV4dCBhbmQgYWRkIHRoZSByZWxldmFudCBET01cbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gIGlkICAgICAgLSBDb250ZXh0J3MgaWQuXG4gICAgICogQHBhcmFtICB7b2JqZWN0P30gb3B0aW9ucyAtICNnZXRDb250ZXh0IHBhcmFtcyB0byBvdmVycmlkZSAob3B0aW9uYWwpXG4gICAgICogQHJldHVybiB7V2ViR0xSZW5kZXJpbmdDb250ZXh0fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVdlYkdMQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoaWQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciBjYW52YXMgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhbnZhcykgfHwgdGhpcy5jcmVhdGVDYW52YXMoaWQsIG9wdGlvbnMpO1xuICAgICAgaWYgKG9wdGlvbnMuaGlkZGVuKSBjYW52YXMucmVtb3ZlKCk7XG4gICAgICB2YXIgY29udGV4dE9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgIHByZXNlcnZlRHJhd2luZ0J1ZmZlcjogZmFsc2UsXG4gICAgICAgIGFudGlhbGlhczogZmFsc2VcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIC8vIEZpcnN0IHdlIHRyeSB3ZWJnbDIgZm9yIGFuIGVhc3kgcGVyZm9ybWFuY2UgYm9vc3RcbiAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsMlwiLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAgIC8vIEVsc2Ugd2UgZmFsbCBiYWNrIHRvIHdlYmdsXG4gICAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIndlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcblxuICAgICAgLy8gRWRnZSwgSSBhbSBsb29raW5nIHJpZ2h0IGF0IHlvdS4uLlxuICAgICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJleHBlcmltZW50YWwtd2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuICAgICAgdmFyIGdsID0gY29udGV4dDtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0c1tpZF0gPSBnbDtcblxuICAgICAgLy8gQmxlbmRpbmc6XG4gICAgICBnbC5ibGVuZEZ1bmMoZ2wuT05FLCBnbC5PTkVfTUlOVVNfU1JDX0FMUEhBKTtcblxuICAgICAgLy8gUHJlcGFyZSBmcmFtZSBidWZmZXIgZm9yIHBpY2tpbmcgbGF5ZXJzOlxuICAgICAgaWYgKG9wdGlvbnMucGlja2luZykge1xuICAgICAgICB0aGlzLnBpY2tpbmdMYXllcnMuYWRkKGlkKTtcbiAgICAgICAgdmFyIG5ld0ZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgaWYgKCFuZXdGcmFtZUJ1ZmZlcikgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNhbm5vdCBjcmVhdGUgYSBuZXcgZnJhbWUgYnVmZmVyIGZvciBsYXllciBcIi5jb25jYXQoaWQpKTtcbiAgICAgICAgdGhpcy5mcmFtZUJ1ZmZlcnNbaWRdID0gbmV3RnJhbWVCdWZmZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2w7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBwcm9wZXJseSBraWxsIGEgbGF5ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gTGF5ZXIgaWQuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwia2lsbExheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGxMYXllcihpZCkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2lkXTtcbiAgICAgIGlmICghZWxlbWVudCkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNhbm5vdCBraWxsIGxheWVyIFwiLmNvbmNhdChpZCwgXCIsIHdoaWNoIGRvZXMgbm90IGV4aXN0XCIpKTtcbiAgICAgIGlmICh0aGlzLndlYkdMQ29udGV4dHNbaWRdKSB7XG4gICAgICAgIHZhciBfZ2wkZ2V0RXh0ZW5zaW9uO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgICAoX2dsJGdldEV4dGVuc2lvbiA9IGdsLmdldEV4dGVuc2lvbihcIldFQkdMX2xvc2VfY29udGV4dFwiKSkgPT09IG51bGwgfHwgX2dsJGdldEV4dGVuc2lvbiA9PT0gdm9pZCAwIHx8IF9nbCRnZXRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMud2ViR0xDb250ZXh0c1tpZF07XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuY2FudmFzQ29udGV4dHNbaWRdKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbnZhc0NvbnRleHRzW2lkXTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVsZXRlIGxheWVyIGVsZW1lbnRcbiAgICAgIGVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICBkZWxldGUgdGhpcy5lbGVtZW50c1tpZF07XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSByZW5kZXJlcidzIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYW1lcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FtZXJhKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY2FtZXJhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBzZXR0aW5nIHRoZSByZW5kZXJlcidzIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge0NhbWVyYX0gY2FtZXJhIC0gTmV3IGNhbWVyYS5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRDYW1lcmFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0Q2FtZXJhKGNhbWVyYSkge1xuICAgICAgdGhpcy51bmJpbmRDYW1lcmFIYW5kbGVycygpO1xuICAgICAgdGhpcy5jYW1lcmEgPSBjYW1lcmE7XG4gICAgICB0aGlzLmJpbmRDYW1lcmFIYW5kbGVycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENvbnRhaW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDb250YWluZXIoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0dyYXBofVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyYXBoKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ3JhcGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2V0IHRoZSByZW5kZXJlcidzIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7R3JhcGh9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0R3JhcGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0R3JhcGgoZ3JhcGgpIHtcbiAgICAgIGlmIChncmFwaCA9PT0gdGhpcy5ncmFwaCkgcmV0dXJuO1xuXG4gICAgICAvLyBDaGVjayBob3ZlcmVkTm9kZSBhbmQgaG92ZXJlZEVkZ2VcbiAgICAgIGlmICh0aGlzLmhvdmVyZWROb2RlICYmICFncmFwaC5oYXNOb2RlKHRoaXMuaG92ZXJlZE5vZGUpKSB0aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLmhvdmVyZWRFZGdlICYmICFncmFwaC5oYXNFZGdlKHRoaXMuaG92ZXJlZEVkZ2UpKSB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcblxuICAgICAgLy8gVW5iaW5kaW5nIGhhbmRsZXJzIG9uIHRoZSBjdXJyZW50IGdyYXBoXG4gICAgICB0aGlzLnVuYmluZEdyYXBoSGFuZGxlcnMoKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSk7XG4gICAgICAgIHRoaXMuY2hlY2tFZGdlc0V2ZW50c0ZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSW5zdGFsbGluZyBuZXcgZ3JhcGhcbiAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcblxuICAgICAgLy8gQmluZGluZyBuZXcgaGFuZGxlcnNcbiAgICAgIHRoaXMuYmluZEdyYXBoSGFuZGxlcnMoKTtcblxuICAgICAgLy8gUmUtcmVuZGVyaW5nIG5vdyB0byBhdm9pZCBkaXNjcmVwYW5jaWVzIGZyb20gbm93IHRvIG5leHQgZnJhbWVcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIG1vdXNlIGNhcHRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01vdXNlQ2FwdG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE1vdXNlQ2FwdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdXNlQ2FwdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VDYXB0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgdG91Y2ggY2FwdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7VG91Y2hDYXB0b3J9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG91Y2hDYXB0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG91Y2hDYXB0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaENhcHRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHJlbmRlcmVyJ3MgZGltZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY3VycmVudCBncmFwaCdzIGRpbWVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEdyYXBoRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaERpbWVuc2lvbnMoKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gdGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBleHRlbnQueFsxXSAtIGV4dGVudC54WzBdIHx8IDEsXG4gICAgICAgIGhlaWdodDogZXh0ZW50LnlbMV0gLSBleHRlbnQueVswXSB8fCAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHNpZ21hIG5vZGUgYXR0cmlidXRlcy5cbiAgICAgKiBJdCdzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0byBnZXQgdGhlIHBvc2l0aW9uIG9mIGEgbm9kZVxuICAgICAqIGFuZCB0byBnZXQgdmFsdWVzIHRoYXQgYXJlIHNldCBieSB0aGUgbm9kZVJlZHVjZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIG5vZGUncyBrZXkuXG4gICAgICogQHJldHVybiB7Tm9kZURpc3BsYXlEYXRhIHwgdW5kZWZpbmVkfSBBIGNvcHkgb2YgdGhlIGRlc2lyZWQgbm9kZSdzIGF0dHJpYnV0ZSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZURpc3BsYXlEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE5vZGVEaXNwbGF5RGF0YShrZXkpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICByZXR1cm4gbm9kZSA/IE9iamVjdC5hc3NpZ24oe30sIG5vZGUpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHNpZ21hIGVkZ2UgYXR0cmlidXRlcy5cbiAgICAgKiBJdCdzIHVzZWZ1bCBmb3IgZXhhbXBsZSB0byBnZXQgdmFsdWVzIHRoYXQgYXJlIHNldCBieSB0aGUgZWRnZVJlZHVjZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgICAqIEByZXR1cm4ge0VkZ2VEaXNwbGF5RGF0YSB8IHVuZGVmaW5lZH0gQSBjb3B5IG9mIHRoZSBkZXNpcmVkIGVkZ2UncyBhdHRyaWJ1dGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VEaXNwbGF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlRGlzcGxheURhdGEoa2V5KSB7XG4gICAgICB2YXIgZWRnZSA9IHRoaXMuZWRnZURhdGFDYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIGVkZ2UgPyBPYmplY3QuYXNzaWduKHt9LCBlZGdlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgZGlzcGxheWVkIG5vZGUgbGFiZWxzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2V0PHN0cmluZz59IEEgc2V0IG9mIG5vZGUga2V5cyB3aG9zZSBsYWJlbCBpcyBkaXNwbGF5ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZURpc3BsYXllZExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlRGlzcGxheWVkTGFiZWxzKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgdGhlIHNldCBvZiBjdXJyZW50bHkgZGlzcGxheWVkIGVkZ2UgbGFiZWxzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2V0PHN0cmluZz59IEEgc2V0IG9mIGVkZ2Uga2V5cyB3aG9zZSBsYWJlbCBpcyBkaXNwbGF5ZWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZURpc3BsYXllZExhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlRGlzcGxheWVkTGFiZWxzKCkge1xuICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcy5kaXNwbGF5ZWRFZGdlTGFiZWxzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIGEgY29weSBvZiB0aGUgc2V0dGluZ3MgY29sbGVjdGlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldHRpbmdzfSBBIGNvcHkgb2YgdGhlIHNldHRpbmdzIGNvbGxlY3Rpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2V0dGluZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2V0dGluZ3MoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc2V0dGluZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgdmFsdWUgZm9yIGEgZ2l2ZW4gc2V0dGluZyBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBzZXR0aW5nIGtleSB0byBnZXQuXG4gICAgICogQHJldHVybiB7YW55fSBUaGUgdmFsdWUgYXR0YWNoZWQgdG8gdGhpcyBzZXR0aW5nIGtleSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2V0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTZXR0aW5nKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0dGluZ3Nba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBzZXR0aW5nIGtleS4gTm90ZSB0aGF0IHRoaXMgd2lsbCBzY2hlZHVsZVxuICAgICAqIGEgbmV3IHJlbmRlciBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgc2V0dGluZyBrZXkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSAge2FueX0gICAgdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2V0dGluZyhrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgb2xkVmFsdWVzID0gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgICB2YWxpZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVTZXR0aW5nc1VwZGF0ZShvbGRWYWx1ZXMpO1xuICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1cGRhdGluZyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBzZXR0aW5nIGtleSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBzY2hlZHVsZSBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgIC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFRoZSB1cGRhdGUgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2V0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZXR0aW5nKGtleSwgdXBkYXRlcikge1xuICAgICAgdGhpcy5zZXRTZXR0aW5nKGtleSwgdXBkYXRlcih0aGlzLnNldHRpbmdzW2tleV0pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBzZXR0aW5nIG11bHRpcGxlIHNldHRpbmdzIGF0IG9uY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtQYXJ0aWFsPFNldHRpbmdzPn0gc2V0dGluZ3MgLSBUaGUgc2V0dGluZ3MgdG8gc2V0LlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICB2YXIgb2xkVmFsdWVzID0gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgICAgdmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUob2xkVmFsdWVzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXNpemUgdGhlIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7Ym9vbGVhbn0gZm9yY2UgLSBJZiB0cnVlLCB0aGVuIHJlc2l6ZSBpcyBwcm9jZXNzZWQgZXZlbiBpZiBzaXplIGlzIHVuY2hhbmdlZCAob3B0aW9uYWwpLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNpemUoZm9yY2UpIHtcbiAgICAgIHZhciBwcmV2aW91c1dpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgcHJldmlvdXNIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgaWYgKHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dJbnZhbGlkQ29udGFpbmVyKSB0aGlzLndpZHRoID0gMTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb250YWluZXIgaGFzIG5vIHdpZHRoLiBZb3UgY2FuIHNldCB0aGUgYWxsb3dJbnZhbGlkQ29udGFpbmVyIHNldHRpbmcgdG8gdHJ1ZSB0byBzdG9wIHNlZWluZyB0aGlzIGVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbGxvd0ludmFsaWRDb250YWluZXIpIHRoaXMuaGVpZ2h0ID0gMTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb250YWluZXIgaGFzIG5vIGhlaWdodC4gWW91IGNhbiBzZXQgdGhlIGFsbG93SW52YWxpZENvbnRhaW5lciBzZXR0aW5nIHRvIHRydWUgdG8gc3RvcCBzZWVpbmcgdGhpcyBlcnJvci5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHdlIGNhbiBzdG9wIHJpZ2h0IGhlcmVcbiAgICAgIGlmICghZm9yY2UgJiYgcHJldmlvdXNXaWR0aCA9PT0gdGhpcy53aWR0aCAmJiBwcmV2aW91c0hlaWdodCA9PT0gdGhpcy5oZWlnaHQpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBTaXppbmcgZG9tIGVsZW1lbnRzXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpZF07XG4gICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSB0aGlzLndpZHRoICsgXCJweFwiO1xuICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgXCJweFwiO1xuICAgICAgfVxuXG4gICAgICAvLyBTaXppbmcgY2FudmFzIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBfaWQgaW4gdGhpcy5jYW52YXNDb250ZXh0cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZF0uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2lkXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICBpZiAodGhpcy5waXhlbFJhdGlvICE9PSAxKSB0aGlzLmNhbnZhc0NvbnRleHRzW19pZF0uc2NhbGUodGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpeGVsUmF0aW8pO1xuICAgICAgfVxuXG4gICAgICAvLyBTaXppbmcgV2ViR0wgY29udGV4dHNcbiAgICAgIGZvciAodmFyIF9pZDIgaW4gdGhpcy53ZWJHTENvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2lkMl0uc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2lkMl0uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53ZWJHTENvbnRleHRzW19pZDJdO1xuICAgICAgICBnbC52aWV3cG9ydCgwLCAwLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyk7XG5cbiAgICAgICAgLy8gQ2xlYXIgcGlja2luZyB0ZXh0dXJlIGlmIG5lZWRlZFxuICAgICAgICBpZiAodGhpcy5waWNraW5nTGF5ZXJzLmhhcyhfaWQyKSkge1xuICAgICAgICAgIHZhciBjdXJyZW50VGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbX2lkMl07XG4gICAgICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlKSBnbC5kZWxldGVUZXh0dXJlKGN1cnJlbnRUZXh0dXJlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwicmVzaXplXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2xlYXIgYWxsIHRoZSBjYW52YXNlcy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlQ2xlYXJcIik7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMubm9kZXMuYmluZEZyYW1lYnVmZmVyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMubm9kZXMuY2xlYXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMubGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzLmhvdmVycy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmVtaXQoXCJhZnRlckNsZWFyXCIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVmcmVzaCwgaS5lLiBmb3JjZSB0aGUgcmVuZGVyZXIgdG8gcmVwcm9jZXNzIGdyYXBoXG4gICAgICogZGF0YSBhbmQgcmVuZGVyLCBidXQga2VlcCB0aGUgc3RhdGUuXG4gICAgICogLSBpZiBhIHBhcnRpYWxHcmFwaCBpcyBwcm92aWRlZCwgd2Ugb25seSByZXByb2Nlc3MgdGhvc2Ugbm9kZXMgJiBlZGdlcy5cbiAgICAgKiAtIGlmIHNjaGVkdWxlIGlzIFRSVUUsIHdlIHNjaGVkdWxlIGEgcmVuZGVyIGluc3RlYWQgb2Ygc3luYyByZW5kZXJcbiAgICAgKiAtIGlmIHNraXBJbmRleGF0aW9uIGlzIFRSVUUsIHRoZW4gbGFiZWxHcmlkICYgcHJvZ3JhbSBpbmRleGF0aW9uIGFyZSBza2lwcGVkIChjYW4gYmUgdXNlZCBpZiB5b3UgaGF2ZW4ndCBtb2RpZnkgeCwgeSwgekluZGV4ICYgc2l6ZSlcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmcmVzaChvcHRzKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgICB2YXIgc2tpcEluZGV4YXRpb24gPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNraXBJbmRleGF0aW9uKSAhPT0gdW5kZWZpbmVkID8gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNraXBJbmRleGF0aW9uIDogZmFsc2U7XG4gICAgICB2YXIgc2NoZWR1bGUgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnNjaGVkdWxlKSAhPT0gdW5kZWZpbmVkID8gb3B0cy5zY2hlZHVsZSA6IGZhbHNlO1xuICAgICAgdmFyIGZ1bGxSZWZyZXNoID0gIW9wdHMgfHwgIW9wdHMucGFydGlhbEdyYXBoO1xuICAgICAgaWYgKGZ1bGxSZWZyZXNoKSB7XG4gICAgICAgIC8vIFJlLWluZGV4IGdyYXBoIGRhdGFcbiAgICAgICAgdGhpcy5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICAgIHRoaXMuY2xlYXJOb2RlSW5kaWNlcygpO1xuICAgICAgICB0aGlzLmdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTAuYWRkTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMxMC5hZGRFZGdlKGVkZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfb3B0cyRwYXJ0aWFsR3JhcGgsIF9vcHRzJHBhcnRpYWxHcmFwaDI7XG4gICAgICAgIHZhciBub2RlcyA9ICgoX29wdHMkcGFydGlhbEdyYXBoID0gb3B0cy5wYXJ0aWFsR3JhcGgpID09PSBudWxsIHx8IF9vcHRzJHBhcnRpYWxHcmFwaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkcGFydGlhbEdyYXBoLm5vZGVzKSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSAobm9kZXMgPT09IG51bGwgfHwgbm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVzLmxlbmd0aCkgfHwgMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgLy8gUmVjb21wdXRlIG5vZGUncyBkYXRhIChpZS4gYXBwbHkgcmVkdWNlcilcbiAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGUobm9kZSk7XG4gICAgICAgICAgLy8gQWRkIG5vZGUgdG8gdGhlIHByb2dyYW0gaWYgbGF5b3V0IGlzIHVuY2hhbmdlZC5cbiAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBiZSBkb25lIGluIHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKHNraXBJbmRleGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcHJvZ3JhbUluZGV4ID0gdGhpcy5ub2RlUHJvZ3JhbUluZGV4W25vZGVdO1xuICAgICAgICAgICAgaWYgKHByb2dyYW1JbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogbm9kZSBcXFwiXCIuY29uY2F0KG5vZGUsIFwiXFxcIiBjYW4ndCBiZSByZXBhaW50XCIpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkTm9kZVRvUHJvZ3JhbShub2RlLCB0aGlzLm5vZGVJbmRpY2VzW25vZGVdLCBwcm9ncmFtSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRnZXMgPSAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgfHwgKF9vcHRzJHBhcnRpYWxHcmFwaDIgPSBvcHRzLnBhcnRpYWxHcmFwaCkgPT09IG51bGwgfHwgX29wdHMkcGFydGlhbEdyYXBoMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX29wdHMkcGFydGlhbEdyYXBoMi5lZGdlcykgfHwgW107XG4gICAgICAgIGZvciAodmFyIF9pNCA9IDAsIF9sNCA9IGVkZ2VzLmxlbmd0aDsgX2k0IDwgX2w0OyBfaTQrKykge1xuICAgICAgICAgIHZhciBlZGdlID0gZWRnZXNbX2k0XTtcbiAgICAgICAgICAvLyBSZWNvbXB1dGUgZWRnZSdzIGRhdGEgKGllLiBhcHBseSByZWR1Y2VyKVxuICAgICAgICAgIHRoaXMudXBkYXRlRWRnZShlZGdlKTtcbiAgICAgICAgICAvLyBBZGQgZWRnZSB0byB0aGUgcHJvZ3JhbVxuICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRvbmUgaW4gdGhlIHByb2Nlc3MgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBfcHJvZ3JhbUluZGV4ID0gdGhpcy5lZGdlUHJvZ3JhbUluZGV4W2VkZ2VdO1xuICAgICAgICAgICAgaWYgKF9wcm9ncmFtSW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGVkZ2UgXFxcIlwiLmNvbmNhdChlZGdlLCBcIlxcXCIgY2FuJ3QgYmUgcmVwYWludFwiKSk7XG4gICAgICAgICAgICB0aGlzLmFkZEVkZ2VUb1Byb2dyYW0oZWRnZSwgdGhpcy5lZGdlSW5kaWNlc1tlZGdlXSwgX3Byb2dyYW1JbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIHdlIG5lZWQgdG8gY2FsbCB0aGUgcHJvY2VzcyBmdW5jdGlvbiA/XG4gICAgICBpZiAoZnVsbFJlZnJlc2ggfHwgIXNraXBJbmRleGF0aW9uKSB0aGlzLm5lZWRUb1Byb2Nlc3MgPSB0cnVlO1xuICAgICAgaWYgKHNjaGVkdWxlKSB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7ZWxzZSB0aGlzLnJlbmRlcigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2NoZWR1bGUgYSByZW5kZXIgYXQgdGhlIG5leHQgYXZhaWxhYmxlIGZyYW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBzYWZlbHkgY2FsbGVkIG9uIGEgc2FtZSBmcmFtZSBiZWNhdXNlIGl0IGJhc2ljYWxseVxuICAgICAqIGRlYm91bmNlcyByZWZyZXNoIHRvIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVSZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVSZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMxMSA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMxMS5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIHJlZnJlc2ggKGkuZS4gZnVsbHkgcmVwcm9jZXNzIGdyYXBoIGRhdGEgYW5kIHJlbmRlcilcbiAgICAgKiBhdCB0aGUgbmV4dCBhdmFpbGFibGUgZnJhbWUuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseSBjYWxsZWQgb24gYSBzYW1lIGZyYW1lIGJlY2F1c2UgaXQgYmFzaWNhbGx5XG4gICAgICogZGVib3VuY2VzIHJlZnJlc2ggdG8gdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZVJlZnJlc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NoZWR1bGVSZWZyZXNoKG9wdHMpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZnJlc2goX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIG9wdHMpLCB7fSwge1xuICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvICh1bil6b29tLCB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBwb3NpdGlvbiBvZiBhIHZpZXdwb3J0IHBvaW50LlxuICAgICAqIFVzZWQgZm9yIGluc3RhbmNlIHRvIHpvb20gXCJvbiB0aGUgbW91c2UgY3Vyc29yXCIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmlld3BvcnRUYXJnZXRcbiAgICAgKiBAcGFyYW0gbmV3UmF0aW9cbiAgICAgKiBAcmV0dXJuIHtDYW1lcmFTdGF0ZX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRWaWV3cG9ydFpvb21lZFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFZpZXdwb3J0Wm9vbWVkU3RhdGUodmlld3BvcnRUYXJnZXQsIG5ld1JhdGlvKSB7XG4gICAgICB2YXIgX3RoaXMkY2FtZXJhJGdldFN0YXRlID0gdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSxcbiAgICAgICAgcmF0aW8gPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUucmF0aW8sXG4gICAgICAgIGFuZ2xlID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLmFuZ2xlLFxuICAgICAgICB4ID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLngsXG4gICAgICAgIHkgPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUueTtcbiAgICAgIHZhciBfdGhpcyRzZXR0aW5nczIgPSB0aGlzLnNldHRpbmdzLFxuICAgICAgICBtaW5DYW1lcmFSYXRpbyA9IF90aGlzJHNldHRpbmdzMi5taW5DYW1lcmFSYXRpbyxcbiAgICAgICAgbWF4Q2FtZXJhUmF0aW8gPSBfdGhpcyRzZXR0aW5nczIubWF4Q2FtZXJhUmF0aW87XG4gICAgICBpZiAodHlwZW9mIG1heENhbWVyYVJhdGlvID09PSBcIm51bWJlclwiKSBuZXdSYXRpbyA9IE1hdGgubWluKG5ld1JhdGlvLCBtYXhDYW1lcmFSYXRpbyk7XG4gICAgICBpZiAodHlwZW9mIG1pbkNhbWVyYVJhdGlvID09PSBcIm51bWJlclwiKSBuZXdSYXRpbyA9IE1hdGgubWF4KG5ld1JhdGlvLCBtaW5DYW1lcmFSYXRpbyk7XG4gICAgICB2YXIgcmF0aW9EaWZmID0gbmV3UmF0aW8gLyByYXRpbztcbiAgICAgIHZhciBjZW50ZXIgPSB7XG4gICAgICAgIHg6IHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgICB2YXIgZ3JhcGhNb3VzZVBvc2l0aW9uID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgodmlld3BvcnRUYXJnZXQpO1xuICAgICAgdmFyIGdyYXBoQ2VudGVyUG9zaXRpb24gPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaChjZW50ZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYW5nbGU6IGFuZ2xlLFxuICAgICAgICB4OiAoZ3JhcGhNb3VzZVBvc2l0aW9uLnggLSBncmFwaENlbnRlclBvc2l0aW9uLngpICogKDEgLSByYXRpb0RpZmYpICsgeCxcbiAgICAgICAgeTogKGdyYXBoTW91c2VQb3NpdGlvbi55IC0gZ3JhcGhDZW50ZXJQb3NpdGlvbi55KSAqICgxIC0gcmF0aW9EaWZmKSArIHksXG4gICAgICAgIHJhdGlvOiBuZXdSYXRpb1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBhYnN0cmFjdCByZWN0YW5nbGUgY29udGFpbmluZyB0aGUgZ3JhcGggYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIGNhbWVyYSdzIHN0YXRlLlxuICAgICAqXG4gICAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSB2aWV3J3MgcmVjdGFuZ2xlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZXdSZWN0YW5nbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlld1JlY3RhbmdsZSgpIHtcbiAgICAgIHZhciBwMSA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIHAyID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9KSxcbiAgICAgICAgaCA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IHRoaXMuaGVpZ2h0XG4gICAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDE6IHAxLngsXG4gICAgICAgIHkxOiBwMS55LFxuICAgICAgICB4MjogcDIueCxcbiAgICAgICAgeTI6IHAyLnksXG4gICAgICAgIGhlaWdodDogcDIueSAtIGgueVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb29yZGluYXRlcyBvZiBhIHBvaW50IGZyb20gdGhlIGZyYW1lZCBncmFwaCBzeXN0ZW0gdG8gdGhlIHZpZXdwb3J0IHN5c3RlbS4gSXQgYWxsb3dzXG4gICAgICogb3ZlcnJpZGluZyBhbnl0aGluZyB0aGF0IGlzIHVzZWQgdG8gZ2V0IHRoZSB0cmFuc2xhdGlvbiBtYXRyaXgsIG9yIGV2ZW4gdGhlIG1hdHJpeCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBCZSBjYXJlZnVsIGlmIG92ZXJyaWRpbmcgZGltZW5zaW9ucywgcGFkZGluZyBvciBjYW1lcmFTdGF0ZSwgYXMgdGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBtYXRyaXggaXMgbm90IHRoZSBsaWdodGVzdFxuICAgICAqIG9mIGNvbXB1dGF0aW9ucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmcmFtZWRHcmFwaFRvVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGNvb3JkaW5hdGVzKSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIHJlY29tcHV0ZU1hdHJpeCA9ICEhb3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgISFvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgISFvdmVycmlkZS5ncmFwaERpbWVuc2lvbnM7XG4gICAgICB2YXIgbWF0cml4ID0gb3ZlcnJpZGUubWF0cml4ID8gb3ZlcnJpZGUubWF0cml4IDogcmVjb21wdXRlTWF0cml4ID8gbWF0cml4RnJvbUNhbWVyYShvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpLCBvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgdGhpcy5nZXREaW1lbnNpb25zKCksIG92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucyB8fCB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpLCBvdmVycmlkZS5wYWRkaW5nIHx8IHRoaXMuZ2V0U3RhZ2VQYWRkaW5nKCkpIDogdGhpcy5tYXRyaXg7XG4gICAgICB2YXIgdmlld3BvcnRQb3MgPSBtdWx0aXBseVZlYzIobWF0cml4LCBjb29yZGluYXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSArIHZpZXdwb3J0UG9zLngpICogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6ICgxIC0gdmlld3BvcnRQb3MueSkgKiB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSB2aWV3cG9ydCBzeXN0ZW0gdG8gdGhlIGZyYW1lZCBncmFwaCBzeXN0ZW0uIEl0IGFsbG93c1xuICAgICAqIG92ZXJyaWRpbmcgYW55dGhpbmcgdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgdHJhbnNsYXRpb24gbWF0cml4LCBvciBldmVuIHRoZSBtYXRyaXggaXRzZWxmLlxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBpZiBvdmVycmlkaW5nIGRpbWVuc2lvbnMsIHBhZGRpbmcgb3IgY2FtZXJhU3RhdGUsIGFzIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgbWF0cml4IGlzIG5vdCB0aGUgbGlnaHRlc3RcbiAgICAgKiBvZiBjb21wdXRhdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRUb0ZyYW1lZEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0VG9GcmFtZWRHcmFwaChjb29yZGluYXRlcykge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZWNvbXB1dGVNYXRyaXggPSAhIW92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8ICEhb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8ICFvdmVycmlkZS5ncmFwaERpbWVuc2lvbnM7XG4gICAgICB2YXIgaW52TWF0cml4ID0gb3ZlcnJpZGUubWF0cml4ID8gb3ZlcnJpZGUubWF0cml4IDogcmVjb21wdXRlTWF0cml4ID8gbWF0cml4RnJvbUNhbWVyYShvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpLCBvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgdGhpcy5nZXREaW1lbnNpb25zKCksIG92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucyB8fCB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpLCBvdmVycmlkZS5wYWRkaW5nIHx8IHRoaXMuZ2V0U3RhZ2VQYWRkaW5nKCksIHRydWUpIDogdGhpcy5pbnZNYXRyaXg7XG4gICAgICB2YXIgcmVzID0gbXVsdGlwbHlWZWMyKGludk1hdHJpeCwge1xuICAgICAgICB4OiBjb29yZGluYXRlcy54IC8gdGhpcy53aWR0aCAqIDIgLSAxLFxuICAgICAgICB5OiAxIC0gY29vcmRpbmF0ZXMueSAvIHRoaXMuaGVpZ2h0ICogMlxuICAgICAgfSk7XG4gICAgICBpZiAoaXNOYU4ocmVzLngpKSByZXMueCA9IDA7XG4gICAgICBpZiAoaXNOYU4ocmVzLnkpKSByZXMueSA9IDA7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHRyYW5zbGF0ZSBhIHBvaW50J3MgY29vcmRpbmF0ZXMgZnJvbSB0aGUgdmlld3BvcnQgc3lzdGVtIChwaXhlbCBkaXN0YW5jZSBmcm9tIHRoZSB0b3AtbGVmdCBvZiB0aGVcbiAgICAgKiBzdGFnZSkgdG8gdGhlIGdyYXBoIHN5c3RlbSAodGhlIHJlZmVyZW5jZSBzeXN0ZW0gb2YgZGF0YSBhcyB0aGV5IGFyZSBpbiB0aGUgZ2l2ZW4gZ3JhcGggaW5zdGFuY2UpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBjYW1lcmEgd2hpY2ggY2FuIGJlIHVzZWZ1bCBpZiB5b3UgbmVlZCB0byB0cmFuc2xhdGUgY29vcmRpbmF0ZXNcbiAgICAgKiBiYXNlZCBvbiBhIGRpZmZlcmVudCB2aWV3IHRoYW4gdGhlIG9uZSBiZWluZyBjdXJyZW50bHkgYmVpbmcgZGlzcGxheWVkIG9uIHNjcmVlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZXN9ICAgICAgICAgICAgICAgICAgdmlld3BvcnRQb2ludFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZUNvbnZlcnNpb25PdmVycmlkZX0gb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3cG9ydFRvR3JhcGhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmlld3BvcnRUb0dyYXBoKHZpZXdwb3J0UG9pbnQpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24uaW52ZXJzZSh0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh2aWV3cG9ydFBvaW50LCBvdmVycmlkZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHRyYW5zbGF0ZSBhIHBvaW50J3MgY29vcmRpbmF0ZXMgZnJvbSB0aGUgZ3JhcGggc3lzdGVtICh0aGUgcmVmZXJlbmNlIHN5c3RlbSBvZiBkYXRhIGFzIHRoZXkgYXJlIGluXG4gICAgICogdGhlIGdpdmVuIGdyYXBoIGluc3RhbmNlKSB0byB0aGUgdmlld3BvcnQgc3lzdGVtIChwaXhlbCBkaXN0YW5jZSBmcm9tIHRoZSB0b3AtbGVmdCBvZiB0aGUgc3RhZ2UpLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWNjZXB0cyBhbiBvcHRpb25hbCBjYW1lcmEgd2hpY2ggY2FuIGJlIHVzZWZ1bCBpZiB5b3UgbmVlZCB0byB0cmFuc2xhdGUgY29vcmRpbmF0ZXNcbiAgICAgKiBiYXNlZCBvbiBhIGRpZmZlcmVudCB2aWV3IHRoYW4gdGhlIG9uZSBiZWluZyBjdXJyZW50bHkgYmVpbmcgZGlzcGxheWVkIG9uIHNjcmVlbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZXN9ICAgICAgICAgICAgICAgICAgZ3JhcGhQb2ludFxuICAgICAqIEBwYXJhbSB7Q29vcmRpbmF0ZUNvbnZlcnNpb25PdmVycmlkZX0gb3ZlcnJpZGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJncmFwaFRvVmlld3BvcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ3JhcGhUb1ZpZXdwb3J0KGdyYXBoUG9pbnQpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQodGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24oZ3JhcGhQb2ludCksIG92ZXJyaWRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBkaXN0YW5jZSBtdWx0aXBsaWVyIGJldHdlZW4gdGhlIGdyYXBoIHN5c3RlbSBhbmQgdGhlXG4gICAgICogdmlld3BvcnQgc3lzdGVtLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEdyYXBoVG9WaWV3cG9ydFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEdyYXBoVG9WaWV3cG9ydFJhdGlvKCkge1xuICAgICAgdmFyIGdyYXBoUDEgPSB7XG4gICAgICAgIHg6IDAsXG4gICAgICAgIHk6IDBcbiAgICAgIH07XG4gICAgICB2YXIgZ3JhcGhQMiA9IHtcbiAgICAgICAgeDogMSxcbiAgICAgICAgeTogMVxuICAgICAgfTtcbiAgICAgIHZhciBncmFwaEQgPSBNYXRoLnNxcnQoTWF0aC5wb3coZ3JhcGhQMS54IC0gZ3JhcGhQMi54LCAyKSArIE1hdGgucG93KGdyYXBoUDEueSAtIGdyYXBoUDIueSwgMikpO1xuICAgICAgdmFyIHZpZXdwb3J0UDEgPSB0aGlzLmdyYXBoVG9WaWV3cG9ydChncmFwaFAxKTtcbiAgICAgIHZhciB2aWV3cG9ydFAyID0gdGhpcy5ncmFwaFRvVmlld3BvcnQoZ3JhcGhQMik7XG4gICAgICB2YXIgdmlld3BvcnREID0gTWF0aC5zcXJ0KE1hdGgucG93KHZpZXdwb3J0UDEueCAtIHZpZXdwb3J0UDIueCwgMikgKyBNYXRoLnBvdyh2aWV3cG9ydFAxLnkgLSB2aWV3cG9ydFAyLnksIDIpKTtcbiAgICAgIHJldHVybiB2aWV3cG9ydEQgLyBncmFwaEQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBib3VuZGluZyBib3guXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt7IHg6IEV4dGVudCwgeTogRXh0ZW50IH19XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRCQm94KCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZUV4dGVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBncmFwaCdzIGN1c3RvbSBib3VuZGluZyBib3gsIGlmIGFueS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3sgeDogRXh0ZW50LCB5OiBFeHRlbnQgfSB8IG51bGx9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q3VzdG9tQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDdXN0b21CQm94KCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tQkJveDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBvdmVycmlkZSB0aGUgZ3JhcGgncyBib3VuZGluZyBib3ggd2l0aCBhIGN1c3RvbSBvbmUuIEdpdmUgYG51bGxgIGFzIHRoZSBhcmd1bWVudCB0byBzdG9wIG92ZXJyaWRpbmcuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRDdXN0b21CQm94XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEN1c3RvbUJCb3goY3VzdG9tQkJveCkge1xuICAgICAgdGhpcy5jdXN0b21CQm94ID0gY3VzdG9tQkJveDtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNodXQgdGhlIGNvbnRhaW5lciAmIHJlbGVhc2UgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIC8vIEVtaXR0aW5nIFwia2lsbFwiIGV2ZW50cyBzbyB0aGF0IHBsdWdpbnMgYW5kIHN1Y2ggY2FuIGNsZWFudXBcbiAgICAgIHRoaXMuZW1pdChcImtpbGxcIik7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBldmVudHNcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBjYW1lcmEgaGFuZGxlcnNcbiAgICAgIHRoaXMudW5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcblxuICAgICAgLy8gUmVsZWFzaW5nIERPTSBldmVudHMgJiBjYXB0b3JzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5raWxsKCk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLmtpbGwoKTtcblxuICAgICAgLy8gUmVsZWFzaW5nIGdyYXBoIGhhbmRsZXJzXG4gICAgICB0aGlzLnVuYmluZEdyYXBoSGFuZGxlcnMoKTtcblxuICAgICAgLy8gUmVsZWFzaW5nIGNhY2hlICYgc3RhdGVcbiAgICAgIHRoaXMuY2xlYXJJbmRpY2VzKCk7XG4gICAgICB0aGlzLmNsZWFyU3RhdGUoKTtcbiAgICAgIHRoaXMubm9kZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuY2xlYXIoKTtcblxuICAgICAgLy8gQ2xlYXJpbmcgZnJhbWVzXG4gICAgICBpZiAodGhpcy5yZW5kZXJGcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUpO1xuICAgICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIERlc3Ryb3lpbmcgY2FudmFzZXNcbiAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lcjtcbiAgICAgIHdoaWxlIChjb250YWluZXIuZmlyc3RDaGlsZCkgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5maXJzdENoaWxkKTtcblxuICAgICAgLy8gS2lsbCBwcm9ncmFtczpcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0ua2lsbCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3R5cGU4IGluIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1tfdHlwZThdLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF90eXBlOSBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTldLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZVByb2dyYW1zID0ge307XG4gICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtcyA9IHt9O1xuXG4gICAgICAvLyBLaWxsIGFsbCBjYW52YXMvV2ViR0wgY29udGV4dHNcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5raWxsTGF5ZXIoaWQpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXN0cm95aW5nIHJlbWFpbmluZyBjb2xsZWN0aW9uc1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cyA9IHt9O1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzID0ge307XG4gICAgICB0aGlzLmVsZW1lbnRzID0ge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2NhbGUgdGhlIGdpdmVuIHNpemUgYWNjb3JkaW5nIHRvIHRoZSBjYW1lcmEncyByYXRpbywgaS5lLlxuICAgICAqIHpvb21pbmcgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXI/fSBzaXplIC0gICAgICAgIFRoZSBzaXplIHRvIHNjYWxlIChub2RlIHNpemUsIGVkZ2UgdGhpY2tuZXNzIGV0Yy4pLlxuICAgICAqIEBwYXJhbSAge251bWJlcj99IGNhbWVyYVJhdGlvIC0gQSBjYW1lcmEgcmF0aW8gKGRlZmF1bHRzIHRvIHRoZSBhY3R1YWwgY2FtZXJhIHJhdGlvKS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgICAgICAgICAtIFRoZSBzY2FsZWQgc2l6ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2FsZVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2NhbGVTaXplKCkge1xuICAgICAgdmFyIHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE7XG4gICAgICB2YXIgY2FtZXJhUmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY2FtZXJhLnJhdGlvO1xuICAgICAgcmV0dXJuIHNpemUgLyB0aGlzLnNldHRpbmdzLnpvb21Ub1NpemVSYXRpb0Z1bmN0aW9uKGNhbWVyYVJhdGlvKSAqICh0aGlzLmdldFNldHRpbmcoXCJpdGVtU2l6ZXNSZWZlcmVuY2VcIikgPT09IFwicG9zaXRpb25zXCIgPyBjYW1lcmFSYXRpbyAqIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0UmF0aW8gOiAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjb2xsZWN0aW9uIG9mIGFsbCB1c2VkIGNhbnZhc2VzLlxuICAgICAqIEF0IHRoZSBtb21lbnQsIHRoZSBpbnN0YW50aWF0ZWQgY2FudmFzZXMgYXJlIHRoZSBmb2xsb3dpbmcsIGFuZCBpbiB0aGVcbiAgICAgKiBmb2xsb3dpbmcgb3JkZXIgaW4gdGhlIERPTTpcbiAgICAgKiAtIGBlZGdlc2BcbiAgICAgKiAtIGBub2Rlc2BcbiAgICAgKiAtIGBlZGdlTGFiZWxzYFxuICAgICAqIC0gYGxhYmVsc2BcbiAgICAgKiAtIGBob3ZlcnNgXG4gICAgICogLSBgaG92ZXJOb2Rlc2BcbiAgICAgKiAtIGBtb3VzZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1BsYWluT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50Pn0gLSBUaGUgY29sbGVjdGlvbiBvZiBjYW52YXNlcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDYW52YXNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYW52YXNlcygpIHtcbiAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgIGZvciAodmFyIGxheWVyIGluIHRoaXMuZWxlbWVudHMpIGlmICh0aGlzLmVsZW1lbnRzW2xheWVyXSBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSByZXNbbGF5ZXJdID0gdGhpcy5lbGVtZW50c1tsYXllcl07XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgfV0pO1xufShUeXBlZEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogU2lnbWEuanMgTGlicmFyeSBFbmRwb2ludFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFRoZSBsaWJyYXJ5IGVuZHBvaW50LlxuICogQG1vZHVsZVxuICovXG52YXIgU2lnbWEgPSBTaWdtYSQxO1xuXG5leHBvcnQgeyBDYW1lcmEsIE1vdXNlQ2FwdG9yLCBTaWdtYSQxIGFzIFNpZ21hLCBUb3VjaENhcHRvciwgU2lnbWEgYXMgZGVmYXVsdCB9O1xuIiwiaW1wb3J0IHsgZCBhcyBkcmF3U3RyYWlnaHRFZGdlTGFiZWwsIGIgYXMgZHJhd0Rpc2NOb2RlTGFiZWwsIGMgYXMgZHJhd0Rpc2NOb2RlSG92ZXIsIE4gYXMgTm9kZUNpcmNsZVByb2dyYW0sIEUgYXMgRWRnZUFycm93UHJvZ3JhbSwgZSBhcyBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSB9IGZyb20gJy4uLy4uL2Rpc3QvaW5kZXgtMjM2YzYyYWQuZXNtLmpzJztcbmltcG9ydCB7IGEgYXMgYXNzaWduIH0gZnJvbSAnLi4vLi4vZGlzdC9kYXRhLTExZGY3MTI0LmVzbS5qcyc7XG5pbXBvcnQgJy4uLy4uL2Rpc3QvaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcblxuLyoqXG4gKiBTaWdtYS5qcyBTZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogVGhlIGxpc3Qgb2Ygc2V0dGluZ3MgYW5kIHNvbWUgaGFuZHkgZnVuY3Rpb25zLlxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogU2lnbWEuanMgc2V0dGluZ3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbnZhciBERUZBVUxUX1NFVFRJTkdTID0ge1xuICAvLyBQZXJmb3JtYW5jZVxuICBoaWRlRWRnZXNPbk1vdmU6IGZhbHNlLFxuICBoaWRlTGFiZWxzT25Nb3ZlOiBmYWxzZSxcbiAgcmVuZGVyTGFiZWxzOiB0cnVlLFxuICByZW5kZXJFZGdlTGFiZWxzOiBmYWxzZSxcbiAgZW5hYmxlRWRnZUV2ZW50czogZmFsc2UsXG4gIC8vIENvbXBvbmVudCByZW5kZXJpbmdcbiAgZGVmYXVsdE5vZGVDb2xvcjogXCIjOTk5XCIsXG4gIGRlZmF1bHROb2RlVHlwZTogXCJjaXJjbGVcIixcbiAgZGVmYXVsdEVkZ2VDb2xvcjogXCIjY2NjXCIsXG4gIGRlZmF1bHRFZGdlVHlwZTogXCJsaW5lXCIsXG4gIGxhYmVsRm9udDogXCJBcmlhbFwiLFxuICBsYWJlbFNpemU6IDE0LFxuICBsYWJlbFdlaWdodDogXCJub3JtYWxcIixcbiAgbGFiZWxDb2xvcjoge1xuICAgIGNvbG9yOiBcIiMwMDBcIlxuICB9LFxuICBlZGdlTGFiZWxGb250OiBcIkFyaWFsXCIsXG4gIGVkZ2VMYWJlbFNpemU6IDE0LFxuICBlZGdlTGFiZWxXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGVkZ2VMYWJlbENvbG9yOiB7XG4gICAgYXR0cmlidXRlOiBcImNvbG9yXCJcbiAgfSxcbiAgc3RhZ2VQYWRkaW5nOiAzMCxcbiAgZGVmYXVsdERyYXdFZGdlTGFiZWw6IGRyYXdTdHJhaWdodEVkZ2VMYWJlbCxcbiAgZGVmYXVsdERyYXdOb2RlTGFiZWw6IGRyYXdEaXNjTm9kZUxhYmVsLFxuICBkZWZhdWx0RHJhd05vZGVIb3ZlcjogZHJhd0Rpc2NOb2RlSG92ZXIsXG4gIG1pbkVkZ2VUaGlja25lc3M6IDEuNyxcbiAgYW50aUFsaWFzaW5nRmVhdGhlcjogMSxcbiAgLy8gTW91c2UgYW5kIHRvdWNoIHNldHRpbmdzXG4gIGRyYWdUaW1lb3V0OiAxMDAsXG4gIGRyYWdnZWRFdmVudHNUb2xlcmFuY2U6IDMsXG4gIGluZXJ0aWFEdXJhdGlvbjogMjAwLFxuICBpbmVydGlhUmF0aW86IDMsXG4gIHpvb21EdXJhdGlvbjogMjUwLFxuICB6b29taW5nUmF0aW86IDEuNyxcbiAgZG91YmxlQ2xpY2tUaW1lb3V0OiAzMDAsXG4gIGRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvOiAyLjIsXG4gIGRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uOiAyMDAsXG4gIHRhcE1vdmVUb2xlcmFuY2U6IDEwLFxuICAvLyBTaXplIGFuZCBzY2FsaW5nXG4gIHpvb21Ub1NpemVSYXRpb0Z1bmN0aW9uOiBNYXRoLnNxcnQsXG4gIGl0ZW1TaXplc1JlZmVyZW5jZTogXCJzY3JlZW5cIixcbiAgYXV0b1Jlc2NhbGU6IHRydWUsXG4gIGF1dG9DZW50ZXI6IHRydWUsXG4gIC8vIExhYmVsc1xuICBsYWJlbERlbnNpdHk6IDEsXG4gIGxhYmVsR3JpZENlbGxTaXplOiAxMDAsXG4gIGxhYmVsUmVuZGVyZWRTaXplVGhyZXNob2xkOiA2LFxuICAvLyBSZWR1Y2Vyc1xuICBub2RlUmVkdWNlcjogbnVsbCxcbiAgZWRnZVJlZHVjZXI6IG51bGwsXG4gIC8vIEZlYXR1cmVzXG4gIHpJbmRleDogZmFsc2UsXG4gIG1pbkNhbWVyYVJhdGlvOiBudWxsLFxuICBtYXhDYW1lcmFSYXRpbzogbnVsbCxcbiAgZW5hYmxlQ2FtZXJhWm9vbWluZzogdHJ1ZSxcbiAgZW5hYmxlQ2FtZXJhUGFubmluZzogdHJ1ZSxcbiAgZW5hYmxlQ2FtZXJhUm90YXRpb246IHRydWUsXG4gIGNhbWVyYVBhbkJvdW5kYXJpZXM6IG51bGwsXG4gIC8vIExpZmVjeWNsZVxuICBhbGxvd0ludmFsaWRDb250YWluZXI6IGZhbHNlLFxuICAvLyBQcm9ncmFtIGNsYXNzZXNcbiAgbm9kZVByb2dyYW1DbGFzc2VzOiB7fSxcbiAgbm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXM6IHt9LFxuICBlZGdlUHJvZ3JhbUNsYXNzZXM6IHt9XG59O1xudmFyIERFRkFVTFRfTk9ERV9QUk9HUkFNX0NMQVNTRVMgPSB7XG4gIGNpcmNsZTogTm9kZUNpcmNsZVByb2dyYW1cbn07XG52YXIgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUyA9IHtcbiAgYXJyb3c6IEVkZ2VBcnJvd1Byb2dyYW0sXG4gIGxpbmU6IEVkZ2VSZWN0YW5nbGVQcm9ncmFtXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICBpZiAodHlwZW9mIHNldHRpbmdzLmxhYmVsRGVuc2l0eSAhPT0gXCJudW1iZXJcIiB8fCBzZXR0aW5ncy5sYWJlbERlbnNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgYGxhYmVsRGVuc2l0eWAuIEV4cGVjdGluZyBhIHBvc2l0aXZlIG51bWJlci5cIik7XG4gIH1cbiAgdmFyIG1pbkNhbWVyYVJhdGlvID0gc2V0dGluZ3MubWluQ2FtZXJhUmF0aW8sXG4gICAgbWF4Q2FtZXJhUmF0aW8gPSBzZXR0aW5ncy5tYXhDYW1lcmFSYXRpbztcbiAgaWYgKHR5cGVvZiBtaW5DYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWF4Q2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIgJiYgbWF4Q2FtZXJhUmF0aW8gPCBtaW5DYW1lcmFSYXRpbykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmdzOiBpbnZhbGlkIGNhbWVyYSByYXRpbyBib3VuZGFyaWVzLiBFeHBlY3RpbmcgYG1heENhbWVyYVJhdGlvYCB0byBiZSBncmVhdGVyIHRoYW4gYG1pbkNhbWVyYVJhdGlvYC5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTZXR0aW5ncyhzZXR0aW5ncykge1xuICB2YXIgcmVzb2x2ZWRTZXR0aW5ncyA9IGFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgc2V0dGluZ3MpO1xuICByZXNvbHZlZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3NlcyA9IGFzc2lnbih7fSwgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUywgcmVzb2x2ZWRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMpO1xuICByZXNvbHZlZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3NlcyA9IGFzc2lnbih7fSwgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUywgcmVzb2x2ZWRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpO1xuICByZXR1cm4gcmVzb2x2ZWRTZXR0aW5ncztcbn1cblxuZXhwb3J0IHsgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUywgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUywgREVGQVVMVF9TRVRUSU5HUywgcmVzb2x2ZVNldHRpbmdzLCB2YWxpZGF0ZVNldHRpbmdzIH07XG4iLCJpbXBvcnQgeyBfIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9jYWxsU3VwZXIgfSBmcm9tICcuLi8uLi9kaXN0L2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIgfSBmcm9tICdldmVudHMnO1xuXG4vKipcbiAqIFV0aWwgdHlwZSB0byByZXByZXNlbnQgbWFwcyBvZiB0eXBlZCBlbGVtZW50cywgYnV0IGltcGxlbWVudGVkIHdpdGhcbiAqIEphdmFTY3JpcHQgb2JqZWN0cy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBSZXR1cm5zIGEgdHlwZSBzaW1pbGFyIHRvIFQsIGJ1dCB3aXRoIHRoZSBLIHNldCBvZiBwcm9wZXJ0aWVzIG9mIHRoZSB0eXBlXG4gKiBUICpyZXF1aXJlZCosIGFuZCB0aGUgcmVzdCBvcHRpb25hbC5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxuLyoqXG4gKiBSZXR1cm5zIGEgdHlwZSBzaW1pbGFyIHRvIFBhcnRpYWw8VD4sIGJ1dCB3aXRoIGF0IGxlYXN0IG9uZSBrZXkgc2V0LlxuICovXG5cbi8qKlxuICogQ3VzdG9tIGV2ZW50IGVtaXR0ZXIgdHlwZXMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbnZhciBUeXBlZEV2ZW50RW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3JlZikge1xuICBmdW5jdGlvbiBUeXBlZEV2ZW50RW1pdHRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVkRXZlbnRFbWl0dGVyKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVHlwZWRFdmVudEVtaXR0ZXIpO1xuICAgIF90aGlzLnJhd0VtaXR0ZXIgPSBfdGhpcztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFR5cGVkRXZlbnRFbWl0dGVyLCBfcmVmKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUeXBlZEV2ZW50RW1pdHRlcik7XG59KEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgdmFyaW91cyBvdGhlciB0eXBlczpcbiAqL1xuXG5leHBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCBTaWdtYSBmcm9tICdzaWdtYSc7XHJcbmltcG9ydCBncmFwaG9sb2d5IGZyb20gJ2dyYXBob2xvZ3knO1xyXG5pbXBvcnQgUGFwYSBmcm9tICdwYXBhcGFyc2UnO1xyXG5cclxud2luZG93Lm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBob2xvZ3kuR3JhcGgoKTtcclxuICAgIC8vIGdyYXBoLmFkZE5vZGUoXCIxXCIsIHsgbGFiZWw6IFwiTm9kZSAxXCIsIHg6IDAsIHk6IDAsIHNpemU6IDEwLCBjb2xvcjogXCJibHVlXCIgfSk7XHJcbiAgICAvLyBncmFwaC5hZGROb2RlKFwiMlwiLCB7IGxhYmVsOiBcIk5vZGUgMlwiLCB4OiAxLCB5OiAxLCBzaXplOiAyMCwgY29sb3I6IFwicmVkXCIgfSk7XHJcbiAgICAvLyBncmFwaC5hZGRFZGdlKFwiMVwiLCBcIjJcIiwgeyBzaXplOiA1LCBjb2xvcjogXCJwdXJwbGVcIiB9KTtcclxuXHJcbiAgICAvLyAvLyBJbnN0YW50aWF0ZSBzaWdtYS5qcyBhbmQgcmVuZGVyIHRoZSBncmFwaFxyXG4gICAgLy8gY29uc3Qgc2lnbWFJbnN0YW5jZSA9IG5ldyBTaWdtYShncmFwaCwgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjb250YWluZXJcIikpO1xyXG4gICAgLy8gfVxyXG4gICAgY29uc29sZS5sb2coXCJIZWxsb1wiKTtcclxuXHJcbiAgICB2YXIgcmVzdWx0cyA9IFBhcGEucGFyc2UoXCIuL2pvbl9zYW1wbGVfZGF0YS5jc3ZcIiwge1xyXG4gICAgICAgIGRvd25sb2FkOiB0cnVlLFxyXG4gICAgICAgIGhlYWRlcjogdHJ1ZSxcclxuICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcclxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDU1YgRGF0YSBQYXJzZWQ6XCIsIHJlc3VsdHMuZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnNlZCBkYXRhIGhlcmVcclxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gY3JlYXRlIG5vZGVzIGFuZCBlZGdlcyBiYXNlZCBvbiB0aGUgQ1NWIGRhdGFcclxuICAgICAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgZ3JhcGhvbG9neS5HcmFwaCgpO1xyXG4gICAgICAgICAgICByZXN1bHRzLmRhdGEuZm9yRWFjaChyb3cgPT4ge1xyXG5cclxuICAgICAgICAgICAgICAgIGlmICghZ3JhcGguaGFzTm9kZShyb3cuc291cmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZE5vZGUocm93LnNvdXJjZSwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcm93LnNvdXJjZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeDogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogTWF0aC5yYW5kb20oKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMTAsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBcImJsdWVcIlxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdHMuZGF0YS5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93LnNvdXJjZSAmJiByb3cudGFyZ2V0ICYmIGdyYXBoLmhhc05vZGUgKHJvdy5zb3VyY2UpICYmIGdyYXBoLmhhc05vZGUocm93LnRhcmdldCkgJiYgIWdyYXBoLmhhc0VkZ2Uocm93LnNvdXJjZSwgcm93LnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBncmFwaC5hZGRFZGdlKHJvdy5zb3VyY2UsIHJvdy50YXJnZXQsIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IDIsIFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogcm93LmxhYmVsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYXJyb3cnLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JjZUxhYmVsOiB0cnVlXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBncmFwaCB1c2luZyBTaWdtYS5qc1xyXG4gICAgICAgICAgICBjb25zdCBzaWdtYUluc3RhbmNlID0gbmV3IFNpZ21hKGdyYXBoLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNvbnRhaW5lclwiKSwge1xyXG4gICAgICAgICAgICAgICAgcmVuZGVyRWRnZUxhYmVsczogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yOiBmdW5jdGlvbiAoZXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHBhcnNpbmcgQ1NWOlwiLCBlcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG59OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==