/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@sigma/edge-curve/dist/sigma-edge-curve.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sigma/edge-curve/dist/sigma-edge-curve.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_EDGE_CURVATURE: () => (/* binding */ DEFAULT_EDGE_CURVATURE),
/* harmony export */   DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS: () => (/* binding */ DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS),
/* harmony export */   DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS: () => (/* binding */ DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS),
/* harmony export */   EdgeCurvedArrowProgram: () => (/* binding */ EdgeCurvedArrowProgram),
/* harmony export */   EdgeCurvedDoubleArrowProgram: () => (/* binding */ EdgeCurvedDoubleArrowProgram),
/* harmony export */   createDrawCurvedEdgeLabel: () => (/* binding */ createDrawCurvedEdgeLabel),
/* harmony export */   createEdgeCurveProgram: () => (/* binding */ createEdgeCurveProgram),
/* harmony export */   "default": () => (/* binding */ EdgeCurveProgram),
/* harmony export */   indexParallelEdgesIndex: () => (/* binding */ indexParallelEdgesIndex)
/* harmony export */ });
/* harmony import */ var sigma_rendering__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sigma/rendering */ "./node_modules/sigma/rendering/dist/sigma-rendering.esm.js");
/* harmony import */ var sigma_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sigma/utils */ "./node_modules/sigma/utils/dist/sigma-utils.esm.js");



function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}

function getCurvePoint(t, p0, p1, p2) {
  var x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;
  var y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;
  return {
    x: x,
    y: y
  };
}
function getCurveLength(p0, p1, p2) {
  var steps = 20;
  var length = 0;
  var lastPoint = p0;
  for (var i = 0; i < steps; i++) {
    var point = getCurvePoint((i + 1) / steps, p0, p1, p2);
    length += Math.sqrt(Math.pow(lastPoint.x - point.x, 2) + Math.pow(lastPoint.y - point.y, 2));
    lastPoint = point;
  }
  return length;
}
function createDrawCurvedEdgeLabel(_ref) {
  var curvatureAttribute = _ref.curvatureAttribute,
    defaultCurvature = _ref.defaultCurvature,
    _ref$keepLabelUpright = _ref.keepLabelUpright,
    keepLabelUpright = _ref$keepLabelUpright === void 0 ? true : _ref$keepLabelUpright;
  return function (context, edgeData, sourceData, targetData, settings) {
    var size = settings.edgeLabelSize,
      curvature = edgeData[curvatureAttribute] || defaultCurvature,
      font = settings.edgeLabelFont,
      weight = settings.edgeLabelWeight,
      color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || "#000" : settings.edgeLabelColor.color;
    var label = edgeData.label;
    if (!label) return;
    context.fillStyle = color;
    context.font = "".concat(weight, " ").concat(size, "px ").concat(font);

    // Computing positions without considering nodes sizes:
    var ltr = !keepLabelUpright || sourceData.x < targetData.x;
    var sourceX = ltr ? sourceData.x : targetData.x;
    var sourceY = ltr ? sourceData.y : targetData.y;
    var targetX = ltr ? targetData.x : sourceData.x;
    var targetY = ltr ? targetData.y : sourceData.y;
    var centerX = (sourceX + targetX) / 2;
    var centerY = (sourceY + targetY) / 2;
    var diffX = targetX - sourceX;
    var diffY = targetY - sourceY;
    var diff = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
    // Anchor point:
    var orientation = ltr ? 1 : -1;
    var anchorX = centerX + diffY * curvature * orientation;
    var anchorY = centerY - diffX * curvature * orientation;

    // Adapt curve points to edge thickness:
    var offset = edgeData.size * 0.7 + 5;
    var sourceOffsetVector = {
      x: anchorY - sourceY,
      y: -(anchorX - sourceX)
    };
    var sourceOffsetVectorLength = Math.sqrt(Math.pow(sourceOffsetVector.x, 2) + Math.pow(sourceOffsetVector.y, 2));
    var targetOffsetVector = {
      x: targetY - anchorY,
      y: -(targetX - anchorX)
    };
    var targetOffsetVectorLength = Math.sqrt(Math.pow(targetOffsetVector.x, 2) + Math.pow(targetOffsetVector.y, 2));
    sourceX += offset * sourceOffsetVector.x / sourceOffsetVectorLength;
    sourceY += offset * sourceOffsetVector.y / sourceOffsetVectorLength;
    targetX += offset * targetOffsetVector.x / targetOffsetVectorLength;
    targetY += offset * targetOffsetVector.y / targetOffsetVectorLength;
    // For anchor, the vector is simpler, so it is inlined:
    anchorX += offset * diffY / diff;
    anchorY -= offset * diffX / diff;

    // Compute curve length:
    var anchorPoint = {
      x: anchorX,
      y: anchorY
    };
    var sourcePoint = {
      x: sourceX,
      y: sourceY
    };
    var targetPoint = {
      x: targetX,
      y: targetY
    };
    var curveLength = getCurveLength(sourcePoint, anchorPoint, targetPoint);
    if (curveLength < sourceData.size + targetData.size) return;

    // Handling ellipsis
    var textLength = context.measureText(label).width;
    var availableTextLength = curveLength - sourceData.size - targetData.size;
    if (textLength > availableTextLength) {
      var ellipsis = "…";
      label = label + ellipsis;
      textLength = context.measureText(label).width;
      while (textLength > availableTextLength && label.length > 1) {
        label = label.slice(0, -2) + ellipsis;
        textLength = context.measureText(label).width;
      }
      if (label.length < 4) return;
    }

    // Measure each character:
    var charactersLengthCache = {};
    for (var i = 0, length = label.length; i < length; i++) {
      var character = label[i];
      if (!charactersLengthCache[character]) {
        charactersLengthCache[character] = context.measureText(character).width * (1 + curvature * 0.35);
      }
    }

    // Draw each character:
    var t = 0.5 - textLength / curveLength / 2;
    for (var _i = 0, _length = label.length; _i < _length; _i++) {
      var _character = label[_i];
      var point = getCurvePoint(t, sourcePoint, anchorPoint, targetPoint);
      var tangentX = 2 * (1 - t) * (anchorX - sourceX) + 2 * t * (targetX - anchorX);
      var tangentY = 2 * (1 - t) * (anchorY - sourceY) + 2 * t * (targetY - anchorY);
      var angle = Math.atan2(tangentY, tangentX);
      context.save();
      context.translate(point.x, point.y);
      context.rotate(angle);

      // Dessiner le caractère
      context.fillText(_character, 0, 0);
      context.restore();
      t += charactersLengthCache[_character] / curveLength;
    }
  };
}

function getFragmentShader(_ref) {
  var arrowHead = _ref.arrowHead;
  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "target" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";
  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "source" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";

  // language=GLSL
  var SHADER = /*glsl*/"\nprecision highp float;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying float v_feather;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n".concat(hasTargetArrowHead ? "\nvarying float v_targetSize;\nvarying vec2 v_targetPoint;" : "", "\n").concat(hasSourceArrowHead ? "\nvarying float v_sourceSize;\nvarying vec2 v_sourcePoint;" : "", "\n").concat(arrowHead ? "\nuniform float u_lengthToThicknessRatio;\nuniform float u_widenessToThicknessRatio;" : "", "\n\nfloat det(vec2 a, vec2 b) {\n  return a.x * b.y - b.x * a.y;\n}\n\nvec2 getDistanceVector(vec2 b0, vec2 b1, vec2 b2) {\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\n  float f = b * d - a * a;\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\n  gf = vec2(gf.y, -gf.x);\n  vec2 pp = -f * gf / dot(gf, gf);\n  vec2 d0p = b0 - pp;\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\n}\n\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\n  return length(getDistanceVector(b0 - p, b1 - p, b2 - p));\n}\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\n  float thickness = v_thickness;\n").concat(hasTargetArrowHead ? "\n  float distToTarget = length(gl_FragCoord.xy - v_targetPoint);\n  float targetArrowLength = v_targetSize + thickness * u_lengthToThicknessRatio;\n  if (distToTarget < targetArrowLength) {\n    thickness = (distToTarget - v_targetSize) / (targetArrowLength - v_targetSize) * u_widenessToThicknessRatio * thickness;\n  }" : "", "\n").concat(hasSourceArrowHead ? "\n  float distToSource = length(gl_FragCoord.xy - v_sourcePoint);\n  float sourceArrowLength = v_sourceSize + thickness * u_lengthToThicknessRatio;\n  if (distToSource < sourceArrowLength) {\n    thickness = (distToSource - v_sourceSize) / (sourceArrowLength - v_sourceSize) * u_widenessToThicknessRatio * thickness;\n  }" : "", "\n\n  float halfThickness = thickness / 2.0;\n  if (dist < halfThickness) {\n    #ifdef PICKING_MODE\n    gl_FragColor = v_color;\n    #else\n    float t = smoothstep(\n      halfThickness - v_feather,\n      halfThickness,\n      dist\n    );\n\n    gl_FragColor = mix(v_color, transparent, t);\n    #endif\n  } else {\n    gl_FragColor = transparent;\n  }\n}\n");
  return SHADER;
}

function getVertexShader(_ref) {
  var arrowHead = _ref.arrowHead;
  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "target" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";
  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "source" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";

  // language=GLSL
  var SHADER = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute float a_direction;\nattribute float a_thickness;\nattribute vec2 a_source;\nattribute vec2 a_target;\nattribute float a_current;\nattribute float a_curvature;\n".concat(hasTargetArrowHead ? "attribute float a_targetSize;\n" : "", "\n").concat(hasSourceArrowHead ? "attribute float a_sourceSize;\n" : "", "\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform vec2 u_dimensions;\nuniform float u_minEdgeThickness;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying float v_thickness;\nvarying float v_feather;\nvarying vec2 v_cpA;\nvarying vec2 v_cpB;\nvarying vec2 v_cpC;\n").concat(hasTargetArrowHead ? "\nvarying float v_targetSize;\nvarying vec2 v_targetPoint;" : "", "\n").concat(hasSourceArrowHead ? "\nvarying float v_sourceSize;\nvarying vec2 v_sourcePoint;" : "", "\n").concat(arrowHead ? "\nuniform float u_widenessToThicknessRatio;" : "", "\n\nconst float bias = 255.0 / 254.0;\nconst float epsilon = 0.7;\n\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\n  return vec2(\n    (pos.x + 1.0) * dimensions.x / 2.0,\n    (pos.y + 1.0) * dimensions.y / 2.0\n  );\n}\n\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\n  return vec2(\n    pos.x / dimensions.x * 2.0 - 1.0,\n    pos.y / dimensions.y * 2.0 - 1.0\n  );\n}\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  // Selecting the correct position\n  // Branchless \"position = a_source if a_current == 1.0 else a_target\"\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\n  position = (u_matrix * vec3(position, 1)).xy;\n\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\n\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\n\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\n  float len = length(delta);\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\n  vec2 unitNormal = normal / len;\n  float boundingBoxThickness = len * a_curvature;\n\n  float curveThickness = max(minThickness, a_thickness / u_sizeRatio);\n  v_thickness = curveThickness * u_pixelRatio;\n  v_feather = u_feather;\n\n  v_cpA = viewportSource;\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\n  v_cpC = viewportTarget;\n\n  vec2 viewportOffsetPosition = (\n    viewportPosition +\n    unitNormal * (boundingBoxThickness / 2.0 + sign(boundingBoxThickness) * (").concat(arrowHead ? "curveThickness * u_widenessToThicknessRatio" : "curveThickness", " + epsilon)) *\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\n  );\n\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\n  gl_Position = vec4(position, 0, 1);\n    \n").concat(hasTargetArrowHead ? "\n  v_targetSize = a_targetSize * u_pixelRatio / u_sizeRatio;\n  v_targetPoint = viewportTarget;\n" : "", "\n").concat(hasSourceArrowHead ? "\n  v_sourceSize = a_sourceSize * u_pixelRatio / u_sizeRatio;\n  v_sourcePoint = viewportSource;\n" : "", "\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n");
  return SHADER;
}

var DEFAULT_EDGE_CURVATURE = 0.25;
var DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS = {
  arrowHead: null,
  curvatureAttribute: "curvature",
  defaultCurvature: DEFAULT_EDGE_CURVATURE
};

/**
 * This function helps to identify parallel edges, to adjust their curvatures.
 */
var DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS = {
  edgeIndexAttribute: "parallelIndex",
  edgeMinIndexAttribute: "parallelMinIndex",
  edgeMaxIndexAttribute: "parallelMaxIndex"
};
function indexParallelEdgesIndex(graph, options) {
  var opts = _objectSpread2(_objectSpread2({}, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS), options || {});
  var nodeIDsMapping = {};
  var edgeDirectedIDsMapping = {};
  var edgeUndirectedIDsMapping = {};

  // Normalize IDs:
  var incr = 0;
  graph.forEachNode(function (node) {
    nodeIDsMapping[node] = ++incr + "";
  });
  graph.forEachEdge(function (edge, _attrs, source, target) {
    var sourceId = nodeIDsMapping[source];
    var targetId = nodeIDsMapping[target];
    var directedId = [sourceId, targetId].join("-");
    edgeDirectedIDsMapping[edge] = directedId;
    edgeUndirectedIDsMapping[directedId] = [sourceId, targetId].sort().join("-");
  });

  // Index edge unique IDs, only based on their extremities:
  var directedIndex = {};
  var undirectedIndex = {};
  graph.forEachEdge(function (edge) {
    var directedId = edgeDirectedIDsMapping[edge];
    var undirectedId = edgeUndirectedIDsMapping[directedId];
    directedIndex[directedId] = directedIndex[directedId] || [];
    directedIndex[directedId].push(edge);
    undirectedIndex[undirectedId] = undirectedIndex[undirectedId] || [];
    undirectedIndex[undirectedId].push(edge);
  });

  // Store index attributes:
  for (var directedId in directedIndex) {
    var edges = directedIndex[directedId];
    var directedCount = edges.length;
    var undirectedCount = undirectedIndex[edgeUndirectedIDsMapping[directedId]].length;

    // If the edge is alone, in both side:
    if (directedCount === 1 && undirectedCount === 1) {
      var edge = edges[0];
      graph.setEdgeAttribute(edge, opts.edgeIndexAttribute, null);
      graph.setEdgeAttribute(edge, opts.edgeMaxIndexAttribute, null);
    }

    // If the edge is alone, but there is at least one edge in the opposite direction:
    else if (directedCount === 1) {
      var _edge = edges[0];
      graph.setEdgeAttribute(_edge, opts.edgeIndexAttribute, 1);
      graph.setEdgeAttribute(_edge, opts.edgeMaxIndexAttribute, 1);
    }

    // If the edge is not alone, and all edges are in the same direction:
    else if (directedCount === undirectedCount) {
      var max = (directedCount - 1) / 2;
      var min = -max;
      for (var i = 0; i < directedCount; i++) {
        var _edge2 = edges[i];
        var edgeIndex = -(directedCount - 1) / 2 + i;
        graph.setEdgeAttribute(_edge2, opts.edgeIndexAttribute, edgeIndex);
        graph.setEdgeAttribute(_edge2, opts.edgeMinIndexAttribute, min);
        graph.setEdgeAttribute(_edge2, opts.edgeMaxIndexAttribute, max);
      }
    }

    // If the edge is not alone, and there are edges in both directions:
    else {
      for (var _i = 0; _i < directedCount; _i++) {
        var _edge3 = edges[_i];
        graph.setEdgeAttribute(_edge3, opts.edgeIndexAttribute, _i + 1);
        graph.setEdgeAttribute(_edge3, opts.edgeMaxIndexAttribute, directedCount);
      }
    }
  }
}

var _WebGLRenderingContex = WebGLRenderingContext,
  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,
  FLOAT = _WebGLRenderingContex.FLOAT;
function createEdgeCurveProgram(inputOptions) {
  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS), inputOptions || {});
  var _ref = options,
    arrowHead = _ref.arrowHead,
    curvatureAttribute = _ref.curvatureAttribute,
    drawLabel = _ref.drawLabel;
  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "target" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";
  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "source" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === "both";
  var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_dimensions", "u_pixelRatio", "u_feather", "u_minEdgeThickness"].concat(_toConsumableArray(arrowHead ? ["u_lengthToThicknessRatio", "u_widenessToThicknessRatio"] : []));
  return /*#__PURE__*/function (_EdgeProgram) {
    _inherits(EdgeCurveProgram, _EdgeProgram);
    function EdgeCurveProgram() {
      var _this;
      _classCallCheck(this, EdgeCurveProgram);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _callSuper(this, EdgeCurveProgram, [].concat(args));
      _defineProperty(_assertThisInitialized(_this), "drawLabel", drawLabel || createDrawCurvedEdgeLabel(options));
      return _this;
    }
    _createClass(EdgeCurveProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 6,
          VERTEX_SHADER_SOURCE: getVertexShader(options),
          FRAGMENT_SHADER_SOURCE: getFragmentShader(options),
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS,
          ATTRIBUTES: [{
            name: "a_source",
            size: 2,
            type: FLOAT
          }, {
            name: "a_target",
            size: 2,
            type: FLOAT
          }].concat(_toConsumableArray(hasTargetArrowHead ? [{
            name: "a_targetSize",
            size: 1,
            type: FLOAT
          }] : []), _toConsumableArray(hasSourceArrowHead ? [{
            name: "a_sourceSize",
            size: 1,
            type: FLOAT
          }] : []), [{
            name: "a_thickness",
            size: 1,
            type: FLOAT
          }, {
            name: "a_curvature",
            size: 1,
            type: FLOAT
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE,
            normalized: true
          }]),
          CONSTANT_ATTRIBUTES: [{
            name: "a_current",
            size: 1,
            type: FLOAT
          },
          // TODO: could optimize to bool
          {
            name: "a_direction",
            size: 1,
            type: FLOAT
          } // TODO: could optimize to byte
          ],
          CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [0, -1], [1, 1], [1, -1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        var _data;
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,sigma_utils__WEBPACK_IMPORTED_MODULE_1__.floatColor)(data.color);
        var curvature = (_data = data[curvatureAttribute]) !== null && _data !== void 0 ? _data : DEFAULT_EDGE_CURVATURE;
        var array = this.array;

        // First point
        array[startIndex++] = x1;
        array[startIndex++] = y1;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        if (hasTargetArrowHead) array[startIndex++] = targetData.size;
        if (hasSourceArrowHead) array[startIndex++] = sourceData.size;
        array[startIndex++] = thickness;
        array[startIndex++] = curvature;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref2) {
        var gl = _ref2.gl,
          uniformLocations = _ref2.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_pixelRatio = uniformLocations.u_pixelRatio,
          u_feather = uniformLocations.u_feather,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_dimensions = uniformLocations.u_dimensions,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_feather, params.antiAliasingFeather);
        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        if (arrowHead) {
          var u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,
            u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;
          gl.uniform1f(u_lengthToThicknessRatio, arrowHead.lengthToThicknessRatio);
          gl.uniform1f(u_widenessToThicknessRatio, arrowHead.widenessToThicknessRatio);
        }
      }
    }]);
    return EdgeCurveProgram;
  }(sigma_rendering__WEBPACK_IMPORTED_MODULE_0__.EdgeProgram);
}

var EdgeCurveProgram = createEdgeCurveProgram();
var EdgeCurvedArrowProgram = createEdgeCurveProgram({
  arrowHead: sigma_rendering__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS
});
var EdgeCurvedDoubleArrowProgram = createEdgeCurveProgram({
  arrowHead: _objectSpread2(_objectSpread2({}, sigma_rendering__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), {}, {
    extremity: "both"
  })
});




/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}


/***/ }),

/***/ "./node_modules/graphology-layout-force/defaults.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphology-layout-force/defaults.js ***!
  \**********************************************************/
/***/ ((module) => {

/**
 * Graphology Force Layout Defaults
 * =================================
 *
 * Default options & settings used by the library.
 */
module.exports = {
  nodeXAttribute: 'x',
  nodeYAttribute: 'y',
  isNodeFixed: 'fixed',
  shouldSkipNode: null,
  shouldSkipEdge: null,
  settings: {
    attraction: 0.0005,
    repulsion: 0.1,
    gravity: 0.0001,
    inertia: 0.6,
    maxMove: 200
  }
};


/***/ }),

/***/ "./node_modules/graphology-layout-force/helpers.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphology-layout-force/helpers.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Force Layout Helpers
 * ================================
 *
 * Miscellaneous helper functions related to the force layout.
 */
exports.assignLayoutChanges = function (graph, nodeStates, params) {
  const {nodeXAttribute: x, nodeYAttribute: y} = params;

  graph.updateEachNodeAttributes(
    (n, attr) => {
      const state = nodeStates[n];

      if (!state || state.fixed) return attr;

      attr[x] = state.x;
      attr[y] = state.y;

      return attr;
    },
    {attributes: ['x', 'y']}
  );
};

exports.collectLayoutChanges = function (nodeStates) {
  const mapping = {};

  for (const n in nodeStates) {
    const state = nodeStates[n];

    mapping[n] = {x: state.x, y: state.y};
  }

  return mapping;
};


/***/ }),

/***/ "./node_modules/graphology-layout-force/iterate.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphology-layout-force/iterate.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Force Layout Iteration
 * ==================================
 *
 * Function describing a single iteration of the force layout.
 */
const {
  createNodeValueGetter,
  createEdgeValueGetter
} = __webpack_require__(/*! graphology-utils/getters */ "./node_modules/graphology-utils/getters.js");

// const EPSILON = -Infinity;

// function isVeryCloseToZero(x) {
//   return Math.abs(x) < EPSILON;
// }

module.exports = function iterate(graph, nodeStates, params) {
  const {nodeXAttribute: xKey, nodeYAttribute: yKey} = params;
  const {attraction, repulsion, gravity, inertia, maxMove} = params.settings;

  let {shouldSkipNode, shouldSkipEdge, isNodeFixed} = params;

  isNodeFixed = createNodeValueGetter(isNodeFixed);
  shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);
  shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);

  const nodes = graph.filterNodes((n, attr) => {
    return !shouldSkipNode.fromEntry(n, attr);
  });

  const adjustedOrder = nodes.length;

  // Check nodeStatess and inertia
  for (let i = 0; i < adjustedOrder; i++) {
    const n = nodes[i];
    const attr = graph.getNodeAttributes(n);
    const nodeState = nodeStates[n];

    if (!nodeState)
      nodeStates[n] = {
        dx: 0,
        dy: 0,
        x: attr[xKey] || 0,
        y: attr[yKey] || 0
      };
    else
      nodeStates[n] = {
        dx: nodeState.dx * inertia,
        dy: nodeState.dy * inertia,
        x: attr[xKey] || 0,
        y: attr[yKey] || 0
      };
  }

  // Repulsion
  if (repulsion)
    for (let i = 0; i < adjustedOrder; i++) {
      const n1 = nodes[i];
      const n1State = nodeStates[n1];

      for (let j = i + 1; j < adjustedOrder; j++) {
        const n2 = nodes[j];
        const n2State = nodeStates[n2];

        // Compute distance:
        const dx = n2State.x - n1State.x;
        const dy = n2State.y - n1State.y;
        const distance = Math.sqrt(dx * dx + dy * dy) || 1;

        // Repulse nodes relatively to 1 / distance:
        const repulsionX = (repulsion / distance) * dx;
        const repulsionY = (repulsion / distance) * dy;
        n1State.dx -= repulsionX;
        n1State.dy -= repulsionY;
        n2State.dx += repulsionX;
        n2State.dy += repulsionY;
      }
    }

  // Attraction
  if (attraction)
    graph.forEachEdge(
      (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {
        if (source === target) return;

        if (
          shouldSkipNode.fromEntry(source, sourceAttr) ||
          shouldSkipNode.fromEntry(target, targetAttr)
        )
          return;

        if (
          shouldSkipEdge.fromEntry(
            edge,
            attr,
            source,
            target,
            sourceAttr,
            targetAttr,
            undirected
          )
        )
          return;

        const n1State = nodeStates[source];
        const n2State = nodeStates[target];

        // Compute distance:
        const dx = n2State.x - n1State.x;
        const dy = n2State.y - n1State.y;

        const distance = Math.sqrt(dx * dx + dy * dy) || 1;

        // Attract nodes relatively to their distance:
        const attractionX = attraction * distance * dx;
        const attractionY = attraction * distance * dy;
        n1State.dx += attractionX;
        n1State.dy += attractionY;
        n2State.dx -= attractionX;
        n2State.dy -= attractionY;
      }
    );

  // Gravity
  if (gravity)
    for (let i = 0; i < adjustedOrder; i++) {
      const n = nodes[i];
      const nodeState = nodeStates[n];

      // Attract nodes to [0, 0] relatively to the distance:
      const {x, y} = nodeState;
      const distance = Math.sqrt(x * x + y * y) || 1;
      nodeStates[n].dx -= x * gravity * distance;
      nodeStates[n].dy -= y * gravity * distance;
    }

  // Apply forces
  const converged = false;

  for (let i = 0; i < adjustedOrder; i++) {
    const n = nodes[i];
    const nodeState = nodeStates[n];

    const distance = Math.sqrt(
      nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy
    );

    if (distance > maxMove) {
      nodeState.dx *= maxMove / distance;
      nodeState.dy *= maxMove / distance;
    }

    // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {
    //   converged = false;
    // }

    if (!isNodeFixed.fromGraph(graph, n)) {
      nodeState.x += nodeState.dx;
      nodeState.y += nodeState.dy;
      nodeState.fixed = false;
    } else {
      nodeState.fixed = true;
    }

    // NOTE: possibility to assign here to save one loop in the future
  }

  return {converged};
};


/***/ }),

/***/ "./node_modules/graphology-layout-force/worker.js":
/*!********************************************************!*\
  !*** ./node_modules/graphology-layout-force/worker.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Graphology Force Layout Worker
 * ===============================
 *
 * A worker made for running a force layout live.
 *
 * Note that it does not run in a webworker yet but respect animation frames.
 */
const isGraph = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
const resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ "./node_modules/graphology-utils/defaults.js");

const iterate = __webpack_require__(/*! ./iterate.js */ "./node_modules/graphology-layout-force/iterate.js");
const helpers = __webpack_require__(/*! ./helpers.js */ "./node_modules/graphology-layout-force/helpers.js");
const DEFAULTS = __webpack_require__(/*! ./defaults.js */ "./node_modules/graphology-layout-force/defaults.js");

function ForceSupervisor(graph, params) {
  // Validation
  if (!isGraph(graph))
    throw new Error(
      'graphology-layout-force/worker: the given graph is not a valid graphology instance.'
    );

  params = resolveDefaults(params, DEFAULTS);

  this.callbacks = {};

  if (params.onConverged) this.callbacks.onConverged = params.onConverged;

  this.graph = graph;
  this.params = params;
  this.nodeStates = {};
  this.frameID = null;
  this.running = false;
  this.killed = false;

  // TODO: hook listeners on graph to listen to dropNode, dropEdge, clear, clearEdges
}

ForceSupervisor.prototype.isRunning = function () {
  return this.running;
};

ForceSupervisor.prototype.runFrame = function () {
  let {converged} = iterate(this.graph, this.nodeStates, this.params);

  helpers.assignLayoutChanges(this.graph, this.nodeStates, this.params);

  // TODO: figure out convergence
  converged = false;

  if (converged) {
    if (this.callbacks.onConverged) this.callbacks.onConverged();
    this.stop();
  } else {
    this.frameID = window.requestAnimationFrame(() => this.runFrame());
  }
};

ForceSupervisor.prototype.stop = function () {
  this.running = false;

  if (this.frameID !== null) {
    window.cancelAnimationFrame(this.frameID);
    this.frameID = null;
  }

  return this;
};

ForceSupervisor.prototype.start = function () {
  if (this.killed)
    throw new Error('graphology-layout-force/worker.start: layout was killed.');

  if (this.running) return;

  this.running = true;
  this.runFrame();
};

ForceSupervisor.prototype.kill = function () {
  this.stop();
  delete this.nodeStates;
  this.killed = true;

  // TODO: cleanup events
};

module.exports = ForceSupervisor;


/***/ }),

/***/ "./node_modules/graphology-utils/defaults.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/defaults.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Graphology Defaults
 * ====================
 *
 * Helper function used throughout the standard lib to resolve defaults.
 */
function isLeaf(o) {
  return (
    !o ||
    typeof o !== 'object' ||
    typeof o === 'function' ||
    Array.isArray(o) ||
    o instanceof Set ||
    o instanceof Map ||
    o instanceof RegExp ||
    o instanceof Date
  );
}

function resolveDefaults(target, defaults) {
  target = target || {};

  var output = {};

  for (var k in defaults) {
    var existing = target[k];
    var def = defaults[k];

    // Recursion
    if (!isLeaf(def)) {
      output[k] = resolveDefaults(existing, def);

      continue;
    }

    // Leaf
    if (existing === undefined) {
      output[k] = def;
    } else {
      output[k] = existing;
    }
  }

  return output;
}

module.exports = resolveDefaults;


/***/ }),

/***/ "./node_modules/graphology-utils/getters.js":
/*!**************************************************!*\
  !*** ./node_modules/graphology-utils/getters.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

/**
 * Graphology Weight Getter
 * =========================
 *
 * Function creating weight getters.
 */
function coerceWeight(value) {
  // Ensuring target value is a correct number
  if (typeof value !== 'number' || isNaN(value)) return 1;

  return value;
}

function createNodeValueGetter(nameOrFunction, defaultValue) {
  var getter = {};

  var coerceToDefault = function (v) {
    if (typeof v === 'undefined') return defaultValue;

    return v;
  };

  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;

  var get = function (attributes) {
    return coerceToDefault(attributes[nameOrFunction]);
  };

  var returnDefault = function () {
    return coerceToDefault(undefined);
  };

  if (typeof nameOrFunction === 'string') {
    getter.fromAttributes = get;
    getter.fromGraph = function (graph, node) {
      return get(graph.getNodeAttributes(node));
    };
    getter.fromEntry = function (node, attributes) {
      return get(attributes);
    };
  } else if (typeof nameOrFunction === 'function') {
    getter.fromAttributes = function () {
      throw new Error(
        'graphology-utils/getters/createNodeValueGetter: irrelevant usage.'
      );
    };
    getter.fromGraph = function (graph, node) {
      return coerceToDefault(
        nameOrFunction(node, graph.getNodeAttributes(node))
      );
    };
    getter.fromEntry = function (node, attributes) {
      return coerceToDefault(nameOrFunction(node, attributes));
    };
  } else {
    getter.fromAttributes = returnDefault;
    getter.fromGraph = returnDefault;
    getter.fromEntry = returnDefault;
  }

  return getter;
}

function createEdgeValueGetter(nameOrFunction, defaultValue) {
  var getter = {};

  var coerceToDefault = function (v) {
    if (typeof v === 'undefined') return defaultValue;

    return v;
  };

  if (typeof defaultValue === 'function') coerceToDefault = defaultValue;

  var get = function (attributes) {
    return coerceToDefault(attributes[nameOrFunction]);
  };

  var returnDefault = function () {
    return coerceToDefault(undefined);
  };

  if (typeof nameOrFunction === 'string') {
    getter.fromAttributes = get;
    getter.fromGraph = function (graph, edge) {
      return get(graph.getEdgeAttributes(edge));
    };
    getter.fromEntry = function (edge, attributes) {
      return get(attributes);
    };
    getter.fromPartialEntry = getter.fromEntry;
    getter.fromMinimalEntry = getter.fromEntry;
  } else if (typeof nameOrFunction === 'function') {
    getter.fromAttributes = function () {
      throw new Error(
        'graphology-utils/getters/createEdgeValueGetter: irrelevant usage.'
      );
    };
    getter.fromGraph = function (graph, edge) {
      // TODO: we can do better, check #310
      var extremities = graph.extremities(edge);
      return coerceToDefault(
        nameOrFunction(
          edge,
          graph.getEdgeAttributes(edge),
          extremities[0],
          extremities[1],
          graph.getNodeAttributes(extremities[0]),
          graph.getNodeAttributes(extremities[1]),
          graph.isUndirected(edge)
        )
      );
    };
    getter.fromEntry = function (e, a, s, t, sa, ta, u) {
      return coerceToDefault(nameOrFunction(e, a, s, t, sa, ta, u));
    };
    getter.fromPartialEntry = function (e, a, s, t) {
      return coerceToDefault(nameOrFunction(e, a, s, t));
    };
    getter.fromMinimalEntry = function (e, a) {
      return coerceToDefault(nameOrFunction(e, a));
    };
  } else {
    getter.fromAttributes = returnDefault;
    getter.fromGraph = returnDefault;
    getter.fromEntry = returnDefault;
    getter.fromMinimalEntry = returnDefault;
  }

  return getter;
}

exports.createNodeValueGetter = createNodeValueGetter;
exports.createEdgeValueGetter = createEdgeValueGetter;
exports.createEdgeWeightGetter = function (name) {
  return createEdgeValueGetter(name, coerceWeight);
};


/***/ }),

/***/ "./node_modules/graphology-utils/is-graph.js":
/*!***************************************************!*\
  !*** ./node_modules/graphology-utils/is-graph.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * Graphology isGraph
 * ===================
 *
 * Very simple function aiming at ensuring the given variable is a
 * graphology instance.
 */

/**
 * Checking the value is a graphology instance.
 *
 * @param  {any}     value - Target value.
 * @return {boolean}
 */
module.exports = function isGraph(value) {
  return (
    value !== null &&
    typeof value === 'object' &&
    typeof value.addUndirectedEdgeWithKey === 'function' &&
    typeof value.dropNode === 'function' &&
    typeof value.multi === 'boolean'
  );
};


/***/ }),

/***/ "./node_modules/graphology/dist/graphology.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DirectedGraph: () => (/* binding */ DirectedGraph),
/* harmony export */   Graph: () => (/* binding */ Graph),
/* harmony export */   InvalidArgumentsGraphError: () => (/* binding */ InvalidArgumentsGraphError),
/* harmony export */   MultiDirectedGraph: () => (/* binding */ MultiDirectedGraph),
/* harmony export */   MultiGraph: () => (/* binding */ MultiGraph),
/* harmony export */   MultiUndirectedGraph: () => (/* binding */ MultiUndirectedGraph),
/* harmony export */   NotFoundGraphError: () => (/* binding */ NotFoundGraphError),
/* harmony export */   UndirectedGraph: () => (/* binding */ UndirectedGraph),
/* harmony export */   UsageGraphError: () => (/* binding */ UsageGraphError),
/* harmony export */   "default": () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");


/**
 * Graphology Utilities
 * =====================
 *
 * Collection of helpful functions used by the implementation.
 */

/**
 * Object.assign-like polyfill.
 *
 * @param  {object} target       - First object.
 * @param  {object} [...objects] - Objects to merge.
 * @return {object}
 */
function assignPolyfill() {
  const target = arguments[0];

  for (let i = 1, l = arguments.length; i < l; i++) {
    if (!arguments[i]) continue;

    for (const k in arguments[i]) target[k] = arguments[i][k];
  }

  return target;
}

let assign = assignPolyfill;

if (typeof Object.assign === 'function') assign = Object.assign;

/**
 * Function returning the first matching edge for given path.
 * Note: this function does not check the existence of source & target. This
 * must be performed by the caller.
 *
 * @param  {Graph}  graph  - Target graph.
 * @param  {any}    source - Source node.
 * @param  {any}    target - Target node.
 * @param  {string} type   - Type of the edge (mixed, directed or undirected).
 * @return {string|null}
 */
function getMatchingEdge(graph, source, target, type) {
  const sourceData = graph._nodes.get(source);

  let edge = null;

  if (!sourceData) return edge;

  if (type === 'mixed') {
    edge =
      (sourceData.out && sourceData.out[target]) ||
      (sourceData.undirected && sourceData.undirected[target]);
  } else if (type === 'directed') {
    edge = sourceData.out && sourceData.out[target];
  } else {
    edge = sourceData.undirected && sourceData.undirected[target];
  }

  return edge;
}

/**
 * Checks whether the given value is a plain object.
 *
 * @param  {mixed}   value - Target value.
 * @return {boolean}
 */
function isPlainObject(value) {
  // NOTE: as per https://github.com/graphology/graphology/issues/149
  // this function has been loosened not to reject object instances
  // coming from other JavaScript contexts. It has also been chosen
  // not to improve it to avoid obvious false positives and avoid
  // taking a performance hit. People should really use TypeScript
  // if they want to avoid feeding subtly irrelvant attribute objects.
  return typeof value === 'object' && value !== null;
}

/**
 * Checks whether the given object is empty.
 *
 * @param  {object}  o - Target Object.
 * @return {boolean}
 */
function isEmpty(o) {
  let k;

  for (k in o) return false;

  return true;
}

/**
 * Creates a "private" property for the given member name by concealing it
 * using the `enumerable` option.
 *
 * @param {object} target - Target object.
 * @param {string} name   - Member name.
 */
function privateProperty(target, name, value) {
  Object.defineProperty(target, name, {
    enumerable: false,
    configurable: false,
    writable: true,
    value
  });
}

/**
 * Creates a read-only property for the given member name & the given getter.
 *
 * @param {object}   target - Target object.
 * @param {string}   name   - Member name.
 * @param {mixed}    value  - The attached getter or fixed value.
 */
function readOnlyProperty(target, name, value) {
  const descriptor = {
    enumerable: true,
    configurable: true
  };

  if (typeof value === 'function') {
    descriptor.get = value;
  } else {
    descriptor.value = value;
    descriptor.writable = false;
  }

  Object.defineProperty(target, name, descriptor);
}

/**
 * Returns whether the given object constitute valid hints.
 *
 * @param {object} hints - Target object.
 */
function validateHints(hints) {
  if (!isPlainObject(hints)) return false;

  if (hints.attributes && !Array.isArray(hints.attributes)) return false;

  return true;
}

/**
 * Creates a function generating incremental ids for edges.
 *
 * @return {function}
 */
function incrementalIdStartingFromRandomByte() {
  let i = Math.floor(Math.random() * 256) & 0xff;

  return () => {
    return i++;
  };
}

/**
 * Chains multiple iterators into a single iterator.
 *
 * @param {...Iterator} iterables
 * @returns {Iterator}
 */
function chain() {
  const iterables = arguments;
  let current = null;
  let i = -1;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step = null;

      do {
        if (current === null) {
          i++;
          if (i >= iterables.length) return {done: true};
          current = iterables[i][Symbol.iterator]();
        }
        step = current.next();
        if (step.done) {
          current = null;
          continue;
        }
        break;
        // eslint-disable-next-line no-constant-condition
      } while (true);

      return step;
    }
  };
}

function emptyIterator() {
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      return {done: true};
    }
  };
}

/**
 * Graphology Custom Errors
 * =========================
 *
 * Defining custom errors for ease of use & easy unit tests across
 * implementations (normalized typology rather than relying on error
 * messages to check whether the correct error was found).
 */
class GraphError extends Error {
  constructor(message) {
    super();
    this.name = 'GraphError';
    this.message = message;
  }
}

class InvalidArgumentsGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'InvalidArgumentsGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(
        this,
        InvalidArgumentsGraphError.prototype.constructor
      );
  }
}

class NotFoundGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'NotFoundGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);
  }
}

class UsageGraphError extends GraphError {
  constructor(message) {
    super(message);
    this.name = 'UsageGraphError';

    // This is V8 specific to enhance stack readability
    if (typeof Error.captureStackTrace === 'function')
      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);
  }
}

/**
 * Graphology Internal Data Classes
 * =================================
 *
 * Internal classes hopefully reduced to structs by engines & storing
 * necessary information for nodes & edges.
 *
 * Note that those classes don't rely on the `class` keyword to avoid some
 * cruft introduced by most of ES2015 transpilers.
 */

/**
 * MixedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function MixedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

MixedNodeData.prototype.clear = function () {
  // Degrees
  this.inDegree = 0;
  this.outDegree = 0;
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;
  this.directedLoops = 0;

  // Indices
  this.in = {};
  this.out = {};
  this.undirected = {};
};

/**
 * DirectedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function DirectedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

DirectedNodeData.prototype.clear = function () {
  // Degrees
  this.inDegree = 0;
  this.outDegree = 0;
  this.directedLoops = 0;

  // Indices
  this.in = {};
  this.out = {};
};

/**
 * UndirectedNodeData class.
 *
 * @constructor
 * @param {string} string     - The node's key.
 * @param {object} attributes - Node's attributes.
 */
function UndirectedNodeData(key, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;

  this.clear();
}

UndirectedNodeData.prototype.clear = function () {
  // Degrees
  this.undirectedDegree = 0;
  this.undirectedLoops = 0;

  // Indices
  this.undirected = {};
};

/**
 * EdgeData class.
 *
 * @constructor
 * @param {boolean} undirected   - Whether the edge is undirected.
 * @param {string}  string       - The edge's key.
 * @param {string}  source       - Source of the edge.
 * @param {string}  target       - Target of the edge.
 * @param {object}  attributes   - Edge's attributes.
 */
function EdgeData(undirected, key, source, target, attributes) {
  // Attributes
  this.key = key;
  this.attributes = attributes;
  this.undirected = undirected;

  // Extremities
  this.source = source;
  this.target = target;
}

EdgeData.prototype.attach = function () {
  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  const source = this.source.key;
  const target = this.target.key;

  // Handling source
  this.source[outKey][target] = this;

  if (this.undirected && source === target) return;

  // Handling target
  this.target[inKey][source] = this;
};

EdgeData.prototype.attachMulti = function () {
  let outKey = 'out';
  let inKey = 'in';

  const source = this.source.key;
  const target = this.target.key;

  if (this.undirected) outKey = inKey = 'undirected';

  // Handling source
  const adj = this.source[outKey];
  const head = adj[target];

  if (typeof head === 'undefined') {
    adj[target] = this;

    // Self-loop optimization
    if (!(this.undirected && source === target)) {
      // Handling target
      this.target[inKey][source] = this;
    }

    return;
  }

  // Prepending to doubly-linked list
  head.previous = this;
  this.next = head;

  // Pointing to new head
  // NOTE: use mutating swap later to avoid lookup?
  adj[target] = this;
  this.target[inKey][source] = this;
};

EdgeData.prototype.detach = function () {
  const source = this.source.key;
  const target = this.target.key;

  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  delete this.source[outKey][target];

  // No-op delete in case of undirected self-loop
  delete this.target[inKey][source];
};

EdgeData.prototype.detachMulti = function () {
  const source = this.source.key;
  const target = this.target.key;

  let outKey = 'out';
  let inKey = 'in';

  if (this.undirected) outKey = inKey = 'undirected';

  // Deleting from doubly-linked list
  if (this.previous === undefined) {
    // We are dealing with the head

    // Should we delete the adjacency entry because it is now empty?
    if (this.next === undefined) {
      delete this.source[outKey][target];

      // No-op delete in case of undirected self-loop
      delete this.target[inKey][source];
    } else {
      // Detaching
      this.next.previous = undefined;

      // NOTE: could avoid the lookups by creating a #.become mutating method
      this.source[outKey][target] = this.next;

      // No-op delete in case of undirected self-loop
      this.target[inKey][source] = this.next;
    }
  } else {
    // We are dealing with another list node
    this.previous.next = this.next;

    // If not last
    if (this.next !== undefined) {
      this.next.previous = this.previous;
    }
  }
};

/**
 * Graphology Node Attributes methods
 * ===================================
 */

const NODE = 0;
const SOURCE = 1;
const TARGET = 2;
const OPPOSITE = 3;

function findRelevantNodeData(
  graph,
  method,
  mode,
  nodeOrEdge,
  nameOrEdge,
  add1,
  add2
) {
  let nodeData, edgeData, arg1, arg2;

  nodeOrEdge = '' + nodeOrEdge;

  if (mode === NODE) {
    nodeData = graph._nodes.get(nodeOrEdge);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nodeOrEdge}" node in the graph.`
      );

    arg1 = nameOrEdge;
    arg2 = add1;
  } else if (mode === OPPOSITE) {
    nameOrEdge = '' + nameOrEdge;

    edgeData = graph._edges.get(nameOrEdge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nameOrEdge}" edge in the graph.`
      );

    const source = edgeData.source.key;
    const target = edgeData.target.key;

    if (nodeOrEdge === source) {
      nodeData = edgeData.target;
    } else if (nodeOrEdge === target) {
      nodeData = edgeData.source;
    } else {
      throw new NotFoundGraphError(
        `Graph.${method}: the "${nodeOrEdge}" node is not attached to the "${nameOrEdge}" edge (${source}, ${target}).`
      );
    }

    arg1 = add1;
    arg2 = add2;
  } else {
    edgeData = graph._edges.get(nodeOrEdge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.${method}: could not find the "${nodeOrEdge}" edge in the graph.`
      );

    if (mode === SOURCE) {
      nodeData = edgeData.source;
    } else {
      nodeData = edgeData.target;
    }

    arg1 = nameOrEdge;
    arg2 = add1;
  }

  return [nodeData, arg1, arg2];
}

function attachNodeAttributeGetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    return data.attributes[name];
  };
}

function attachNodeAttributesGetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {
    const [data] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge
    );

    return data.attributes;
  };
}

function attachNodeAttributeChecker(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    return data.attributes.hasOwnProperty(name);
  };
}

function attachNodeAttributeSetter(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, value] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1,
      add2
    );

    data.attributes[name] = value;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributeUpdater(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {
    const [data, name, updater] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1,
      add2
    );

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: updater should be a function.`
      );

    const attributes = data.attributes;
    const value = updater(attributes[name]);

    attributes[name] = value;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributeRemover(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, name] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    delete data.attributes[name];

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'remove',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

function attachNodeAttributesReplacer(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    data.attributes = attributes;

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'replace',
      attributes: data.attributes
    });

    return this;
  };
}

function attachNodeAttributesMerger(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, attributes] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    assign(data.attributes, attributes);

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'merge',
      attributes: data.attributes,
      data: attributes
    });

    return this;
  };
}

function attachNodeAttributesUpdater(Class, method, mode) {
  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {
    const [data, updater] = findRelevantNodeData(
      this,
      method,
      mode,
      nodeOrEdge,
      nameOrEdge,
      add1
    );

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided updater is not a function.`
      );

    data.attributes = updater(data.attributes);

    // Emitting
    this.emit('nodeAttributesUpdated', {
      key: data.key,
      type: 'update',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * List of methods to attach.
 */
const NODE_ATTRIBUTES_METHODS = [
  {
    name: element => `get${element}Attribute`,
    attacher: attachNodeAttributeGetter
  },
  {
    name: element => `get${element}Attributes`,
    attacher: attachNodeAttributesGetter
  },
  {
    name: element => `has${element}Attribute`,
    attacher: attachNodeAttributeChecker
  },
  {
    name: element => `set${element}Attribute`,
    attacher: attachNodeAttributeSetter
  },
  {
    name: element => `update${element}Attribute`,
    attacher: attachNodeAttributeUpdater
  },
  {
    name: element => `remove${element}Attribute`,
    attacher: attachNodeAttributeRemover
  },
  {
    name: element => `replace${element}Attributes`,
    attacher: attachNodeAttributesReplacer
  },
  {
    name: element => `merge${element}Attributes`,
    attacher: attachNodeAttributesMerger
  },
  {
    name: element => `update${element}Attributes`,
    attacher: attachNodeAttributesUpdater
  }
];

/**
 * Attach every attributes-related methods to a Graph class.
 *
 * @param {function} Graph - Target class.
 */
function attachNodeAttributesMethods(Graph) {
  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
    // For nodes
    attacher(Graph, name('Node'), NODE);

    // For sources
    attacher(Graph, name('Source'), SOURCE);

    // For targets
    attacher(Graph, name('Target'), TARGET);

    // For opposites
    attacher(Graph, name('Opposite'), OPPOSITE);
  });
}

/**
 * Graphology Edge Attributes methods
 * ===================================
 */

/**
 * Attach an attribute getter method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeGetter(Class, method, type) {
  /**
   * Get the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {mixed}          - The attribute's value.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes[name];
  };
}

/**
 * Attach an attributes getter method onto the provided class.
 *
 * @param {function} Class       - Target class.
 * @param {string}   method      - Method name.
 * @param {string}   type        - Type of the edge to find.
 */
function attachEdgeAttributesGetter(Class, method, type) {
  /**
   * Retrieves all the target element's attributes.
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   *
   * @return {object}          - The element's attributes.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 1) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + arguments[1];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes;
  };
}

/**
 * Attach an attribute checker method onto the provided class.
 *
 * @param {function} Class       - Target class.
 * @param {string}   method      - Method name.
 * @param {string}   type        - Type of the edge to find.
 */
function attachEdgeAttributeChecker(Class, method, type) {
  /**
   * Checks whether the desired attribute is set for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    return data.attributes.hasOwnProperty(name);
  };
}

/**
 * Attach an attribute setter method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeSetter(Class, method, type) {
  /**
   * Set the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   * @param  {mixed}  value   - New attribute value.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   * @param  {mixed}  value   - New attribute value.
   *
   * @return {Graph}          - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name, value) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];
      value = arguments[3];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    data.attributes[name] = value;

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute updater method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeUpdater(Class, method, type) {
  /**
   * Update the desired attribute for the given element (node or edge) using
   * the provided function.
   *
   * Arity 2:
   * @param  {any}      element - Target element.
   * @param  {string}   name    - Attribute's name.
   * @param  {function} updater - Updater function.
   *
   * Arity 3 (only for edges):
   * @param  {any}      source  - Source element.
   * @param  {any}      target  - Target element.
   * @param  {string}   name    - Attribute's name.
   * @param  {function} updater - Updater function.
   *
   * @return {Graph}            - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name, updater) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 3) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];
      updater = arguments[3];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: updater should be a function.`
      );

    data.attributes[name] = updater(data.attributes[name]);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'set',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute remover method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributeRemover(Class, method, type) {
  /**
   * Remove the desired attribute for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element - Target element.
   * @param  {string} name    - Attribute's name.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source - Source element.
   * @param  {any}     target - Target element.
   * @param  {string}  name   - Attribute's name.
   *
   * @return {Graph}          - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, name) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element;
      const target = '' + name;

      name = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    delete data.attributes[name];

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'remove',
      attributes: data.attributes,
      name
    });

    return this;
  };
}

/**
 * Attach an attribute replacer method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesReplacer(Class, method, type) {
  /**
   * Replace the attributes for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element    - Target element.
   * @param  {object} attributes - New attributes.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source     - Source element.
   * @param  {any}     target     - Target element.
   * @param  {object}  attributes - New attributes.
   *
   * @return {Graph}              - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, attributes) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + attributes;

      attributes = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    data.attributes = attributes;

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'replace',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * Attach an attribute merger method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesMerger(Class, method, type) {
  /**
   * Merge the attributes for the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}    element    - Target element.
   * @param  {object} attributes - Attributes to merge.
   *
   * Arity 3 (only for edges):
   * @param  {any}     source     - Source element.
   * @param  {any}     target     - Target element.
   * @param  {object}  attributes - Attributes to merge.
   *
   * @return {Graph}              - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, attributes) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + attributes;

      attributes = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided attributes are not a plain object.`
      );

    assign(data.attributes, attributes);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'merge',
      attributes: data.attributes,
      data: attributes
    });

    return this;
  };
}

/**
 * Attach an attribute updater method onto the provided class.
 *
 * @param {function} Class         - Target class.
 * @param {string}   method        - Method name.
 * @param {string}   type          - Type of the edge to find.
 */
function attachEdgeAttributesUpdater(Class, method, type) {
  /**
   * Update the attributes of the given element (node or edge).
   *
   * Arity 2:
   * @param  {any}      element - Target element.
   * @param  {function} updater - Updater function.
   *
   * Arity 3 (only for edges):
   * @param  {any}      source  - Source element.
   * @param  {any}      target  - Target element.
   * @param  {function} updater - Updater function.
   *
   * @return {Graph}            - Returns itself for chaining.
   *
   * @throws {Error} - Will throw if too many arguments are provided.
   * @throws {Error} - Will throw if any of the elements is not found.
   */
  Class.prototype[method] = function (element, updater) {
    let data;

    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)
      throw new UsageGraphError(
        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`
      );

    if (arguments.length > 2) {
      if (this.multi)
        throw new UsageGraphError(
          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`
        );

      const source = '' + element,
        target = '' + updater;

      updater = arguments[2];

      data = getMatchingEdge(this, source, target, type);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find an edge for the given path ("${source}" - "${target}").`
        );
    } else {
      if (type !== 'mixed')
        throw new UsageGraphError(
          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`
        );

      element = '' + element;
      data = this._edges.get(element);

      if (!data)
        throw new NotFoundGraphError(
          `Graph.${method}: could not find the "${element}" edge in the graph.`
        );
    }

    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.${method}: provided updater is not a function.`
      );

    data.attributes = updater(data.attributes);

    // Emitting
    this.emit('edgeAttributesUpdated', {
      key: data.key,
      type: 'update',
      attributes: data.attributes
    });

    return this;
  };
}

/**
 * List of methods to attach.
 */
const EDGE_ATTRIBUTES_METHODS = [
  {
    name: element => `get${element}Attribute`,
    attacher: attachEdgeAttributeGetter
  },
  {
    name: element => `get${element}Attributes`,
    attacher: attachEdgeAttributesGetter
  },
  {
    name: element => `has${element}Attribute`,
    attacher: attachEdgeAttributeChecker
  },
  {
    name: element => `set${element}Attribute`,
    attacher: attachEdgeAttributeSetter
  },
  {
    name: element => `update${element}Attribute`,
    attacher: attachEdgeAttributeUpdater
  },
  {
    name: element => `remove${element}Attribute`,
    attacher: attachEdgeAttributeRemover
  },
  {
    name: element => `replace${element}Attributes`,
    attacher: attachEdgeAttributesReplacer
  },
  {
    name: element => `merge${element}Attributes`,
    attacher: attachEdgeAttributesMerger
  },
  {
    name: element => `update${element}Attributes`,
    attacher: attachEdgeAttributesUpdater
  }
];

/**
 * Attach every attributes-related methods to a Graph class.
 *
 * @param {function} Graph - Target class.
 */
function attachEdgeAttributesMethods(Graph) {
  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {
    // For edges
    attacher(Graph, name('Edge'), 'mixed');

    // For directed edges
    attacher(Graph, name('DirectedEdge'), 'directed');

    // For undirected edges
    attacher(Graph, name('UndirectedEdge'), 'undirected');
  });
}

/**
 * Graphology Edge Iteration
 * ==========================
 *
 * Attaching some methods to the Graph class to be able to iterate over a
 * graph's edges.
 */

/**
 * Definitions.
 */
const EDGES_ITERATION = [
  {
    name: 'edges',
    type: 'mixed'
  },
  {
    name: 'inEdges',
    type: 'directed',
    direction: 'in'
  },
  {
    name: 'outEdges',
    type: 'directed',
    direction: 'out'
  },
  {
    name: 'inboundEdges',
    type: 'mixed',
    direction: 'in'
  },
  {
    name: 'outboundEdges',
    type: 'mixed',
    direction: 'out'
  },
  {
    name: 'directedEdges',
    type: 'directed'
  },
  {
    name: 'undirectedEdges',
    type: 'undirected'
  }
];

/**
 * Function iterating over edges from the given object to match one of them.
 *
 * @param {object}   object   - Target object.
 * @param {function} callback - Function to call.
 */
function forEachSimple(breakable, object, callback, avoid) {
  let shouldBreak = false;

  for (const k in object) {
    if (k === avoid) continue;

    const edgeData = object[k];

    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected
    );

    if (breakable && shouldBreak) return edgeData.key;
  }

  return;
}

function forEachMulti(breakable, object, callback, avoid) {
  let edgeData, source, target;

  let shouldBreak = false;

  for (const k in object) {
    if (k === avoid) continue;

    edgeData = object[k];

    do {
      source = edgeData.source;
      target = edgeData.target;

      shouldBreak = callback(
        edgeData.key,
        edgeData.attributes,
        source.key,
        target.key,
        source.attributes,
        target.attributes,
        edgeData.undirected
      );

      if (breakable && shouldBreak) return edgeData.key;

      edgeData = edgeData.next;
    } while (edgeData !== undefined);
  }

  return;
}

/**
 * Function returning an iterator over edges from the given object.
 *
 * @param  {object}   object - Target object.
 * @return {Iterator}
 */
function createIterator(object, avoid) {
  const keys = Object.keys(object);
  const l = keys.length;

  let edgeData;
  let i = 0;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      do {
        if (!edgeData) {
          if (i >= l) return {done: true};

          const k = keys[i++];

          if (k === avoid) {
            edgeData = undefined;
            continue;
          }

          edgeData = object[k];
        } else {
          edgeData = edgeData.next;
        }
      } while (!edgeData);

      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}

/**
 * Function iterating over the egdes from the object at given key to match
 * one of them.
 *
 * @param {object}   object   - Target object.
 * @param {mixed}    k        - Neighbor key.
 * @param {function} callback - Callback to use.
 */
function forEachForKeySimple(breakable, object, k, callback) {
  const edgeData = object[k];

  if (!edgeData) return;

  const sourceData = edgeData.source;
  const targetData = edgeData.target;

  if (
    callback(
      edgeData.key,
      edgeData.attributes,
      sourceData.key,
      targetData.key,
      sourceData.attributes,
      targetData.attributes,
      edgeData.undirected
    ) &&
    breakable
  )
    return edgeData.key;
}

function forEachForKeyMulti(breakable, object, k, callback) {
  let edgeData = object[k];

  if (!edgeData) return;

  let shouldBreak = false;

  do {
    shouldBreak = callback(
      edgeData.key,
      edgeData.attributes,
      edgeData.source.key,
      edgeData.target.key,
      edgeData.source.attributes,
      edgeData.target.attributes,
      edgeData.undirected
    );

    if (breakable && shouldBreak) return edgeData.key;

    edgeData = edgeData.next;
  } while (edgeData !== undefined);

  return;
}

/**
 * Function returning an iterator over the egdes from the object at given key.
 *
 * @param  {object}   object   - Target object.
 * @param  {mixed}    k        - Neighbor key.
 * @return {Iterator}
 */
function createIteratorForKey(object, k) {
  let edgeData = object[k];

  if (edgeData.next !== undefined) {
    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        if (!edgeData) return {done: true};

        const value = {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        };

        edgeData = edgeData.next;

        return {
          done: false,
          value
        };
      }
    };
  }

  let done = false;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      if (done === true) return {done: true};
      done = true;
      return {
        done: false,
        value: {
          edge: edgeData.key,
          attributes: edgeData.attributes,
          source: edgeData.source.key,
          target: edgeData.target.key,
          sourceAttributes: edgeData.source.attributes,
          targetAttributes: edgeData.target.attributes,
          undirected: edgeData.undirected
        }
      };
    }
  };
}

/**
 * Function creating an array of edges for the given type.
 *
 * @param  {Graph}   graph - Target Graph instance.
 * @param  {string}  type  - Type of edges to retrieve.
 * @return {array}         - Array of edges.
 */
function createEdgeArray(graph, type) {
  if (graph.size === 0) return [];

  if (type === 'mixed' || type === graph.type) {
    return Array.from(graph._edges.keys());
  }

  const size =
    type === 'undirected' ? graph.undirectedSize : graph.directedSize;

  const list = new Array(size),
    mask = type === 'undirected';

  const iterator = graph._edges.values();

  let i = 0;
  let step, data;

  while (((step = iterator.next()), step.done !== true)) {
    data = step.value;

    if (data.undirected === mask) list[i++] = data.key;
  }

  return list;
}

/**
 * Function iterating over a graph's edges using a callback to match one of
 * them.
 *
 * @param  {Graph}    graph    - Target Graph instance.
 * @param  {string}   type     - Type of edges to retrieve.
 * @param  {function} callback - Function to call.
 */
function forEachEdge(breakable, graph, type, callback) {
  if (graph.size === 0) return;

  const shouldFilter = type !== 'mixed' && type !== graph.type;
  const mask = type === 'undirected';

  let step, data;
  let shouldBreak = false;
  const iterator = graph._edges.values();

  while (((step = iterator.next()), step.done !== true)) {
    data = step.value;

    if (shouldFilter && data.undirected !== mask) continue;

    const {key, attributes, source, target} = data;

    shouldBreak = callback(
      key,
      attributes,
      source.key,
      target.key,
      source.attributes,
      target.attributes,
      data.undirected
    );

    if (breakable && shouldBreak) return key;
  }

  return;
}

/**
 * Function creating an iterator of edges for the given type.
 *
 * @param  {Graph}    graph - Target Graph instance.
 * @param  {string}   type  - Type of edges to retrieve.
 * @return {Iterator}
 */
function createEdgeIterator(graph, type) {
  if (graph.size === 0) return emptyIterator();

  const shouldFilter = type !== 'mixed' && type !== graph.type;
  const mask = type === 'undirected';

  const iterator = graph._edges.values();

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let step, data;

      // eslint-disable-next-line no-constant-condition
      while (true) {
        step = iterator.next();

        if (step.done) return step;

        data = step.value;

        if (shouldFilter && data.undirected !== mask) continue;

        break;
      }

      const value = {
        edge: data.key,
        attributes: data.attributes,
        source: data.source.key,
        target: data.target.key,
        sourceAttributes: data.source.attributes,
        targetAttributes: data.target.attributes,
        undirected: data.undirected
      };

      return {value, done: false};
    }
  };
}

/**
 * Function iterating over a node's edges using a callback to match one of them.
 *
 * @param  {boolean}  multi     - Whether the graph is multi or not.
 * @param  {string}   type      - Type of edges to retrieve.
 * @param  {string}   direction - In or out?
 * @param  {any}      nodeData  - Target node's data.
 * @param  {function} callback  - Function to call.
 */
function forEachEdgeForNode(
  breakable,
  multi,
  type,
  direction,
  nodeData,
  callback
) {
  const fn = multi ? forEachMulti : forEachSimple;

  let found;

  if (type !== 'undirected') {
    if (direction !== 'out') {
      found = fn(breakable, nodeData.in, callback);

      if (breakable && found) return found;
    }
    if (direction !== 'in') {
      found = fn(
        breakable,
        nodeData.out,
        callback,
        !direction ? nodeData.key : undefined
      );

      if (breakable && found) return found;
    }
  }

  if (type !== 'directed') {
    found = fn(breakable, nodeData.undirected, callback);

    if (breakable && found) return found;
  }

  return;
}

/**
 * Function creating an array of edges for the given type & the given node.
 *
 * @param  {boolean} multi     - Whether the graph is multi or not.
 * @param  {string}  type      - Type of edges to retrieve.
 * @param  {string}  direction - In or out?
 * @param  {any}     nodeData  - Target node's data.
 * @return {array}             - Array of edges.
 */
function createEdgeArrayForNode(multi, type, direction, nodeData) {
  const edges = []; // TODO: possibility to know size beforehand or factorize with map

  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {
    edges.push(key);
  });

  return edges;
}

/**
 * Function iterating over a node's edges using a callback.
 *
 * @param  {string}   type      - Type of edges to retrieve.
 * @param  {string}   direction - In or out?
 * @param  {any}      nodeData  - Target node's data.
 * @return {Iterator}
 */
function createEdgeIteratorForNode(type, direction, nodeData) {
  let iterator = emptyIterator();

  if (type !== 'undirected') {
    if (direction !== 'out' && typeof nodeData.in !== 'undefined')
      iterator = chain(iterator, createIterator(nodeData.in));
    if (direction !== 'in' && typeof nodeData.out !== 'undefined')
      iterator = chain(
        iterator,
        createIterator(nodeData.out, !direction ? nodeData.key : undefined)
      );
  }

  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {
    iterator = chain(iterator, createIterator(nodeData.undirected));
  }

  return iterator;
}

/**
 * Function iterating over edges for the given path using a callback to match
 * one of them.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {boolean}  multi      - Whether the graph is multi.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {string}   target     - Target node.
 * @param  {function} callback   - Function to call.
 */
function forEachEdgeForPath(
  breakable,
  type,
  multi,
  direction,
  sourceData,
  target,
  callback
) {
  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;

  let found;

  if (type !== 'undirected') {
    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {
      found = fn(breakable, sourceData.in, target, callback);

      if (breakable && found) return found;
    }

    if (
      typeof sourceData.out !== 'undefined' &&
      direction !== 'in' &&
      (direction || sourceData.key !== target)
    ) {
      found = fn(breakable, sourceData.out, target, callback);

      if (breakable && found) return found;
    }
  }

  if (type !== 'directed') {
    if (typeof sourceData.undirected !== 'undefined') {
      found = fn(breakable, sourceData.undirected, target, callback);

      if (breakable && found) return found;
    }
  }

  return;
}

/**
 * Function creating an array of edges for the given path.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {boolean}  multi      - Whether the graph is multi.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {any}      target     - Target node.
 * @return {array}               - Array of edges.
 */
function createEdgeArrayForPath(type, multi, direction, sourceData, target) {
  const edges = []; // TODO: possibility to know size beforehand or factorize with map

  forEachEdgeForPath(
    false,
    type,
    multi,
    direction,
    sourceData,
    target,
    function (key) {
      edges.push(key);
    }
  );

  return edges;
}

/**
 * Function returning an iterator over edges for the given path.
 *
 * @param  {string}   type       - Type of edges to retrieve.
 * @param  {string}   direction  - In or out?
 * @param  {NodeData} sourceData - Source node's data.
 * @param  {string}   target     - Target node.
 * @param  {function} callback   - Function to call.
 */
function createEdgeIteratorForPath(type, direction, sourceData, target) {
  let iterator = emptyIterator();

  if (type !== 'undirected') {
    if (
      typeof sourceData.in !== 'undefined' &&
      direction !== 'out' &&
      target in sourceData.in
    )
      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));

    if (
      typeof sourceData.out !== 'undefined' &&
      direction !== 'in' &&
      target in sourceData.out &&
      (direction || sourceData.key !== target)
    )
      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));
  }

  if (type !== 'directed') {
    if (
      typeof sourceData.undirected !== 'undefined' &&
      target in sourceData.undirected
    )
      iterator = chain(
        iterator,
        createIteratorForKey(sourceData.undirected, target)
      );
  }

  return iterator;
}

/**
 * Function attaching an edge array creator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeArrayCreator(Class, description) {
  const {name, type, direction} = description;

  /**
   * Function returning an array of certain edges.
   *
   * Arity 0: Return all the relevant edges.
   *
   * Arity 1: Return all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 2: Return the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[name] = function (source, target) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return [];

    if (!arguments.length) return createEdgeArray(this, type);

    if (arguments.length === 1) {
      source = '' + source;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${name}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      return createEdgeArrayForNode(
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData
      );
    }

    if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return createEdgeArrayForPath(
        type,
        this.multi,
        direction,
        sourceData,
        target
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
    );
  };
}

/**
 * Function attaching a edge callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachForEachEdge(Class, description) {
  const {name, type, direction} = description;

  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over the graph's relevant edges by applying the given
   * callback.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[forEachName] = function (source, target, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(false, this, type, callback);
    }

    if (arguments.length === 2) {
      source = '' + source;
      callback = target;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${forEachName}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      // TODO: maybe attach the sub method to the instance dynamically?
      return forEachEdgeForNode(
        false,
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }

    if (arguments.length === 3) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${forEachName}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${forEachName}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return forEachEdgeForPath(
        false,
        type,
        this.multi,
        direction,
        sourceData,
        target,
        callback
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
    );
  };

  /**
   * Function mapping the graph's relevant edges by applying the given
   * callback.
   *
   * Arity 1: Map all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Map all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Map the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[mapName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    let result;

    // We know the result length beforehand
    if (args.length === 0) {
      let length = 0;

      if (type !== 'directed') length += this.undirectedSize;
      if (type !== 'undirected') length += this.directedSize;

      result = new Array(length);

      let i = 0;

      args.push((e, ea, s, t, sa, ta, u) => {
        result[i++] = callback(e, ea, s, t, sa, ta, u);
      });
    }

    // We don't know the result length beforehand
    // TODO: we can in some instances of simple graphs, knowing degree
    else {
      result = [];

      args.push((e, ea, s, t, sa, ta, u) => {
        result.push(callback(e, ea, s, t, sa, ta, u));
      });
    }

    this[forEachName].apply(this, args);

    return result;
  };

  /**
   * Function filtering the graph's relevant edges using the provided predicate
   * function.
   *
   * Arity 1: Filter all the relevant edges.
   * @param  {function} predicate - Predicate to use.
   *
   * Arity 2: Filter all of a node's relevant edges.
   * @param  {any}      node      - Target node.
   * @param  {function} predicate - Predicate to use.
   *
   * Arity 3: Filter the relevant edges across the given path.
   * @param  {any}      source    - Source node.
   * @param  {any}      target    - Target node.
   * @param  {function} predicate - Predicate to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[filterName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    const result = [];

    args.push((e, ea, s, t, sa, ta, u) => {
      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);
    });

    this[forEachName].apply(this, args);

    return result;
  };

  /**
   * Function reducing the graph's relevant edges using the provided accumulator
   * function.
   *
   * Arity 1: Reduce all the relevant edges.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * Arity 2: Reduce all of a node's relevant edges.
   * @param  {any}      node         - Target node.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * Arity 3: Reduce the relevant edges across the given path.
   * @param  {any}      source       - Source node.
   * @param  {any}      target       - Target node.
   * @param  {function} accumulator  - Accumulator to use.
   * @param  {any}      initialValue - Initial value.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[reduceName] = function () {
    let args = Array.prototype.slice.call(arguments);

    if (args.length < 2 || args.length > 4) {
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`
      );
    }

    if (
      typeof args[args.length - 1] === 'function' &&
      typeof args[args.length - 2] !== 'function'
    ) {
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
      );
    }

    let callback;
    let initialValue;

    if (args.length === 2) {
      callback = args[0];
      initialValue = args[1];
      args = [];
    } else if (args.length === 3) {
      callback = args[1];
      initialValue = args[2];
      args = [args[0]];
    } else if (args.length === 4) {
      callback = args[2];
      initialValue = args[3];
      args = [args[0], args[1]];
    }

    let accumulator = initialValue;

    args.push((e, ea, s, t, sa, ta, u) => {
      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);
    });

    this[forEachName].apply(this, args);

    return accumulator;
  };
}

/**
 * Function attaching a breakable edge callback iterator method to the Graph
 * prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachFindEdge(Class, description) {
  const {name, type, direction} = description;

  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over the graph's relevant edges in order to match
   * one of them using the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[findEdgeName] = function (source, target, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return false;

    if (arguments.length === 1) {
      callback = source;
      return forEachEdge(true, this, type, callback);
    }

    if (arguments.length === 2) {
      source = '' + source;
      callback = target;

      const nodeData = this._nodes.get(source);

      if (typeof nodeData === 'undefined')
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      // TODO: maybe attach the sub method to the instance dynamically?
      return forEachEdgeForNode(
        true,
        this.multi,
        type === 'mixed' ? this.type : type,
        direction,
        nodeData,
        callback
      );
    }

    if (arguments.length === 3) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${findEdgeName}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return forEachEdgeForPath(
        true,
        type,
        this.multi,
        direction,
        sourceData,
        target,
        callback
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`
    );
  };

  /**
   * Function iterating over the graph's relevant edges in order to assert
   * whether any one of them matches the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);

  Class.prototype[someName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    args.push((e, ea, s, t, sa, ta, u) => {
      return callback(e, ea, s, t, sa, ta, u);
    });

    const found = this[findEdgeName].apply(this, args);

    if (found) return true;

    return false;
  };

  /**
   * Function iterating over the graph's relevant edges in order to assert
   * whether all of them matche the provided predicate function.
   *
   * Arity 1: Iterate over all the relevant edges.
   * @param  {function} callback - Callback to use.
   *
   * Arity 2: Iterate over all of a node's relevant edges.
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * Arity 3: Iterate over the relevant edges across the given path.
   * @param  {any}      source   - Source node.
   * @param  {any}      target   - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);

  Class.prototype[everyName] = function () {
    const args = Array.prototype.slice.call(arguments);
    const callback = args.pop();

    args.push((e, ea, s, t, sa, ta, u) => {
      return !callback(e, ea, s, t, sa, ta, u);
    });

    const found = this[findEdgeName].apply(this, args);

    if (found) return false;

    return true;
  };
}

/**
 * Function attaching an edge iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachEdgeIteratorCreator(Class, description) {
  const {name: originalName, type, direction} = description;

  const name = originalName.slice(0, -1) + 'Entries';

  /**
   * Function returning an iterator over the graph's edges.
   *
   * Arity 0: Iterate over all the relevant edges.
   *
   * Arity 1: Iterate over all of a node's relevant edges.
   * @param  {any}   node   - Target node.
   *
   * Arity 2: Iterate over the relevant edges across the given path.
   * @param  {any}   source - Source node.
   * @param  {any}   target - Target node.
   *
   * @return {array|number} - The edges or the number of edges.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[name] = function (source, target) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return emptyIterator();

    if (!arguments.length) return createEdgeIterator(this, type);

    if (arguments.length === 1) {
      source = '' + source;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}: could not find the "${source}" node in the graph.`
        );

      // Iterating over a node's edges
      return createEdgeIteratorForNode(type, direction, sourceData);
    }

    if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      const sourceData = this._nodes.get(source);

      if (!sourceData)
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${source}" source node in the graph.`
        );

      if (!this._nodes.has(target))
        throw new NotFoundGraphError(
          `Graph.${name}:  could not find the "${target}" target node in the graph.`
        );

      // Iterating over the edges between source & target
      return createEdgeIteratorForPath(type, direction, sourceData, target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`
    );
  };
}

/**
 * Function attaching every edge iteration method to the Graph class.
 *
 * @param {function} Graph - Graph class.
 */
function attachEdgeIterationMethods(Graph) {
  EDGES_ITERATION.forEach(description => {
    attachEdgeArrayCreator(Graph, description);
    attachForEachEdge(Graph, description);
    attachFindEdge(Graph, description);
    attachEdgeIteratorCreator(Graph, description);
  });
}

/**
 * Graphology Neighbor Iteration
 * ==============================
 *
 * Attaching some methods to the Graph class to be able to iterate over
 * neighbors.
 */

/**
 * Definitions.
 */
const NEIGHBORS_ITERATION = [
  {
    name: 'neighbors',
    type: 'mixed'
  },
  {
    name: 'inNeighbors',
    type: 'directed',
    direction: 'in'
  },
  {
    name: 'outNeighbors',
    type: 'directed',
    direction: 'out'
  },
  {
    name: 'inboundNeighbors',
    type: 'mixed',
    direction: 'in'
  },
  {
    name: 'outboundNeighbors',
    type: 'mixed',
    direction: 'out'
  },
  {
    name: 'directedNeighbors',
    type: 'directed'
  },
  {
    name: 'undirectedNeighbors',
    type: 'undirected'
  }
];

/**
 * Helpers.
 */
function CompositeSetWrapper() {
  this.A = null;
  this.B = null;
}

CompositeSetWrapper.prototype.wrap = function (set) {
  if (this.A === null) this.A = set;
  else if (this.B === null) this.B = set;
};

CompositeSetWrapper.prototype.has = function (key) {
  if (this.A !== null && key in this.A) return true;
  if (this.B !== null && key in this.B) return true;
  return false;
};

/**
 * Function iterating over the given node's relevant neighbors to match
 * one of them using a predicated function.
 *
 * @param  {string}   type      - Type of neighbors.
 * @param  {string}   direction - Direction.
 * @param  {any}      nodeData  - Target node's data.
 * @param  {function} callback  - Callback to use.
 */
function forEachInObjectOnce(breakable, visited, nodeData, object, callback) {
  for (const k in object) {
    const edgeData = object[k];

    const sourceData = edgeData.source;
    const targetData = edgeData.target;

    const neighborData = sourceData === nodeData ? targetData : sourceData;

    if (visited && visited.has(neighborData.key)) continue;

    const shouldBreak = callback(neighborData.key, neighborData.attributes);

    if (breakable && shouldBreak) return neighborData.key;
  }

  return;
}

function forEachNeighbor(breakable, type, direction, nodeData, callback) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected')
      return forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData.undirected,
        callback
      );

    if (typeof direction === 'string')
      return forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData[direction],
        callback
      );
  }

  // Else we need to keep a set of neighbors not to return duplicates
  // We cheat by querying the other adjacencies
  const visited = new CompositeSetWrapper();

  let found;

  if (type !== 'undirected') {
    if (direction !== 'out') {
      found = forEachInObjectOnce(
        breakable,
        null,
        nodeData,
        nodeData.in,
        callback
      );

      if (breakable && found) return found;

      visited.wrap(nodeData.in);
    }
    if (direction !== 'in') {
      found = forEachInObjectOnce(
        breakable,
        visited,
        nodeData,
        nodeData.out,
        callback
      );

      if (breakable && found) return found;

      visited.wrap(nodeData.out);
    }
  }

  if (type !== 'directed') {
    found = forEachInObjectOnce(
      breakable,
      visited,
      nodeData,
      nodeData.undirected,
      callback
    );

    if (breakable && found) return found;
  }

  return;
}

/**
 * Function creating an array of relevant neighbors for the given node.
 *
 * @param  {string}       type      - Type of neighbors.
 * @param  {string}       direction - Direction.
 * @param  {any}          nodeData  - Target node's data.
 * @return {Array}                  - The list of neighbors.
 */
function createNeighborArrayForNode(type, direction, nodeData) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected') return Object.keys(nodeData.undirected);

    if (typeof direction === 'string') return Object.keys(nodeData[direction]);
  }

  const neighbors = [];

  forEachNeighbor(false, type, direction, nodeData, function (key) {
    neighbors.push(key);
  });

  return neighbors;
}

/**
 * Function returning an iterator over the given node's relevant neighbors.
 *
 * @param  {string}   type      - Type of neighbors.
 * @param  {string}   direction - Direction.
 * @param  {any}      nodeData  - Target node's data.
 * @return {Iterator}
 */
function createDedupedObjectIterator(visited, nodeData, object) {
  const keys = Object.keys(object);
  const l = keys.length;

  let i = 0;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      let neighborData = null;

      do {
        if (i >= l) {
          if (visited) visited.wrap(object);
          return {done: true};
        }

        const edgeData = object[keys[i++]];

        const sourceData = edgeData.source;
        const targetData = edgeData.target;

        neighborData = sourceData === nodeData ? targetData : sourceData;

        if (visited && visited.has(neighborData.key)) {
          neighborData = null;
          continue;
        }
      } while (neighborData === null);

      return {
        done: false,
        value: {neighbor: neighborData.key, attributes: neighborData.attributes}
      };
    }
  };
}

function createNeighborIterator(type, direction, nodeData) {
  // If we want only undirected or in or out, we can roll some optimizations
  if (type !== 'mixed') {
    if (type === 'undirected')
      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);

    if (typeof direction === 'string')
      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);
  }

  let iterator = emptyIterator();

  // Else we need to keep a set of neighbors not to return duplicates
  // We cheat by querying the other adjacencies
  const visited = new CompositeSetWrapper();

  if (type !== 'undirected') {
    if (direction !== 'out') {
      iterator = chain(
        iterator,
        createDedupedObjectIterator(visited, nodeData, nodeData.in)
      );
    }
    if (direction !== 'in') {
      iterator = chain(
        iterator,
        createDedupedObjectIterator(visited, nodeData, nodeData.out)
      );
    }
  }

  if (type !== 'directed') {
    iterator = chain(
      iterator,
      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)
    );
  }

  return iterator;
}

/**
 * Function attaching a neighbors array creator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachNeighborArrayCreator(Class, description) {
  const {name, type, direction} = description;

  /**
   * Function returning an array of certain neighbors.
   *
   * @param  {any}   node   - Target node.
   * @return {array} - The neighbors of neighbors.
   *
   * @throws {Error} - Will throw if node is not found in the graph.
   */
  Class.prototype[name] = function (node) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return [];

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${name}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return createNeighborArrayForNode(
      type === 'mixed' ? this.type : type,
      direction,
      nodeData
    );
  };
}

/**
 * Function attaching a neighbors callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachForEachNeighbor(Class, description) {
  const {name, type, direction} = description;

  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);

  /**
   * Function iterating over all the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[forEachName] = function (node, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${forEachName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    forEachNeighbor(
      false,
      type === 'mixed' ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };

  /**
   * Function mapping the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[mapName] = function (node, callback) {
    // TODO: optimize when size is known beforehand
    const result = [];

    this[forEachName](node, (n, a) => {
      result.push(callback(n, a));
    });

    return result;
  };

  /**
   * Function filtering the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[filterName] = function (node, callback) {
    const result = [];

    this[forEachName](node, (n, a) => {
      if (callback(n, a)) result.push(n);
    });

    return result;
  };

  /**
   * Function reducing the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);

  Class.prototype[reduceName] = function (node, callback, initialValue) {
    if (arguments.length < 3)
      throw new InvalidArgumentsGraphError(
        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`
      );

    let accumulator = initialValue;

    this[forEachName](node, (n, a) => {
      accumulator = callback(accumulator, n, a);
    });

    return accumulator;
  };
}

/**
 * Function attaching a breakable neighbors callback iterator method to the
 * Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachFindNeighbor(Class, description) {
  const {name, type, direction} = description;

  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);

  const findName = 'find' + capitalizedSingular;

  /**
   * Function iterating over all the relevant neighbors using a callback.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {undefined}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[findName] = function (node, callback) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${findName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return forEachNeighbor(
      true,
      type === 'mixed' ? this.type : type,
      direction,
      nodeData,
      callback
    );
  };

  /**
   * Function iterating over all the relevant neighbors to find if any of them
   * matches the given predicate.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const someName = 'some' + capitalizedSingular;

  Class.prototype[someName] = function (node, callback) {
    const found = this[findName](node, callback);

    if (found) return true;

    return false;
  };

  /**
   * Function iterating over all the relevant neighbors to find if all of them
   * matche the given predicate.
   *
   * @param  {any}      node     - Target node.
   * @param  {function} callback - Callback to use.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  const everyName = 'every' + capitalizedSingular;

  Class.prototype[everyName] = function (node, callback) {
    const found = this[findName](node, (n, a) => {
      return !callback(n, a);
    });

    if (found) return false;

    return true;
  };
}

/**
 * Function attaching a neighbors callback iterator method to the Graph prototype.
 *
 * @param {function} Class       - Target class.
 * @param {object}   description - Method description.
 */
function attachNeighborIteratorCreator(Class, description) {
  const {name, type, direction} = description;

  const iteratorName = name.slice(0, -1) + 'Entries';

  /**
   * Function returning an iterator over all the relevant neighbors.
   *
   * @param  {any}      node     - Target node.
   * @return {Iterator}
   *
   * @throws {Error} - Will throw if there are too many arguments.
   */
  Class.prototype[iteratorName] = function (node) {
    // Early termination
    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)
      return emptyIterator();

    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (typeof nodeData === 'undefined')
      throw new NotFoundGraphError(
        `Graph.${iteratorName}: could not find the "${node}" node in the graph.`
      );

    // Here, we want to iterate over a node's relevant neighbors
    return createNeighborIterator(
      type === 'mixed' ? this.type : type,
      direction,
      nodeData
    );
  };
}

/**
 * Function attaching every neighbor iteration method to the Graph class.
 *
 * @param {function} Graph - Graph class.
 */
function attachNeighborIterationMethods(Graph) {
  NEIGHBORS_ITERATION.forEach(description => {
    attachNeighborArrayCreator(Graph, description);
    attachForEachNeighbor(Graph, description);
    attachFindNeighbor(Graph, description);
    attachNeighborIteratorCreator(Graph, description);
  });
}

/**
 * Graphology Adjacency Iteration
 * ===============================
 *
 * Attaching some methods to the Graph class to be able to iterate over a
 * graph's adjacency.
 */

/**
 * Function iterating over a simple graph's adjacency using a callback.
 *
 * @param {boolean}  breakable         - Can we break?
 * @param {boolean}  assymetric        - Whether to emit undirected edges only once.
 * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.
 * @param {Graph}    graph             - Target Graph instance.
 * @param {callback} function          - Iteration callback.
 */
function forEachAdjacency(
  breakable,
  assymetric,
  disconnectedNodes,
  graph,
  callback
) {
  const iterator = graph._nodes.values();

  const type = graph.type;

  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;

  while (((step = iterator.next()), step.done !== true)) {
    let hasEdges = false;

    sourceData = step.value;

    if (type !== 'undirected') {
      adj = sourceData.out;

      for (neighbor in adj) {
        edgeData = adj[neighbor];

        do {
          targetData = edgeData.target;

          hasEdges = true;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected
          );

          if (breakable && shouldBreak) return edgeData;

          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (type !== 'directed') {
      adj = sourceData.undirected;

      for (neighbor in adj) {
        if (assymetric && sourceData.key > neighbor) continue;

        edgeData = adj[neighbor];

        do {
          targetData = edgeData.target;

          if (targetData.key !== neighbor) targetData = edgeData.source;

          hasEdges = true;
          shouldBreak = callback(
            sourceData.key,
            targetData.key,
            sourceData.attributes,
            targetData.attributes,
            edgeData.key,
            edgeData.attributes,
            edgeData.undirected
          );

          if (breakable && shouldBreak) return edgeData;

          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (disconnectedNodes && !hasEdges) {
      shouldBreak = callback(
        sourceData.key,
        null,
        sourceData.attributes,
        null,
        null,
        null,
        null
      );

      if (breakable && shouldBreak) return null;
    }
  }

  return;
}

/**
 * Graphology Serialization Utilities
 * ===================================
 *
 * Collection of functions used by the graph serialization schemes.
 */

/**
 * Formats internal node data into a serialized node.
 *
 * @param  {any}    key  - The node's key.
 * @param  {object} data - Internal node's data.
 * @return {array}       - The serialized node.
 */
function serializeNode(key, data) {
  const serialized = {key};

  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);

  return serialized;
}

/**
 * Formats internal edge data into a serialized edge.
 *
 * @param  {string} type - The graph's type.
 * @param  {any}    key  - The edge's key.
 * @param  {object} data - Internal edge's data.
 * @return {array}       - The serialized edge.
 */
function serializeEdge(type, key, data) {
  const serialized = {
    key,
    source: data.source.key,
    target: data.target.key
  };

  if (!isEmpty(data.attributes))
    serialized.attributes = assign({}, data.attributes);

  if (type === 'mixed' && data.undirected) serialized.undirected = true;

  return serialized;
}

/**
 * Checks whether the given value is a serialized node.
 *
 * @param  {mixed} value - Target value.
 * @return {string|null}
 */
function validateSerializedNode(value) {
  if (!isPlainObject(value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.'
    );

  if (!('key' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized node is missing its key.'
    );

  if (
    'attributes' in value &&
    (!isPlainObject(value.attributes) || value.attributes === null)
  )
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
    );
}

/**
 * Checks whether the given value is a serialized edge.
 *
 * @param  {mixed} value - Target value.
 * @return {string|null}
 */
function validateSerializedEdge(value) {
  if (!isPlainObject(value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.'
    );

  if (!('source' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized edge is missing its source.'
    );

  if (!('target' in value))
    throw new InvalidArgumentsGraphError(
      'Graph.import: serialized edge is missing its target.'
    );

  if (
    'attributes' in value &&
    (!isPlainObject(value.attributes) || value.attributes === null)
  )
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'
    );

  if ('undirected' in value && typeof value.undirected !== 'boolean')
    throw new InvalidArgumentsGraphError(
      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'
    );
}

/* eslint no-nested-ternary: 0 */

/**
 * Constants.
 */
const INSTANCE_ID = incrementalIdStartingFromRandomByte();

/**
 * Enums.
 */
const TYPES = new Set(['directed', 'undirected', 'mixed']);

const EMITTER_PROPS = new Set([
  'domain',
  '_events',
  '_eventsCount',
  '_maxListeners'
]);

const EDGE_ADD_METHODS = [
  {
    name: verb => `${verb}Edge`,
    generateKey: true
  },
  {
    name: verb => `${verb}DirectedEdge`,
    generateKey: true,
    type: 'directed'
  },
  {
    name: verb => `${verb}UndirectedEdge`,
    generateKey: true,
    type: 'undirected'
  },
  {
    name: verb => `${verb}EdgeWithKey`
  },
  {
    name: verb => `${verb}DirectedEdgeWithKey`,
    type: 'directed'
  },
  {
    name: verb => `${verb}UndirectedEdgeWithKey`,
    type: 'undirected'
  }
];

/**
 * Default options.
 */
const DEFAULTS = {
  allowSelfLoops: true,
  multi: false,
  type: 'mixed'
};

/**
 * Abstract functions used by the Graph class for various methods.
 */

/**
 * Internal method used to add a node to the given graph
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {any}     node            - The node's key.
 * @param  {object}  [attributes]    - Optional attributes.
 * @return {NodeData}                - Created node data.
 */
function addNode(graph, node, attributes) {
  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(
      `Graph.addNode: invalid attributes. Expecting an object but got "${attributes}"`
    );

  // String coercion
  node = '' + node;
  attributes = attributes || {};

  if (graph._nodes.has(node))
    throw new UsageGraphError(
      `Graph.addNode: the "${node}" node already exist in the graph.`
    );

  const data = new graph.NodeDataClass(node, attributes);

  // Adding the node to internal register
  graph._nodes.set(node, data);

  // Emitting
  graph.emit('nodeAdded', {
    key: node,
    attributes
  });

  return data;
}

/**
 * Same as the above but without sanity checks because we call this in contexts
 * where necessary checks were already done.
 */
function unsafeAddNode(graph, node, attributes) {
  const data = new graph.NodeDataClass(node, attributes);

  graph._nodes.set(node, data);

  graph.emit('nodeAdded', {
    key: node,
    attributes
  });

  return data;
}

/**
 * Internal method used to add an arbitrary edge to the given graph.
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {string}  name            - Name of the child method for errors.
 * @param  {boolean} mustGenerateKey - Should the graph generate an id?
 * @param  {boolean} undirected      - Whether the edge is undirected.
 * @param  {any}     edge            - The edge's key.
 * @param  {any}     source          - The source node.
 * @param  {any}     target          - The target node.
 * @param  {object}  [attributes]    - Optional attributes.
 * @return {any}                     - The edge.
 *
 * @throws {Error} - Will throw if the graph is of the wrong type.
 * @throws {Error} - Will throw if the given attributes are not an object.
 * @throws {Error} - Will throw if source or target doesn't exist.
 * @throws {Error} - Will throw if the edge already exist.
 */
function addEdge(
  graph,
  name,
  mustGenerateKey,
  undirected,
  edge,
  source,
  target,
  attributes
) {
  // Checking validity of operation
  if (!undirected && graph.type === 'undirected')
    throw new UsageGraphError(
      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`
    );

  if (undirected && graph.type === 'directed')
    throw new UsageGraphError(
      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`
    );

  if (attributes && !isPlainObject(attributes))
    throw new InvalidArgumentsGraphError(
      `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
    );

  // Coercion of source & target:
  source = '' + source;
  target = '' + target;
  attributes = attributes || {};

  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(
      `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
    );

  const sourceData = graph._nodes.get(source),
    targetData = graph._nodes.get(target);

  if (!sourceData)
    throw new NotFoundGraphError(
      `Graph.${name}: source node "${source}" not found.`
    );

  if (!targetData)
    throw new NotFoundGraphError(
      `Graph.${name}: target node "${target}" not found.`
    );

  // Must the graph generate an id for this edge?
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };

  if (mustGenerateKey) {
    // NOTE: in this case we can guarantee that the key does not already
    // exist and is already correctly casted as a string
    edge = graph._edgeKeyGenerator();
  } else {
    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(
        `Graph.${name}: the "${edge}" edge already exists in the graph.`
      );
  }

  // Here, we might have a source / target collision
  if (
    !graph.multi &&
    (undirected
      ? typeof sourceData.undirected[target] !== 'undefined'
      : typeof sourceData.out[target] !== 'undefined')
  ) {
    throw new UsageGraphError(
      `Graph.${name}: an edge linking "${source}" to "${target}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`
    );
  }

  // Storing some data
  const edgeData = new EdgeData(
    undirected,
    edge,
    sourceData,
    targetData,
    attributes
  );

  // Adding the edge to the internal register
  graph._edges.set(edge, edgeData);

  // Incrementing node degree counters
  const isSelfLoop = source === target;

  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;

    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;

    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }

  // Updating relevant index
  if (graph.multi) edgeData.attachMulti();
  else edgeData.attach();

  if (undirected) graph._undirectedSize++;
  else graph._directedSize++;

  // Emitting
  eventData.key = edge;

  graph.emit('edgeAdded', eventData);

  return edge;
}

/**
 * Internal method used to add an arbitrary edge to the given graph.
 *
 * @param  {Graph}   graph           - Target graph.
 * @param  {string}  name            - Name of the child method for errors.
 * @param  {boolean} mustGenerateKey - Should the graph generate an id?
 * @param  {boolean} undirected      - Whether the edge is undirected.
 * @param  {any}     edge            - The edge's key.
 * @param  {any}     source          - The source node.
 * @param  {any}     target          - The target node.
 * @param  {object}  [attributes]    - Optional attributes.
 * @param  {boolean} [asUpdater]       - Are we updating or merging?
 * @return {any}                     - The edge.
 *
 * @throws {Error} - Will throw if the graph is of the wrong type.
 * @throws {Error} - Will throw if the given attributes are not an object.
 * @throws {Error} - Will throw if source or target doesn't exist.
 * @throws {Error} - Will throw if the edge already exist.
 */
function mergeEdge(
  graph,
  name,
  mustGenerateKey,
  undirected,
  edge,
  source,
  target,
  attributes,
  asUpdater
) {
  // Checking validity of operation
  if (!undirected && graph.type === 'undirected')
    throw new UsageGraphError(
      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`
    );

  if (undirected && graph.type === 'directed')
    throw new UsageGraphError(
      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`
    );

  if (attributes) {
    if (asUpdater) {
      if (typeof attributes !== 'function')
        throw new InvalidArgumentsGraphError(
          `Graph.${name}: invalid updater function. Expecting a function but got "${attributes}"`
        );
    } else {
      if (!isPlainObject(attributes))
        throw new InvalidArgumentsGraphError(
          `Graph.${name}: invalid attributes. Expecting an object but got "${attributes}"`
        );
    }
  }

  // Coercion of source & target:
  source = '' + source;
  target = '' + target;

  let updater;

  if (asUpdater) {
    updater = attributes;
    attributes = undefined;
  }

  if (!graph.allowSelfLoops && source === target)
    throw new UsageGraphError(
      `Graph.${name}: source & target are the same ("${source}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`
    );

  let sourceData = graph._nodes.get(source);
  let targetData = graph._nodes.get(target);
  let edgeData;

  // Do we need to handle duplicate?
  let alreadyExistingEdgeData;

  if (!mustGenerateKey) {
    edgeData = graph._edges.get(edge);

    if (edgeData) {
      // Here, we need to ensure, if the user gave a key, that source & target
      // are consistent
      if (edgeData.source.key !== source || edgeData.target.key !== target) {
        // If source or target inconsistent
        if (
          !undirected ||
          edgeData.source.key !== target ||
          edgeData.target.key !== source
        ) {
          // If directed, or source/target aren't flipped
          throw new UsageGraphError(
            `Graph.${name}: inconsistency detected when attempting to merge the "${edge}" edge with "${source}" source & "${target}" target vs. ("${edgeData.source.key}", "${edgeData.target.key}").`
          );
        }
      }

      alreadyExistingEdgeData = edgeData;
    }
  }

  // Here, we might have a source / target collision
  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {
    alreadyExistingEdgeData = undirected
      ? sourceData.undirected[target]
      : sourceData.out[target];
  }

  // Handling duplicates
  if (alreadyExistingEdgeData) {
    const info = [alreadyExistingEdgeData.key, false, false, false];

    // We can skip the attribute merging part if the user did not provide them
    if (asUpdater ? !updater : !attributes) return info;

    // Updating the attributes
    if (asUpdater) {
      const oldAttributes = alreadyExistingEdgeData.attributes;
      alreadyExistingEdgeData.attributes = updater(oldAttributes);

      graph.emit('edgeAttributesUpdated', {
        type: 'replace',
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes
      });
    }

    // Merging the attributes
    else {
      assign(alreadyExistingEdgeData.attributes, attributes);

      graph.emit('edgeAttributesUpdated', {
        type: 'merge',
        key: alreadyExistingEdgeData.key,
        attributes: alreadyExistingEdgeData.attributes,
        data: attributes
      });
    }

    return info;
  }

  attributes = attributes || {};

  if (asUpdater && updater) attributes = updater(attributes);

  // Must the graph generate an id for this edge?
  const eventData = {
    key: null,
    undirected,
    source,
    target,
    attributes
  };

  if (mustGenerateKey) {
    // NOTE: in this case we can guarantee that the key does not already
    // exist and is already correctly casted as a string
    edge = graph._edgeKeyGenerator();
  } else {
    // Coercion of edge key
    edge = '' + edge;

    // Here, we have a key collision
    if (graph._edges.has(edge))
      throw new UsageGraphError(
        `Graph.${name}: the "${edge}" edge already exists in the graph.`
      );
  }

  let sourceWasAdded = false;
  let targetWasAdded = false;

  if (!sourceData) {
    sourceData = unsafeAddNode(graph, source, {});
    sourceWasAdded = true;

    if (source === target) {
      targetData = sourceData;
      targetWasAdded = true;
    }
  }
  if (!targetData) {
    targetData = unsafeAddNode(graph, target, {});
    targetWasAdded = true;
  }

  // Storing some data
  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);

  // Adding the edge to the internal register
  graph._edges.set(edge, edgeData);

  // Incrementing node degree counters
  const isSelfLoop = source === target;

  if (undirected) {
    sourceData.undirectedDegree++;
    targetData.undirectedDegree++;

    if (isSelfLoop) {
      sourceData.undirectedLoops++;
      graph._undirectedSelfLoopCount++;
    }
  } else {
    sourceData.outDegree++;
    targetData.inDegree++;

    if (isSelfLoop) {
      sourceData.directedLoops++;
      graph._directedSelfLoopCount++;
    }
  }

  // Updating relevant index
  if (graph.multi) edgeData.attachMulti();
  else edgeData.attach();

  if (undirected) graph._undirectedSize++;
  else graph._directedSize++;

  // Emitting
  eventData.key = edge;

  graph.emit('edgeAdded', eventData);

  return [edge, true, sourceWasAdded, targetWasAdded];
}

/**
 * Internal method used to drop an edge.
 *
 * @param  {Graph}    graph    - Target graph.
 * @param  {EdgeData} edgeData - Data of the edge to drop.
 */
function dropEdgeFromData(graph, edgeData) {
  // Dropping the edge from the register
  graph._edges.delete(edgeData.key);

  // Updating related degrees
  const {source: sourceData, target: targetData, attributes} = edgeData;

  const undirected = edgeData.undirected;

  const isSelfLoop = sourceData === targetData;

  if (undirected) {
    sourceData.undirectedDegree--;
    targetData.undirectedDegree--;

    if (isSelfLoop) {
      sourceData.undirectedLoops--;
      graph._undirectedSelfLoopCount--;
    }
  } else {
    sourceData.outDegree--;
    targetData.inDegree--;

    if (isSelfLoop) {
      sourceData.directedLoops--;
      graph._directedSelfLoopCount--;
    }
  }

  // Clearing index
  if (graph.multi) edgeData.detachMulti();
  else edgeData.detach();

  if (undirected) graph._undirectedSize--;
  else graph._directedSize--;

  // Emitting
  graph.emit('edgeDropped', {
    key: edgeData.key,
    attributes,
    source: sourceData.key,
    target: targetData.key,
    undirected
  });
}

/**
 * Graph class
 *
 * @constructor
 * @param  {object}  [options] - Options:
 * @param  {boolean}   [allowSelfLoops] - Allow self loops?
 * @param  {string}    [type]           - Type of the graph.
 * @param  {boolean}   [map]            - Allow references as keys?
 * @param  {boolean}   [multi]          - Allow parallel edges?
 *
 * @throws {Error} - Will throw if the arguments are not valid.
 */
class Graph extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {
  constructor(options) {
    super();

    //-- Solving options
    options = assign({}, DEFAULTS, options);

    // Enforcing options validity
    if (typeof options.multi !== 'boolean')
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${options.multi}".`
      );

    if (!TYPES.has(options.type))
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${options.type}".`
      );

    if (typeof options.allowSelfLoops !== 'boolean')
      throw new InvalidArgumentsGraphError(
        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${options.allowSelfLoops}".`
      );

    //-- Private properties

    // Utilities
    const NodeDataClass =
      options.type === 'mixed'
        ? MixedNodeData
        : options.type === 'directed'
        ? DirectedNodeData
        : UndirectedNodeData;

    privateProperty(this, 'NodeDataClass', NodeDataClass);

    // Internal edge key generator

    // NOTE: this internal generator produce keys that are strings
    // composed of a weird prefix, an incremental instance id starting from
    // a random byte and finally an internal instance incremental id.
    // All this to avoid intra-frame and cross-frame adversarial inputs
    // that can force a single #.addEdge call to degenerate into a O(n)
    // available key search loop.

    // It also ensures that automatically generated edge keys are unlikely
    // to produce collisions with arbitrary keys given by users.
    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';
    let edgeId = 0;

    const edgeKeyGenerator = () => {
      let availableEdgeKey;

      do {
        availableEdgeKey = instancePrefix + edgeId++;
      } while (this._edges.has(availableEdgeKey));

      return availableEdgeKey;
    };

    // Indexes
    privateProperty(this, '_attributes', {});
    privateProperty(this, '_nodes', new Map());
    privateProperty(this, '_edges', new Map());
    privateProperty(this, '_directedSize', 0);
    privateProperty(this, '_undirectedSize', 0);
    privateProperty(this, '_directedSelfLoopCount', 0);
    privateProperty(this, '_undirectedSelfLoopCount', 0);
    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);

    // Options
    privateProperty(this, '_options', options);

    // Emitter properties
    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));

    //-- Properties readers
    readOnlyProperty(this, 'order', () => this._nodes.size);
    readOnlyProperty(this, 'size', () => this._edges.size);
    readOnlyProperty(this, 'directedSize', () => this._directedSize);
    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);
    readOnlyProperty(
      this,
      'selfLoopCount',
      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount
    );
    readOnlyProperty(
      this,
      'directedSelfLoopCount',
      () => this._directedSelfLoopCount
    );
    readOnlyProperty(
      this,
      'undirectedSelfLoopCount',
      () => this._undirectedSelfLoopCount
    );
    readOnlyProperty(this, 'multi', this._options.multi);
    readOnlyProperty(this, 'type', this._options.type);
    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);
    readOnlyProperty(this, 'implementation', () => 'graphology');
  }

  _resetInstanceCounters() {
    this._directedSize = 0;
    this._undirectedSize = 0;
    this._directedSelfLoopCount = 0;
    this._undirectedSelfLoopCount = 0;
  }

  /**---------------------------------------------------------------------------
   * Read
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning whether the given node is found in the graph.
   *
   * @param  {any}     node - The node.
   * @return {boolean}
   */
  hasNode(node) {
    return this._nodes.has('' + node);
  }

  /**
   * Method returning whether the given directed edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasDirectedEdge(source, target) {
    // Early termination
    if (this.type === 'undirected') return false;

    if (arguments.length === 1) {
      const edge = '' + source;

      const edgeData = this._edges.get(edge);

      return !!edgeData && !edgeData.undirected;
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return nodeData.out.hasOwnProperty(target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning whether the given undirected edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasUndirectedEdge(source, target) {
    // Early termination
    if (this.type === 'directed') return false;

    if (arguments.length === 1) {
      const edge = '' + source;

      const edgeData = this._edges.get(edge);

      return !!edgeData && edgeData.undirected;
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return nodeData.undirected.hasOwnProperty(target);
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning whether the given edge is found in the graph.
   *
   * Arity 1:
   * @param  {any}     edge - The edge's key.
   *
   * Arity 2:
   * @param  {any}     source - The edge's source.
   * @param  {any}     target - The edge's target.
   *
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the arguments are invalid.
   */
  hasEdge(source, target) {
    if (arguments.length === 1) {
      const edge = '' + source;

      return this._edges.has(edge);
    } else if (arguments.length === 2) {
      source = '' + source;
      target = '' + target;

      // If the node source or the target is not in the graph we break
      const nodeData = this._nodes.get(source);

      if (!nodeData) return false;

      // Is there a directed edge pointing toward target?
      return (
        (typeof nodeData.out !== 'undefined' &&
          nodeData.out.hasOwnProperty(target)) ||
        (typeof nodeData.undirected !== 'undefined' &&
          nodeData.undirected.hasOwnProperty(target))
      );
    }

    throw new InvalidArgumentsGraphError(
      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`
    );
  }

  /**
   * Method returning the edge matching source & target in a directed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  directedEdge(source, target) {
    if (this.type === 'undirected') return;

    source = '' + source;
    target = '' + target;

    if (this.multi)
      throw new UsageGraphError(
        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'
      );

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.directedEdge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.directedEdge: could not find the "${target}" target node in the graph.`
      );

    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning the edge matching source & target in a undirected fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  undirectedEdge(source, target) {
    if (this.type === 'directed') return;

    source = '' + source;
    target = '' + target;

    if (this.multi)
      throw new UsageGraphError(
        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'
      );

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.undirectedEdge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.undirectedEdge: could not find the "${target}" target node in the graph.`
      );

    const edgeData =
      (sourceData.undirected && sourceData.undirected[target]) || undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning the edge matching source & target in a mixed fashion.
   *
   * @param  {any} source - The edge's source.
   * @param  {any} target - The edge's target.
   *
   * @return {any|undefined}
   *
   * @throws {Error} - Will throw if the graph is multi.
   * @throws {Error} - Will throw if source or target doesn't exist.
   */
  edge(source, target) {
    if (this.multi)
      throw new UsageGraphError(
        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'
      );

    source = '' + source;
    target = '' + target;

    const sourceData = this._nodes.get(source);

    if (!sourceData)
      throw new NotFoundGraphError(
        `Graph.edge: could not find the "${source}" source node in the graph.`
      );

    if (!this._nodes.has(target))
      throw new NotFoundGraphError(
        `Graph.edge: could not find the "${target}" target node in the graph.`
      );

    const edgeData =
      (sourceData.out && sourceData.out[target]) ||
      (sourceData.undirected && sourceData.undirected[target]) ||
      undefined;

    if (edgeData) return edgeData.key;
  }

  /**
   * Method returning whether two nodes are directed neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areDirectedNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areDirectedNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.in || neighbor in nodeData.out;
  }

  /**
   * Method returning whether two nodes are out neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areOutNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areOutNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.out;
  }

  /**
   * Method returning whether two nodes are in neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areInNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areInNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return false;

    return neighbor in nodeData.in;
  }

  /**
   * Method returning whether two nodes are undirected neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areUndirectedNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areUndirectedNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return false;

    return neighbor in nodeData.undirected;
  }

  /**
   * Method returning whether two nodes are neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning whether two nodes are inbound neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areInboundNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areInboundNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.in) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning whether two nodes are outbound neighbors.
   *
   * @param  {any}     node     - The node's key.
   * @param  {any}     neighbor - The neighbor's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  areOutboundNeighbors(node, neighbor) {
    node = '' + node;
    neighbor = '' + neighbor;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.areOutboundNeighbors: could not find the "${node}" node in the graph.`
      );

    if (this.type !== 'undirected') {
      if (neighbor in nodeData.out) return true;
    }

    if (this.type !== 'directed') {
      if (neighbor in nodeData.undirected) return true;
    }

    return false;
  }

  /**
   * Method returning the given node's in degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree;
  }

  /**
   * Method returning the given node's out degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.outDegree;
  }

  /**
   * Method returning the given node's directed degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  directedDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.directedDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree + nodeData.outDegree;
  }

  /**
   * Method returning the given node's undirected degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  undirectedDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.undirectedDegree: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return 0;

    return nodeData.undirectedDegree;
  }

  /**
   * Method returning the given node's inbound degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's inbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inboundDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inboundDegree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's outbound degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's outbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outboundDegree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outboundDegree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.outDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's directed degree.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  degree(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.degree: could not find the "${node}" node in the graph.`
      );

    let degree = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree + nodeData.outDegree;
    }

    return degree;
  }

  /**
   * Method returning the given node's in degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree - nodeData.directedLoops;
  }

  /**
   * Method returning the given node's out degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.outDegree - nodeData.directedLoops;
  }

  /**
   * Method returning the given node's directed degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  directedDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.directedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'undirected') return 0;

    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;
  }

  /**
   * Method returning the given node's undirected degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's in degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  undirectedDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.undirectedDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    if (this.type === 'directed') return 0;

    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;
  }

  /**
   * Method returning the given node's inbound degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's inbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  inboundDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.inboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree;
      loops += nodeData.directedLoops;
    }

    return degree - loops;
  }

  /**
   * Method returning the given node's outbound degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's outbound degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  outboundDegreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.outboundDegreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.outDegree;
      loops += nodeData.directedLoops;
    }

    return degree - loops;
  }

  /**
   * Method returning the given node's directed degree without considering self loops.
   *
   * @param  {any}     node - The node's key.
   * @return {number}       - The node's degree.
   *
   * @throws {Error} - Will throw if the node isn't in the graph.
   */
  degreeWithoutSelfLoops(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.degreeWithoutSelfLoops: could not find the "${node}" node in the graph.`
      );

    let degree = 0;
    let loops = 0;

    if (this.type !== 'directed') {
      degree += nodeData.undirectedDegree;
      loops += nodeData.undirectedLoops * 2;
    }

    if (this.type !== 'undirected') {
      degree += nodeData.inDegree + nodeData.outDegree;
      loops += nodeData.directedLoops * 2;
    }

    return degree - loops;
  }

  /**
   * Method returning the given edge's source.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's source.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  source(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.source: could not find the "${edge}" edge in the graph.`
      );

    return data.source.key;
  }

  /**
   * Method returning the given edge's target.
   *
   * @param  {any} edge - The edge's key.
   * @return {any}      - The edge's target.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  target(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.target: could not find the "${edge}" edge in the graph.`
      );

    return data.target.key;
  }

  /**
   * Method returning the given edge's extremities.
   *
   * @param  {any}   edge - The edge's key.
   * @return {array}      - The edge's extremities.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  extremities(edge) {
    edge = '' + edge;

    const edgeData = this._edges.get(edge);

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.extremities: could not find the "${edge}" edge in the graph.`
      );

    return [edgeData.source.key, edgeData.target.key];
  }

  /**
   * Given a node & an edge, returns the other extremity of the edge.
   *
   * @param  {any}   node - The node's key.
   * @param  {any}   edge - The edge's key.
   * @return {any}        - The related node.
   *
   * @throws {Error} - Will throw if the edge isn't in the graph or if the
   *                   edge & node are not related.
   */
  opposite(node, edge) {
    node = '' + node;
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.opposite: could not find the "${edge}" edge in the graph.`
      );

    const source = data.source.key;
    const target = data.target.key;

    if (node === source) return target;
    if (node === target) return source;

    throw new NotFoundGraphError(
      `Graph.opposite: the "${node}" node is not attached to the "${edge}" edge (${source}, ${target}).`
    );
  }

  /**
   * Returns whether the given edge has the given node as extremity.
   *
   * @param  {any}     edge - The edge's key.
   * @param  {any}     node - The node's key.
   * @return {boolean}      - The related node.
   *
   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.
   */
  hasExtremity(edge, node) {
    edge = '' + edge;
    node = '' + node;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.hasExtremity: could not find the "${edge}" edge in the graph.`
      );

    return data.source.key === node || data.target.key === node;
  }

  /**
   * Method returning whether the given edge is undirected.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isUndirected(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isUndirected: could not find the "${edge}" edge in the graph.`
      );

    return data.undirected;
  }

  /**
   * Method returning whether the given edge is directed.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isDirected(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isDirected: could not find the "${edge}" edge in the graph.`
      );

    return !data.undirected;
  }

  /**
   * Method returning whether the given edge is a self loop.
   *
   * @param  {any}     edge - The edge's key.
   * @return {boolean}
   *
   * @throws {Error} - Will throw if the edge isn't in the graph.
   */
  isSelfLoop(edge) {
    edge = '' + edge;

    const data = this._edges.get(edge);

    if (!data)
      throw new NotFoundGraphError(
        `Graph.isSelfLoop: could not find the "${edge}" edge in the graph.`
      );

    return data.source === data.target;
  }

  /**---------------------------------------------------------------------------
   * Mutation
   **---------------------------------------------------------------------------
   */

  /**
   * Method used to add a node to the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   *
   * @throws {Error} - Will throw if the given node already exist.
   * @throws {Error} - Will throw if the given attributes are not an object.
   */
  addNode(node, attributes) {
    const nodeData = addNode(this, node, attributes);

    return nodeData.key;
  }

  /**
   * Method used to merge a node into the graph.
   *
   * @param  {any}    node         - The node.
   * @param  {object} [attributes] - Optional attributes.
   * @return {any}                 - The node.
   */
  mergeNode(node, attributes) {
    if (attributes && !isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        `Graph.mergeNode: invalid attributes. Expecting an object but got "${attributes}"`
      );

    // String coercion
    node = '' + node;
    attributes = attributes || {};

    // If the node already exists, we merge the attributes
    let data = this._nodes.get(node);

    if (data) {
      if (attributes) {
        assign(data.attributes, attributes);

        this.emit('nodeAttributesUpdated', {
          type: 'merge',
          key: node,
          attributes: data.attributes,
          data: attributes
        });
      }
      return [node, false];
    }

    data = new this.NodeDataClass(node, attributes);

    // Adding the node to internal register
    this._nodes.set(node, data);

    // Emitting
    this.emit('nodeAdded', {
      key: node,
      attributes
    });

    return [node, true];
  }

  /**
   * Method used to add a node if it does not exist in the graph or else to
   * update its attributes using a function.
   *
   * @param  {any}      node      - The node.
   * @param  {function} [updater] - Optional updater function.
   * @return {any}                - The node.
   */
  updateNode(node, updater) {
    if (updater && typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        `Graph.updateNode: invalid updater function. Expecting a function but got "${updater}"`
      );

    // String coercion
    node = '' + node;

    // If the node already exists, we update the attributes
    let data = this._nodes.get(node);

    if (data) {
      if (updater) {
        const oldAttributes = data.attributes;
        data.attributes = updater(oldAttributes);

        this.emit('nodeAttributesUpdated', {
          type: 'replace',
          key: node,
          attributes: data.attributes
        });
      }
      return [node, false];
    }

    const attributes = updater ? updater({}) : {};

    data = new this.NodeDataClass(node, attributes);

    // Adding the node to internal register
    this._nodes.set(node, data);

    // Emitting
    this.emit('nodeAdded', {
      key: node,
      attributes
    });

    return [node, true];
  }

  /**
   * Method used to drop a single node & all its attached edges from the graph.
   *
   * @param  {any}    node - The node.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the node doesn't exist.
   */
  dropNode(node) {
    node = '' + node;

    const nodeData = this._nodes.get(node);

    if (!nodeData)
      throw new NotFoundGraphError(
        `Graph.dropNode: could not find the "${node}" node in the graph.`
      );

    let edgeData;

    // Removing attached edges
    // NOTE: we could be faster here, but this is such a pain to maintain
    if (this.type !== 'undirected') {
      for (const neighbor in nodeData.out) {
        edgeData = nodeData.out[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }

      for (const neighbor in nodeData.in) {
        edgeData = nodeData.in[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    if (this.type !== 'directed') {
      for (const neighbor in nodeData.undirected) {
        edgeData = nodeData.undirected[neighbor];

        do {
          dropEdgeFromData(this, edgeData);
          edgeData = edgeData.next;
        } while (edgeData);
      }
    }

    // Dropping the node from the register
    this._nodes.delete(node);

    // Emitting
    this.emit('nodeDropped', {
      key: node,
      attributes: nodeData.attributes
    });
  }

  /**
   * Method used to drop a single edge from the graph.
   *
   * Arity 1:
   * @param  {any}    edge - The edge.
   *
   * Arity 2:
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropEdge(edge) {
    let edgeData;

    if (arguments.length > 1) {
      const source = '' + arguments[0];
      const target = '' + arguments[1];

      edgeData = getMatchingEdge(this, source, target, this.type);

      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropEdge: could not find the "${source}" -> "${target}" edge in the graph.`
        );
    } else {
      edge = '' + edge;

      edgeData = this._edges.get(edge);

      if (!edgeData)
        throw new NotFoundGraphError(
          `Graph.dropEdge: could not find the "${edge}" edge in the graph.`
        );
    }

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to drop a single directed edge from the graph.
   *
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropDirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError(
        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
      );

    if (this.multi)
      throw new UsageGraphError(
        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
      );

    source = '' + source;
    target = '' + target;

    const edgeData = getMatchingEdge(this, source, target, 'directed');

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.dropDirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
      );

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to drop a single undirected edge from the graph.
   *
   * @param  {any}    source - Source node.
   * @param  {any}    target - Target node.
   *
   * @return {Graph}
   *
   * @throws {Error} - Will throw if the edge doesn't exist.
   */
  dropUndirectedEdge(source, target) {
    if (arguments.length < 2)
      throw new UsageGraphError(
        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'
      );

    if (this.multi)
      throw new UsageGraphError(
        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'
      );

    const edgeData = getMatchingEdge(this, source, target, 'undirected');

    if (!edgeData)
      throw new NotFoundGraphError(
        `Graph.dropUndirectedEdge: could not find a "${source}" -> "${target}" edge in the graph.`
      );

    dropEdgeFromData(this, edgeData);

    return this;
  }

  /**
   * Method used to remove every edge & every node from the graph.
   *
   * @return {Graph}
   */
  clear() {
    // Clearing edges
    this._edges.clear();

    // Clearing nodes
    this._nodes.clear();

    // Reset counters
    this._resetInstanceCounters();

    // Emitting
    this.emit('cleared');
  }

  /**
   * Method used to remove every edge from the graph.
   *
   * @return {Graph}
   */
  clearEdges() {
    // Clearing structure index
    const iterator = this._nodes.values();

    let step;

    while (((step = iterator.next()), step.done !== true)) {
      step.value.clear();
    }

    // Clearing edges
    this._edges.clear();

    // Reset counters
    this._resetInstanceCounters();

    // Emitting
    this.emit('edgesCleared');
  }

  /**---------------------------------------------------------------------------
   * Attributes-related methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning the desired graph's attribute.
   *
   * @param  {string} name - Name of the attribute.
   * @return {any}
   */
  getAttribute(name) {
    return this._attributes[name];
  }

  /**
   * Method returning the graph's attributes.
   *
   * @return {object}
   */
  getAttributes() {
    return this._attributes;
  }

  /**
   * Method returning whether the graph has the desired attribute.
   *
   * @param  {string}  name - Name of the attribute.
   * @return {boolean}
   */
  hasAttribute(name) {
    return this._attributes.hasOwnProperty(name);
  }

  /**
   * Method setting a value for the desired graph's attribute.
   *
   * @param  {string}  name  - Name of the attribute.
   * @param  {any}     value - Value for the attribute.
   * @return {Graph}
   */
  setAttribute(name, value) {
    this._attributes[name] = value;

    // Emitting
    this.emit('attributesUpdated', {
      type: 'set',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method using a function to update the desired graph's attribute's value.
   *
   * @param  {string}   name    - Name of the attribute.
   * @param  {function} updater - Function use to update the attribute's value.
   * @return {Graph}
   */
  updateAttribute(name, updater) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateAttribute: updater should be a function.'
      );

    const value = this._attributes[name];

    this._attributes[name] = updater(value);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'set',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method removing the desired graph's attribute.
   *
   * @param  {string} name  - Name of the attribute.
   * @return {Graph}
   */
  removeAttribute(name) {
    delete this._attributes[name];

    // Emitting
    this.emit('attributesUpdated', {
      type: 'remove',
      attributes: this._attributes,
      name
    });

    return this;
  }

  /**
   * Method replacing the graph's attributes.
   *
   * @param  {object} attributes - New attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  replaceAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        'Graph.replaceAttributes: provided attributes are not a plain object.'
      );

    this._attributes = attributes;

    // Emitting
    this.emit('attributesUpdated', {
      type: 'replace',
      attributes: this._attributes
    });

    return this;
  }

  /**
   * Method merging the graph's attributes.
   *
   * @param  {object} attributes - Attributes to merge.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given attributes are not a plain object.
   */
  mergeAttributes(attributes) {
    if (!isPlainObject(attributes))
      throw new InvalidArgumentsGraphError(
        'Graph.mergeAttributes: provided attributes are not a plain object.'
      );

    assign(this._attributes, attributes);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'merge',
      attributes: this._attributes,
      data: attributes
    });

    return this;
  }

  /**
   * Method updating the graph's attributes.
   *
   * @param  {function} updater - Function used to update the attributes.
   * @return {Graph}
   *
   * @throws {Error} - Will throw if given updater is not a function.
   */
  updateAttributes(updater) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateAttributes: provided updater is not a function.'
      );

    this._attributes = updater(this._attributes);

    // Emitting
    this.emit('attributesUpdated', {
      type: 'update',
      attributes: this._attributes
    });

    return this;
  }

  /**
   * Method used to update each node's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachNodeAttributes(updater, hints) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachNodeAttributes: expecting an updater function.'
      );

    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      nodeData.attributes = updater(nodeData.key, nodeData.attributes);
    }

    this.emit('eachNodeAttributesUpdated', {
      hints: hints ? hints : null
    });
  }

  /**
   * Method used to update each edge's attributes using the given function.
   *
   * @param {function}  updater - Updater function to use.
   * @param {object}    [hints] - Optional hints.
   */
  updateEachEdgeAttributes(updater, hints) {
    if (typeof updater !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachEdgeAttributes: expecting an updater function.'
      );

    if (hints && !validateHints(hints))
      throw new InvalidArgumentsGraphError(
        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'
      );

    const iterator = this._edges.values();

    let step, edgeData, sourceData, targetData;

    while (((step = iterator.next()), step.done !== true)) {
      edgeData = step.value;
      sourceData = edgeData.source;
      targetData = edgeData.target;

      edgeData.attributes = updater(
        edgeData.key,
        edgeData.attributes,
        sourceData.key,
        targetData.key,
        sourceData.attributes,
        targetData.attributes,
        edgeData.undirected
      );
    }

    this.emit('eachEdgeAttributesUpdated', {
      hints: hints ? hints : null
    });
  }

  /**---------------------------------------------------------------------------
   * Iteration-related methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method iterating over the graph's adjacency using the given callback.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEachAdjacencyEntry(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAdjacencyEntry: expecting a callback.'
      );

    forEachAdjacency(false, false, false, this, callback);
  }
  forEachAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'
      );

    forEachAdjacency(false, false, true, this, callback);
  }

  /**
   * Method iterating over the graph's assymetric adjacency using the given callback.
   *
   * @param  {function}  callback - Callback to use.
   */
  forEachAssymetricAdjacencyEntry(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'
      );

    forEachAdjacency(false, true, false, this, callback);
  }
  forEachAssymetricAdjacencyEntryWithOrphans(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'
      );

    forEachAdjacency(false, true, true, this, callback);
  }

  /**
   * Method returning the list of the graph's nodes.
   *
   * @return {array} - The nodes.
   */
  nodes() {
    return Array.from(this._nodes.keys());
  }

  /**
   * Method iterating over the graph's nodes using the given callback.
   *
   * @param  {function}  callback - Callback (key, attributes, index).
   */
  forEachNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.forEachNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      callback(nodeData.key, nodeData.attributes);
    }
  }

  /**
   * Method iterating attempting to find a node matching the given predicate
   * function.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  findNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.findNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;
    }

    return;
  }

  /**
   * Method mapping nodes.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  mapNodes(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.mapNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    const result = new Array(this.order);
    let i = 0;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      result[i++] = callback(nodeData.key, nodeData.attributes);
    }

    return result;
  }

  /**
   * Method returning whether some node verify the given predicate.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  someNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.someNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes)) return true;
    }

    return false;
  }

  /**
   * Method returning whether all node verify the given predicate.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  everyNode(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.everyNode: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (!callback(nodeData.key, nodeData.attributes)) return false;
    }

    return true;
  }

  /**
   * Method filtering nodes.
   *
   * @param  {function}  callback - Callback (key, attributes).
   */
  filterNodes(callback) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.filterNodes: expecting a callback.'
      );

    const iterator = this._nodes.values();

    let step, nodeData;

    const result = [];

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;

      if (callback(nodeData.key, nodeData.attributes))
        result.push(nodeData.key);
    }

    return result;
  }

  /**
   * Method reducing nodes.
   *
   * @param  {function}  callback - Callback (accumulator, key, attributes).
   */
  reduceNodes(callback, initialValue) {
    if (typeof callback !== 'function')
      throw new InvalidArgumentsGraphError(
        'Graph.reduceNodes: expecting a callback.'
      );

    if (arguments.length < 2)
      throw new InvalidArgumentsGraphError(
        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'
      );

    let accumulator = initialValue;

    const iterator = this._nodes.values();

    let step, nodeData;

    while (((step = iterator.next()), step.done !== true)) {
      nodeData = step.value;
      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);
    }

    return accumulator;
  }

  /**
   * Method returning an iterator over the graph's node entries.
   *
   * @return {Iterator}
   */
  nodeEntries() {
    const iterator = this._nodes.values();

    return {
      [Symbol.iterator]() {
        return this;
      },
      next() {
        const step = iterator.next();
        if (step.done) return step;
        const data = step.value;
        return {
          value: {node: data.key, attributes: data.attributes},
          done: false
        };
      }
    };
  }

  /**---------------------------------------------------------------------------
   * Serialization
   **---------------------------------------------------------------------------
   */

  /**
   * Method used to export the whole graph.
   *
   * @return {object} - The serialized graph.
   */
  export() {
    const nodes = new Array(this._nodes.size);

    let i = 0;

    this._nodes.forEach((data, key) => {
      nodes[i++] = serializeNode(key, data);
    });

    const edges = new Array(this._edges.size);

    i = 0;

    this._edges.forEach((data, key) => {
      edges[i++] = serializeEdge(this.type, key, data);
    });

    return {
      options: {
        type: this.type,
        multi: this.multi,
        allowSelfLoops: this.allowSelfLoops
      },
      attributes: this.getAttributes(),
      nodes,
      edges
    };
  }

  /**
   * Method used to import a serialized graph.
   *
   * @param  {object|Graph} data  - The serialized graph.
   * @param  {boolean}      merge - Whether to merge data.
   * @return {Graph}              - Returns itself for chaining.
   */
  import(data, merge = false) {
    // Importing a Graph instance directly
    if (data instanceof Graph) {
      // Nodes
      data.forEachNode((n, a) => {
        if (merge) this.mergeNode(n, a);
        else this.addNode(n, a);
      });

      // Edges
      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {
        if (merge) {
          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);
          else this.mergeDirectedEdgeWithKey(e, s, t, a);
        } else {
          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);
          else this.addDirectedEdgeWithKey(e, s, t, a);
        }
      });

      return this;
    }

    // Importing a serialized graph
    if (!isPlainObject(data))
      throw new InvalidArgumentsGraphError(
        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'
      );

    if (data.attributes) {
      if (!isPlainObject(data.attributes))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid attributes. Expecting a plain object.'
        );

      if (merge) this.mergeAttributes(data.attributes);
      else this.replaceAttributes(data.attributes);
    }

    let i, l, list, node, edge;

    if (data.nodes) {
      list = data.nodes;

      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid nodes. Expecting an array.'
        );

      for (i = 0, l = list.length; i < l; i++) {
        node = list[i];

        // Validating
        validateSerializedNode(node);

        // Adding the node
        const {key, attributes} = node;

        if (merge) this.mergeNode(key, attributes);
        else this.addNode(key, attributes);
      }
    }

    if (data.edges) {
      let undirectedByDefault = false;

      if (this.type === 'undirected') {
        undirectedByDefault = true;
      }

      list = data.edges;

      if (!Array.isArray(list))
        throw new InvalidArgumentsGraphError(
          'Graph.import: invalid edges. Expecting an array.'
        );

      for (i = 0, l = list.length; i < l; i++) {
        edge = list[i];

        // Validating
        validateSerializedEdge(edge);

        // Adding the edge
        const {
          source,
          target,
          attributes,
          undirected = undirectedByDefault
        } = edge;

        let method;

        if ('key' in edge) {
          method = merge
            ? undirected
              ? this.mergeUndirectedEdgeWithKey
              : this.mergeDirectedEdgeWithKey
            : undirected
            ? this.addUndirectedEdgeWithKey
            : this.addDirectedEdgeWithKey;

          method.call(this, edge.key, source, target, attributes);
        } else {
          method = merge
            ? undirected
              ? this.mergeUndirectedEdge
              : this.mergeDirectedEdge
            : undirected
            ? this.addUndirectedEdge
            : this.addDirectedEdge;

          method.call(this, source, target, attributes);
        }
      }
    }

    return this;
  }

  /**---------------------------------------------------------------------------
   * Utils
   **---------------------------------------------------------------------------
   */

  /**
   * Method returning a null copy of the graph, i.e. a graph without nodes
   * & edges but with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The null copy.
   */
  nullCopy(options) {
    const graph = new Graph(assign({}, this._options, options));
    graph.replaceAttributes(assign({}, this.getAttributes()));
    return graph;
  }

  /**
   * Method returning an empty copy of the graph, i.e. a graph without edges but
   * with the exact same options.
   *
   * @param  {object} options - Options to merge with the current ones.
   * @return {Graph}          - The empty copy.
   */
  emptyCopy(options) {
    const graph = this.nullCopy(options);

    this._nodes.forEach((nodeData, key) => {
      const attributes = assign({}, nodeData.attributes);

      // NOTE: no need to emit events since user cannot access the instance yet
      nodeData = new graph.NodeDataClass(key, attributes);
      graph._nodes.set(key, nodeData);
    });

    return graph;
  }

  /**
   * Method returning an exact copy of the graph.
   *
   * @param  {object} options - Upgrade options.
   * @return {Graph}          - The copy.
   */
  copy(options) {
    options = options || {};

    if (
      typeof options.type === 'string' &&
      options.type !== this.type &&
      options.type !== 'mixed'
    )
      throw new UsageGraphError(
        `Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${options.type}" because this would mean losing information about the current graph.`
      );

    if (
      typeof options.multi === 'boolean' &&
      options.multi !== this.multi &&
      options.multi !== true
    )
      throw new UsageGraphError(
        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'
      );

    if (
      typeof options.allowSelfLoops === 'boolean' &&
      options.allowSelfLoops !== this.allowSelfLoops &&
      options.allowSelfLoops !== true
    )
      throw new UsageGraphError(
        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'
      );

    const graph = this.emptyCopy(options);

    const iterator = this._edges.values();

    let step, edgeData;

    while (((step = iterator.next()), step.done !== true)) {
      edgeData = step.value;

      // NOTE: no need to emit events since user cannot access the instance yet
      addEdge(
        graph,
        'copy',
        false,
        edgeData.undirected,
        edgeData.key,
        edgeData.source.key,
        edgeData.target.key,
        assign({}, edgeData.attributes)
      );
    }

    return graph;
  }

  /**---------------------------------------------------------------------------
   * Known methods
   **---------------------------------------------------------------------------
   */

  /**
   * Method used by JavaScript to perform JSON serialization.
   *
   * @return {object} - The serialized graph.
   */
  toJSON() {
    return this.export();
  }

  /**
   * Method returning [object Graph].
   */
  toString() {
    return '[object Graph]';
  }

  /**
   * Method used internally by node's console to display a custom object.
   *
   * @return {object} - Formatted object representation of the graph.
   */
  inspect() {
    const nodes = {};
    this._nodes.forEach((data, key) => {
      nodes[key] = data.attributes;
    });

    const edges = {},
      multiIndex = {};

    this._edges.forEach((data, key) => {
      const direction = data.undirected ? '--' : '->';

      let label = '';

      let source = data.source.key;
      let target = data.target.key;
      let tmp;

      if (data.undirected && source > target) {
        tmp = source;
        source = target;
        target = tmp;
      }

      const desc = `(${source})${direction}(${target})`;

      if (!key.startsWith('geid_')) {
        label += `[${key}]: `;
      } else if (this.multi) {
        if (typeof multiIndex[desc] === 'undefined') {
          multiIndex[desc] = 0;
        } else {
          multiIndex[desc]++;
        }

        label += `${multiIndex[desc]}. `;
      }

      label += desc;

      edges[label] = data.attributes;
    });

    const dummy = {};

    for (const k in this) {
      if (
        this.hasOwnProperty(k) &&
        !EMITTER_PROPS.has(k) &&
        typeof this[k] !== 'function' &&
        typeof k !== 'symbol'
      )
        dummy[k] = this[k];
    }

    dummy.attributes = this._attributes;
    dummy.nodes = nodes;
    dummy.edges = edges;

    privateProperty(dummy, 'constructor', this.constructor);

    return dummy;
  }
}

/**
 * Attaching methods to the prototype.
 *
 * Here, we are attaching a wide variety of methods to the Graph class'
 * prototype when those are very numerous and when their creation is
 * abstracted.
 */

/**
 * Attaching custom inspect method for node >= 10.
 */
if (typeof Symbol !== 'undefined')
  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =
    Graph.prototype.inspect;

/**
 * Related to edge addition.
 */
EDGE_ADD_METHODS.forEach(method => {
  ['add', 'merge', 'update'].forEach(verb => {
    const name = method.name(verb);
    const fn = verb === 'add' ? addEdge : mergeEdge;

    if (method.generateKey) {
      Graph.prototype[name] = function (source, target, attributes) {
        return fn(
          this,
          name,
          true,
          (method.type || this.type) === 'undirected',
          null,
          source,
          target,
          attributes,
          verb === 'update'
        );
      };
    } else {
      Graph.prototype[name] = function (edge, source, target, attributes) {
        return fn(
          this,
          name,
          false,
          (method.type || this.type) === 'undirected',
          edge,
          source,
          target,
          attributes,
          verb === 'update'
        );
      };
    }
  });
});

/**
 * Attributes-related.
 */
attachNodeAttributesMethods(Graph);
attachEdgeAttributesMethods(Graph);

/**
 * Edge iteration-related.
 */
attachEdgeIterationMethods(Graph);

/**
 * Neighbor iteration-related.
 */
attachNeighborIterationMethods(Graph);

/**
 * Graphology Helper Classes
 * ==========================
 *
 * Building some higher-order classes instantiating the graph with
 * predefinite options.
 */

/**
 * Alternative constructors.
 */
class DirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'directed'}, options);

    if ('multi' in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError(
        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
      );

    if (finalOptions.type !== 'directed')
      throw new InvalidArgumentsGraphError(
        'DirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class UndirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'undirected'}, options);

    if ('multi' in finalOptions && finalOptions.multi !== false)
      throw new InvalidArgumentsGraphError(
        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'
      );

    if (finalOptions.type !== 'undirected')
      throw new InvalidArgumentsGraphError(
        'UndirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class MultiGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    super(finalOptions);
  }
}
class MultiDirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'directed', multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    if (finalOptions.type !== 'directed')
      throw new InvalidArgumentsGraphError(
        'MultiDirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}
class MultiUndirectedGraph extends Graph {
  constructor(options) {
    const finalOptions = assign({type: 'undirected', multi: true}, options);

    if ('multi' in finalOptions && finalOptions.multi !== true)
      throw new InvalidArgumentsGraphError(
        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'
      );

    if (finalOptions.type !== 'undirected')
      throw new InvalidArgumentsGraphError(
        'MultiUndirectedGraph.from: inconsistent "' +
          finalOptions.type +
          '" type in given options!'
      );

    super(finalOptions);
  }
}

/**
 * Attaching static #.from method to each of the constructors.
 */
function attachStaticFromMethod(Class) {
  /**
   * Builds a graph from serialized data or another graph's data.
   *
   * @param  {Graph|SerializedGraph} data      - Hydratation data.
   * @param  {object}                [options] - Options.
   * @return {Class}
   */
  Class.from = function (data, options) {
    // Merging given options with serialized ones
    const finalOptions = assign({}, data.options, options);

    const instance = new Class(finalOptions);
    instance.import(data);

    return instance;
  };
}

attachStaticFromMethod(Graph);
attachStaticFromMethod(DirectedGraph);
attachStaticFromMethod(UndirectedGraph);
attachStaticFromMethod(MultiGraph);
attachStaticFromMethod(MultiDirectedGraph);
attachStaticFromMethod(MultiUndirectedGraph);

Graph.Graph = Graph;
Graph.DirectedGraph = DirectedGraph;
Graph.UndirectedGraph = UndirectedGraph;
Graph.MultiGraph = MultiGraph;
Graph.MultiDirectedGraph = MultiDirectedGraph;
Graph.MultiUndirectedGraph = MultiUndirectedGraph;

Graph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;
Graph.NotFoundGraphError = NotFoundGraphError;
Graph.UsageGraphError = UsageGraphError;

/**
 * Graphology ESM Endoint
 * =======================
 *
 * Endpoint for ESM modules consumers.
 */


//# sourceMappingURL=graphology.mjs.map


/***/ }),

/***/ "./node_modules/papaparse/papaparse.min.js":
/*!*************************************************!*\
  !*** ./node_modules/papaparse/papaparse.min.js ***!
  \*************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* @license
Papa Parse
v5.5.3
https://github.com/mholt/PapaParse
License: MIT
*/
((e,t)=>{ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0})(this,function r(){var n="undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==n?n:{};var d,s=!n.document&&!!n.postMessage,a=n.IS_PAPA_WORKER||!1,o={},h=0,v={};function u(e){this._handle=null,this._finished=!1,this._completed=!1,this._halted=!1,this._input=null,this._baseIndex=0,this._partialLine="",this._rowCount=0,this._start=0,this._nextChunk=null,this.isFirstChunk=!0,this._completeResults={data:[],errors:[],meta:{}},function(e){var t=b(e);t.chunkSize=parseInt(t.chunkSize),e.step||e.chunk||(t.chunkSize=null);this._handle=new i(t),(this._handle.streamer=this)._config=t}.call(this,e),this.parseChunk=function(t,e){var i=parseInt(this._config.skipFirstNLines)||0;if(this.isFirstChunk&&0<i){let e=this._config.newline;e||(r=this._config.quoteChar||'"',e=this._handle.guessLineEndings(t,r)),t=[...t.split(e).slice(i)].join(e)}this.isFirstChunk&&U(this._config.beforeFirstChunk)&&void 0!==(r=this._config.beforeFirstChunk(t))&&(t=r),this.isFirstChunk=!1,this._halted=!1;var i=this._partialLine+t,r=(this._partialLine="",this._handle.parse(i,this._baseIndex,!this._finished));if(!this._handle.paused()&&!this._handle.aborted()){t=r.meta.cursor,i=(this._finished||(this._partialLine=i.substring(t-this._baseIndex),this._baseIndex=t),r&&r.data&&(this._rowCount+=r.data.length),this._finished||this._config.preview&&this._rowCount>=this._config.preview);if(a)n.postMessage({results:r,workerId:v.WORKER_ID,finished:i});else if(U(this._config.chunk)&&!e){if(this._config.chunk(r,this._handle),this._handle.paused()||this._handle.aborted())return void(this._halted=!0);this._completeResults=r=void 0}return this._config.step||this._config.chunk||(this._completeResults.data=this._completeResults.data.concat(r.data),this._completeResults.errors=this._completeResults.errors.concat(r.errors),this._completeResults.meta=r.meta),this._completed||!i||!U(this._config.complete)||r&&r.meta.aborted||(this._config.complete(this._completeResults,this._input),this._completed=!0),i||r&&r.meta.paused||this._nextChunk(),r}this._halted=!0},this._sendError=function(e){U(this._config.error)?this._config.error(e):a&&this._config.error&&n.postMessage({workerId:v.WORKER_ID,error:e,finished:!1})}}function f(e){var r;(e=e||{}).chunkSize||(e.chunkSize=v.RemoteChunkSize),u.call(this,e),this._nextChunk=s?function(){this._readChunk(),this._chunkLoaded()}:function(){this._readChunk()},this.stream=function(e){this._input=e,this._nextChunk()},this._readChunk=function(){if(this._finished)this._chunkLoaded();else{if(r=new XMLHttpRequest,this._config.withCredentials&&(r.withCredentials=this._config.withCredentials),s||(r.onload=y(this._chunkLoaded,this),r.onerror=y(this._chunkError,this)),r.open(this._config.downloadRequestBody?"POST":"GET",this._input,!s),this._config.downloadRequestHeaders){var e,t=this._config.downloadRequestHeaders;for(e in t)r.setRequestHeader(e,t[e])}var i;this._config.chunkSize&&(i=this._start+this._config.chunkSize-1,r.setRequestHeader("Range","bytes="+this._start+"-"+i));try{r.send(this._config.downloadRequestBody)}catch(e){this._chunkError(e.message)}s&&0===r.status&&this._chunkError()}},this._chunkLoaded=function(){4===r.readyState&&(r.status<200||400<=r.status?this._chunkError():(this._start+=this._config.chunkSize||r.responseText.length,this._finished=!this._config.chunkSize||this._start>=(e=>null!==(e=e.getResponseHeader("Content-Range"))?parseInt(e.substring(e.lastIndexOf("/")+1)):-1)(r),this.parseChunk(r.responseText)))},this._chunkError=function(e){e=r.statusText||e;this._sendError(new Error(e))}}function l(e){(e=e||{}).chunkSize||(e.chunkSize=v.LocalChunkSize),u.call(this,e);var i,r,n="undefined"!=typeof FileReader;this.stream=function(e){this._input=e,r=e.slice||e.webkitSlice||e.mozSlice,n?((i=new FileReader).onload=y(this._chunkLoaded,this),i.onerror=y(this._chunkError,this)):i=new FileReaderSync,this._nextChunk()},this._nextChunk=function(){this._finished||this._config.preview&&!(this._rowCount<this._config.preview)||this._readChunk()},this._readChunk=function(){var e=this._input,t=(this._config.chunkSize&&(t=Math.min(this._start+this._config.chunkSize,this._input.size),e=r.call(e,this._start,t)),i.readAsText(e,this._config.encoding));n||this._chunkLoaded({target:{result:t}})},this._chunkLoaded=function(e){this._start+=this._config.chunkSize,this._finished=!this._config.chunkSize||this._start>=this._input.size,this.parseChunk(e.target.result)},this._chunkError=function(){this._sendError(i.error)}}function c(e){var i;u.call(this,e=e||{}),this.stream=function(e){return i=e,this._nextChunk()},this._nextChunk=function(){var e,t;if(!this._finished)return e=this._config.chunkSize,i=e?(t=i.substring(0,e),i.substring(e)):(t=i,""),this._finished=!i,this.parseChunk(t)}}function p(e){u.call(this,e=e||{});var t=[],i=!0,r=!1;this.pause=function(){u.prototype.pause.apply(this,arguments),this._input.pause()},this.resume=function(){u.prototype.resume.apply(this,arguments),this._input.resume()},this.stream=function(e){this._input=e,this._input.on("data",this._streamData),this._input.on("end",this._streamEnd),this._input.on("error",this._streamError)},this._checkIsFinished=function(){r&&1===t.length&&(this._finished=!0)},this._nextChunk=function(){this._checkIsFinished(),t.length?this.parseChunk(t.shift()):i=!0},this._streamData=y(function(e){try{t.push("string"==typeof e?e:e.toString(this._config.encoding)),i&&(i=!1,this._checkIsFinished(),this.parseChunk(t.shift()))}catch(e){this._streamError(e)}},this),this._streamError=y(function(e){this._streamCleanUp(),this._sendError(e)},this),this._streamEnd=y(function(){this._streamCleanUp(),r=!0,this._streamData("")},this),this._streamCleanUp=y(function(){this._input.removeListener("data",this._streamData),this._input.removeListener("end",this._streamEnd),this._input.removeListener("error",this._streamError)},this)}function i(m){var n,s,a,t,o=Math.pow(2,53),h=-o,u=/^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/,d=/^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/,i=this,r=0,f=0,l=!1,e=!1,c=[],p={data:[],errors:[],meta:{}};function y(e){return"greedy"===m.skipEmptyLines?""===e.join("").trim():1===e.length&&0===e[0].length}function g(){if(p&&a&&(k("Delimiter","UndetectableDelimiter","Unable to auto-detect delimiting character; defaulted to '"+v.DefaultDelimiter+"'"),a=!1),m.skipEmptyLines&&(p.data=p.data.filter(function(e){return!y(e)})),_()){if(p)if(Array.isArray(p.data[0])){for(var e=0;_()&&e<p.data.length;e++)p.data[e].forEach(t);p.data.splice(0,1)}else p.data.forEach(t);function t(e,t){U(m.transformHeader)&&(e=m.transformHeader(e,t)),c.push(e)}}function i(e,t){for(var i=m.header?{}:[],r=0;r<e.length;r++){var n=r,s=e[r],s=((e,t)=>(e=>(m.dynamicTypingFunction&&void 0===m.dynamicTyping[e]&&(m.dynamicTyping[e]=m.dynamicTypingFunction(e)),!0===(m.dynamicTyping[e]||m.dynamicTyping)))(e)?"true"===t||"TRUE"===t||"false"!==t&&"FALSE"!==t&&((e=>{if(u.test(e)){e=parseFloat(e);if(h<e&&e<o)return 1}})(t)?parseFloat(t):d.test(t)?new Date(t):""===t?null:t):t)(n=m.header?r>=c.length?"__parsed_extra":c[r]:n,s=m.transform?m.transform(s,n):s);"__parsed_extra"===n?(i[n]=i[n]||[],i[n].push(s)):i[n]=s}return m.header&&(r>c.length?k("FieldMismatch","TooManyFields","Too many fields: expected "+c.length+" fields but parsed "+r,f+t):r<c.length&&k("FieldMismatch","TooFewFields","Too few fields: expected "+c.length+" fields but parsed "+r,f+t)),i}var r;p&&(m.header||m.dynamicTyping||m.transform)&&(r=1,!p.data.length||Array.isArray(p.data[0])?(p.data=p.data.map(i),r=p.data.length):p.data=i(p.data,0),m.header&&p.meta&&(p.meta.fields=c),f+=r)}function _(){return m.header&&0===c.length}function k(e,t,i,r){e={type:e,code:t,message:i};void 0!==r&&(e.row=r),p.errors.push(e)}U(m.step)&&(t=m.step,m.step=function(e){p=e,_()?g():(g(),0!==p.data.length&&(r+=e.data.length,m.preview&&r>m.preview?s.abort():(p.data=p.data[0],t(p,i))))}),this.parse=function(e,t,i){var r=m.quoteChar||'"',r=(m.newline||(m.newline=this.guessLineEndings(e,r)),a=!1,m.delimiter?U(m.delimiter)&&(m.delimiter=m.delimiter(e),p.meta.delimiter=m.delimiter):((r=((e,t,i,r,n)=>{var s,a,o,h;n=n||[",","\t","|",";",v.RECORD_SEP,v.UNIT_SEP];for(var u=0;u<n.length;u++){for(var d,f=n[u],l=0,c=0,p=0,g=(o=void 0,new E({comments:r,delimiter:f,newline:t,preview:10}).parse(e)),_=0;_<g.data.length;_++)i&&y(g.data[_])?p++:(d=g.data[_].length,c+=d,void 0===o?o=d:0<d&&(l+=Math.abs(d-o),o=d));0<g.data.length&&(c/=g.data.length-p),(void 0===a||l<=a)&&(void 0===h||h<c)&&1.99<c&&(a=l,s=f,h=c)}return{successful:!!(m.delimiter=s),bestDelimiter:s}})(e,m.newline,m.skipEmptyLines,m.comments,m.delimitersToGuess)).successful?m.delimiter=r.bestDelimiter:(a=!0,m.delimiter=v.DefaultDelimiter),p.meta.delimiter=m.delimiter),b(m));return m.preview&&m.header&&r.preview++,n=e,s=new E(r),p=s.parse(n,t,i),g(),l?{meta:{paused:!0}}:p||{meta:{paused:!1}}},this.paused=function(){return l},this.pause=function(){l=!0,s.abort(),n=U(m.chunk)?"":n.substring(s.getCharIndex())},this.resume=function(){i.streamer._halted?(l=!1,i.streamer.parseChunk(n,!0)):setTimeout(i.resume,3)},this.aborted=function(){return e},this.abort=function(){e=!0,s.abort(),p.meta.aborted=!0,U(m.complete)&&m.complete(p),n=""},this.guessLineEndings=function(e,t){e=e.substring(0,1048576);var t=new RegExp(P(t)+"([^]*?)"+P(t),"gm"),i=(e=e.replace(t,"")).split("\r"),t=e.split("\n"),e=1<t.length&&t[0].length<i[0].length;if(1===i.length||e)return"\n";for(var r=0,n=0;n<i.length;n++)"\n"===i[n][0]&&r++;return r>=i.length/2?"\r\n":"\r"}}function P(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")}function E(C){var S=(C=C||{}).delimiter,O=C.newline,x=C.comments,I=C.step,A=C.preview,T=C.fastMode,D=null,L=!1,F=null==C.quoteChar?'"':C.quoteChar,j=F;if(void 0!==C.escapeChar&&(j=C.escapeChar),("string"!=typeof S||-1<v.BAD_DELIMITERS.indexOf(S))&&(S=","),x===S)throw new Error("Comment character same as delimiter");!0===x?x="#":("string"!=typeof x||-1<v.BAD_DELIMITERS.indexOf(x))&&(x=!1),"\n"!==O&&"\r"!==O&&"\r\n"!==O&&(O="\n");var z=0,M=!1;this.parse=function(i,t,r){if("string"!=typeof i)throw new Error("Input must be a string");var n=i.length,e=S.length,s=O.length,a=x.length,o=U(I),h=[],u=[],d=[],f=z=0;if(!i)return w();if(T||!1!==T&&-1===i.indexOf(F)){for(var l=i.split(O),c=0;c<l.length;c++){if(d=l[c],z+=d.length,c!==l.length-1)z+=O.length;else if(r)return w();if(!x||d.substring(0,a)!==x){if(o){if(h=[],k(d.split(S)),R(),M)return w()}else k(d.split(S));if(A&&A<=c)return h=h.slice(0,A),w(!0)}}return w()}for(var p=i.indexOf(S,z),g=i.indexOf(O,z),_=new RegExp(P(j)+P(F),"g"),m=i.indexOf(F,z);;)if(i[z]===F)for(m=z,z++;;){if(-1===(m=i.indexOf(F,m+1)))return r||u.push({type:"Quotes",code:"MissingQuotes",message:"Quoted field unterminated",row:h.length,index:z}),E();if(m===n-1)return E(i.substring(z,m).replace(_,F));if(F===j&&i[m+1]===j)m++;else if(F===j||0===m||i[m-1]!==j){-1!==p&&p<m+1&&(p=i.indexOf(S,m+1));var y=v(-1===(g=-1!==g&&g<m+1?i.indexOf(O,m+1):g)?p:Math.min(p,g));if(i.substr(m+1+y,e)===S){d.push(i.substring(z,m).replace(_,F)),i[z=m+1+y+e]!==F&&(m=i.indexOf(F,z)),p=i.indexOf(S,z),g=i.indexOf(O,z);break}y=v(g);if(i.substring(m+1+y,m+1+y+s)===O){if(d.push(i.substring(z,m).replace(_,F)),b(m+1+y+s),p=i.indexOf(S,z),m=i.indexOf(F,z),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0);break}u.push({type:"Quotes",code:"InvalidQuotes",message:"Trailing quote on quoted field is malformed",row:h.length,index:z}),m++}}else if(x&&0===d.length&&i.substring(z,z+a)===x){if(-1===g)return w();z=g+s,g=i.indexOf(O,z),p=i.indexOf(S,z)}else if(-1!==p&&(p<g||-1===g))d.push(i.substring(z,p)),z=p+e,p=i.indexOf(S,z);else{if(-1===g)break;if(d.push(i.substring(z,g)),b(g+s),o&&(R(),M))return w();if(A&&h.length>=A)return w(!0)}return E();function k(e){h.push(e),f=z}function v(e){var t=0;return t=-1!==e&&(e=i.substring(m+1,e))&&""===e.trim()?e.length:t}function E(e){return r||(void 0===e&&(e=i.substring(z)),d.push(e),z=n,k(d),o&&R()),w()}function b(e){z=e,k(d),d=[],g=i.indexOf(O,z)}function w(e){if(C.header&&!t&&h.length&&!L){var s=h[0],a=Object.create(null),o=new Set(s);let n=!1;for(let r=0;r<s.length;r++){let i=s[r];if(a[i=U(C.transformHeader)?C.transformHeader(i,r):i]){let e,t=a[i];for(;e=i+"_"+t,t++,o.has(e););o.add(e),s[r]=e,a[i]++,n=!0,(D=null===D?{}:D)[e]=i}else a[i]=1,s[r]=i;o.add(i)}n&&console.warn("Duplicate headers found and renamed."),L=!0}return{data:h,errors:u,meta:{delimiter:S,linebreak:O,aborted:M,truncated:!!e,cursor:f+(t||0),renamedHeaders:D}}}function R(){I(w()),h=[],u=[]}},this.abort=function(){M=!0},this.getCharIndex=function(){return z}}function g(e){var t=e.data,i=o[t.workerId],r=!1;if(t.error)i.userError(t.error,t.file);else if(t.results&&t.results.data){var n={abort:function(){r=!0,_(t.workerId,{data:[],errors:[],meta:{aborted:!0}})},pause:m,resume:m};if(U(i.userStep)){for(var s=0;s<t.results.data.length&&(i.userStep({data:t.results.data[s],errors:t.results.errors,meta:t.results.meta},n),!r);s++);delete t.results}else U(i.userChunk)&&(i.userChunk(t.results,n,t.file),delete t.results)}t.finished&&!r&&_(t.workerId,t.results)}function _(e,t){var i=o[e];U(i.userComplete)&&i.userComplete(t),i.terminate(),delete o[e]}function m(){throw new Error("Not implemented.")}function b(e){if("object"!=typeof e||null===e)return e;var t,i=Array.isArray(e)?[]:{};for(t in e)i[t]=b(e[t]);return i}function y(e,t){return function(){e.apply(t,arguments)}}function U(e){return"function"==typeof e}return v.parse=function(e,t){var i=(t=t||{}).dynamicTyping||!1;U(i)&&(t.dynamicTypingFunction=i,i={});if(t.dynamicTyping=i,t.transform=!!U(t.transform)&&t.transform,!t.worker||!v.WORKERS_SUPPORTED)return i=null,v.NODE_STREAM_INPUT,"string"==typeof e?(e=(e=>65279!==e.charCodeAt(0)?e:e.slice(1))(e),i=new(t.download?f:c)(t)):!0===e.readable&&U(e.read)&&U(e.on)?i=new p(t):(n.File&&e instanceof File||e instanceof Object)&&(i=new l(t)),i.stream(e);(i=(()=>{var e;return!!v.WORKERS_SUPPORTED&&(e=(()=>{var e=n.URL||n.webkitURL||null,t=r.toString();return v.BLOB_URL||(v.BLOB_URL=e.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ","(",t,")();"],{type:"text/javascript"})))})(),(e=new n.Worker(e)).onmessage=g,e.id=h++,o[e.id]=e)})()).userStep=t.step,i.userChunk=t.chunk,i.userComplete=t.complete,i.userError=t.error,t.step=U(t.step),t.chunk=U(t.chunk),t.complete=U(t.complete),t.error=U(t.error),delete t.worker,i.postMessage({input:e,config:t,workerId:i.id})},v.unparse=function(e,t){var n=!1,_=!0,m=",",y="\r\n",s='"',a=s+s,i=!1,r=null,o=!1,h=((()=>{if("object"==typeof t){if("string"!=typeof t.delimiter||v.BAD_DELIMITERS.filter(function(e){return-1!==t.delimiter.indexOf(e)}).length||(m=t.delimiter),"boolean"!=typeof t.quotes&&"function"!=typeof t.quotes&&!Array.isArray(t.quotes)||(n=t.quotes),"boolean"!=typeof t.skipEmptyLines&&"string"!=typeof t.skipEmptyLines||(i=t.skipEmptyLines),"string"==typeof t.newline&&(y=t.newline),"string"==typeof t.quoteChar&&(s=t.quoteChar),"boolean"==typeof t.header&&(_=t.header),Array.isArray(t.columns)){if(0===t.columns.length)throw new Error("Option columns is empty");r=t.columns}void 0!==t.escapeChar&&(a=t.escapeChar+s),t.escapeFormulae instanceof RegExp?o=t.escapeFormulae:"boolean"==typeof t.escapeFormulae&&t.escapeFormulae&&(o=/^[=+\-@\t\r].*$/)}})(),new RegExp(P(s),"g"));"string"==typeof e&&(e=JSON.parse(e));if(Array.isArray(e)){if(!e.length||Array.isArray(e[0]))return u(null,e,i);if("object"==typeof e[0])return u(r||Object.keys(e[0]),e,i)}else if("object"==typeof e)return"string"==typeof e.data&&(e.data=JSON.parse(e.data)),Array.isArray(e.data)&&(e.fields||(e.fields=e.meta&&e.meta.fields||r),e.fields||(e.fields=Array.isArray(e.data[0])?e.fields:"object"==typeof e.data[0]?Object.keys(e.data[0]):[]),Array.isArray(e.data[0])||"object"==typeof e.data[0]||(e.data=[e.data])),u(e.fields||[],e.data||[],i);throw new Error("Unable to serialize unrecognized input");function u(e,t,i){var r="",n=("string"==typeof e&&(e=JSON.parse(e)),"string"==typeof t&&(t=JSON.parse(t)),Array.isArray(e)&&0<e.length),s=!Array.isArray(t[0]);if(n&&_){for(var a=0;a<e.length;a++)0<a&&(r+=m),r+=k(e[a],a);0<t.length&&(r+=y)}for(var o=0;o<t.length;o++){var h=(n?e:t[o]).length,u=!1,d=n?0===Object.keys(t[o]).length:0===t[o].length;if(i&&!n&&(u="greedy"===i?""===t[o].join("").trim():1===t[o].length&&0===t[o][0].length),"greedy"===i&&n){for(var f=[],l=0;l<h;l++){var c=s?e[l]:l;f.push(t[o][c])}u=""===f.join("").trim()}if(!u){for(var p=0;p<h;p++){0<p&&!d&&(r+=m);var g=n&&s?e[p]:p;r+=k(t[o][g],p)}o<t.length-1&&(!i||0<h&&!d)&&(r+=y)}}return r}function k(e,t){var i,r;return null==e?"":e.constructor===Date?JSON.stringify(e).slice(1,25):(r=!1,o&&"string"==typeof e&&o.test(e)&&(e="'"+e,r=!0),i=e.toString().replace(h,a),(r=r||!0===n||"function"==typeof n&&n(e,t)||Array.isArray(n)&&n[t]||((e,t)=>{for(var i=0;i<t.length;i++)if(-1<e.indexOf(t[i]))return!0;return!1})(i,v.BAD_DELIMITERS)||-1<i.indexOf(m)||" "===i.charAt(0)||" "===i.charAt(i.length-1))?s+i+s:i)}},v.RECORD_SEP=String.fromCharCode(30),v.UNIT_SEP=String.fromCharCode(31),v.BYTE_ORDER_MARK="\ufeff",v.BAD_DELIMITERS=["\r","\n",'"',v.BYTE_ORDER_MARK],v.WORKERS_SUPPORTED=!s&&!!n.Worker,v.NODE_STREAM_INPUT=1,v.LocalChunkSize=10485760,v.RemoteChunkSize=5242880,v.DefaultDelimiter=",",v.Parser=E,v.ParserHandle=i,v.NetworkStreamer=f,v.FileStreamer=l,v.StringStreamer=c,v.ReadableStreamStreamer=p,n.jQuery&&((d=n.jQuery).fn.parse=function(o){var i=o.config||{},h=[];return this.each(function(e){if(!("INPUT"===d(this).prop("tagName").toUpperCase()&&"file"===d(this).attr("type").toLowerCase()&&n.FileReader)||!this.files||0===this.files.length)return!0;for(var t=0;t<this.files.length;t++)h.push({file:this.files[t],inputElem:this,instanceConfig:d.extend({},i)})}),e(),this;function e(){if(0===h.length)U(o.complete)&&o.complete();else{var e,t,i,r,n=h[0];if(U(o.before)){var s=o.before(n.file,n.inputElem);if("object"==typeof s){if("abort"===s.action)return e="AbortError",t=n.file,i=n.inputElem,r=s.reason,void(U(o.error)&&o.error({name:e},t,i,r));if("skip"===s.action)return void u();"object"==typeof s.config&&(n.instanceConfig=d.extend(n.instanceConfig,s.config))}else if("skip"===s)return void u()}var a=n.instanceConfig.complete;n.instanceConfig.complete=function(e){U(a)&&a(e,n.file,n.inputElem),u()},v.parse(n.file,n.instanceConfig)}}function u(){h.splice(0,1),e()}}),a&&(n.onmessage=function(e){e=e.data;void 0===v.WORKER_ID&&e&&(v.WORKER_ID=e.workerId);"string"==typeof e.input?n.postMessage({workerId:v.WORKER_ID,results:v.parse(e.input,e.config),finished:!0}):(n.File&&e.input instanceof File||e.input instanceof Object)&&(e=v.parse(e.input,e.config))&&n.postMessage({workerId:v.WORKER_ID,results:e,finished:!0})}),(f.prototype=Object.create(u.prototype)).constructor=f,(l.prototype=Object.create(u.prototype)).constructor=l,(c.prototype=Object.create(c.prototype)).constructor=c,(p.prototype=Object.create(u.prototype)).constructor=p,v});

/***/ }),

/***/ "./node_modules/sigma/dist/colors-beb06eb2.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/dist/colors-beb06eb2.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   H: () => (/* binding */ HTML_COLORS),
/* harmony export */   _: () => (/* binding */ _slicedToArray),
/* harmony export */   a: () => (/* binding */ _arrayLikeToArray),
/* harmony export */   b: () => (/* binding */ _unsupportedIterableToArray),
/* harmony export */   c: () => (/* binding */ colorToIndex),
/* harmony export */   d: () => (/* binding */ colorToArray),
/* harmony export */   e: () => (/* binding */ extractPixel),
/* harmony export */   f: () => (/* binding */ floatColor),
/* harmony export */   g: () => (/* binding */ getPixelColor),
/* harmony export */   i: () => (/* binding */ indexToColor),
/* harmony export */   p: () => (/* binding */ parseColor),
/* harmony export */   r: () => (/* binding */ rgbaToFloat)
/* harmony export */ });
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}

function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e,
      n,
      i,
      u,
      a = [],
      f = !0,
      o = !1;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = !1;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
    } catch (r) {
      o = !0, n = r;
    } finally {
      try {
        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}

function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}

function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}

var HTML_COLORS = {
  black: "#000000",
  silver: "#C0C0C0",
  gray: "#808080",
  grey: "#808080",
  white: "#FFFFFF",
  maroon: "#800000",
  red: "#FF0000",
  purple: "#800080",
  fuchsia: "#FF00FF",
  green: "#008000",
  lime: "#00FF00",
  olive: "#808000",
  yellow: "#FFFF00",
  navy: "#000080",
  blue: "#0000FF",
  teal: "#008080",
  aqua: "#00FFFF",
  darkblue: "#00008B",
  mediumblue: "#0000CD",
  darkgreen: "#006400",
  darkcyan: "#008B8B",
  deepskyblue: "#00BFFF",
  darkturquoise: "#00CED1",
  mediumspringgreen: "#00FA9A",
  springgreen: "#00FF7F",
  cyan: "#00FFFF",
  midnightblue: "#191970",
  dodgerblue: "#1E90FF",
  lightseagreen: "#20B2AA",
  forestgreen: "#228B22",
  seagreen: "#2E8B57",
  darkslategray: "#2F4F4F",
  darkslategrey: "#2F4F4F",
  limegreen: "#32CD32",
  mediumseagreen: "#3CB371",
  turquoise: "#40E0D0",
  royalblue: "#4169E1",
  steelblue: "#4682B4",
  darkslateblue: "#483D8B",
  mediumturquoise: "#48D1CC",
  indigo: "#4B0082",
  darkolivegreen: "#556B2F",
  cadetblue: "#5F9EA0",
  cornflowerblue: "#6495ED",
  rebeccapurple: "#663399",
  mediumaquamarine: "#66CDAA",
  dimgray: "#696969",
  dimgrey: "#696969",
  slateblue: "#6A5ACD",
  olivedrab: "#6B8E23",
  slategray: "#708090",
  slategrey: "#708090",
  lightslategray: "#778899",
  lightslategrey: "#778899",
  mediumslateblue: "#7B68EE",
  lawngreen: "#7CFC00",
  chartreuse: "#7FFF00",
  aquamarine: "#7FFFD4",
  skyblue: "#87CEEB",
  lightskyblue: "#87CEFA",
  blueviolet: "#8A2BE2",
  darkred: "#8B0000",
  darkmagenta: "#8B008B",
  saddlebrown: "#8B4513",
  darkseagreen: "#8FBC8F",
  lightgreen: "#90EE90",
  mediumpurple: "#9370DB",
  darkviolet: "#9400D3",
  palegreen: "#98FB98",
  darkorchid: "#9932CC",
  yellowgreen: "#9ACD32",
  sienna: "#A0522D",
  brown: "#A52A2A",
  darkgray: "#A9A9A9",
  darkgrey: "#A9A9A9",
  lightblue: "#ADD8E6",
  greenyellow: "#ADFF2F",
  paleturquoise: "#AFEEEE",
  lightsteelblue: "#B0C4DE",
  powderblue: "#B0E0E6",
  firebrick: "#B22222",
  darkgoldenrod: "#B8860B",
  mediumorchid: "#BA55D3",
  rosybrown: "#BC8F8F",
  darkkhaki: "#BDB76B",
  mediumvioletred: "#C71585",
  indianred: "#CD5C5C",
  peru: "#CD853F",
  chocolate: "#D2691E",
  tan: "#D2B48C",
  lightgray: "#D3D3D3",
  lightgrey: "#D3D3D3",
  thistle: "#D8BFD8",
  orchid: "#DA70D6",
  goldenrod: "#DAA520",
  palevioletred: "#DB7093",
  crimson: "#DC143C",
  gainsboro: "#DCDCDC",
  plum: "#DDA0DD",
  burlywood: "#DEB887",
  lightcyan: "#E0FFFF",
  lavender: "#E6E6FA",
  darksalmon: "#E9967A",
  violet: "#EE82EE",
  palegoldenrod: "#EEE8AA",
  lightcoral: "#F08080",
  khaki: "#F0E68C",
  aliceblue: "#F0F8FF",
  honeydew: "#F0FFF0",
  azure: "#F0FFFF",
  sandybrown: "#F4A460",
  wheat: "#F5DEB3",
  beige: "#F5F5DC",
  whitesmoke: "#F5F5F5",
  mintcream: "#F5FFFA",
  ghostwhite: "#F8F8FF",
  salmon: "#FA8072",
  antiquewhite: "#FAEBD7",
  linen: "#FAF0E6",
  lightgoldenrodyellow: "#FAFAD2",
  oldlace: "#FDF5E6",
  magenta: "#FF00FF",
  deeppink: "#FF1493",
  orangered: "#FF4500",
  tomato: "#FF6347",
  hotpink: "#FF69B4",
  coral: "#FF7F50",
  darkorange: "#FF8C00",
  lightsalmon: "#FFA07A",
  orange: "#FFA500",
  lightpink: "#FFB6C1",
  pink: "#FFC0CB",
  gold: "#FFD700",
  peachpuff: "#FFDAB9",
  navajowhite: "#FFDEAD",
  moccasin: "#FFE4B5",
  bisque: "#FFE4C4",
  mistyrose: "#FFE4E1",
  blanchedalmond: "#FFEBCD",
  papayawhip: "#FFEFD5",
  lavenderblush: "#FFF0F5",
  seashell: "#FFF5EE",
  cornsilk: "#FFF8DC",
  lemonchiffon: "#FFFACD",
  floralwhite: "#FFFAF0",
  snow: "#FFFAFA",
  lightyellow: "#FFFFE0",
  ivory: "#FFFFF0"
};

/**
 * Function extracting the color at the given pixel.
 */
function extractPixel(gl, x, y, array) {
  var data = array || new Uint8Array(4);
  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);
  return data;
}

/**
 * Memoized function returning a float-encoded color from various string
 * formats describing colors.
 */
var INT8 = new Int8Array(4);
var INT32 = new Int32Array(INT8.buffer, 0, 1);
var FLOAT32 = new Float32Array(INT8.buffer, 0, 1);
var RGBA_TEST_REGEX = /^\s*rgba?\s*\(/;
var RGBA_EXTRACT_REGEX = /^\s*rgba?\s*\(\s*([0-9]*)\s*,\s*([0-9]*)\s*,\s*([0-9]*)(?:\s*,\s*(.*)?)?\)\s*$/;
function parseColor(val) {
  var r = 0; // byte
  var g = 0; // byte
  var b = 0; // byte
  var a = 1; // float

  // Handling hexadecimal notation
  if (val[0] === "#") {
    if (val.length === 4) {
      r = parseInt(val.charAt(1) + val.charAt(1), 16);
      g = parseInt(val.charAt(2) + val.charAt(2), 16);
      b = parseInt(val.charAt(3) + val.charAt(3), 16);
    } else {
      r = parseInt(val.charAt(1) + val.charAt(2), 16);
      g = parseInt(val.charAt(3) + val.charAt(4), 16);
      b = parseInt(val.charAt(5) + val.charAt(6), 16);
    }
    if (val.length === 9) {
      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;
    }
  }

  // Handling rgb notation
  else if (RGBA_TEST_REGEX.test(val)) {
    var match = val.match(RGBA_EXTRACT_REGEX);
    if (match) {
      r = +match[1];
      g = +match[2];
      b = +match[3];
      if (match[4]) a = +match[4];
    }
  }
  return {
    r: r,
    g: g,
    b: b,
    a: a
  };
}
var FLOAT_COLOR_CACHE = {};
for (var htmlColor in HTML_COLORS) {
  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);
  // Replicating cache for hex values for free
  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];
}
function rgbaToFloat(r, g, b, a, masking) {
  INT32[0] = a << 24 | b << 16 | g << 8 | r;
  if (masking) INT32[0] = INT32[0] & 0xfeffffff;
  return FLOAT32[0];
}
function floatColor(val) {
  // The html color names are case-insensitive
  val = val.toLowerCase();

  // If the color is already computed, we yield it
  if (typeof FLOAT_COLOR_CACHE[val] !== "undefined") return FLOAT_COLOR_CACHE[val];
  var parsed = parseColor(val);
  var r = parsed.r,
    g = parsed.g,
    b = parsed.b;
  var a = parsed.a;
  a = a * 255 | 0;
  var color = rgbaToFloat(r, g, b, a, true);
  FLOAT_COLOR_CACHE[val] = color;
  return color;
}
function colorToArray(val, masking) {
  FLOAT32[0] = floatColor(val);
  var intValue = INT32[0];
  if (masking) {
    intValue = intValue | 0x01000000;
  }
  var r = intValue & 0xff;
  var g = intValue >> 8 & 0xff;
  var b = intValue >> 16 & 0xff;
  var a = intValue >> 24 & 0xff;
  return [r, g, b, a];
}
var FLOAT_INDEX_CACHE = {};
function indexToColor(index) {
  // If the index is already computed, we yield it
  if (typeof FLOAT_INDEX_CACHE[index] !== "undefined") return FLOAT_INDEX_CACHE[index];

  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,
  // but with alpha hard-set to 1.0 (or 255):
  var r = (index & 0x00ff0000) >>> 16;
  var g = (index & 0x0000ff00) >>> 8;
  var b = index & 0x000000ff;
  var a = 0x000000ff;

  // The original 4 bytes color encoding was the following:
  // const r = (index & 0xff000000) >>> 24;
  // const g = (index & 0x00ff0000) >>> 16;
  // const b = (index & 0x0000ff00) >>> 8;
  // const a = index & 0x000000ff;

  var color = rgbaToFloat(r, g, b, a, true);
  FLOAT_INDEX_CACHE[index] = color;
  return color;
}
function colorToIndex(r, g, b, _a) {
  // As for the function indexToColor, because of #1397 and the "alpha is always
  // 1.0" strategy, we need to fix this function as well:
  return b + (g << 8) + (r << 16);

  // The original 4 bytes color decoding is the following:
  // return a + (b << 8) + (g << 16) + (r << 24);
}
function getPixelColor(gl, frameBuffer, x, y, pixelRatio, downSizingRatio) {
  var bufferX = Math.floor(x / downSizingRatio * pixelRatio);
  var bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y / downSizingRatio * pixelRatio);
  var pixel = new Uint8Array(4);
  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);
  var _pixel = _slicedToArray(pixel, 4),
    r = _pixel[0],
    g = _pixel[1],
    b = _pixel[2],
    a = _pixel[3];
  return [r, g, b, a];
}




/***/ }),

/***/ "./node_modules/sigma/dist/data-11df7124.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/dist/data-11df7124.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ _typeof),
/* harmony export */   a: () => (/* binding */ assign),
/* harmony export */   b: () => (/* binding */ assignDeep),
/* harmony export */   e: () => (/* binding */ extend),
/* harmony export */   i: () => (/* binding */ isPlainObject)
/* harmony export */ });
function _typeof(o) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    return typeof o;
  } : function (o) {
    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof(o);
}

/**
 * Extends the target array with the given values.
 */
function extend(array, values) {
  var l2 = values.size;
  if (l2 === 0) return;
  var l1 = array.length;
  array.length += l2;
  var i = 0;
  values.forEach(function (value) {
    array[l1 + i] = value;
    i++;
  });
}

/**
 * Checks whether the given value is a plain object.
 */
function isPlainObject(value) {
  return _typeof(value) === "object" && value !== null && value.constructor === Object;
}

/**
 * Helper to use `Object.assign` with more than two objects.
 */
function assign(target) {
  target = target || {};
  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    if (!o) continue;
    Object.assign(target, o);
  }
  return target;
}

/**
 * Very simple recursive `Object.assign` like function.
 */
function assignDeep(target) {
  target = target || {};
  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {
    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];
    if (!o) continue;
    for (var k in o) {
      if (isPlainObject(o[k])) {
        target[k] = assignDeep(target[k], o[k]);
      } else {
        target[k] = o[k];
      }
    }
  }
  return target;
}




/***/ }),

/***/ "./node_modules/sigma/dist/index-236c62ad.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/sigma/dist/index-236c62ad.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ AbstractNodeProgram),
/* harmony export */   D: () => (/* binding */ DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS),
/* harmony export */   E: () => (/* binding */ EdgeArrowProgram$1),
/* harmony export */   F: () => (/* binding */ FRAGMENT_SHADER_SOURCE),
/* harmony export */   N: () => (/* binding */ NodeCircleProgram),
/* harmony export */   P: () => (/* binding */ Program),
/* harmony export */   _: () => (/* binding */ _objectSpread2),
/* harmony export */   a: () => (/* binding */ _defineProperty),
/* harmony export */   b: () => (/* binding */ drawDiscNodeLabel),
/* harmony export */   c: () => (/* binding */ drawDiscNodeHover),
/* harmony export */   d: () => (/* binding */ drawStraightEdgeLabel),
/* harmony export */   e: () => (/* binding */ EdgeRectangleProgram),
/* harmony export */   f: () => (/* binding */ NodeProgram),
/* harmony export */   g: () => (/* binding */ EdgeProgram),
/* harmony export */   h: () => (/* binding */ createEdgeCompoundProgram),
/* harmony export */   i: () => (/* binding */ createEdgeArrowHeadProgram),
/* harmony export */   j: () => (/* binding */ createNodeCompoundProgram),
/* harmony export */   k: () => (/* binding */ AbstractEdgeProgram),
/* harmony export */   l: () => (/* binding */ AbstractProgram),
/* harmony export */   m: () => (/* binding */ EdgeArrowHeadProgram$1),
/* harmony export */   n: () => (/* binding */ EdgeClampedProgram$1),
/* harmony export */   o: () => (/* binding */ createEdgeClampedProgram),
/* harmony export */   p: () => (/* binding */ DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS),
/* harmony export */   q: () => (/* binding */ createEdgeArrowProgram),
/* harmony export */   r: () => (/* binding */ getAttributeItemsCount),
/* harmony export */   s: () => (/* binding */ getAttributesItemsCount),
/* harmony export */   t: () => (/* binding */ loadVertexShader),
/* harmony export */   u: () => (/* binding */ loadFragmentShader),
/* harmony export */   v: () => (/* binding */ loadProgram),
/* harmony export */   w: () => (/* binding */ killProgram),
/* harmony export */   x: () => (/* binding */ numberToGLSLFloat)
/* harmony export */ });
/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");



function _defineProperty(e, r, t) {
  return (r = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[r] = t, e;
}

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}

function _superPropBase(t, o) {
  for (; !{}.hasOwnProperty.call(t, o) && null !== (t = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(t)););
  return t;
}

function _get() {
  return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
    var p = _superPropBase(e, t);
    if (p) {
      var n = Object.getOwnPropertyDescriptor(p, t);
      return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
    }
  }, _get.apply(null, arguments);
}

function _superPropGet(t, o, e, r) {
  var p = _get((0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(1 & r ? t.prototype : t), o, e);
  return 2 & r && "function" == typeof p ? function (t) {
    return p.apply(e, t);
  } : p;
}

function getAttributeItemsCount(attr) {
  return attr.normalized ? 1 : attr.size;
}
function getAttributesItemsCount(attrs) {
  var res = 0;
  attrs.forEach(function (attr) {
    return res += getAttributeItemsCount(attr);
  });
  return res;
}
function loadShader(type, gl, source) {
  var glType = type === "VERTEX" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;

  // Creating the shader
  var shader = gl.createShader(glType);
  if (shader === null) {
    throw new Error("loadShader: error while creating the shader");
  }

  // Loading source
  gl.shaderSource(shader, source);

  // Compiling the shader
  gl.compileShader(shader);

  // Retrieving compilation status
  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);

  // Throwing if something went awry
  if (!successfullyCompiled) {
    var infoLog = gl.getShaderInfoLog(shader);
    gl.deleteShader(shader);
    throw new Error("loadShader: error while compiling the shader:\n".concat(infoLog, "\n").concat(source));
  }
  return shader;
}
function loadVertexShader(gl, source) {
  return loadShader("VERTEX", gl, source);
}
function loadFragmentShader(gl, source) {
  return loadShader("FRAGMENT", gl, source);
}

/**
 * Function used to load a program.
 */
function loadProgram(gl, shaders) {
  var program = gl.createProgram();
  if (program === null) {
    throw new Error("loadProgram: error while creating the program.");
  }
  var i, l;

  // Attaching the shaders
  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);
  gl.linkProgram(program);

  // Checking status
  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!successfullyLinked) {
    gl.deleteProgram(program);
    throw new Error("loadProgram: error while linking the program.");
  }
  return program;
}
function killProgram(_ref) {
  var gl = _ref.gl,
    buffer = _ref.buffer,
    program = _ref.program,
    vertexShader = _ref.vertexShader,
    fragmentShader = _ref.fragmentShader;
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);
  gl.deleteProgram(program);
  gl.deleteBuffer(buffer);
}

/**
 * Function use to print a float for inserting in a GLSL program.
 */
function numberToGLSLFloat(n) {
  return n % 1 === 0 ? n.toFixed(1) : n.toString();
}

var PICKING_PREFIX = "#define PICKING_MODE\n";
var SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);
var AbstractProgram = /*#__PURE__*/(0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(function AbstractProgram(_gl, _pickGl, _renderer) {
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractProgram);
});
var Program = /*#__PURE__*/function () {
  function Program(gl, pickingBuffer, renderer) {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, Program);
    // GLenum
    _defineProperty(this, "array", new Float32Array());
    _defineProperty(this, "constantArray", new Float32Array());
    _defineProperty(this, "capacity", 0);
    _defineProperty(this, "verticesCount", 0);
    // Reading and caching program definition
    var def = this.getDefinition();
    this.VERTICES = def.VERTICES;
    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;
    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;
    this.UNIFORMS = def.UNIFORMS;
    this.ATTRIBUTES = def.ATTRIBUTES;
    this.METHOD = def.METHOD;
    this.CONSTANT_ATTRIBUTES = "CONSTANT_ATTRIBUTES" in def ? def.CONSTANT_ATTRIBUTES : [];
    this.CONSTANT_DATA = "CONSTANT_DATA" in def ? def.CONSTANT_DATA : [];
    this.isInstanced = "CONSTANT_ATTRIBUTES" in def;

    // Computing stride
    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);
    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;

    // Members
    this.renderer = renderer;
    this.normalProgram = this.getProgramInfo("normal", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);
    this.pickProgram = pickingBuffer ? this.getProgramInfo("pick", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;

    // For instanced programs:
    if (this.isInstanced) {
      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);
      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error("Program: error while getting constant data (expected ".concat(this.VERTICES, " items, received ").concat(this.CONSTANT_DATA.length, " instead)"));
      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);
      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {
        var vector = this.CONSTANT_DATA[i];
        if (vector.length !== constantAttributesItemsCount) throw new Error("Program: error while getting constant data (one vector has ".concat(vector.length, " items instead of ").concat(constantAttributesItemsCount, ")"));
        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];
      }
      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;
    }
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(Program, [{
    key: "kill",
    value: function kill() {
      killProgram(this.normalProgram);
      if (this.pickProgram) {
        killProgram(this.pickProgram);
        this.pickProgram = null;
      }
    }
  }, {
    key: "getProgramInfo",
    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {
      var def = this.getDefinition();

      // WebGL buffers
      var buffer = gl.createBuffer();
      if (buffer === null) throw new Error("Program: error while creating the WebGL buffer.");

      // Shaders and program
      var vertexShader = loadVertexShader(gl, vertexShaderSource);
      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);
      var program = loadProgram(gl, [vertexShader, fragmentShader]);

      // Initializing locations
      var uniformLocations = {};
      def.UNIFORMS.forEach(function (uniformName) {
        var location = gl.getUniformLocation(program, uniformName);
        if (location) uniformLocations[uniformName] = location;
      });
      var attributeLocations = {};
      def.ATTRIBUTES.forEach(function (attr) {
        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
      });

      // For instanced programs:
      var constantBuffer;
      if ("CONSTANT_ATTRIBUTES" in def) {
        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);
        });
        constantBuffer = gl.createBuffer();
        if (constantBuffer === null) throw new Error("Program: error while creating the WebGL constant buffer.");
      }
      return {
        name: name,
        program: program,
        gl: gl,
        frameBuffer: frameBuffer,
        buffer: buffer,
        constantBuffer: constantBuffer || {},
        uniformLocations: uniformLocations,
        attributeLocations: attributeLocations,
        isPicking: name === "pick",
        vertexShader: vertexShader,
        fragmentShader: fragmentShader
      };
    }
  }, {
    key: "bindProgram",
    value: function bindProgram(program) {
      var _this = this;
      var offset = 0;
      var gl = program.gl,
        buffer = program.buffer;
      if (!this.isInstanced) {
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
        offset = 0;
        this.ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      } else {
        // Handle constant data (things that remain unchanged for all items):
        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);
        offset = 0;
        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset, false);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);

        // Handle "instance specific" data (things that vary for each item):
        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);
        offset = 0;
        this.ATTRIBUTES.forEach(function (attr) {
          return offset += _this.bindAttribute(attr, program, offset, true);
        });
        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);
      }
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
    }
  }, {
    key: "unbindProgram",
    value: function unbindProgram(program) {
      var _this2 = this;
      if (!this.isInstanced) {
        this.ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program);
        });
      } else {
        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program, false);
        });
        this.ATTRIBUTES.forEach(function (attr) {
          return _this2.unbindAttribute(attr, program, true);
        });
      }
    }
  }, {
    key: "bindAttribute",
    value: function bindAttribute(attr, program, offset, setDivisor) {
      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];
      if (typeof sizeFactor !== "number") throw new Error("Program.bind: yet unsupported attribute type \"".concat(attr.type, "\""));
      var location = program.attributeLocations[attr.name];
      var gl = program.gl;
      if (location !== -1) {
        gl.enableVertexAttribArray(location);
        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;
        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);
        if (this.isInstanced && setDivisor) {
          if (gl instanceof WebGL2RenderingContext) {
            gl.vertexAttribDivisor(location, 1);
          } else {
            var ext = gl.getExtension("ANGLE_instanced_arrays");
            if (ext) ext.vertexAttribDivisorANGLE(location, 1);
          }
        }
      }
      return attr.size * sizeFactor;
    }
  }, {
    key: "unbindAttribute",
    value: function unbindAttribute(attr, program, unsetDivisor) {
      var location = program.attributeLocations[attr.name];
      var gl = program.gl;
      if (location !== -1) {
        gl.disableVertexAttribArray(location);
        if (this.isInstanced && unsetDivisor) {
          if (gl instanceof WebGL2RenderingContext) {
            gl.vertexAttribDivisor(location, 0);
          } else {
            var ext = gl.getExtension("ANGLE_instanced_arrays");
            if (ext) ext.vertexAttribDivisorANGLE(location, 0);
          }
        }
      }
    }
  }, {
    key: "reallocate",
    value: function reallocate(capacity) {
      // If desired capacity has not changed we do nothing
      // NOTE: it's possible here to implement more subtle reallocation schemes
      // when the number of rendered items increase or decrease
      if (capacity === this.capacity) return;
      this.capacity = capacity;
      this.verticesCount = this.VERTICES * capacity;
      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);
    }
  }, {
    key: "hasNothingToRender",
    value: function hasNothingToRender() {
      return this.verticesCount === 0;
    }
  }, {
    key: "renderProgram",
    value: function renderProgram(params, programInfo) {
      var gl = programInfo.gl,
        program = programInfo.program;

      // With the current fix for #1397, the alpha blending is enabled for the
      // picking layer:
      gl.enable(gl.BLEND);

      // Original code:
      // if (!isPicking) gl.enable(gl.BLEND);
      // else gl.disable(gl.BLEND);

      gl.useProgram(program);
      this.setUniforms(params, programInfo);
      this.drawWebGL(this.METHOD, programInfo);
    }
  }, {
    key: "render",
    value: function render(params) {
      if (this.hasNothingToRender()) return;
      if (this.pickProgram) {
        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);
        this.bindProgram(this.pickProgram);
        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {
          pixelRatio: params.pixelRatio / params.downSizingRatio
        }), this.pickProgram);
        this.unbindProgram(this.pickProgram);
      }
      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);
      this.bindProgram(this.normalProgram);
      this.renderProgram(params, this.normalProgram);
      this.unbindProgram(this.normalProgram);
    }
  }, {
    key: "drawWebGL",
    value: function drawWebGL(method, _ref) {
      var gl = _ref.gl,
        frameBuffer = _ref.frameBuffer;
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      if (!this.isInstanced) {
        gl.drawArrays(method, 0, this.verticesCount);
      } else {
        if (gl instanceof WebGL2RenderingContext) {
          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);
        } else {
          var ext = gl.getExtension("ANGLE_instanced_arrays");
          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);
        }
      }
    }
  }]);
}();

var AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {
  function AbstractNodeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractNodeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractNodeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractNodeProgram, _AbstractProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractNodeProgram);
}(AbstractProgram);
var NodeProgram = /*#__PURE__*/function (_ref) {
  function NodeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeProgram, _ref);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeProgram, [{
    key: "kill",
    value: function kill() {
      _superPropGet(NodeProgram, "kill", this, 3)([]);
    }
  }, {
    key: "process",
    value: function process(nodeIndex, offset, data) {
      var i = offset * this.STRIDE;
      // NOTE: dealing with hidden items automatically
      if (data.hidden) {
        for (var l = i + this.STRIDE; i < l; i++) {
          this.array[i] = 0;
        }
        return;
      }
      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(nodeIndex), i, data);
    }
  }]);
}(Program);
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @param  {function} drawLabel - An optional node "draw label" function.
 * @param  {function} drawHover - An optional node "draw hover" function.
 * @return {function}
 */
function createNodeCompoundProgram(programClasses, drawLabel, drawHover) {
  return /*#__PURE__*/function () {
    function NodeCompoundProgram(gl, pickingBuffer, renderer) {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCompoundProgram);
      _defineProperty(this, "drawLabel", drawLabel);
      _defineProperty(this, "drawHover", drawHover);
      this.programs = programClasses.map(function (Program) {
        return new Program(gl, pickingBuffer, renderer);
      });
    }
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCompoundProgram, [{
      key: "reallocate",
      value: function reallocate(capacity) {
        this.programs.forEach(function (program) {
          return program.reallocate(capacity);
        });
      }
    }, {
      key: "process",
      value: function process(nodeIndex, offset, data) {
        this.programs.forEach(function (program) {
          return program.process(nodeIndex, offset, data);
        });
      }
    }, {
      key: "render",
      value: function render(params) {
        this.programs.forEach(function (program) {
          return program.render(params);
        });
      }
    }, {
      key: "kill",
      value: function kill() {
        this.programs.forEach(function (program) {
          return program.kill();
        });
      }
    }]);
  }();
}

var AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {
  function AbstractEdgeProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractEdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, AbstractEdgeProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractEdgeProgram, _AbstractProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(AbstractEdgeProgram);
}(AbstractProgram);
var EdgeProgram = /*#__PURE__*/function (_ref) {
  function EdgeProgram() {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeProgram);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeProgram, [].concat(args));
    _defineProperty(_this, "drawLabel", undefined);
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeProgram, _ref);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeProgram, [{
    key: "kill",
    value: function kill() {
      _superPropGet(EdgeProgram, "kill", this, 3)([]);
    }
  }, {
    key: "process",
    value: function process(edgeIndex, offset, sourceData, targetData, data) {
      var i = offset * this.STRIDE;
      // NOTE: dealing with hidden items automatically
      if (data.hidden || sourceData.hidden || targetData.hidden) {
        for (var l = i + this.STRIDE; i < l; i++) {
          this.array[i] = 0;
        }
        return;
      }
      return this.processVisibleItem((0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(edgeIndex), i, sourceData, targetData, data);
    }
  }]);
}(Program);
/**
 * Helper function combining two or more programs into a single compound one.
 * Note that this is more a quick & easy way to combine program than a really
 * performant option. More performant programs can be written entirely.
 *
 * @param  {array}    programClasses - Program classes to combine.
 * @param  {function} drawLabel - An optional edge "draw label" function.
 * @return {function}
 */
function createEdgeCompoundProgram(programClasses, drawLabel) {
  return /*#__PURE__*/function () {
    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeCompoundProgram);
      _defineProperty(this, "drawLabel", drawLabel);
      this.programs = programClasses.map(function (Program) {
        return new Program(gl, pickingBuffer, renderer);
      });
    }
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeCompoundProgram, [{
      key: "reallocate",
      value: function reallocate(capacity) {
        this.programs.forEach(function (program) {
          return program.reallocate(capacity);
        });
      }
    }, {
      key: "process",
      value: function process(edgeIndex, offset, sourceData, targetData, data) {
        this.programs.forEach(function (program) {
          return program.process(edgeIndex, offset, sourceData, targetData, data);
        });
      }
    }, {
      key: "render",
      value: function render(params) {
        this.programs.forEach(function (program) {
          return program.render(params);
        });
      }
    }, {
      key: "kill",
      value: function kill() {
        this.programs.forEach(function (program) {
          return program.kill();
        });
      }
    }]);
  }();
}

function drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {
  var size = settings.edgeLabelSize,
    font = settings.edgeLabelFont,
    weight = settings.edgeLabelWeight,
    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || "#000" : settings.edgeLabelColor.color;
  var label = edgeData.label;
  if (!label) return;
  context.fillStyle = color;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);

  // Computing positions without considering nodes sizes:
  var sSize = sourceData.size;
  var tSize = targetData.size;
  var sx = sourceData.x;
  var sy = sourceData.y;
  var tx = targetData.x;
  var ty = targetData.y;
  var cx = (sx + tx) / 2;
  var cy = (sy + ty) / 2;
  var dx = tx - sx;
  var dy = ty - sy;
  var d = Math.sqrt(dx * dx + dy * dy);
  if (d < sSize + tSize) return;

  // Adding nodes sizes:
  sx += dx * sSize / d;
  sy += dy * sSize / d;
  tx -= dx * tSize / d;
  ty -= dy * tSize / d;
  cx = (sx + tx) / 2;
  cy = (sy + ty) / 2;
  dx = tx - sx;
  dy = ty - sy;
  d = Math.sqrt(dx * dx + dy * dy);

  // Handling ellipsis
  var textLength = context.measureText(label).width;
  if (textLength > d) {
    var ellipsis = "…";
    label = label + ellipsis;
    textLength = context.measureText(label).width;
    while (textLength > d && label.length > 1) {
      label = label.slice(0, -2) + ellipsis;
      textLength = context.measureText(label).width;
    }
    if (label.length < 4) return;
  }
  var angle;
  if (dx > 0) {
    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);
  } else {
    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;
  }
  context.save();
  context.translate(cx, cy);
  context.rotate(angle);
  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);
  context.restore();
}

function drawDiscNodeLabel(context, data, settings) {
  if (!data.label) return;
  var size = settings.labelSize,
    font = settings.labelFont,
    weight = settings.labelWeight,
    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || "#000" : settings.labelColor.color;
  context.fillStyle = color;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);
  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);
}

/**
 * Draw an hovered node.
 * - if there is no label => display a shadow on the node
 * - if the label box is bigger than node size => display a label box that contains the node with a shadow
 * - else node with shadow and the label box
 */
function drawDiscNodeHover(context, data, settings) {
  var size = settings.labelSize,
    font = settings.labelFont,
    weight = settings.labelWeight;
  context.font = "".concat(weight, " ").concat(size, "px ").concat(font);

  // Then we draw the label background
  context.fillStyle = "#FFF";
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 8;
  context.shadowColor = "#000";
  var PADDING = 2;
  if (typeof data.label === "string") {
    var textWidth = context.measureText(data.label).width,
      boxWidth = Math.round(textWidth + 5),
      boxHeight = Math.round(size + 2 * PADDING),
      radius = Math.max(data.size, size / 2) + PADDING;
    var angleRadian = Math.asin(boxHeight / 2 / radius);
    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));
    context.beginPath();
    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);
    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);
    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);
    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);
    context.closePath();
    context.fill();
  } else {
    context.beginPath();
    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);
    context.closePath();
    context.fill();
  }
  context.shadowOffsetX = 0;
  context.shadowOffsetY = 0;
  context.shadowBlur = 0;

  // And finally we draw the label
  drawDiscNodeLabel(context, data, settings);
}

// language=GLSL
var SHADER_SOURCE$6 = /*glsl*/"\nprecision highp float;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\n\nuniform float u_correctionRatio;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  float border = u_correctionRatio * 2.0;\n  float dist = length(v_diffVector) - v_radius + border;\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > border)\n    gl_FragColor = transparent;\n  else\n    gl_FragColor = v_color;\n\n  #else\n  float t = 0.0;\n  if (dist > border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / border;\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n";
var FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;

// language=GLSL
var SHADER_SOURCE$5 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\nattribute float a_angle;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\nvarying vec2 v_diffVector;\nvarying float v_radius;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\n  vec2 position = a_position + diffVector;\n  gl_Position = vec4(\n    (u_matrix * vec3(position, 1)).xy,\n    0,\n    1\n  );\n\n  v_diffVector = diffVector;\n  v_radius = size / 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;

var _WebGLRenderingContex$3 = WebGLRenderingContext,
  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,
  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;
var UNIFORMS$3 = ["u_sizeRatio", "u_correctionRatio", "u_matrix"];
var NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {
  function NodeCircleProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCircleProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, NodeCircleProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeCircleProgram, _NodeProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(NodeCircleProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 3,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS$3,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$3
        }, {
          name: "a_size",
          size: 1,
          type: FLOAT$3
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [{
          name: "a_angle",
          size: 1,
          type: FLOAT$3
        }],
        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(nodeIndex, startIndex, data) {
      var array = this.array;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);
      array[startIndex++] = data.x;
      array[startIndex++] = data.y;
      array[startIndex++] = data.size;
      array[startIndex++] = color;
      array[startIndex++] = nodeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_sizeRatio = uniformLocations.u_sizeRatio,
        u_correctionRatio = uniformLocations.u_correctionRatio,
        u_matrix = uniformLocations.u_matrix;
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
    }
  }]);
}(NodeProgram);
_defineProperty(NodeCircleProgram, "ANGLE_1", 0);
_defineProperty(NodeCircleProgram, "ANGLE_2", 2 * Math.PI / 3);
_defineProperty(NodeCircleProgram, "ANGLE_3", 4 * Math.PI / 3);

// language=GLSL
var SHADER_SOURCE$4 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";
var FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;

// language=GLSL
var SHADER_SOURCE$3 = /*glsl*/"\nattribute vec2 a_position;\nattribute vec2 a_normal;\nattribute float a_radius;\nattribute vec3 a_barycentric;\n\n#ifdef PICKING_MODE\nattribute vec4 a_id;\n#else\nattribute vec4 a_color;\n#endif\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_widenessToThicknessRatio;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float normalLength = length(a_normal);\n  vec2 unitNormal = a_normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl and\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\n  // happening:\n  float pixelsThickness = max(normalLength / u_sizeRatio, minThickness);\n  float webGLThickness = pixelsThickness * u_correctionRatio;\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n  float webGLArrowHeadThickness = webGLThickness * u_widenessToThicknessRatio;\n\n  float da = a_barycentric.x;\n  float db = a_barycentric.y;\n  float dc = a_barycentric.z;\n\n  vec2 delta = vec2(\n      da * (webGLNodeRadius * unitNormal.y)\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadThickness * unitNormal.x)\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadThickness * unitNormal.x),\n\n      da * (-webGLNodeRadius * unitNormal.x)\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadThickness * unitNormal.y)\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadThickness * unitNormal.y)\n  );\n\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\n\n  gl_Position = vec4(position, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;

var _WebGLRenderingContex$2 = WebGLRenderingContext,
  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,
  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;
var UNIFORMS$2 = ["u_matrix", "u_sizeRatio", "u_correctionRatio", "u_minEdgeThickness", "u_lengthToThicknessRatio", "u_widenessToThicknessRatio"];
var DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS = {
  extremity: "target",
  lengthToThicknessRatio: 2.5,
  widenessToThicknessRatio: 2
};
function createEdgeArrowHeadProgram(inputOptions) {
  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), inputOptions || {});
  return /*#__PURE__*/function (_EdgeProgram) {
    function EdgeArrowHeadProgram() {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeArrowHeadProgram);
      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeArrowHeadProgram, arguments);
    }
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeArrowHeadProgram, _EdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeArrowHeadProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 3,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,
          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS$2,
          ATTRIBUTES: [{
            name: "a_position",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_normal",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_radius",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }],
          CONSTANT_ATTRIBUTES: [{
            name: "a_barycentric",
            size: 3,
            type: FLOAT$2
          }],
          CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        if (options.extremity === "source") {
          var _ref = [targetData, sourceData];
          sourceData = _ref[0];
          targetData = _ref[1];
        }
        var thickness = data.size || 1;
        var radius = targetData.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len * thickness;
          n2 = dx * len * thickness;
        }
        var array = this.array;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        array[startIndex++] = -n1;
        array[startIndex++] = -n2;
        array[startIndex++] = radius;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref2) {
        var gl = _ref2.gl,
          uniformLocations = _ref2.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_correctionRatio = uniformLocations.u_correctionRatio,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,
          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,
          u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
        gl.uniform1f(u_widenessToThicknessRatio, options.widenessToThicknessRatio);
      }
    }]);
  }(EdgeProgram);
}
var EdgeArrowHeadProgram = createEdgeArrowHeadProgram();
var EdgeArrowHeadProgram$1 = EdgeArrowHeadProgram;

// language=GLSL
var SHADER_SOURCE$2 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  // We only handle antialiasing for normal mode:\n  #ifdef PICKING_MODE\n  gl_FragColor = v_color;\n  #else\n  float dist = length(v_normal) * v_thickness;\n\n  float t = smoothstep(\n    v_thickness - v_feather,\n    v_thickness,\n    dist\n  );\n\n  gl_FragColor = mix(v_color, transparent, t);\n  #endif\n}\n";
var FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;

// language=GLSL
var SHADER_SOURCE$1 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_radius;\nattribute float a_radiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  float radius = a_radius * a_radiusCoef;\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow head:\n  float direction = sign(radius);\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;

var _WebGLRenderingContex$1 = WebGLRenderingContext,
  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,
  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;
var UNIFORMS$1 = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio", "u_pixelRatio", "u_feather", "u_minEdgeThickness", "u_lengthToThicknessRatio"];
var DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS = {
  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio
};
function createEdgeClampedProgram(inputOptions) {
  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});
  return /*#__PURE__*/function (_EdgeProgram) {
    function EdgeClampedProgram() {
      (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeClampedProgram);
      return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeClampedProgram, arguments);
    }
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeClampedProgram, _EdgeProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeClampedProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 6,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,
          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS$1,
          ATTRIBUTES: [{
            name: "a_positionStart",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_positionEnd",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_normal",
            size: 2,
            type: FLOAT$1
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE$1,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE$1,
            normalized: true
          }, {
            name: "a_radius",
            size: 1,
            type: FLOAT$1
          }],
          CONSTANT_ATTRIBUTES: [
          // If 0, then position will be a_positionStart
          // If 1, then position will be a_positionEnd
          {
            name: "a_positionCoef",
            size: 1,
            type: FLOAT$1
          }, {
            name: "a_normalCoef",
            size: 1,
            type: FLOAT$1
          }, {
            name: "a_radiusCoef",
            size: 1,
            type: FLOAT$1
          }],
          CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var radius = targetData.size || 1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len * thickness;
          n2 = dx * len * thickness;
        }
        var array = this.array;
        array[startIndex++] = x1;
        array[startIndex++] = y1;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        array[startIndex++] = n1;
        array[startIndex++] = n2;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
        array[startIndex++] = radius;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref) {
        var gl = _ref.gl,
          uniformLocations = _ref.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_zoomRatio = uniformLocations.u_zoomRatio,
          u_feather = uniformLocations.u_feather,
          u_pixelRatio = uniformLocations.u_pixelRatio,
          u_correctionRatio = uniformLocations.u_correctionRatio,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,
          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_zoomRatio, params.zoomRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_feather, params.antiAliasingFeather);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
      }
    }]);
  }(EdgeProgram);
}
var EdgeClampedProgram = createEdgeClampedProgram();
var EdgeClampedProgram$1 = EdgeClampedProgram;

function createEdgeArrowProgram(inputOptions) {
  return createEdgeCompoundProgram([createEdgeClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions)]);
}
var EdgeArrowProgram = createEdgeArrowProgram();
var EdgeArrowProgram$1 = EdgeArrowProgram;

// language=GLSL
var SHADER_SOURCE = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_zoomRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // We require edges to be at least \"minThickness\" pixels thick *on screen*\n  // (so we need to compensate the size ratio):\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\n  // referential (in a ([0, 1], [0, 1]) space), using our \"magic\" correction\n  // ratio:\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  // For the fragment shader though, we need a thickness that takes the \"magic\"\n  // correction ratio into account (as in webGLThickness), but so that the\n  // antialiasing effect does not depend on the zoom level. So here's yet\n  // another thickness version:\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE = SHADER_SOURCE;

var _WebGLRenderingContex = WebGLRenderingContext,
  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,
  FLOAT = _WebGLRenderingContex.FLOAT;
var UNIFORMS = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio", "u_pixelRatio", "u_feather", "u_minEdgeThickness"];
var EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {
  function EdgeRectangleProgram() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeRectangleProgram);
    return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(this, EdgeRectangleProgram, arguments);
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeRectangleProgram, _EdgeProgram);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(EdgeRectangleProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 6,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS,
        ATTRIBUTES: [{
          name: "a_positionStart",
          size: 2,
          type: FLOAT
        }, {
          name: "a_positionEnd",
          size: 2,
          type: FLOAT
        }, {
          name: "a_normal",
          size: 2,
          type: FLOAT
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 2, then position will be a_positionEnd
        {
          name: "a_positionCoef",
          size: 1,
          type: FLOAT
        }, {
          name: "a_normalCoef",
          size: 1,
          type: FLOAT
        }],
        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var thickness = data.size || 1;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);

      // Computing normals
      var dx = x2 - x1;
      var dy = y2 - y1;
      var len = dx * dx + dy * dy;
      var n1 = 0;
      var n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      var array = this.array;
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = n1;
      array[startIndex++] = n2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix,
        u_zoomRatio = uniformLocations.u_zoomRatio,
        u_feather = uniformLocations.u_feather,
        u_pixelRatio = uniformLocations.u_pixelRatio,
        u_correctionRatio = uniformLocations.u_correctionRatio,
        u_sizeRatio = uniformLocations.u_sizeRatio,
        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_zoomRatio, params.zoomRatio);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_pixelRatio, params.pixelRatio);
      gl.uniform1f(u_feather, params.antiAliasingFeather);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
    }
  }]);
}(EdgeProgram);




/***/ }),

/***/ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/dist/inherits-d1a1e29b.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _: () => (/* binding */ _inherits),
/* harmony export */   a: () => (/* binding */ _createClass),
/* harmony export */   b: () => (/* binding */ _classCallCheck),
/* harmony export */   c: () => (/* binding */ _callSuper),
/* harmony export */   d: () => (/* binding */ _toPropertyKey),
/* harmony export */   e: () => (/* binding */ _getPrototypeOf)
/* harmony export */ });
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}

function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}

function _classCallCheck(a, n) {
  if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
}

function _defineProperties(e, r) {
  for (var t = 0; t < r.length; t++) {
    var o = r[t];
    o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);
  }
}
function _createClass(e, r, t) {
  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
    writable: !1
  }), e;
}

function _getPrototypeOf(t) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, _getPrototypeOf(t);
}

function _isNativeReflectConstruct() {
  try {
    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
  } catch (t) {}
  return (_isNativeReflectConstruct = function () {
    return !!t;
  })();
}

function _assertThisInitialized(e) {
  if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e;
}

function _possibleConstructorReturn(t, e) {
  if (e && ("object" == typeof e || "function" == typeof e)) return e;
  if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(t);
}

function _callSuper(t, o, e) {
  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
}

function _setPrototypeOf(t, e) {
  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
    return t.__proto__ = e, t;
  }, _setPrototypeOf(t, e);
}

function _inherits(t, e) {
  if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
  t.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: t,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(t, "prototype", {
    writable: !1
  }), e && _setPrototypeOf(t, e);
}




/***/ }),

/***/ "./node_modules/sigma/dist/normalization-be445518.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/sigma/dist/normalization-be445518.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   A: () => (/* binding */ ANIMATE_DEFAULTS),
/* harmony export */   a: () => (/* binding */ getMatrixImpact),
/* harmony export */   b: () => (/* binding */ createElement),
/* harmony export */   c: () => (/* binding */ createNormalizationFunction),
/* harmony export */   d: () => (/* binding */ getPixelRatio),
/* harmony export */   e: () => (/* binding */ easings),
/* harmony export */   f: () => (/* binding */ multiplyVec2),
/* harmony export */   g: () => (/* binding */ graphExtent),
/* harmony export */   h: () => (/* binding */ animateNodes),
/* harmony export */   i: () => (/* binding */ identity),
/* harmony export */   j: () => (/* binding */ getCorrectionRatio),
/* harmony export */   k: () => (/* binding */ quadraticOut),
/* harmony export */   l: () => (/* binding */ linear),
/* harmony export */   m: () => (/* binding */ matrixFromCamera),
/* harmony export */   n: () => (/* binding */ quadraticInOut),
/* harmony export */   o: () => (/* binding */ cubicIn),
/* harmony export */   p: () => (/* binding */ cubicOut),
/* harmony export */   q: () => (/* binding */ quadraticIn),
/* harmony export */   r: () => (/* binding */ cubicInOut),
/* harmony export */   s: () => (/* binding */ scale),
/* harmony export */   t: () => (/* binding */ rotate),
/* harmony export */   u: () => (/* binding */ translate),
/* harmony export */   v: () => (/* binding */ validateGraph),
/* harmony export */   w: () => (/* binding */ multiply),
/* harmony export */   z: () => (/* binding */ zIndexOrdering)
/* harmony export */ });
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");



var linear = function linear(k) {
  return k;
};
var quadraticIn = function quadraticIn(k) {
  return k * k;
};
var quadraticOut = function quadraticOut(k) {
  return k * (2 - k);
};
var quadraticInOut = function quadraticInOut(k) {
  if ((k *= 2) < 1) return 0.5 * k * k;
  return -0.5 * (--k * (k - 2) - 1);
};
var cubicIn = function cubicIn(k) {
  return k * k * k;
};
var cubicOut = function cubicOut(k) {
  return --k * k * k + 1;
};
var cubicInOut = function cubicInOut(k) {
  if ((k *= 2) < 1) return 0.5 * k * k * k;
  return 0.5 * ((k -= 2) * k * k + 2);
};
var easings = {
  linear: linear,
  quadraticIn: quadraticIn,
  quadraticOut: quadraticOut,
  quadraticInOut: quadraticInOut,
  cubicIn: cubicIn,
  cubicOut: cubicOut,
  cubicInOut: cubicInOut
};

/**
 * Defaults.
 */

var ANIMATE_DEFAULTS = {
  easing: "quadraticInOut",
  duration: 150
};

/**
 * Function used to animate the nodes.
 */
function animateNodes(graph, targets, opts, callback) {
  var options = Object.assign({}, ANIMATE_DEFAULTS, opts);
  var easing = typeof options.easing === "function" ? options.easing : easings[options.easing];
  var start = Date.now();
  var startPositions = {};
  for (var node in targets) {
    var attrs = targets[node];
    startPositions[node] = {};
    for (var _k in attrs) startPositions[node][_k] = graph.getNodeAttribute(node, _k);
  }
  var frame = null;
  var _step = function step() {
    frame = null;
    var p = (Date.now() - start) / options.duration;
    if (p >= 1) {
      // Animation is done
      for (var _node in targets) {
        var _attrs = targets[_node];

        // We use given values to avoid precision issues and for convenience
        for (var _k2 in _attrs) graph.setNodeAttribute(_node, _k2, _attrs[_k2]);
      }
      if (typeof callback === "function") callback();
      return;
    }
    p = easing(p);
    for (var _node2 in targets) {
      var _attrs2 = targets[_node2];
      var s = startPositions[_node2];
      for (var _k3 in _attrs2) graph.setNodeAttribute(_node2, _k3, _attrs2[_k3] * p + s[_k3] * (1 - p));
    }
    frame = requestAnimationFrame(_step);
  };
  _step();
  return function () {
    if (frame) cancelAnimationFrame(frame);
  };
}

function identity() {
  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);
}

// TODO: optimize
function scale(m, x, y) {
  m[0] = x;
  m[4] = typeof y === "number" ? y : x;
  return m;
}
function rotate(m, r) {
  var s = Math.sin(r),
    c = Math.cos(r);
  m[0] = c;
  m[1] = s;
  m[3] = -s;
  m[4] = c;
  return m;
}
function translate(m, x, y) {
  m[6] = x;
  m[7] = y;
  return m;
}
function multiply(a, b) {
  var a00 = a[0],
    a01 = a[1],
    a02 = a[2];
  var a10 = a[3],
    a11 = a[4],
    a12 = a[5];
  var a20 = a[6],
    a21 = a[7],
    a22 = a[8];
  var b00 = b[0],
    b01 = b[1],
    b02 = b[2];
  var b10 = b[3],
    b11 = b[4],
    b12 = b[5];
  var b20 = b[6],
    b21 = b[7],
    b22 = b[8];
  a[0] = b00 * a00 + b01 * a10 + b02 * a20;
  a[1] = b00 * a01 + b01 * a11 + b02 * a21;
  a[2] = b00 * a02 + b01 * a12 + b02 * a22;
  a[3] = b10 * a00 + b11 * a10 + b12 * a20;
  a[4] = b10 * a01 + b11 * a11 + b12 * a21;
  a[5] = b10 * a02 + b11 * a12 + b12 * a22;
  a[6] = b20 * a00 + b21 * a10 + b22 * a20;
  a[7] = b20 * a01 + b21 * a11 + b22 * a21;
  a[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return a;
}
function multiplyVec2(a, b) {
  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var a00 = a[0];
  var a01 = a[1];
  var a10 = a[3];
  var a11 = a[4];
  var a20 = a[6];
  var a21 = a[7];
  var b0 = b.x;
  var b1 = b.y;
  return {
    x: b0 * a00 + b1 * a10 + a20 * z,
    y: b0 * a01 + b1 * a11 + a21 * z
  };
}

/**
 * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This
 * helps to deal with quadtree in particular.
 * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two
 * nodes "touching" opposite sides of the graph, with the camera being at its default state.
 *
 * This function determines this ratio.
 */
function getCorrectionRatio(viewportDimensions, graphDimensions) {
  var viewportRatio = viewportDimensions.height / viewportDimensions.width;
  var graphRatio = graphDimensions.height / graphDimensions.width;

  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage
  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:
  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {
    return 1;
  }

  // Else, we need to fit the graph inside the stage:
  // 1. If the graph is "squarer" (i.e. with a ratio closer to 1), we need to make the largest sides touch;
  // 2. If the stage is "squarer", we need to make the smallest sides touch.
  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));
}

/**
 * Function returning a matrix from the current state of the camera.
 */
function matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {
  // TODO: it's possible to optimize this drastically!
  var angle = state.angle,
    ratio = state.ratio,
    x = state.x,
    y = state.y;
  var width = viewportDimensions.width,
    height = viewportDimensions.height;
  var matrix = identity();
  var smallestDimension = Math.min(width, height) - 2 * padding;
  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);
  if (!inverse) {
    multiply(matrix, scale(identity(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));
    multiply(matrix, rotate(identity(), -angle));
    multiply(matrix, scale(identity(), 1 / ratio));
    multiply(matrix, translate(identity(), -x, -y));
  } else {
    multiply(matrix, translate(identity(), x, y));
    multiply(matrix, scale(identity(), ratio));
    multiply(matrix, rotate(identity(), angle));
    multiply(matrix, scale(identity(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));
  }
  return matrix;
}

/**
 * All these transformations we apply on the matrix to get it rescale the graph
 * as we want make it very hard to get pixel-perfect distances in WebGL. This
 * function returns a factor that properly cancels the matrix effect on lengths.
 *
 * [jacomyal]
 * To be fully honest, I can't really explain happens here... I notice that the
 * following ratio works (i.e. it correctly compensates the matrix impact on all
 * camera states I could try):
 * > `R = size(V) / size(M * V) / W`
 * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works
 * as well with H and a vector that transforms into something parallel to (Oy).
 *
 * Also, note that we use `angle` and not `-angle` (that would seem logical,
 * since we want to anticipate the rotation), because the image is vertically
 * swapped in WebGL.
 */
function getMatrixImpact(matrix, cameraState, viewportDimensions) {
  var _multiplyVec = multiplyVec2(matrix, {
      x: Math.cos(cameraState.angle),
      y: Math.sin(cameraState.angle)
    }, 0),
    x = _multiplyVec.x,
    y = _multiplyVec.y;
  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;
}

/**
 * Function returning the graph's node extent in x & y.
 */
function graphExtent(graph) {
  if (!graph.order) return {
    x: [0, 1],
    y: [0, 1]
  };
  var xMin = Infinity;
  var xMax = -Infinity;
  var yMin = Infinity;
  var yMax = -Infinity;
  graph.forEachNode(function (_, attr) {
    var x = attr.x,
      y = attr.y;
    if (x < xMin) xMin = x;
    if (x > xMax) xMax = x;
    if (y < yMin) yMin = y;
    if (y > yMax) yMax = y;
  });
  return {
    x: [xMin, xMax],
    y: [yMin, yMax]
  };
}

/**
 * Check if the graph variable is a valid graph, and if sigma can render it.
 */
function validateGraph(graph) {
  // check if it's a valid graphology instance
  if (!graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default()(graph)) throw new Error("Sigma: invalid graph instance.");

  // check if nodes have x/y attributes
  graph.forEachNode(function (key, attributes) {
    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {
      throw new Error("Sigma: Coordinates of node ".concat(key, " are invalid. A node must have a numeric 'x' and 'y' attribute."));
    }
  });
}

/**
 * Function used to create DOM elements easily.
 */
function createElement(tag, style, attributes) {
  var element = document.createElement(tag);
  if (style) {
    for (var k in style) {
      element.style[k] = style[k];
    }
  }
  if (attributes) {
    for (var _k in attributes) {
      element.setAttribute(_k, attributes[_k]);
    }
  }
  return element;
}

/**
 * Function returning the browser's pixel ratio.
 */
function getPixelRatio() {
  if (typeof window.devicePixelRatio !== "undefined") return window.devicePixelRatio;
  return 1;
}

/**
 * Function ordering the given elements in reverse z-order so they drawn
 * the correct way.
 */
function zIndexOrdering(_extent, getter, elements) {
  // If k is > n, we'll use a standard sort
  return elements.sort(function (a, b) {
    var zA = getter(a) || 0,
      zB = getter(b) || 0;
    if (zA < zB) return -1;
    if (zA > zB) return 1;
    return 0;
  });

  // TODO: counting sort optimization
}

/**
 * Factory returning a function normalizing the given node's position & size.
 */

function createNormalizationFunction(extent) {
  var _extent$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.x, 2),
    minX = _extent$x[0],
    maxX = _extent$x[1],
    _extent$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.y, 2),
    minY = _extent$y[0],
    maxY = _extent$y[1];
  var ratio = Math.max(maxX - minX, maxY - minY),
    dX = (maxX + minX) / 2,
    dY = (maxY + minY) / 2;
  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;
  if (isNaN(dX)) dX = 0;
  if (isNaN(dY)) dY = 0;
  var fn = function fn(data) {
    return {
      x: 0.5 + (data.x - dX) / ratio,
      y: 0.5 + (data.y - dY) / ratio
    };
  };

  // TODO: possibility to apply this in batch over array of indices
  fn.applyTo = function (data) {
    data.x = 0.5 + (data.x - dX) / ratio;
    data.y = 0.5 + (data.y - dY) / ratio;
  };
  fn.inverse = function (data) {
    return {
      x: dX + ratio * (data.x - 0.5),
      y: dY + ratio * (data.y - 0.5)
    };
  };
  fn.ratio = ratio;
  return fn;
}




/***/ }),

/***/ "./node_modules/sigma/dist/sigma.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/dist/sigma.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Camera: () => (/* binding */ Camera),
/* harmony export */   MouseCaptor: () => (/* binding */ MouseCaptor),
/* harmony export */   Sigma: () => (/* binding */ Sigma$1),
/* harmony export */   TouchCaptor: () => (/* binding */ TouchCaptor),
/* harmony export */   "default": () => (/* binding */ Sigma)
/* harmony export */ });
/* harmony import */ var _index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-236c62ad.esm.js */ "./node_modules/sigma/dist/index-236c62ad.esm.js");
/* harmony import */ var _inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var _types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/dist/sigma-types.esm.js */ "./node_modules/sigma/types/dist/sigma-types.esm.js");
/* harmony import */ var _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalization-be445518.esm.js */ "./node_modules/sigma/dist/normalization-be445518.esm.js");
/* harmony import */ var _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings/dist/sigma-settings.esm.js */ "./node_modules/sigma/settings/dist/sigma-settings.esm.js");
/* harmony import */ var _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");
/* harmony import */ var _data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-11df7124.esm.js */ "./node_modules/sigma/dist/data-11df7124.esm.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);










/**
 * Defaults.
 */
var DEFAULT_ZOOMING_RATIO = 1.5;

/**
 * Event types.
 */
/**
 * Camera class
 */
var Camera = /*#__PURE__*/function (_TypedEventEmitter) {
  function Camera() {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Camera);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Camera);

    // State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "x", 0.5);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "y", 0.5);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "angle", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "ratio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "minRatio", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "maxRatio", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledZooming", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledPanning", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabledRotation", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "clean", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nextFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "previousState", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    _this.previousState = _this.getState();
    return _this;
  }

  /**
   * Static method used to create a Camera object with a given state.
   */
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Camera, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Camera, [{
    key: "enable",
    value:
    /**
     * Method used to enable the camera.
     */
    function enable() {
      this.enabled = true;
      return this;
    }

    /**
     * Method used to disable the camera.
     */
  }, {
    key: "disable",
    value: function disable() {
      this.enabled = false;
      return this;
    }

    /**
     * Method used to retrieve the camera's current state.
     */
  }, {
    key: "getState",
    value: function getState() {
      return {
        x: this.x,
        y: this.y,
        angle: this.angle,
        ratio: this.ratio
      };
    }

    /**
     * Method used to check whether the camera has the given state.
     */
  }, {
    key: "hasState",
    value: function hasState(state) {
      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;
    }

    /**
     * Method used to retrieve the camera's previous state.
     */
  }, {
    key: "getPreviousState",
    value: function getPreviousState() {
      var state = this.previousState;
      if (!state) return null;
      return {
        x: state.x,
        y: state.y,
        angle: state.angle,
        ratio: state.ratio
      };
    }

    /**
     * Method used to check minRatio and maxRatio values.
     */
  }, {
    key: "getBoundedRatio",
    value: function getBoundedRatio(ratio) {
      var r = ratio;
      if (typeof this.minRatio === "number") r = Math.max(r, this.minRatio);
      if (typeof this.maxRatio === "number") r = Math.min(r, this.maxRatio);
      return r;
    }

    /**
     * Method used to check various things to return a legit state candidate.
     */
  }, {
    key: "validateState",
    value: function validateState(state) {
      var validatedState = {};
      if (this.enabledPanning && typeof state.x === "number") validatedState.x = state.x;
      if (this.enabledPanning && typeof state.y === "number") validatedState.y = state.y;
      if (this.enabledZooming && typeof state.ratio === "number") validatedState.ratio = this.getBoundedRatio(state.ratio);
      if (this.enabledRotation && typeof state.angle === "number") validatedState.angle = state.angle;
      return this.clean ? this.clean((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.getState()), validatedState)) : validatedState;
    }

    /**
     * Method used to check whether the camera is currently being animated.
     */
  }, {
    key: "isAnimated",
    value: function isAnimated() {
      return !!this.nextFrame;
    }

    /**
     * Method used to set the camera's state.
     */
  }, {
    key: "setState",
    value: function setState(state) {
      if (!this.enabled) return this;

      // Keeping track of last state
      this.previousState = this.getState();
      var validState = this.validateState(state);
      if (typeof validState.x === "number") this.x = validState.x;
      if (typeof validState.y === "number") this.y = validState.y;
      if (typeof validState.ratio === "number") this.ratio = validState.ratio;
      if (typeof validState.angle === "number") this.angle = validState.angle;

      // Emitting
      if (!this.hasState(this.previousState)) this.emit("updated", this.getState());
      return this;
    }

    /**
     * Method used to update the camera's state using a function.
     */
  }, {
    key: "updateState",
    value: function updateState(updater) {
      this.setState(updater(this.getState()));
      return this;
    }

    /**
     * Method used to animate the camera.
     */
  }, {
    key: "animate",
    value: function animate(state) {
      var _this2 = this;
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 ? arguments[2] : undefined;
      if (!callback) return new Promise(function (resolve) {
        return _this2.animate(state, opts, resolve);
      });
      if (!this.enabled) return;
      var options = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.A), opts);
      var validState = this.validateState(state);
      var easing = typeof options.easing === "function" ? options.easing : _normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.e[options.easing];

      // State
      var start = Date.now(),
        initialState = this.getState();

      // Function performing the animation
      var _fn = function fn() {
        var t = (Date.now() - start) / options.duration;

        // The animation is over:
        if (t >= 1) {
          _this2.nextFrame = null;
          _this2.setState(validState);
          if (_this2.animationCallback) {
            _this2.animationCallback.call(null);
            _this2.animationCallback = undefined;
          }
          return;
        }
        var coefficient = easing(t);
        var newState = {};
        if (typeof validState.x === "number") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;
        if (typeof validState.y === "number") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;
        if (_this2.enabledRotation && typeof validState.angle === "number") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;
        if (typeof validState.ratio === "number") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;
        _this2.setState(newState);
        _this2.nextFrame = requestAnimationFrame(_fn);
      };
      if (this.nextFrame) {
        cancelAnimationFrame(this.nextFrame);
        if (this.animationCallback) this.animationCallback.call(null);
        this.nextFrame = requestAnimationFrame(_fn);
      } else {
        _fn();
      }
      this.animationCallback = callback;
    }

    /**
     * Method used to zoom the camera.
     */
  }, {
    key: "animatedZoom",
    value: function animatedZoom(factorOrOptions) {
      if (!factorOrOptions) return this.animate({
        ratio: this.ratio / DEFAULT_ZOOMING_RATIO
      });
      if (typeof factorOrOptions === "number") return this.animate({
        ratio: this.ratio / factorOrOptions
      });
      return this.animate({
        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      }, factorOrOptions);
    }

    /**
     * Method used to unzoom the camera.
     */
  }, {
    key: "animatedUnzoom",
    value: function animatedUnzoom(factorOrOptions) {
      if (!factorOrOptions) return this.animate({
        ratio: this.ratio * DEFAULT_ZOOMING_RATIO
      });
      if (typeof factorOrOptions === "number") return this.animate({
        ratio: this.ratio * factorOrOptions
      });
      return this.animate({
        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)
      }, factorOrOptions);
    }

    /**
     * Method used to reset the camera.
     */
  }, {
    key: "animatedReset",
    value: function animatedReset(options) {
      return this.animate({
        x: 0.5,
        y: 0.5,
        ratio: 1,
        angle: 0
      }, options);
    }

    /**
     * Returns a new Camera instance, with the same state as the current camera.
     */
  }, {
    key: "copy",
    value: function copy() {
      return Camera.from(this.getState());
    }
  }], [{
    key: "from",
    value: function from(state) {
      var camera = new Camera();
      return camera.setState(state);
    }
  }]);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

/**
 * Captor utils functions
 * ======================
 */

/**
 * Extract the local X and Y coordinates from a mouse event or touch object. If
 * a DOM element is given, it uses this element's offset to compute the position
 * (this allows using events that are not bound to the container itself and
 * still have a proper position).
 *
 * @param  {event}       e - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {number}      The local Y value of the mouse.
 */
function getPosition(e, dom) {
  var bbox = dom.getBoundingClientRect();
  return {
    x: e.clientX - bbox.left,
    y: e.clientY - bbox.top
  };
}

/**
 * Convert mouse coords to sigma coords.
 *
 * @param  {event}       e   - A mouse event or touch object.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getMouseCoords(e, dom) {
  var res = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getPosition(e, dom)), {}, {
    sigmaDefaultPrevented: false,
    preventSigmaDefault: function preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e
  });
  return res;
}

/**
 * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.
 */
function cleanMouseCoords(e) {
  var res = "x" in e ? e : (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, e.touches[0] || e.previousTouches[0]), {}, {
    original: e.original,
    sigmaDefaultPrevented: e.sigmaDefaultPrevented,
    preventSigmaDefault: function preventSigmaDefault() {
      e.sigmaDefaultPrevented = true;
      res.sigmaDefaultPrevented = true;
    }
  });
  return res;
}

/**
 * Convert mouse wheel event coords to sigma coords.
 *
 * @param  {event}       e   - A wheel mouse event.
 * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getWheelCoords(e, dom) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, getMouseCoords(e, dom)), {}, {
    delta: getWheelDelta(e)
  });
}
var MAX_TOUCHES = 2;
function getTouchesArray(touches) {
  var arr = [];
  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);
  return arr;
}

/**
 * Convert touch coords to sigma coords.
 *
 * @param  {event}       e               - A touch event.
 * @param  {Touch[]}     previousTouches - An array of the previously stored touches.
 * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.
 * @return {object}
 */
function getTouchCoords(e, previousTouches, dom) {
  var res = {
    touches: getTouchesArray(e.touches).map(function (touch) {
      return getPosition(touch, dom);
    }),
    previousTouches: previousTouches.map(function (touch) {
      return getPosition(touch, dom);
    }),
    sigmaDefaultPrevented: false,
    preventSigmaDefault: function preventSigmaDefault() {
      res.sigmaDefaultPrevented = true;
    },
    original: e
  };
  return res;
}

/**
 * Extract the wheel delta from a mouse event or touch object.
 *
 * @param  {event}  e - A mouse event or touch object.
 * @return {number}     The wheel delta of the mouse.
 */
function getWheelDelta(e) {
  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat
  if (typeof e.deltaY !== "undefined") return e.deltaY * -3 / 360;
  if (typeof e.detail !== "undefined") return e.detail / -9;
  throw new Error("Captor: could not extract delta from event.");
}

/**
 * Abstract class representing a captor like the user's mouse or touch controls.
 */
var Captor = /*#__PURE__*/function (_TypedEventEmitter) {
  function Captor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Captor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Captor);
    // Properties
    _this.container = container;
    _this.renderer = renderer;
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Captor, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Captor);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

var MOUSE_SETTINGS_KEYS = ["doubleClickTimeout", "doubleClickZoomingDuration", "doubleClickZoomingRatio", "dragTimeout", "draggedEventsTolerance", "inertiaDuration", "inertiaRatio", "zoomDuration", "zoomingRatio"];
var DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));
}, {});

/**
 * Event types.
 */
/**
 * Mouse captor class.
 *
 * @constructor
 */
var MouseCaptor = /*#__PURE__*/function (_Captor) {
  function MouseCaptor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, MouseCaptor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, MouseCaptor, [container, renderer]);

    // Binding methods
    // State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "draggedEvents", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "downStartTime", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastMouseX", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastMouseY", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMouseDown", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMoving", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "movingTimeout", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "startCameraState", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "clicks", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "doubleClickTimeout", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "currentWheelDirection", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "settings", DEFAULT_MOUSE_SETTINGS);
    _this.handleClick = _this.handleClick.bind(_this);
    _this.handleRightClick = _this.handleRightClick.bind(_this);
    _this.handleDown = _this.handleDown.bind(_this);
    _this.handleUp = _this.handleUp.bind(_this);
    _this.handleMove = _this.handleMove.bind(_this);
    _this.handleWheel = _this.handleWheel.bind(_this);
    _this.handleLeave = _this.handleLeave.bind(_this);
    _this.handleEnter = _this.handleEnter.bind(_this);

    // Binding events
    container.addEventListener("click", _this.handleClick, {
      capture: false
    });
    container.addEventListener("contextmenu", _this.handleRightClick, {
      capture: false
    });
    container.addEventListener("mousedown", _this.handleDown, {
      capture: false
    });
    container.addEventListener("wheel", _this.handleWheel, {
      capture: false
    });
    container.addEventListener("mouseleave", _this.handleLeave, {
      capture: false
    });
    container.addEventListener("mouseenter", _this.handleEnter, {
      capture: false
    });
    document.addEventListener("mousemove", _this.handleMove, {
      capture: false
    });
    document.addEventListener("mouseup", _this.handleUp, {
      capture: false
    });
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(MouseCaptor, _Captor);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(MouseCaptor, [{
    key: "kill",
    value: function kill() {
      var container = this.container;
      container.removeEventListener("click", this.handleClick);
      container.removeEventListener("contextmenu", this.handleRightClick);
      container.removeEventListener("mousedown", this.handleDown);
      container.removeEventListener("wheel", this.handleWheel);
      container.removeEventListener("mouseleave", this.handleLeave);
      container.removeEventListener("mouseenter", this.handleEnter);
      document.removeEventListener("mousemove", this.handleMove);
      document.removeEventListener("mouseup", this.handleUp);
    }
  }, {
    key: "handleClick",
    value: function handleClick(e) {
      var _this2 = this;
      if (!this.enabled) return;
      this.clicks++;
      if (this.clicks === 2) {
        this.clicks = 0;
        if (typeof this.doubleClickTimeout === "number") {
          clearTimeout(this.doubleClickTimeout);
          this.doubleClickTimeout = null;
        }
        return this.handleDoubleClick(e);
      }
      setTimeout(function () {
        _this2.clicks = 0;
        _this2.doubleClickTimeout = null;
      }, this.settings.doubleClickTimeout);

      // NOTE: this is here to prevent click events on drag
      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit("click", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleRightClick",
    value: function handleRightClick(e) {
      if (!this.enabled) return;
      this.emit("rightClick", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleDoubleClick",
    value: function handleDoubleClick(e) {
      if (!this.enabled) return;
      e.preventDefault();
      e.stopPropagation();
      var mouseCoords = getMouseCoords(e, this.container);
      this.emit("doubleClick", mouseCoords);
      if (mouseCoords.sigmaDefaultPrevented) return;

      // default behavior
      var camera = this.renderer.getCamera();
      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);
      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {
        easing: "quadraticInOut",
        duration: this.settings.doubleClickZoomingDuration
      });
    }
  }, {
    key: "handleDown",
    value: function handleDown(e) {
      if (!this.enabled) return;

      // We only start dragging on left button
      if (e.button === 0) {
        this.startCameraState = this.renderer.getCamera().getState();
        var _getPosition = getPosition(e, this.container),
          x = _getPosition.x,
          y = _getPosition.y;
        this.lastMouseX = x;
        this.lastMouseY = y;
        this.draggedEvents = 0;
        this.downStartTime = Date.now();
        this.isMouseDown = true;
      }
      this.emit("mousedown", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleUp",
    value: function handleUp(e) {
      var _this3 = this;
      if (!this.enabled || !this.isMouseDown) return;
      var camera = this.renderer.getCamera();
      this.isMouseDown = false;
      if (typeof this.movingTimeout === "number") {
        clearTimeout(this.movingTimeout);
        this.movingTimeout = null;
      }
      var _getPosition2 = getPosition(e, this.container),
        x = _getPosition2.x,
        y = _getPosition2.y;
      var cameraState = camera.getState(),
        previousCameraState = camera.getPreviousState() || {
          x: 0,
          y: 0
        };
      if (this.isMoving) {
        camera.animate({
          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
        }, {
          duration: this.settings.inertiaDuration,
          easing: "quadraticOut"
        });
      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {
        camera.setState({
          x: cameraState.x,
          y: cameraState.y
        });
      }
      this.isMoving = false;
      setTimeout(function () {
        var shouldRefresh = _this3.draggedEvents > 0;
        _this3.draggedEvents = 0;

        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work
        // when someone releases camera pan drag after having stopped moving.
        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2
        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290
        // It could be possible to render instead of scheduling a refresh but for
        // now it seems good enough.
        if (shouldRefresh && _this3.renderer.getSetting("hideEdgesOnMove")) _this3.renderer.refresh();
      }, 0);
      this.emit("mouseup", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleMove",
    value: function handleMove(e) {
      var _this4 = this;
      if (!this.enabled) return;
      var mouseCoords = getMouseCoords(e, this.container);

      // Always trigger a "mousemovebody" event, so that it is possible to develop
      // a drag-and-drop effect that works even when the mouse is out of the
      // container:
      this.emit("mousemovebody", mouseCoords);

      // Only trigger the "mousemove" event when the mouse is actually hovering
      // the container, to avoid weirdly hovering nodes and/or edges when the
      // mouse is not hover the container:
      if (e.target === this.container || e.composedPath()[0] === this.container) {
        this.emit("mousemove", mouseCoords);
      }
      if (mouseCoords.sigmaDefaultPrevented) return;

      // Handle the case when "isMouseDown" all the time, to allow dragging the
      // stage while the mouse is not hover the container:
      if (this.isMouseDown) {
        this.isMoving = true;
        this.draggedEvents++;
        if (typeof this.movingTimeout === "number") {
          clearTimeout(this.movingTimeout);
        }
        this.movingTimeout = window.setTimeout(function () {
          _this4.movingTimeout = null;
          _this4.isMoving = false;
        }, this.settings.dragTimeout);
        var camera = this.renderer.getCamera();
        var _getPosition3 = getPosition(e, this.container),
          eX = _getPosition3.x,
          eY = _getPosition3.y;
        var lastMouse = this.renderer.viewportToFramedGraph({
          x: this.lastMouseX,
          y: this.lastMouseY
        });
        var mouse = this.renderer.viewportToFramedGraph({
          x: eX,
          y: eY
        });
        var offsetX = lastMouse.x - mouse.x,
          offsetY = lastMouse.y - mouse.y;
        var cameraState = camera.getState();
        var x = cameraState.x + offsetX,
          y = cameraState.y + offsetY;
        camera.setState({
          x: x,
          y: y
        });
        this.lastMouseX = eX;
        this.lastMouseY = eY;
        e.preventDefault();
        e.stopPropagation();
      }
    }
  }, {
    key: "handleLeave",
    value: function handleLeave(e) {
      this.emit("mouseleave", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleEnter",
    value: function handleEnter(e) {
      this.emit("mouseenter", getMouseCoords(e, this.container));
    }
  }, {
    key: "handleWheel",
    value: function handleWheel(e) {
      var _this5 = this;
      var camera = this.renderer.getCamera();
      if (!this.enabled || !camera.enabledZooming) return;
      var delta = getWheelDelta(e);
      if (!delta) return;
      var wheelCoords = getWheelCoords(e, this.container);
      this.emit("wheel", wheelCoords);
      if (wheelCoords.sigmaDefaultPrevented) {
        e.preventDefault();
        e.stopPropagation();
        return;
      }

      // Default behavior
      var currentRatio = camera.getState().ratio;
      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;
      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);
      var wheelDirection = delta > 0 ? 1 : -1;
      var now = Date.now();

      // Exit early without preventing default behavior when ratio doesn't change:
      if (currentRatio === newRatio) return;
      e.preventDefault();
      e.stopPropagation();

      // Cancel events that are too close each other and in the same direction:
      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {
        return;
      }
      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {
        easing: "quadraticOut",
        duration: this.settings.zoomDuration
      }, function () {
        _this5.currentWheelDirection = 0;
      });
      this.currentWheelDirection = wheelDirection;
      this.lastWheelTriggerTime = now;
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
  }]);
}(Captor);

var TOUCH_SETTINGS_KEYS = ["dragTimeout", "inertiaDuration", "inertiaRatio", "doubleClickTimeout", "doubleClickZoomingRatio", "doubleClickZoomingDuration", "tapMoveTolerance"];
var DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {
  return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, iter), {}, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, key, _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_SETTINGS[key]));
}, {});

/**
 * Event types.
 */
/**
 * Touch captor class.
 *
 * @constructor
 */
var TouchCaptor = /*#__PURE__*/function (_Captor) {
  function TouchCaptor(container, renderer) {
    var _this;
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, TouchCaptor);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, TouchCaptor, [container, renderer]);

    // Binding methods:
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "enabled", true);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "isMoving", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hasMoved", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "touchMode", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "startTouchesPositions", []);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastTouches", []);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "lastTap", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "settings", DEFAULT_TOUCH_SETTINGS);
    _this.handleStart = _this.handleStart.bind(_this);
    _this.handleLeave = _this.handleLeave.bind(_this);
    _this.handleMove = _this.handleMove.bind(_this);

    // Binding events
    container.addEventListener("touchstart", _this.handleStart, {
      capture: false
    });
    container.addEventListener("touchcancel", _this.handleLeave, {
      capture: false
    });
    document.addEventListener("touchend", _this.handleLeave, {
      capture: false,
      passive: false
    });
    document.addEventListener("touchmove", _this.handleMove, {
      capture: false,
      passive: false
    });
    return _this;
  }
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(TouchCaptor, _Captor);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(TouchCaptor, [{
    key: "kill",
    value: function kill() {
      var container = this.container;
      container.removeEventListener("touchstart", this.handleStart);
      container.removeEventListener("touchcancel", this.handleLeave);
      document.removeEventListener("touchend", this.handleLeave);
      document.removeEventListener("touchmove", this.handleMove);
    }
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return {
        width: this.container.offsetWidth,
        height: this.container.offsetHeight
      };
    }
  }, {
    key: "handleStart",
    value: function handleStart(e) {
      var _this2 = this;
      if (!this.enabled) return;
      e.preventDefault();
      var touches = getTouchesArray(e.touches);
      this.touchMode = touches.length;
      this.startCameraState = this.renderer.getCamera().getState();
      this.startTouchesPositions = touches.map(function (touch) {
        return getPosition(touch, _this2.container);
      });

      // When there are two touches down, let's record distance and angle as well:
      if (this.touchMode === 2) {
        var _this$startTouchesPos = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this.startTouchesPositions, 2),
          _this$startTouchesPos2 = _this$startTouchesPos[0],
          x0 = _this$startTouchesPos2.x,
          y0 = _this$startTouchesPos2.y,
          _this$startTouchesPos3 = _this$startTouchesPos[1],
          x1 = _this$startTouchesPos3.x,
          y1 = _this$startTouchesPos3.y;
        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);
        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));
      }
      this.emit("touchdown", getTouchCoords(e, this.lastTouches, this.container));
      this.lastTouches = touches;
      this.lastTouchesPositions = this.startTouchesPositions;
    }
  }, {
    key: "handleLeave",
    value: function handleLeave(e) {
      if (!this.enabled || !this.startTouchesPositions.length) return;
      if (e.cancelable) e.preventDefault();
      if (this.movingTimeout) {
        this.isMoving = false;
        clearTimeout(this.movingTimeout);
      }
      switch (this.touchMode) {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        case 2:
          if (e.touches.length === 1) {
            this.handleStart(e);
            e.preventDefault();
            break;
          }
        /* falls through */
        case 1:
          if (this.isMoving) {
            var camera = this.renderer.getCamera();
            var cameraState = camera.getState(),
              previousCameraState = camera.getPreviousState() || {
                x: 0,
                y: 0
              };
            camera.animate({
              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),
              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)
            }, {
              duration: this.settings.inertiaDuration,
              easing: "quadraticOut"
            });
          }
          this.hasMoved = false;
          this.isMoving = false;
          this.touchMode = 0;
          break;
      }
      this.emit("touchup", getTouchCoords(e, this.lastTouches, this.container));

      // When the last touch ends and there hasn't been too much movement, trigger a "tap" or "doubletap" event:
      if (!e.touches.length) {
        var position = getPosition(this.lastTouches[0], this.container);
        var downPosition = this.startTouchesPositions[0];
        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);
        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {
          // Only trigger "doubletap" when the last tap is recent enough:
          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {
            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);
            this.emit("doubletap", touchCoords);
            this.lastTap = null;
            if (!touchCoords.sigmaDefaultPrevented) {
              var _camera = this.renderer.getCamera();
              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);
              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {
                easing: "quadraticInOut",
                duration: this.settings.doubleClickZoomingDuration
              });
            }
          }
          // Else, trigger a normal "tap" event:
          else {
            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);
            this.emit("tap", _touchCoords);
            this.lastTap = {
              time: Date.now(),
              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]
            };
          }
        }
      }
      this.lastTouches = getTouchesArray(e.touches);
      this.startTouchesPositions = [];
    }
  }, {
    key: "handleMove",
    value: function handleMove(e) {
      var _this3 = this;
      if (!this.enabled || !this.startTouchesPositions.length) return;
      e.preventDefault();
      var touches = getTouchesArray(e.touches);
      var touchesPositions = touches.map(function (touch) {
        return getPosition(touch, _this3.container);
      });
      var lastTouches = this.lastTouches;
      this.lastTouches = touches;
      this.lastTouchesPositions = touchesPositions;
      var touchCoords = getTouchCoords(e, lastTouches, this.container);
      this.emit("touchmove", touchCoords);
      if (touchCoords.sigmaDefaultPrevented) return;

      // If a move was initiated at some point, and we get back to start point,
      // we should still consider that we did move (which also happens after a
      // multiple touch when only one touch remains in which case handleStart
      // is recalled within handleLeave).
      // Now, some mobile browsers report zero-distance moves so we also check that
      // one of the touches did actually move from the origin position.
      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {
        var startPosition = _this3.startTouchesPositions[idx];
        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);
      }));

      // If there was no move, do not trigger touch moves behavior
      if (!this.hasMoved) {
        return;
      }
      this.isMoving = true;
      if (this.movingTimeout) clearTimeout(this.movingTimeout);
      this.movingTimeout = window.setTimeout(function () {
        _this3.isMoving = false;
      }, this.settings.dragTimeout);
      var camera = this.renderer.getCamera();
      var startCameraState = this.startCameraState;
      var padding = this.renderer.getSetting("stagePadding");
      switch (this.touchMode) {
        case 1:
          {
            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),
              xStart = _this$renderer$viewpo.x,
              yStart = _this$renderer$viewpo.y;
            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),
              x = _this$renderer$viewpo2.x,
              y = _this$renderer$viewpo2.y;
            camera.setState({
              x: startCameraState.x + xStart - x,
              y: startCameraState.y + yStart - y
            });
            break;
          }
        case 2:
          {
            /**
             * Here is the thinking here:
             *
             * 1. We can find the new angle and ratio, by comparing the vector from "touch one" to "touch two" at the start
             *    of the d'n'd and now
             *
             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph
             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport
             *    position of this same touch now
             */
            var newCameraState = {
              x: 0.5,
              y: 0.5,
              angle: 0,
              ratio: 1
            };
            var _touchesPositions$ = touchesPositions[0],
              x0 = _touchesPositions$.x,
              y0 = _touchesPositions$.y;
            var _touchesPositions$2 = touchesPositions[1],
              x1 = _touchesPositions$2.x,
              y1 = _touchesPositions$2.y;
            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;
            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;

            // 1.
            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);
            newCameraState.ratio = newRatio;
            newCameraState.angle = startCameraState.angle + angleDiff;

            // 2.
            var dimensions = this.getDimensions();
            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {
              cameraState: startCameraState
            });
            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;
            var dx = smallestDimension / dimensions.width;
            var dy = smallestDimension / dimensions.height;
            var ratio = newRatio / smallestDimension;

            // Align with center of the graph:
            var _x = x0 - smallestDimension / 2 / dx;
            var _y = y0 - smallestDimension / 2 / dy;

            // Rotate:
            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];
            _x = _ref[0];
            _y = _ref[1];
            newCameraState.x = touchGraphPosition.x - _x * ratio;
            newCameraState.y = touchGraphPosition.y + _y * ratio;
            camera.setState(newCameraState);
            break;
          }
      }
    }
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      this.settings = settings;
    }
  }]);
}(Captor);

function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(r);
}

function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(r) || _nonIterableSpread();
}

function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

function _objectWithoutProperties(e, t) {
  if (null == e) return {};
  var o,
    r,
    i = _objectWithoutPropertiesLoose(e, t);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    for (r = 0; r < n.length; r++) o = n[r], -1 === t.indexOf(o) && {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
  }
  return i;
}

/**
 * Sigma.js Labels Heuristics
 * ===========================
 *
 * Miscellaneous heuristics related to label display.
 * @module
 */
/**
 * Class representing a single candidate for the label grid selection.
 *
 * It also describes a deterministic way to compare two candidates to assess
 * which one is better.
 */
var LabelCandidate = /*#__PURE__*/function () {
  function LabelCandidate(key, size) {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelCandidate);
    this.key = key;
    this.size = size;
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelCandidate, null, [{
    key: "compare",
    value: function compare(first, second) {
      // First we compare by size
      if (first.size > second.size) return -1;
      if (first.size < second.size) return 1;

      // Then since no two nodes can have the same key, we use it to
      // deterministically tie-break by key
      if (first.key > second.key) return 1;

      // NOTE: this comparator cannot return 0
      return -1;
    }
  }]);
}();
/**
 * Class representing a 2D spatial grid divided into constant-size cells.
 */
var LabelGrid = /*#__PURE__*/function () {
  function LabelGrid() {
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, LabelGrid);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "width", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "height", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "cellSize", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "columns", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "rows", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(this, "cells", {});
  }
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(LabelGrid, [{
    key: "resizeAndClear",
    value: function resizeAndClear(dimensions, cellSize) {
      this.width = dimensions.width;
      this.height = dimensions.height;
      this.cellSize = cellSize;
      this.columns = Math.ceil(dimensions.width / cellSize);
      this.rows = Math.ceil(dimensions.height / cellSize);
      this.cells = {};
    }
  }, {
    key: "getIndex",
    value: function getIndex(pos) {
      var xIndex = Math.floor(pos.x / this.cellSize);
      var yIndex = Math.floor(pos.y / this.cellSize);
      return yIndex * this.columns + xIndex;
    }
  }, {
    key: "add",
    value: function add(key, size, pos) {
      var candidate = new LabelCandidate(key, size);
      var index = this.getIndex(pos);
      var cell = this.cells[index];
      if (!cell) {
        cell = [];
        this.cells[index] = cell;
      }
      cell.push(candidate);
    }
  }, {
    key: "organize",
    value: function organize() {
      for (var k in this.cells) {
        var cell = this.cells[k];
        cell.sort(LabelCandidate.compare);
      }
    }
  }, {
    key: "getLabelsToDisplay",
    value: function getLabelsToDisplay(ratio, density) {
      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?
      // TODO: adjust threshold lower, but increase cells a bit?
      // TODO: hunt for geom issue in disguise
      // TODO: memoize while ratio does not move. method to force recompute
      var cellArea = this.cellSize * this.cellSize;
      var scaledCellArea = cellArea / ratio / ratio;
      var scaledDensity = scaledCellArea * density / cellArea;
      var labelsToDisplayPerCell = Math.ceil(scaledDensity);
      var labels = [];
      for (var k in this.cells) {
        var cell = this.cells[k];
        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {
          labels.push(cell[i].key);
        }
      }
      return labels;
    }
  }]);
}();

/**
 * Label heuristic selecting edge labels to display, based on displayed node
 * labels
 *
 * @param  {object} params                 - Parameters:
 * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.
 * @param  {Set}      highlightedNodes     - Highlighted nodes.
 * @param  {Graph}    graph                - The rendered graph.
 * @param  {string}   hoveredNode          - Hovered node (optional)
 * @return {Array}                         - The selected labels.
 */
function edgeLabelsToDisplayFromNodes(params) {
  var graph = params.graph,
    hoveredNode = params.hoveredNode,
    highlightedNodes = params.highlightedNodes,
    displayedNodeLabels = params.displayedNodeLabels;
  var worthyEdges = [];

  // TODO: the code below can be optimized using #.forEach and batching the code per adj

  // We should display an edge's label if:
  //   - Any of its extremities is highlighted or hovered
  //   - Both of its extremities has its label shown
  graph.forEachEdge(function (edge, _, source, target) {
    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {
      worthyEdges.push(edge);
    }
  });
  return worthyEdges;
}

/**
 * Constants.
 */
var X_LABEL_MARGIN = 150;
var Y_LABEL_MARGIN = 50;
var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * Important functions.
 */
function applyNodeDefaults(settings, key, data) {
  if (!hasOwnProperty.call(data, "x") || !hasOwnProperty.call(data, "y")) throw new Error("Sigma: could not find a valid position (x, y) for node \"".concat(key, "\". All your nodes must have a number \"x\" and \"y\". Maybe your forgot to apply a layout or your \"nodeReducer\" is not returning the correct data?"));
  if (!data.color) data.color = settings.defaultNodeColor;
  if (!data.label && data.label !== "") data.label = null;
  if (data.label !== undefined && data.label !== null) data.label = "" + data.label;else data.label = null;
  if (!data.size) data.size = 2;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "highlighted")) data.highlighted = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultNodeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}
function applyEdgeDefaults(settings, _key, data) {
  if (!data.color) data.color = settings.defaultEdgeColor;
  if (!data.label) data.label = "";
  if (!data.size) data.size = 0.5;
  if (!hasOwnProperty.call(data, "hidden")) data.hidden = false;
  if (!hasOwnProperty.call(data, "forceLabel")) data.forceLabel = false;
  if (!data.type || data.type === "") data.type = settings.defaultEdgeType;
  if (!data.zIndex) data.zIndex = 0;
  return data;
}

/**
 * Main class.
 *
 * @constructor
 * @param {Graph}       graph     - Graph to render.
 * @param {HTMLElement} container - DOM container in which to render.
 * @param {object}      settings  - Optional settings.
 */
var Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {
  function Sigma(graph, container) {
    var _this;
    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Sigma);
    _this = (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(this, Sigma);

    // Resolving settings
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "elements", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "canvasContexts", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "webGLContexts", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pickingLayers", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "textures", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "frameBuffers", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "activeListeners", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "labelGrid", new LabelGrid());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeDataCache", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeDataCache", {});
    // Indices to keep track of the index of the item inside programs
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeProgramIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeProgramIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodesWithForcedLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgesWithForcedLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeExtent", {
      x: [0, 1],
      y: [0, 1]
    });
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeZExtent", [Infinity, -Infinity]);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeZExtent", [Infinity, -Infinity]);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "matrix", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "invMatrix", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "correctionRatio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "customBBox", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "normalizationFunction", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)({
      x: [0, 1],
      y: [0, 1]
    }));
    // Cache:
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "graphToViewportRatio", 1);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "itemIDsIndex", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeIndices", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgeIndices", {});
    // Starting dimensions and pixel ratio
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "width", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "height", 0);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pixelRatio", (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "pickingDownSizingRatio", 2 * _this.pixelRatio);
    // Graph State
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "displayedNodeLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "displayedEdgeLabels", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "highlightedNodes", new Set());
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hoveredNode", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "hoveredEdge", null);
    // Internal states
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "renderFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "renderHighlightedNodesFrame", null);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "needToProcess", false);
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "checkEdgesEventsFrame", null);
    // Programs
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodePrograms", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "nodeHoverPrograms", {});
    (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)(_this, "edgePrograms", {});
    _this.settings = (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.resolveSettings)(settings);

    // Validating
    (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(_this.settings);
    (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.v)(graph);
    if (!(container instanceof HTMLElement)) throw new Error("Sigma: container should be an html element.");

    // Properties
    _this.graph = graph;
    _this.container = container;

    // Initializing contexts
    _this.createWebGLContext("edges", {
      picking: settings.enableEdgeEvents
    });
    _this.createCanvasContext("edgeLabels");
    _this.createWebGLContext("nodes", {
      picking: true
    });
    _this.createCanvasContext("labels");
    _this.createCanvasContext("hovers");
    _this.createWebGLContext("hoverNodes");
    _this.createCanvasContext("mouse", {
      style: {
        touchAction: "none",
        userSelect: "none"
      }
    });

    // Initial resize
    _this.resize();

    // Loading programs
    for (var type in _this.settings.nodeProgramClasses) {
      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);
    }
    for (var _type in _this.settings.edgeProgramClasses) {
      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);
    }

    // Initializing the camera
    _this.camera = new Camera();

    // Binding camera events
    _this.bindCameraHandlers();

    // Initializing captors
    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);
    _this.mouseCaptor.setSettings(_this.settings);
    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);
    _this.touchCaptor.setSettings(_this.settings);

    // Binding event handlers
    _this.bindEventHandlers();

    // Binding graph handlers
    _this.bindGraphHandlers();

    // Trigger eventual settings-related things
    _this.handleSettingsUpdate();

    // Processing data for the first time & render
    _this.refresh();
    return _this;
  }

  /**---------------------------------------------------------------------------
   * Internal methods.
   **---------------------------------------------------------------------------
   */

  /**
   * Internal function used to register a node program
   *
   * @param  {string}           key              - The program's key, matching the related nodes "type" values.
   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.
   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).
   * @return {Sigma}
   */
  (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Sigma, _TypedEventEmitter);
  return (0,_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(Sigma, [{
    key: "registerNodeProgram",
    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {
      if (this.nodePrograms[key]) this.nodePrograms[key].kill();
      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();
      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);
      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);
      return this;
    }

    /**
     * Internal function used to register an edge program
     *
     * @param  {string}          key              - The program's key, matching the related edges "type" values.
     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.
     * @return {Sigma}
     */
  }, {
    key: "registerEdgeProgram",
    value: function registerEdgeProgram(key, EdgeProgramClass) {
      if (this.edgePrograms[key]) this.edgePrograms[key].kill();
      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);
      return this;
    }

    /**
     * Internal function used to unregister a node program
     *
     * @param  {string} key - The program's key, matching the related nodes "type" values.
     * @return {Sigma}
     */
  }, {
    key: "unregisterNodeProgram",
    value: function unregisterNodeProgram(key) {
      if (this.nodePrograms[key]) {
        var _this$nodePrograms = this.nodePrograms,
          program = _this$nodePrograms[key],
          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        program.kill();
        this.nodePrograms = programs;
      }
      if (this.nodeHoverPrograms[key]) {
        var _this$nodeHoverProgra = this.nodeHoverPrograms,
          _program = _this$nodeHoverProgra[key],
          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        _program.kill();
        this.nodePrograms = _programs;
      }
      return this;
    }

    /**
     * Internal function used to unregister an edge program
     *
     * @param  {string} key - The program's key, matching the related edges "type" values.
     * @return {Sigma}
     */
  }, {
    key: "unregisterEdgeProgram",
    value: function unregisterEdgeProgram(key) {
      if (this.edgePrograms[key]) {
        var _this$edgePrograms = this.edgePrograms,
          program = _this$edgePrograms[key],
          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_4__.d));
        program.kill();
        this.edgePrograms = programs;
      }
      return this;
    }

    /**
     * Method (re)binding WebGL texture (for picking).
     *
     * @return {Sigma}
     */
  }, {
    key: "resetWebGLTexture",
    value: function resetWebGLTexture(id) {
      var gl = this.webGLContexts[id];
      var frameBuffer = this.frameBuffers[id];
      var currentTexture = this.textures[id];
      if (currentTexture) gl.deleteTexture(currentTexture);
      var pickingTexture = gl.createTexture();
      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);
      this.textures[id] = pickingTexture;
      return this;
    }

    /**
     * Method binding camera handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "bindCameraHandlers",
    value: function bindCameraHandlers() {
      var _this2 = this;
      this.activeListeners.camera = function () {
        _this2.scheduleRender();
      };
      this.camera.on("updated", this.activeListeners.camera);
      return this;
    }

    /**
     * Method unbinding camera handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "unbindCameraHandlers",
    value: function unbindCameraHandlers() {
      this.camera.removeListener("updated", this.activeListeners.camera);
      return this;
    }

    /**
     * Method that returns the closest node to a given position.
     */
  }, {
    key: "getNodeAtPosition",
    value: function getNodeAtPosition(position) {
      var x = position.x,
        y = position.y;
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);
      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));
      var itemAt = this.itemIDsIndex[index];
      return itemAt && itemAt.type === "node" ? itemAt.id : null;
    }

    /**
     * Method binding event handlers.
     *
     * @return {Sigma}
     */
  }, {
    key: "bindEventHandlers",
    value: function bindEventHandlers() {
      var _this3 = this;
      // Handling window resize
      this.activeListeners.handleResize = function () {
        // need to call a refresh to rebuild the labelgrid
        _this3.scheduleRefresh();
      };
      window.addEventListener("resize", this.activeListeners.handleResize);

      // Handling mouse move
      this.activeListeners.handleMove = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        var nodeToHover = _this3.getNodeAtPosition(event);
        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {
          // Handling passing from one node to the other directly
          if (_this3.hoveredNode) _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: _this3.hoveredNode
          }));
          _this3.hoveredNode = nodeToHover;
          _this3.emit("enterNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: nodeToHover
          }));
          _this3.scheduleHighlightedNodesRender();
          return;
        }

        // Checking if the hovered node is still hovered
        if (_this3.hoveredNode) {
          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {
            var node = _this3.hoveredNode;
            _this3.hoveredNode = null;
            _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              node: node
            }));
            _this3.scheduleHighlightedNodesRender();
            return;
          }
        }
        if (_this3.settings.enableEdgeEvents) {
          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);
          if (edgeToHover !== _this3.hoveredEdge) {
            if (_this3.hoveredEdge) _this3.emit("leaveEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: _this3.hoveredEdge
            }));
            if (edgeToHover) _this3.emit("enterEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: edgeToHover
            }));
            _this3.hoveredEdge = edgeToHover;
          }
        }
      };

      // Handling mouse move over body (only to dispatch the proper event):
      this.activeListeners.handleMoveBody = function (e) {
        var event = cleanMouseCoords(e);
        _this3.emit("moveBody", {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        });
      };

      // Handling mouse leave stage:
      this.activeListeners.handleLeave = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        if (_this3.hoveredNode) {
          _this3.emit("leaveNode", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: _this3.hoveredNode
          }));
          _this3.scheduleHighlightedNodesRender();
        }
        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {
          _this3.emit("leaveEdge", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            edge: _this3.hoveredEdge
          }));
          _this3.scheduleHighlightedNodesRender();
        }
        _this3.emit("leaveStage", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));
      };

      // Handling mouse enter stage:
      this.activeListeners.handleEnter = function (e) {
        var event = cleanMouseCoords(e);
        var baseEvent = {
          event: event,
          preventSigmaDefault: function preventSigmaDefault() {
            event.preventSigmaDefault();
          }
        };
        _this3.emit("enterStage", (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent));
      };

      // Handling click
      var createInteractionListener = function createInteractionListener(eventType) {
        return function (e) {
          var event = cleanMouseCoords(e);
          var baseEvent = {
            event: event,
            preventSigmaDefault: function preventSigmaDefault() {
              event.preventSigmaDefault();
            }
          };
          var nodeAtPosition = _this3.getNodeAtPosition(event);
          if (nodeAtPosition) return _this3.emit("".concat(eventType, "Node"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
            node: nodeAtPosition
          }));
          if (_this3.settings.enableEdgeEvents) {
            var edge = _this3.getEdgeAtPoint(event.x, event.y);
            if (edge) return _this3.emit("".concat(eventType, "Edge"), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, baseEvent), {}, {
              edge: edge
            }));
          }
          return _this3.emit("".concat(eventType, "Stage"), baseEvent);
        };
      };
      this.activeListeners.handleClick = createInteractionListener("click");
      this.activeListeners.handleRightClick = createInteractionListener("rightClick");
      this.activeListeners.handleDoubleClick = createInteractionListener("doubleClick");
      this.activeListeners.handleWheel = createInteractionListener("wheel");
      this.activeListeners.handleDown = createInteractionListener("down");
      this.activeListeners.handleUp = createInteractionListener("up");
      this.mouseCaptor.on("mousemove", this.activeListeners.handleMove);
      this.mouseCaptor.on("mousemovebody", this.activeListeners.handleMoveBody);
      this.mouseCaptor.on("click", this.activeListeners.handleClick);
      this.mouseCaptor.on("rightClick", this.activeListeners.handleRightClick);
      this.mouseCaptor.on("doubleClick", this.activeListeners.handleDoubleClick);
      this.mouseCaptor.on("wheel", this.activeListeners.handleWheel);
      this.mouseCaptor.on("mousedown", this.activeListeners.handleDown);
      this.mouseCaptor.on("mouseup", this.activeListeners.handleUp);
      this.mouseCaptor.on("mouseleave", this.activeListeners.handleLeave);
      this.mouseCaptor.on("mouseenter", this.activeListeners.handleEnter);
      this.touchCaptor.on("touchdown", this.activeListeners.handleDown);
      this.touchCaptor.on("touchdown", this.activeListeners.handleMove);
      this.touchCaptor.on("touchup", this.activeListeners.handleUp);
      this.touchCaptor.on("touchmove", this.activeListeners.handleMove);
      this.touchCaptor.on("tap", this.activeListeners.handleClick);
      this.touchCaptor.on("doubletap", this.activeListeners.handleDoubleClick);
      this.touchCaptor.on("touchmove", this.activeListeners.handleMoveBody);
      return this;
    }

    /**
     * Method binding graph handlers
     *
     * @return {Sigma}
     */
  }, {
    key: "bindGraphHandlers",
    value: function bindGraphHandlers() {
      var _this4 = this;
      var graph = this.graph;
      var LAYOUT_IMPACTING_FIELDS = new Set(["x", "y", "zIndex", "type"]);
      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {
        var _e$hints;
        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;
        // we process all nodes
        _this4.graph.forEachNode(function (node) {
          return _this4.updateNode(node);
        });

        // if coord, type or zIndex have changed, we need to schedule a render
        // (zIndex for the programIndex)
        var layoutChanged = !updatedFields || updatedFields.some(function (f) {
          return LAYOUT_IMPACTING_FIELDS.has(f);
        });
        _this4.refresh({
          partialGraph: {
            nodes: graph.nodes()
          },
          skipIndexation: !layoutChanged,
          schedule: true
        });
      };
      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {
        var _e$hints2;
        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;
        // we process all edges
        _this4.graph.forEachEdge(function (edge) {
          return _this4.updateEdge(edge);
        });
        var layoutChanged = updatedFields && ["zIndex", "type"].some(function (f) {
          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);
        });
        _this4.refresh({
          partialGraph: {
            edges: graph.edges()
          },
          skipIndexation: !layoutChanged,
          schedule: true
        });
      };

      // On add node, we add the node in indices and then call for a render
      this.activeListeners.addNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // we process the node
        _this4.addNode(node);
        // schedule a render for the node
        _this4.refresh({
          partialGraph: {
            nodes: [node]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On update node, we update indices and then call for a render
      this.activeListeners.updateNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // schedule a render for the node
        _this4.refresh({
          partialGraph: {
            nodes: [node]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On drop node, we remove the node from indices and then call for a refresh
      this.activeListeners.dropNodeGraphUpdate = function (payload) {
        var node = payload.key;
        // we process the node
        _this4.removeNode(node);
        // schedule a render for everything
        _this4.refresh({
          schedule: true
        });
      };

      // On add edge, we remove the edge from indices and then call for a refresh
      this.activeListeners.addEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // we process the edge
        _this4.addEdge(edge);
        // schedule a render for the edge
        _this4.refresh({
          partialGraph: {
            edges: [edge]
          },
          schedule: true
        });
      };

      // On update edge, we update indices and then call for a refresh
      this.activeListeners.updateEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // schedule a repaint for the edge
        _this4.refresh({
          partialGraph: {
            edges: [edge]
          },
          skipIndexation: false,
          schedule: true
        });
      };

      // On drop edge, we remove the edge from indices and then call for a refresh
      this.activeListeners.dropEdgeGraphUpdate = function (payload) {
        var edge = payload.key;
        // we process the edge
        _this4.removeEdge(edge);
        // schedule a render for all edges
        _this4.refresh({
          schedule: true
        });
      };

      // On clear edges, we clear the edge indices and then call for a refresh
      this.activeListeners.clearEdgesGraphUpdate = function () {
        // we clear the edge data structures
        _this4.clearEdgeState();
        _this4.clearEdgeIndices();
        // schedule a render for all edges
        _this4.refresh({
          schedule: true
        });
      };

      // On graph clear, we clear indices and then call for a refresh
      this.activeListeners.clearGraphUpdate = function () {
        // clear graph state
        _this4.clearEdgeState();
        _this4.clearNodeState();

        // clear graph indices
        _this4.clearEdgeIndices();
        _this4.clearNodeIndices();

        // schedule a render for all
        _this4.refresh({
          schedule: true
        });
      };
      graph.on("nodeAdded", this.activeListeners.addNodeGraphUpdate);
      graph.on("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
      graph.on("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
      graph.on("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
      graph.on("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
      graph.on("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
      graph.on("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
      graph.on("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
      graph.on("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
      graph.on("cleared", this.activeListeners.clearGraphUpdate);
      return this;
    }

    /**
     * Method used to unbind handlers from the graph.
     *
     * @return {undefined}
     */
  }, {
    key: "unbindGraphHandlers",
    value: function unbindGraphHandlers() {
      var graph = this.graph;
      graph.removeListener("nodeAdded", this.activeListeners.addNodeGraphUpdate);
      graph.removeListener("nodeDropped", this.activeListeners.dropNodeGraphUpdate);
      graph.removeListener("nodeAttributesUpdated", this.activeListeners.updateNodeGraphUpdate);
      graph.removeListener("eachNodeAttributesUpdated", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);
      graph.removeListener("edgeAdded", this.activeListeners.addEdgeGraphUpdate);
      graph.removeListener("edgeDropped", this.activeListeners.dropEdgeGraphUpdate);
      graph.removeListener("edgeAttributesUpdated", this.activeListeners.updateEdgeGraphUpdate);
      graph.removeListener("eachEdgeAttributesUpdated", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);
      graph.removeListener("edgesCleared", this.activeListeners.clearEdgesGraphUpdate);
      graph.removeListener("cleared", this.activeListeners.clearGraphUpdate);
    }

    /**
     * Method looking for an edge colliding with a given point at (x, y). Returns
     * the key of the edge if any, or null else.
     */
  }, {
    key: "getEdgeAtPoint",
    value: function getEdgeAtPoint(x, y) {
      var color = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);
      var index = _colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));
      var itemAt = this.itemIDsIndex[index];
      return itemAt && itemAt.type === "edge" ? itemAt.id : null;
    }

    /**
     * Method used to process the whole graph's data.
     *  - extent
     *  - normalizationFunction
     *  - compute node's coordinate
     *  - labelgrid
     *  - program data allocation
     * @return {Sigma}
     */
  }, {
    key: "process",
    value: function process() {
      var _this5 = this;
      this.emit("beforeProcess");
      var graph = this.graph;
      var settings = this.settings;
      var dimensions = this.getDimensions();

      //
      // NODES
      //
      this.nodeExtent = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)(this.graph);
      if (!this.settings.autoRescale) {
        var width = dimensions.width,
          height = dimensions.height;
        var _this$nodeExtent = this.nodeExtent,
          x = _this$nodeExtent.x,
          y = _this$nodeExtent.y;
        this.nodeExtent = {
          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],
          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]
        };
      }
      this.normalizationFunction = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(this.customBBox || this.nodeExtent);

      // NOTE: it is important to compute this matrix after computing the node's extent
      // because #.getGraphDimensions relies on it
      var nullCamera = new Camera();
      var nullCameraMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());
      // Resetting the label grid
      // TODO: it's probably better to do this explicitly or on resizes for layout and anims
      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);
      var nodesPerPrograms = {};
      var nodeIndices = {};
      var edgeIndices = {};
      var itemIDsIndex = {};
      var incrID = 1;
      var nodes = graph.nodes();

      // Do some indexation on the whole graph
      for (var i = 0, l = nodes.length; i < l; i++) {
        var node = nodes[i];
        var data = this.nodeDataCache[node];

        // Get initial coordinates
        var attrs = graph.getNodeAttributes(node);
        data.x = attrs.x;
        data.y = attrs.y;
        this.normalizationFunction.applyTo(data);

        // labelgrid
        if (typeof data.label === "string" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {
          matrix: nullCameraMatrix
        }));

        // update count per program
        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;
      }
      this.labelGrid.organize();

      // Allocate memory to programs
      for (var type in this.nodePrograms) {
        if (!hasOwnProperty.call(this.nodePrograms, type)) {
          throw new Error("Sigma: could not find a suitable program for node type \"".concat(type, "\"!"));
        }
        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);
        // We reset that count here, so that we can reuse it while calling the Program#process methods:
        nodesPerPrograms[type] = 0;
      }

      // Order nodes by zIndex before to add them to program
      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.nodeZExtent, function (node) {
        return _this5.nodeDataCache[node].zIndex;
      }, nodes);

      // Add data to programs
      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {
        var _node = nodes[_i];
        nodeIndices[_node] = incrID;
        itemIDsIndex[nodeIndices[_node]] = {
          type: "node",
          id: _node
        };
        incrID++;
        var _data = this.nodeDataCache[_node];
        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);
      }

      //
      // EDGES
      //

      var edgesPerPrograms = {};
      var edges = graph.edges();

      // Allocate memory to programs
      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {
        var edge = edges[_i2];
        var _data2 = this.edgeDataCache[edge];
        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;
      }

      // Order edges by zIndex before to add them to program
      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.edgeZExtent, function (edge) {
        return _this5.edgeDataCache[edge].zIndex;
      }, edges);
      for (var _type2 in this.edgePrograms) {
        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {
          throw new Error("Sigma: could not find a suitable program for edge type \"".concat(_type2, "\"!"));
        }
        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);
        // We reset that count here, so that we can reuse it while calling the Program#process methods:
        edgesPerPrograms[_type2] = 0;
      }

      // Add data to programs
      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {
        var _edge = edges[_i3];
        edgeIndices[_edge] = incrID;
        itemIDsIndex[edgeIndices[_edge]] = {
          type: "edge",
          id: _edge
        };
        incrID++;
        var _data3 = this.edgeDataCache[_edge];
        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);
      }
      this.itemIDsIndex = itemIDsIndex;
      this.nodeIndices = nodeIndices;
      this.edgeIndices = edgeIndices;
      this.emit("afterProcess");
      return this;
    }

    /**
     * Method that backports potential settings updates where it's needed.
     * @private
     */
  }, {
    key: "handleSettingsUpdate",
    value: function handleSettingsUpdate(oldSettings) {
      var _this6 = this;
      var settings = this.settings;
      this.camera.minRatio = settings.minCameraRatio;
      this.camera.maxRatio = settings.maxCameraRatio;
      this.camera.enabledZooming = settings.enableCameraZooming;
      this.camera.enabledPanning = settings.enableCameraPanning;
      this.camera.enabledRotation = settings.enableCameraRotation;
      if (settings.cameraPanBoundaries) {
        this.camera.clean = function (state) {
          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__._)(settings.cameraPanBoundaries) === "object" ? settings.cameraPanBoundaries : {});
        };
      } else {
        this.camera.clean = null;
      }
      this.camera.setState(this.camera.validateState(this.camera.getState()));
      if (oldSettings) {
        // Check edge programs:
        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {
          for (var type in settings.edgeProgramClasses) {
            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {
              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);
            }
          }
          for (var _type3 in oldSettings.edgeProgramClasses) {
            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);
          }
        }

        // Check node programs:
        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {
          for (var _type4 in settings.nodeProgramClasses) {
            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {
              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);
            }
          }
          for (var _type5 in oldSettings.nodeProgramClasses) {
            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);
          }
        }
      }

      // Update captors settings:
      this.mouseCaptor.setSettings(this.settings);
      this.touchCaptor.setSettings(this.settings);
      return this;
    }
  }, {
    key: "cleanCameraState",
    value: function cleanCameraState(state) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$tolerance = _ref.tolerance,
        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,
        boundaries = _ref.boundaries;
      var newState = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, state);

      // Extract necessary properties
      var _ref2 = boundaries || this.nodeExtent,
        _ref2$x = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.x, 2),
        xMinGraph = _ref2$x[0],
        xMaxGraph = _ref2$x[1],
        _ref2$y = (0,_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(_ref2.y, 2),
        yMinGraph = _ref2$y[0],
        yMaxGraph = _ref2$y[1];

      // Transform the four corners of the graph rectangle using the provided camera state
      var corners = [this.graphToViewport({
        x: xMinGraph,
        y: yMinGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMaxGraph,
        y: yMinGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMinGraph,
        y: yMaxGraph
      }, {
        cameraState: state
      }), this.graphToViewport({
        x: xMaxGraph,
        y: yMaxGraph
      }, {
        cameraState: state
      })];

      // Look for new extents, based on these four corners
      var xMin = Infinity,
        xMax = -Infinity,
        yMin = Infinity,
        yMax = -Infinity;
      corners.forEach(function (_ref3) {
        var x = _ref3.x,
          y = _ref3.y;
        xMin = Math.min(xMin, x);
        xMax = Math.max(xMax, x);
        yMin = Math.min(yMin, y);
        yMax = Math.max(yMax, y);
      });

      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:
      var graphWidth = xMax - xMin;
      var graphHeight = yMax - yMin;
      var _this$getDimensions = this.getDimensions(),
        width = _this$getDimensions.width,
        height = _this$getDimensions.height;
      var dx = 0;
      var dy = 0;
      if (graphWidth >= width) {
        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;
      } else {
        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;
      }
      if (graphHeight >= height) {
        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;
      } else {
        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;
      }
      if (dx || dy) {
        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):
        var origin = this.viewportToFramedGraph({
          x: 0,
          y: 0
        }, {
          cameraState: state
        });
        var delta = this.viewportToFramedGraph({
          x: dx,
          y: dy
        }, {
          cameraState: state
        });
        dx = delta.x - origin.x;
        dy = delta.y - origin.y;
        newState.x += dx;
        newState.y += dy;
      }
      return newState;
    }

    /**
     * Method used to render labels.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderLabels",
    value: function renderLabels() {
      if (!this.settings.renderLabels) return this;
      var cameraState = this.camera.getState();

      // Selecting labels to draw
      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);
      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(labelsToDisplay, this.nodesWithForcedLabels);
      this.displayedNodeLabels = new Set();

      // Drawing labels
      var context = this.canvasContexts.labels;
      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {
        var node = labelsToDisplay[i];
        var data = this.nodeDataCache[node];

        // If the node was already drawn (like if it is eligible AND has
        // `forceLabel`), we don't want to draw it again
        // NOTE: we can do better probably
        if (this.displayedNodeLabels.has(node)) continue;

        // If the node is hidden, we don't need to display its label obviously
        if (data.hidden) continue;
        var _this$framedGraphToVi = this.framedGraphToViewport(data),
          x = _this$framedGraphToVi.x,
          y = _this$framedGraphToVi.y;

        // NOTE: we can cache the labels we need to render until the camera's ratio changes
        var size = this.scaleSize(data.size);

        // Is node big enough?
        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;

        // Is node actually on screen (with some margin)
        // NOTE: we used to rely on the quadtree for this, but the coordinates
        // conversion make it unreliable and at that point we already converted
        // to viewport coordinates and since the label grid already culls the
        // number of potential labels to display this looks like a good
        // performance compromise.
        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not
        // considering cells obviously outside of the range of the current
        // view rectangle.
        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;

        // Because displayed edge labels depend directly on actually rendered node
        // labels, we need to only add to this.displayedNodeLabels nodes whose label
        // is rendered.
        // This makes this.displayedNodeLabels depend on viewport, which might become
        // an issue once we start memoizing getLabelsToDisplay.
        this.displayedNodeLabels.add(node);
        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;
        var nodeProgram = this.nodePrograms[data.type];
        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;
        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: node
        }, data), {}, {
          size: size,
          x: x,
          y: y
        }), this.settings);
      }
      return this;
    }

    /**
     * Method used to render edge labels, based on which node labels were
     * rendered.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderEdgeLabels",
    value: function renderEdgeLabels() {
      if (!this.settings.renderEdgeLabels) return this;
      var context = this.canvasContexts.edgeLabels;

      // Clearing
      context.clearRect(0, 0, this.width, this.height);
      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({
        graph: this.graph,
        hoveredNode: this.hoveredNode,
        displayedNodeLabels: this.displayedNodeLabels,
        highlightedNodes: this.highlightedNodes
      });
      (0,_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(edgeLabelsToDisplay, this.edgesWithForcedLabels);
      var displayedLabels = new Set();
      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {
        var edge = edgeLabelsToDisplay[i],
          extremities = this.graph.extremities(edge),
          sourceData = this.nodeDataCache[extremities[0]],
          targetData = this.nodeDataCache[extremities[1]],
          edgeData = this.edgeDataCache[edge];

        // If the edge was already drawn (like if it is eligible AND has
        // `forceLabel`), we don't want to draw it again
        if (displayedLabels.has(edge)) continue;

        // If the edge is hidden we don't need to display its label
        // NOTE: the test on sourceData & targetData is probably paranoid at this point?
        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {
          continue;
        }
        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;
        var edgeProgram = this.edgePrograms[edgeData.type];
        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;
        drawLabel(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: edge
        }, edgeData), {}, {
          size: this.scaleSize(edgeData.size)
        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: extremities[0]
        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {
          size: this.scaleSize(sourceData.size)
        }), (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: extremities[1]
        }, targetData), this.framedGraphToViewport(targetData)), {}, {
          size: this.scaleSize(targetData.size)
        }), this.settings);
        displayedLabels.add(edge);
      }
      this.displayedEdgeLabels = displayedLabels;
      return this;
    }

    /**
     * Method used to render the highlighted nodes.
     *
     * @return {Sigma}
     */
  }, {
    key: "renderHighlightedNodes",
    value: function renderHighlightedNodes() {
      var _this7 = this;
      var context = this.canvasContexts.hovers;

      // Clearing
      context.clearRect(0, 0, this.width, this.height);

      // Rendering
      var render = function render(node) {
        var data = _this7.nodeDataCache[node];
        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),
          x = _this7$framedGraphToV.x,
          y = _this7$framedGraphToV.y;
        var size = _this7.scaleSize(data.size);
        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;
        var nodeProgram = _this7.nodePrograms[data.type];
        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;
        drawHover(context, (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
          key: node
        }, data), {}, {
          size: size,
          x: x,
          y: y
        }), _this7.settings);
      };
      var nodesToRender = [];
      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {
        nodesToRender.push(this.hoveredNode);
      }
      this.highlightedNodes.forEach(function (node) {
        // The hovered node has already been highlighted
        if (node !== _this7.hoveredNode) nodesToRender.push(node);
      });

      // Draw labels:
      nodesToRender.forEach(function (node) {
        return render(node);
      });

      // Draw WebGL nodes on top of the labels:
      var nodesPerPrograms = {};

      // 1. Count nodes per type:
      nodesToRender.forEach(function (node) {
        var type = _this7.nodeDataCache[node].type;
        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;
      });
      // 2. Allocate for each type for the proper number of nodes
      for (var type in this.nodeHoverPrograms) {
        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);
        // Also reset count, to use when rendering:
        nodesPerPrograms[type] = 0;
      }
      // 3. Process all nodes to render:
      nodesToRender.forEach(function (node) {
        var data = _this7.nodeDataCache[node];
        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);
      });
      // 4. Clear hovered nodes layer:
      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);
      // 5. Render:
      var renderParams = this.getRenderParams();
      for (var _type6 in this.nodeHoverPrograms) {
        var program = this.nodeHoverPrograms[_type6];
        program.render(renderParams);
      }
    }

    /**
     * Method used to schedule a hover render.
     *
     */
  }, {
    key: "scheduleHighlightedNodesRender",
    value: function scheduleHighlightedNodesRender() {
      var _this8 = this;
      if (this.renderHighlightedNodesFrame || this.renderFrame) return;
      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {
        // Resetting state
        _this8.renderHighlightedNodesFrame = null;

        // Rendering
        _this8.renderHighlightedNodes();
        _this8.renderEdgeLabels();
      });
    }

    /**
     * Method used to render.
     *
     * @return {Sigma}
     */
  }, {
    key: "render",
    value: function render() {
      var _this9 = this;
      this.emit("beforeRender");
      var exitRender = function exitRender() {
        _this9.emit("afterRender");
        return _this9;
      };

      // If a render was scheduled, we cancel it
      if (this.renderFrame) {
        cancelAnimationFrame(this.renderFrame);
        this.renderFrame = null;
      }

      // First we need to resize
      this.resize();

      // Do we need to reprocess data?
      if (this.needToProcess) this.process();
      this.needToProcess = false;

      // Clearing the canvases
      this.clear();

      // Prepare the textures
      this.pickingLayers.forEach(function (layer) {
        return _this9.resetWebGLTexture(layer);
      });

      // If we have no nodes we can stop right there
      if (!this.graph.order) return exitRender();

      // TODO: improve this heuristic or move to the captor itself?
      // TODO: deal with the touch captor here as well
      var mouseCaptor = this.mouseCaptor;
      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;

      // Then we need to extract a matrix from the camera
      var cameraState = this.camera.getState();
      var viewportDimensions = this.getDimensions();
      var graphDimensions = this.getGraphDimensions();
      var padding = this.getStagePadding();
      this.matrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding);
      this.invMatrix = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding, true);
      this.correctionRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.a)(this.matrix, cameraState, viewportDimensions);
      this.graphToViewportRatio = this.getGraphToViewportRatio();

      // [jacomyal]
      // This comment is related to the one above the `getMatrixImpact` definition:
      // - `this.correctionRatio` is somehow not completely explained
      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the
      //   graph
      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`
      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even
      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:
      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);

      var params = this.getRenderParams();

      // Drawing nodes
      for (var type in this.nodePrograms) {
        var program = this.nodePrograms[type];
        program.render(params);
      }

      // Drawing edges
      if (!this.settings.hideEdgesOnMove || !moving) {
        for (var _type7 in this.edgePrograms) {
          var _program2 = this.edgePrograms[_type7];
          _program2.render(params);
        }
      }

      // Do not display labels on move per setting
      if (this.settings.hideLabelsOnMove && moving) return exitRender();
      this.renderLabels();
      this.renderEdgeLabels();
      this.renderHighlightedNodes();
      return exitRender();
    }

    /**
     * Add a node in the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "addNode",
    value: function addNode(key) {
      // Node display data resolution:
      //  1. First we get the node's attributes
      //  2. We optionally reduce them using the function provided by the user
      //     Note that this function must return a total object and won't be merged
      //  3. We apply our defaults, while running some vital checks
      //  4. We apply the normalization function
      // We shallow copy node data to avoid dangerous behaviors from reducers
      var attr = Object.assign({}, this.graph.getNodeAttributes(key));
      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);
      var data = applyNodeDefaults(this.settings, key, attr);
      this.nodeDataCache[key] = data;

      // Label:
      // We delete and add if needed because this function is also used from
      // update
      this.nodesWithForcedLabels["delete"](key);
      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);

      // Highlighted:
      // We remove and re add if needed because this function is also used from
      // update
      this.highlightedNodes["delete"](key);
      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);

      // zIndex
      if (this.settings.zIndex) {
        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;
        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;
      }
    }

    /**
     * Update a node the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "updateNode",
    value: function updateNode(key) {
      this.addNode(key);

      // Re-apply normalization on the node
      var data = this.nodeDataCache[key];
      this.normalizationFunction.applyTo(data);
    }

    /**
     * Remove a node from the internal data structures.
     * @private
     * @param key The node's graphology ID
     */
  }, {
    key: "removeNode",
    value: function removeNode(key) {
      // Remove from node cache
      delete this.nodeDataCache[key];
      // Remove from node program index
      delete this.nodeProgramIndex[key];
      // Remove from higlighted nodes
      this.highlightedNodes["delete"](key);
      // Remove from hovered
      if (this.hoveredNode === key) this.hoveredNode = null;
      // Remove from forced label
      this.nodesWithForcedLabels["delete"](key);
    }

    /**
     * Add an edge into the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "addEdge",
    value: function addEdge(key) {
      // Edge display data resolution:
      //  1. First we get the edge's attributes
      //  2. We optionally reduce them using the function provided by the user
      //  3. Note that this function must return a total object and won't be merged
      //  4. We apply our defaults, while running some vital checks
      // We shallow copy edge data to avoid dangerous behaviors from reducers
      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));
      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);
      var data = applyEdgeDefaults(this.settings, key, attr);
      this.edgeDataCache[key] = data;

      // Forced label
      // we filter and re push if needed because this function is also used from
      // update
      this.edgesWithForcedLabels["delete"](key);
      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);

      // Check zIndex
      if (this.settings.zIndex) {
        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;
        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;
      }
    }

    /**
     * Update an edge in the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "updateEdge",
    value: function updateEdge(key) {
      this.addEdge(key);
    }

    /**
     * Remove an edge from the internal data structures.
     * @private
     * @param key The edge's graphology ID
     */
  }, {
    key: "removeEdge",
    value: function removeEdge(key) {
      // Remove from edge cache
      delete this.edgeDataCache[key];
      // Remove from programId index
      delete this.edgeProgramIndex[key];
      // Remove from hovered
      if (this.hoveredEdge === key) this.hoveredEdge = null;
      // Remove from forced label
      this.edgesWithForcedLabels["delete"](key);
    }

    /**
     * Clear all indices related to nodes.
     * @private
     */
  }, {
    key: "clearNodeIndices",
    value: function clearNodeIndices() {
      // LabelGrid & nodeExtent are only manage/populated in the process function
      this.labelGrid = new LabelGrid();
      this.nodeExtent = {
        x: [0, 1],
        y: [0, 1]
      };
      this.nodeDataCache = {};
      this.edgeProgramIndex = {};
      this.nodesWithForcedLabels = new Set();
      this.nodeZExtent = [Infinity, -Infinity];
      this.highlightedNodes = new Set();
    }

    /**
     * Clear all indices related to edges.
     * @private
     */
  }, {
    key: "clearEdgeIndices",
    value: function clearEdgeIndices() {
      this.edgeDataCache = {};
      this.edgeProgramIndex = {};
      this.edgesWithForcedLabels = new Set();
      this.edgeZExtent = [Infinity, -Infinity];
    }

    /**
     * Clear all indices.
     * @private
     */
  }, {
    key: "clearIndices",
    value: function clearIndices() {
      this.clearEdgeIndices();
      this.clearNodeIndices();
    }

    /**
     * Clear all graph state related to nodes.
     * @private
     */
  }, {
    key: "clearNodeState",
    value: function clearNodeState() {
      this.displayedNodeLabels = new Set();
      this.highlightedNodes = new Set();
      this.hoveredNode = null;
    }

    /**
     * Clear all graph state related to edges.
     * @private
     */
  }, {
    key: "clearEdgeState",
    value: function clearEdgeState() {
      this.displayedEdgeLabels = new Set();
      this.highlightedNodes = new Set();
      this.hoveredEdge = null;
    }

    /**
     * Clear all graph state.
     * @private
     */
  }, {
    key: "clearState",
    value: function clearState() {
      this.clearEdgeState();
      this.clearNodeState();
    }

    /**
     * Add the node data to its program.
     * @private
     * @param node The node's graphology ID
     * @param fingerprint A fingerprint used to identity the node with picking
     * @param position The index where to place the node in the program
     */
  }, {
    key: "addNodeToProgram",
    value: function addNodeToProgram(node, fingerprint, position) {
      var data = this.nodeDataCache[node];
      var nodeProgram = this.nodePrograms[data.type];
      if (!nodeProgram) throw new Error("Sigma: could not find a suitable program for node type \"".concat(data.type, "\"!"));
      nodeProgram.process(fingerprint, position, data);
      // Saving program index
      this.nodeProgramIndex[node] = position;
    }

    /**
     * Add the edge data to its program.
     * @private
     * @param edge The edge's graphology ID
     * @param fingerprint A fingerprint used to identity the edge with picking
     * @param position The index where to place the edge in the program
     */
  }, {
    key: "addEdgeToProgram",
    value: function addEdgeToProgram(edge, fingerprint, position) {
      var data = this.edgeDataCache[edge];
      var edgeProgram = this.edgePrograms[data.type];
      if (!edgeProgram) throw new Error("Sigma: could not find a suitable program for edge type \"".concat(data.type, "\"!"));
      var extremities = this.graph.extremities(edge),
        sourceData = this.nodeDataCache[extremities[0]],
        targetData = this.nodeDataCache[extremities[1]];
      edgeProgram.process(fingerprint, position, sourceData, targetData, data);
      // Saving program index
      this.edgeProgramIndex[edge] = position;
    }

    /**---------------------------------------------------------------------------
     * Public API.
     **---------------------------------------------------------------------------
     */

    /**
     * Function used to get the render params.
     *
     * @return {RenderParams}
     */
  }, {
    key: "getRenderParams",
    value: function getRenderParams() {
      return {
        matrix: this.matrix,
        invMatrix: this.invMatrix,
        width: this.width,
        height: this.height,
        pixelRatio: this.pixelRatio,
        zoomRatio: this.camera.ratio,
        cameraAngle: this.camera.angle,
        sizeRatio: 1 / this.scaleSize(),
        correctionRatio: this.correctionRatio,
        downSizingRatio: this.pickingDownSizingRatio,
        minEdgeThickness: this.settings.minEdgeThickness,
        antiAliasingFeather: this.settings.antiAliasingFeather
      };
    }

    /**
     * Function used to retrieve the actual stage padding value.
     *
     * @return {number}
     */
  }, {
    key: "getStagePadding",
    value: function getStagePadding() {
      var _this$settings = this.settings,
        stagePadding = _this$settings.stagePadding,
        autoRescale = _this$settings.autoRescale;
      return autoRescale ? stagePadding || 0 : 0;
    }

    /**
     * Function used to create a layer element.
     *
     * @param {string} id - Context's id.
     * @param {string} tag - The HTML tag to use.
     * @param options
     * @return {Sigma}
     */
  }, {
    key: "createLayer",
    value: function createLayer(id, tag) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      if (this.elements[id]) throw new Error("Sigma: a layer named \"".concat(id, "\" already exists"));
      var element = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.b)(tag, {
        position: "absolute"
      }, {
        "class": "sigma-".concat(id)
      });
      if (options.style) Object.assign(element.style, options.style);
      this.elements[id] = element;
      if ("beforeLayer" in options && options.beforeLayer) {
        this.elements[options.beforeLayer].before(element);
      } else if ("afterLayer" in options && options.afterLayer) {
        this.elements[options.afterLayer].after(element);
      } else {
        this.container.appendChild(element);
      }
      return element;
    }

    /**
     * Function used to create a canvas element.
     *
     * @param {string} id - Context's id.
     * @param options
     * @return {Sigma}
     */
  }, {
    key: "createCanvas",
    value: function createCanvas(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.createLayer(id, "canvas", options);
    }

    /**
     * Function used to create a canvas context and add the relevant DOM elements.
     *
     * @param  {string} id - Context's id.
     * @param  options
     * @return {Sigma}
     */
  }, {
    key: "createCanvasContext",
    value: function createCanvasContext(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var canvas = this.createCanvas(id, options);
      var contextOptions = {
        preserveDrawingBuffer: false,
        antialias: false
      };
      this.canvasContexts[id] = canvas.getContext("2d", contextOptions);
      return this;
    }

    /**
     * Function used to create a WebGL context and add the relevant DOM
     * elements.
     *
     * @param  {string}  id      - Context's id.
     * @param  {object?} options - #getContext params to override (optional)
     * @return {WebGLRenderingContext}
     */
  }, {
    key: "createWebGLContext",
    value: function createWebGLContext(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);
      if (options.hidden) canvas.remove();
      var contextOptions = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({
        preserveDrawingBuffer: false,
        antialias: false
      }, options);
      var context;

      // First we try webgl2 for an easy performance boost
      context = canvas.getContext("webgl2", contextOptions);

      // Else we fall back to webgl
      if (!context) context = canvas.getContext("webgl", contextOptions);

      // Edge, I am looking right at you...
      if (!context) context = canvas.getContext("experimental-webgl", contextOptions);
      var gl = context;
      this.webGLContexts[id] = gl;

      // Blending:
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);

      // Prepare frame buffer for picking layers:
      if (options.picking) {
        this.pickingLayers.add(id);
        var newFrameBuffer = gl.createFramebuffer();
        if (!newFrameBuffer) throw new Error("Sigma: cannot create a new frame buffer for layer ".concat(id));
        this.frameBuffers[id] = newFrameBuffer;
      }
      return gl;
    }

    /**
     * Function used to properly kill a layer.
     *
     * @param  {string} id - Layer id.
     * @return {Sigma}
     */
  }, {
    key: "killLayer",
    value: function killLayer(id) {
      var element = this.elements[id];
      if (!element) throw new Error("Sigma: cannot kill layer ".concat(id, ", which does not exist"));
      if (this.webGLContexts[id]) {
        var _gl$getExtension;
        var gl = this.webGLContexts[id];
        (_gl$getExtension = gl.getExtension("WEBGL_lose_context")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();
        delete this.webGLContexts[id];
      } else if (this.canvasContexts[id]) {
        delete this.canvasContexts[id];
      }

      // Delete layer element
      element.remove();
      delete this.elements[id];
      return this;
    }

    /**
     * Method returning the renderer's camera.
     *
     * @return {Camera}
     */
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.camera;
    }

    /**
     * Method setting the renderer's camera.
     *
     * @param  {Camera} camera - New camera.
     * @return {Sigma}
     */
  }, {
    key: "setCamera",
    value: function setCamera(camera) {
      this.unbindCameraHandlers();
      this.camera = camera;
      this.bindCameraHandlers();
    }

    /**
     * Method returning the container DOM element.
     *
     * @return {HTMLElement}
     */
  }, {
    key: "getContainer",
    value: function getContainer() {
      return this.container;
    }

    /**
     * Method returning the renderer's graph.
     *
     * @return {Graph}
     */
  }, {
    key: "getGraph",
    value: function getGraph() {
      return this.graph;
    }

    /**
     * Method used to set the renderer's graph.
     *
     * @return {Graph}
     */
  }, {
    key: "setGraph",
    value: function setGraph(graph) {
      if (graph === this.graph) return;

      // Check hoveredNode and hoveredEdge
      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;
      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;

      // Unbinding handlers on the current graph
      this.unbindGraphHandlers();
      if (this.checkEdgesEventsFrame !== null) {
        cancelAnimationFrame(this.checkEdgesEventsFrame);
        this.checkEdgesEventsFrame = null;
      }

      // Installing new graph
      this.graph = graph;

      // Binding new handlers
      this.bindGraphHandlers();

      // Re-rendering now to avoid discrepancies from now to next frame
      this.refresh();
    }

    /**
     * Method returning the mouse captor.
     *
     * @return {MouseCaptor}
     */
  }, {
    key: "getMouseCaptor",
    value: function getMouseCaptor() {
      return this.mouseCaptor;
    }

    /**
     * Method returning the touch captor.
     *
     * @return {TouchCaptor}
     */
  }, {
    key: "getTouchCaptor",
    value: function getTouchCaptor() {
      return this.touchCaptor;
    }

    /**
     * Method returning the current renderer's dimensions.
     *
     * @return {Dimensions}
     */
  }, {
    key: "getDimensions",
    value: function getDimensions() {
      return {
        width: this.width,
        height: this.height
      };
    }

    /**
     * Method returning the current graph's dimensions.
     *
     * @return {Dimensions}
     */
  }, {
    key: "getGraphDimensions",
    value: function getGraphDimensions() {
      var extent = this.customBBox || this.nodeExtent;
      return {
        width: extent.x[1] - extent.x[0] || 1,
        height: extent.y[1] - extent.y[0] || 1
      };
    }

    /**
     * Method used to get all the sigma node attributes.
     * It's useful for example to get the position of a node
     * and to get values that are set by the nodeReducer
     *
     * @param  {string} key - The node's key.
     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found
     */
  }, {
    key: "getNodeDisplayData",
    value: function getNodeDisplayData(key) {
      var node = this.nodeDataCache[key];
      return node ? Object.assign({}, node) : undefined;
    }

    /**
     * Method used to get all the sigma edge attributes.
     * It's useful for example to get values that are set by the edgeReducer.
     *
     * @param  {string} key - The edge's key.
     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found
     */
  }, {
    key: "getEdgeDisplayData",
    value: function getEdgeDisplayData(key) {
      var edge = this.edgeDataCache[key];
      return edge ? Object.assign({}, edge) : undefined;
    }

    /**
     * Method used to get the set of currently displayed node labels.
     *
     * @return {Set<string>} A set of node keys whose label is displayed.
     */
  }, {
    key: "getNodeDisplayedLabels",
    value: function getNodeDisplayedLabels() {
      return new Set(this.displayedNodeLabels);
    }

    /**
     * Method used to get the set of currently displayed edge labels.
     *
     * @return {Set<string>} A set of edge keys whose label is displayed.
     */
  }, {
    key: "getEdgeDisplayedLabels",
    value: function getEdgeDisplayedLabels() {
      return new Set(this.displayedEdgeLabels);
    }

    /**
     * Method returning a copy of the settings collection.
     *
     * @return {Settings} A copy of the settings collection.
     */
  }, {
    key: "getSettings",
    value: function getSettings() {
      return (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
    }

    /**
     * Method returning the current value for a given setting key.
     *
     * @param  {string} key - The setting key to get.
     * @return {any} The value attached to this setting key or undefined if not found
     */
  }, {
    key: "getSetting",
    value: function getSetting(key) {
      return this.settings[key];
    }

    /**
     * Method setting the value of a given setting key. Note that this will schedule
     * a new render next frame.
     *
     * @param  {string} key - The setting key to set.
     * @param  {any}    value - The value to set.
     * @return {Sigma}
     */
  }, {
    key: "setSetting",
    value: function setSetting(key, value) {
      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
      this.settings[key] = value;
      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);
      this.handleSettingsUpdate(oldValues);
      this.scheduleRefresh();
      return this;
    }

    /**
     * Method updating the value of a given setting key using the provided function.
     * Note that this will schedule a new render next frame.
     *
     * @param  {string}   key     - The setting key to set.
     * @param  {function} updater - The update function.
     * @return {Sigma}
     */
  }, {
    key: "updateSetting",
    value: function updateSetting(key, updater) {
      this.setSetting(key, updater(this.settings[key]));
      return this;
    }

    /**
     * Method setting multiple settings at once.
     *
     * @param  {Partial<Settings>} settings - The settings to set.
     * @return {Sigma}
     */
  }, {
    key: "setSettings",
    value: function setSettings(settings) {
      var oldValues = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings);
      this.settings = (0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, this.settings), settings);
      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);
      this.handleSettingsUpdate(oldValues);
      this.scheduleRefresh();
      return this;
    }

    /**
     * Method used to resize the renderer.
     *
     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).
     * @return {Sigma}
     */
  }, {
    key: "resize",
    value: function resize(force) {
      var previousWidth = this.width,
        previousHeight = this.height;
      this.width = this.container.offsetWidth;
      this.height = this.container.offsetHeight;
      this.pixelRatio = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)();
      if (this.width === 0) {
        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error("Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.");
      }
      if (this.height === 0) {
        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error("Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.");
      }

      // If nothing has changed, we can stop right here
      if (!force && previousWidth === this.width && previousHeight === this.height) return this;

      // Sizing dom elements
      for (var id in this.elements) {
        var element = this.elements[id];
        element.style.width = this.width + "px";
        element.style.height = this.height + "px";
      }

      // Sizing canvas contexts
      for (var _id in this.canvasContexts) {
        this.elements[_id].setAttribute("width", this.width * this.pixelRatio + "px");
        this.elements[_id].setAttribute("height", this.height * this.pixelRatio + "px");
        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);
      }

      // Sizing WebGL contexts
      for (var _id2 in this.webGLContexts) {
        this.elements[_id2].setAttribute("width", this.width * this.pixelRatio + "px");
        this.elements[_id2].setAttribute("height", this.height * this.pixelRatio + "px");
        var gl = this.webGLContexts[_id2];
        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);

        // Clear picking texture if needed
        if (this.pickingLayers.has(_id2)) {
          var currentTexture = this.textures[_id2];
          if (currentTexture) gl.deleteTexture(currentTexture);
        }
      }
      this.emit("resize");
      return this;
    }

    /**
     * Method used to clear all the canvases.
     *
     * @return {Sigma}
     */
  }, {
    key: "clear",
    value: function clear() {
      this.emit("beforeClear");
      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);
      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);
      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);
      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);
      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);
      this.emit("afterClear");
      return this;
    }

    /**
     * Method used to refresh, i.e. force the renderer to reprocess graph
     * data and render, but keep the state.
     * - if a partialGraph is provided, we only reprocess those nodes & edges.
     * - if schedule is TRUE, we schedule a render instead of sync render
     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)
     *
     * @return {Sigma}
     */
  }, {
    key: "refresh",
    value: function refresh(opts) {
      var _this10 = this;
      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;
      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;
      var fullRefresh = !opts || !opts.partialGraph;
      if (fullRefresh) {
        // Re-index graph data
        this.clearEdgeIndices();
        this.clearNodeIndices();
        this.graph.forEachNode(function (node) {
          return _this10.addNode(node);
        });
        this.graph.forEachEdge(function (edge) {
          return _this10.addEdge(edge);
        });
      } else {
        var _opts$partialGraph, _opts$partialGraph2;
        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];
        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {
          var node = nodes[i];
          // Recompute node's data (ie. apply reducer)
          this.updateNode(node);
          // Add node to the program if layout is unchanged.
          // otherwise it will be done in the process function
          if (skipIndexation) {
            var programIndex = this.nodeProgramIndex[node];
            if (programIndex === undefined) throw new Error("Sigma: node \"".concat(node, "\" can't be repaint"));
            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);
          }
        }
        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];
        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {
          var edge = edges[_i4];
          // Recompute edge's data (ie. apply reducer)
          this.updateEdge(edge);
          // Add edge to the program
          // otherwise it will be done in the process function
          if (skipIndexation) {
            var _programIndex = this.edgeProgramIndex[edge];
            if (_programIndex === undefined) throw new Error("Sigma: edge \"".concat(edge, "\" can't be repaint"));
            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);
          }
        }
      }

      // Do we need to call the process function ?
      if (fullRefresh || !skipIndexation) this.needToProcess = true;
      if (schedule) this.scheduleRender();else this.render();
      return this;
    }

    /**
     * Method used to schedule a render at the next available frame.
     * This method can be safely called on a same frame because it basically
     * debounces refresh to the next frame.
     *
     * @return {Sigma}
     */
  }, {
    key: "scheduleRender",
    value: function scheduleRender() {
      var _this11 = this;
      if (!this.renderFrame) {
        this.renderFrame = requestAnimationFrame(function () {
          _this11.render();
        });
      }
      return this;
    }

    /**
     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)
     * at the next available frame.
     * This method can be safely called on a same frame because it basically
     * debounces refresh to the next frame.
     *
     * @return {Sigma}
     */
  }, {
    key: "scheduleRefresh",
    value: function scheduleRefresh(opts) {
      return this.refresh((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_5__._)({}, opts), {}, {
        schedule: true
      }));
    }

    /**
     * Method used to (un)zoom, while preserving the position of a viewport point.
     * Used for instance to zoom "on the mouse cursor".
     *
     * @param viewportTarget
     * @param newRatio
     * @return {CameraState}
     */
  }, {
    key: "getViewportZoomedState",
    value: function getViewportZoomedState(viewportTarget, newRatio) {
      var _this$camera$getState = this.camera.getState(),
        ratio = _this$camera$getState.ratio,
        angle = _this$camera$getState.angle,
        x = _this$camera$getState.x,
        y = _this$camera$getState.y;
      var _this$settings2 = this.settings,
        minCameraRatio = _this$settings2.minCameraRatio,
        maxCameraRatio = _this$settings2.maxCameraRatio;
      if (typeof maxCameraRatio === "number") newRatio = Math.min(newRatio, maxCameraRatio);
      if (typeof minCameraRatio === "number") newRatio = Math.max(newRatio, minCameraRatio);
      var ratioDiff = newRatio / ratio;
      var center = {
        x: this.width / 2,
        y: this.height / 2
      };
      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);
      var graphCenterPosition = this.viewportToFramedGraph(center);
      return {
        angle: angle,
        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,
        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,
        ratio: newRatio
      };
    }

    /**
     * Method returning the abstract rectangle containing the graph according
     * to the camera's state.
     *
     * @return {object} - The view's rectangle.
     */
  }, {
    key: "viewRectangle",
    value: function viewRectangle() {
      var p1 = this.viewportToFramedGraph({
          x: 0,
          y: 0
        }),
        p2 = this.viewportToFramedGraph({
          x: this.width,
          y: 0
        }),
        h = this.viewportToFramedGraph({
          x: 0,
          y: this.height
        });
      return {
        x1: p1.x,
        y1: p1.y,
        x2: p2.x,
        y2: p2.y,
        height: p2.y - h.y
      };
    }

    /**
     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
  }, {
    key: "framedGraphToViewport",
    value: function framedGraphToViewport(coordinates) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;
      var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;
      var viewportPos = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(matrix, coordinates);
      return {
        x: (1 + viewportPos.x) * this.width / 2,
        y: (1 - viewportPos.y) * this.height / 2
      };
    }

    /**
     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows
     * overriding anything that is used to get the translation matrix, or even the matrix itself.
     *
     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest
     * of computations.
     */
  }, {
    key: "viewportToFramedGraph",
    value: function viewportToFramedGraph(coordinates) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;
      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;
      var res = (0,_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(invMatrix, {
        x: coordinates.x / this.width * 2 - 1,
        y: 1 - coordinates.y / this.height * 2
      });
      if (isNaN(res.x)) res.x = 0;
      if (isNaN(res.y)) res.y = 0;
      return res;
    }

    /**
     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the
     * stage) to the graph system (the reference system of data as they are in the given graph instance).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  viewportPoint
     * @param {CoordinateConversionOverride} override
     */
  }, {
    key: "viewportToGraph",
    value: function viewportToGraph(viewportPoint) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));
    }

    /**
     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in
     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).
     *
     * This method accepts an optional camera which can be useful if you need to translate coordinates
     * based on a different view than the one being currently being displayed on screen.
     *
     * @param {Coordinates}                  graphPoint
     * @param {CoordinateConversionOverride} override
     */
  }, {
    key: "graphToViewport",
    value: function graphToViewport(graphPoint) {
      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);
    }

    /**
     * Method returning the distance multiplier between the graph system and the
     * viewport system.
     */
  }, {
    key: "getGraphToViewportRatio",
    value: function getGraphToViewportRatio() {
      var graphP1 = {
        x: 0,
        y: 0
      };
      var graphP2 = {
        x: 1,
        y: 1
      };
      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));
      var viewportP1 = this.graphToViewport(graphP1);
      var viewportP2 = this.graphToViewport(graphP2);
      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));
      return viewportD / graphD;
    }

    /**
     * Method returning the graph's bounding box.
     *
     * @return {{ x: Extent, y: Extent }}
     */
  }, {
    key: "getBBox",
    value: function getBBox() {
      return this.nodeExtent;
    }

    /**
     * Method returning the graph's custom bounding box, if any.
     *
     * @return {{ x: Extent, y: Extent } | null}
     */
  }, {
    key: "getCustomBBox",
    value: function getCustomBBox() {
      return this.customBBox;
    }

    /**
     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.
     *
     * @return {Sigma}
     */
  }, {
    key: "setCustomBBox",
    value: function setCustomBBox(customBBox) {
      this.customBBox = customBBox;
      this.scheduleRender();
      return this;
    }

    /**
     * Method used to shut the container & release event listeners.
     *
     * @return {undefined}
     */
  }, {
    key: "kill",
    value: function kill() {
      // Emitting "kill" events so that plugins and such can cleanup
      this.emit("kill");

      // Releasing events
      this.removeAllListeners();

      // Releasing camera handlers
      this.unbindCameraHandlers();

      // Releasing DOM events & captors
      window.removeEventListener("resize", this.activeListeners.handleResize);
      this.mouseCaptor.kill();
      this.touchCaptor.kill();

      // Releasing graph handlers
      this.unbindGraphHandlers();

      // Releasing cache & state
      this.clearIndices();
      this.clearState();
      this.nodeDataCache = {};
      this.edgeDataCache = {};
      this.highlightedNodes.clear();

      // Clearing frames
      if (this.renderFrame) {
        cancelAnimationFrame(this.renderFrame);
        this.renderFrame = null;
      }
      if (this.renderHighlightedNodesFrame) {
        cancelAnimationFrame(this.renderHighlightedNodesFrame);
        this.renderHighlightedNodesFrame = null;
      }

      // Destroying canvases
      var container = this.container;
      while (container.firstChild) container.removeChild(container.firstChild);

      // Kill programs:
      for (var type in this.nodePrograms) {
        this.nodePrograms[type].kill();
      }
      for (var _type8 in this.nodeHoverPrograms) {
        this.nodeHoverPrograms[_type8].kill();
      }
      for (var _type9 in this.edgePrograms) {
        this.edgePrograms[_type9].kill();
      }
      this.nodePrograms = {};
      this.nodeHoverPrograms = {};
      this.edgePrograms = {};

      // Kill all canvas/WebGL contexts
      for (var id in this.elements) {
        this.killLayer(id);
      }

      // Destroying remaining collections
      this.canvasContexts = {};
      this.webGLContexts = {};
      this.elements = {};
    }

    /**
     * Method used to scale the given size according to the camera's ratio, i.e.
     * zooming state.
     *
     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).
     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).
     * @return {number}              - The scaled size.
     */
  }, {
    key: "scaleSize",
    value: function scaleSize() {
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;
      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting("itemSizesReference") === "positions" ? cameraRatio * this.graphToViewportRatio : 1);
    }

    /**
     * Method that returns the collection of all used canvases.
     * At the moment, the instantiated canvases are the following, and in the
     * following order in the DOM:
     * - `edges`
     * - `nodes`
     * - `edgeLabels`
     * - `labels`
     * - `hovers`
     * - `hoverNodes`
     * - `mouse`
     *
     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.
     */
  }, {
    key: "getCanvases",
    value: function getCanvases() {
      var res = {};
      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];
      return res;
    }
  }]);
}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);

/**
 * Sigma.js Library Endpoint
 * =========================
 *
 * The library endpoint.
 * @module
 */
var Sigma = Sigma$1;




/***/ }),

/***/ "./node_modules/sigma/rendering/dist/sigma-rendering.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/sigma/rendering/dist/sigma-rendering.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractEdgeProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),
/* harmony export */   AbstractNodeProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   AbstractProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),
/* harmony export */   DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),
/* harmony export */   DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),
/* harmony export */   DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS: () => (/* binding */ DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS),
/* harmony export */   EdgeArrowHeadProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),
/* harmony export */   EdgeArrowProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.E),
/* harmony export */   EdgeClampedProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),
/* harmony export */   EdgeDoubleArrowProgram: () => (/* binding */ EdgeDoubleArrowProgram$1),
/* harmony export */   EdgeDoubleClampedProgram: () => (/* binding */ EdgeDoubleClampedProgram$1),
/* harmony export */   EdgeLineProgram: () => (/* binding */ EdgeLineProgram),
/* harmony export */   EdgeProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),
/* harmony export */   EdgeRectangleProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   EdgeTriangleProgram: () => (/* binding */ EdgeTriangleProgram),
/* harmony export */   NodeCircleProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.N),
/* harmony export */   NodePointProgram: () => (/* binding */ NodePointProgram),
/* harmony export */   NodeProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),
/* harmony export */   Program: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.P),
/* harmony export */   createEdgeArrowHeadProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.i),
/* harmony export */   createEdgeArrowProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),
/* harmony export */   createEdgeClampedProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),
/* harmony export */   createEdgeCompoundProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   createEdgeDoubleArrowProgram: () => (/* binding */ createEdgeDoubleArrowProgram),
/* harmony export */   createEdgeDoubleClampedProgram: () => (/* binding */ createEdgeDoubleClampedProgram),
/* harmony export */   createNodeCompoundProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),
/* harmony export */   drawDiscNodeHover: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),
/* harmony export */   drawDiscNodeLabel: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),
/* harmony export */   drawStraightEdgeLabel: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   getAttributeItemsCount: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),
/* harmony export */   getAttributesItemsCount: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),
/* harmony export */   killProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),
/* harmony export */   loadFragmentShader: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.u),
/* harmony export */   loadProgram: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),
/* harmony export */   loadVertexShader: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),
/* harmony export */   numberToGLSLFloat: () => (/* reexport safe */ _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.x)
/* harmony export */ });
/* harmony import */ var _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-236c62ad.esm.js */ "./node_modules/sigma/dist/index-236c62ad.esm.js");
/* harmony import */ var _dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dist/colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");





// language=GLSL
var SHADER_SOURCE$6 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float radius = 0.5;\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\n\nvoid main(void) {\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\n  float dist = radius - length(m);\n\n  // No antialiasing for picking mode:\n  #ifdef PICKING_MODE\n  if (dist > v_border)\n    gl_FragColor = v_color;\n  else\n    gl_FragColor = transparent;\n\n  #else\n  float t = 0.0;\n  if (dist > v_border)\n    t = 1.0;\n  else if (dist > 0.0)\n    t = dist / v_border;\n\n  gl_FragColor = mix(transparent, v_color, t);\n  #endif\n}\n";
var FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;

// language=GLSL
var SHADER_SOURCE$5 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\nattribute float a_size;\n\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\nvarying float v_border;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  // Multiply the point size twice:\n  //  - x SCALING_RATIO to correct the canvas scaling\n  //  - x 2 to correct the formulae\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\n\n  v_border = (0.5 / a_size) * u_sizeRatio;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;

var _WebGLRenderingContex$3 = WebGLRenderingContext,
  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,
  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;
var UNIFORMS$3 = ["u_sizeRatio", "u_pixelRatio", "u_matrix"];
var NodePointProgram = /*#__PURE__*/function (_NodeProgram) {
  function NodePointProgram() {
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, NodePointProgram);
    return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, NodePointProgram, arguments);
  }
  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(NodePointProgram, _NodeProgram);
  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(NodePointProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 1,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,
        METHOD: WebGLRenderingContext.POINTS,
        UNIFORMS: UNIFORMS$3,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$3
        }, {
          name: "a_size",
          size: 1,
          type: FLOAT$3
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$3,
          normalized: true
        }]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(nodeIndex, startIndex, data) {
      var array = this.array;
      array[startIndex++] = data.x;
      array[startIndex++] = data.y;
      array[startIndex++] = data.size;
      array[startIndex++] = (0,_dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);
      array[startIndex++] = nodeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(_ref, _ref2) {
      var sizeRatio = _ref.sizeRatio,
        pixelRatio = _ref.pixelRatio,
        matrix = _ref.matrix;
      var gl = _ref2.gl,
        uniformLocations = _ref2.uniformLocations;
      var u_sizeRatio = uniformLocations.u_sizeRatio,
        u_pixelRatio = uniformLocations.u_pixelRatio,
        u_matrix = uniformLocations.u_matrix;
      gl.uniform1f(u_pixelRatio, pixelRatio);
      gl.uniform1f(u_sizeRatio, sizeRatio);
      gl.uniformMatrix3fv(u_matrix, false, matrix);
    }
  }]);
}(_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.f);

// language=GLSL
var SHADER_SOURCE$4 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\nattribute float a_sourceRadius;\nattribute float a_targetRadius;\nattribute float a_sourceRadiusCoef;\nattribute float a_targetRadiusCoef;\n\nuniform mat3 u_matrix;\nuniform float u_zoomRatio;\nuniform float u_sizeRatio;\nuniform float u_pixelRatio;\nuniform float u_correctionRatio;\nuniform float u_minEdgeThickness;\nuniform float u_lengthToThicknessRatio;\nuniform float u_feather;\n\nvarying vec4 v_color;\nvarying vec2 v_normal;\nvarying float v_thickness;\nvarying float v_feather;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  float minThickness = u_minEdgeThickness;\n\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n\n  // These first computations are taken from edge.vert.glsl. Please read it to\n  // get better comments on what's happening:\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  // Here, we move the point to leave space for the arrow heads:\n  // Source arrow head\n  float sourceRadius = a_sourceRadius * a_sourceRadiusCoef;\n  float sourceDirection = sign(sourceRadius);\n  float webGLSourceRadius = sourceDirection * sourceRadius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLSourceArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n  vec2 sourceCompensationVector =\n    vec2(-sourceDirection * unitNormal.y, sourceDirection * unitNormal.x)\n    * (webGLSourceRadius + webGLSourceArrowHeadLength);\n    \n  // Target arrow head\n  float targetRadius = a_targetRadius * a_targetRadiusCoef;\n  float targetDirection = sign(targetRadius);\n  float webGLTargetRadius = targetDirection * targetRadius * 2.0 * u_correctionRatio / u_sizeRatio;\n  float webGLTargetArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\n  vec2 targetCompensationVector =\n  vec2(-targetDirection * unitNormal.y, targetDirection * unitNormal.x)\n    * (webGLTargetRadius + webGLTargetArrowHeadLength);\n\n  // Here is the proper position of the vertex\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + sourceCompensationVector + targetCompensationVector, 1)).xy, 0, 1);\n\n  v_thickness = webGLThickness / u_zoomRatio;\n\n  v_normal = unitNormal;\n\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;

var _WebGLRenderingContex$2 = WebGLRenderingContext,
  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,
  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;
var UNIFORMS$2 = ["u_matrix", "u_zoomRatio", "u_sizeRatio", "u_correctionRatio", "u_pixelRatio", "u_feather", "u_minEdgeThickness", "u_lengthToThicknessRatio"];
var DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS = {
  lengthToThicknessRatio: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.D.lengthToThicknessRatio
};
function createEdgeDoubleClampedProgram(inputOptions) {
  var options = (0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});
  return /*#__PURE__*/function (_EdgeProgram) {
    function EdgeDoubleClampedProgram() {
      (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, EdgeDoubleClampedProgram);
      return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, EdgeDoubleClampedProgram, arguments);
    }
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(EdgeDoubleClampedProgram, _EdgeProgram);
    return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(EdgeDoubleClampedProgram, [{
      key: "getDefinition",
      value: function getDefinition() {
        return {
          VERTICES: 6,
          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,
          FRAGMENT_SHADER_SOURCE: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.F,
          METHOD: WebGLRenderingContext.TRIANGLES,
          UNIFORMS: UNIFORMS$2,
          ATTRIBUTES: [{
            name: "a_positionStart",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_positionEnd",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_normal",
            size: 2,
            type: FLOAT$2
          }, {
            name: "a_color",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }, {
            name: "a_id",
            size: 4,
            type: UNSIGNED_BYTE$2,
            normalized: true
          }, {
            name: "a_sourceRadius",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_targetRadius",
            size: 1,
            type: FLOAT$2
          }],
          CONSTANT_ATTRIBUTES: [
          // If 0, then position will be a_positionStart
          // If 1, then position will be a_positionEnd
          {
            name: "a_positionCoef",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_normalCoef",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_sourceRadiusCoef",
            size: 1,
            type: FLOAT$2
          }, {
            name: "a_targetRadiusCoef",
            size: 1,
            type: FLOAT$2
          }],
          CONSTANT_DATA: [[0, 1, -1, 0], [0, -1, 1, 0], [1, 1, 0, 1], [1, 1, 0, 1], [0, -1, 1, 0], [1, -1, 0, -1]]
        };
      }
    }, {
      key: "processVisibleItem",
      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
        var thickness = data.size || 1;
        var x1 = sourceData.x;
        var y1 = sourceData.y;
        var x2 = targetData.x;
        var y2 = targetData.y;
        var color = (0,_dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);

        // Computing normals
        var dx = x2 - x1;
        var dy = y2 - y1;
        var sourceRadius = sourceData.size || 1;
        var targetRadius = targetData.size || 1;
        var len = dx * dx + dy * dy;
        var n1 = 0;
        var n2 = 0;
        if (len) {
          len = 1 / Math.sqrt(len);
          n1 = -dy * len * thickness;
          n2 = dx * len * thickness;
        }
        var array = this.array;
        array[startIndex++] = x1;
        array[startIndex++] = y1;
        array[startIndex++] = x2;
        array[startIndex++] = y2;
        array[startIndex++] = n1;
        array[startIndex++] = n2;
        array[startIndex++] = color;
        array[startIndex++] = edgeIndex;
        array[startIndex++] = sourceRadius;
        array[startIndex++] = targetRadius;
      }
    }, {
      key: "setUniforms",
      value: function setUniforms(params, _ref) {
        var gl = _ref.gl,
          uniformLocations = _ref.uniformLocations;
        var u_matrix = uniformLocations.u_matrix,
          u_zoomRatio = uniformLocations.u_zoomRatio,
          u_feather = uniformLocations.u_feather,
          u_pixelRatio = uniformLocations.u_pixelRatio,
          u_correctionRatio = uniformLocations.u_correctionRatio,
          u_sizeRatio = uniformLocations.u_sizeRatio,
          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,
          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;
        gl.uniformMatrix3fv(u_matrix, false, params.matrix);
        gl.uniform1f(u_zoomRatio, params.zoomRatio);
        gl.uniform1f(u_sizeRatio, params.sizeRatio);
        gl.uniform1f(u_correctionRatio, params.correctionRatio);
        gl.uniform1f(u_pixelRatio, params.pixelRatio);
        gl.uniform1f(u_feather, params.antiAliasingFeather);
        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);
      }
    }]);
  }(_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.g);
}
var EdgeDoubleClampedProgram = createEdgeDoubleClampedProgram();
var EdgeDoubleClampedProgram$1 = EdgeDoubleClampedProgram;

function createEdgeDoubleArrowProgram(inputOptions) {
  return (0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.h)([createEdgeDoubleClampedProgram(inputOptions), (0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(inputOptions), (0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)((0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__._)((0,_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__._)({}, inputOptions), {}, {
    extremity: "source"
  }))]);
}
var EdgeDoubleArrowProgram = createEdgeDoubleArrowProgram();
var EdgeDoubleArrowProgram$1 = EdgeDoubleArrowProgram;

// language=GLSL
var SHADER_SOURCE$3 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";
var FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;

// language=GLSL
var SHADER_SOURCE$2 = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_position;\n\nuniform mat3 u_matrix;\n\nvarying vec4 v_color;\n\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  // Scale from [[-1 1] [-1 1]] to the container:\n  gl_Position = vec4(\n    (u_matrix * vec3(a_position, 1)).xy,\n    0,\n    1\n  );\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;

var _WebGLRenderingContex$1 = WebGLRenderingContext,
  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,
  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;
var UNIFORMS$1 = ["u_matrix"];
var EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {
  function EdgeLineProgram() {
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, EdgeLineProgram);
    return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, EdgeLineProgram, arguments);
  }
  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(EdgeLineProgram, _EdgeProgram);
  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(EdgeLineProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 2,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,
        METHOD: WebGLRenderingContext.LINES,
        UNIFORMS: UNIFORMS$1,
        ATTRIBUTES: [{
          name: "a_position",
          size: 2,
          type: FLOAT$1
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE$1,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE$1,
          normalized: true
        }]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var array = this.array;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = (0,_dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);

      // First point
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;

      // Second point
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
    }
  }]);
}(_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.g);

// language=GLSL
var SHADER_SOURCE$1 = /*glsl*/"\nprecision mediump float;\n\nvarying vec4 v_color;\n\nvoid main(void) {\n  gl_FragColor = v_color;\n}\n";
var FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;

// language=GLSL
var SHADER_SOURCE = /*glsl*/"\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec2 a_normal;\nattribute float a_normalCoef;\nattribute vec2 a_positionStart;\nattribute vec2 a_positionEnd;\nattribute float a_positionCoef;\n\nuniform mat3 u_matrix;\nuniform float u_sizeRatio;\nuniform float u_correctionRatio;\n\nvarying vec4 v_color;\n\nconst float minThickness = 1.7;\nconst float bias = 255.0 / 254.0;\n\nvoid main() {\n  vec2 normal = a_normal * a_normalCoef;\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\n\n  // The only different here with edge.vert.glsl is that we need to handle null\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\n  // on how it works:\n  float normalLength = length(normal);\n  vec2 unitNormal = normal / normalLength;\n  if (normalLength <= 0.0) unitNormal = normal;\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\n\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\n\n  #ifdef PICKING_MODE\n  // For picking mode, we use the ID as the color:\n  v_color = a_id;\n  #else\n  // For normal mode, we use the color:\n  v_color = a_color;\n  #endif\n\n  v_color.a *= bias;\n}\n";
var VERTEX_SHADER_SOURCE = SHADER_SOURCE;

var _WebGLRenderingContex = WebGLRenderingContext,
  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,
  FLOAT = _WebGLRenderingContex.FLOAT;
var UNIFORMS = ["u_matrix", "u_sizeRatio", "u_correctionRatio", "u_minEdgeThickness"];
var EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {
  function EdgeTriangleProgram() {
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, EdgeTriangleProgram);
    return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, EdgeTriangleProgram, arguments);
  }
  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(EdgeTriangleProgram, _EdgeProgram);
  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(EdgeTriangleProgram, [{
    key: "getDefinition",
    value: function getDefinition() {
      return {
        VERTICES: 3,
        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,
        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,
        METHOD: WebGLRenderingContext.TRIANGLES,
        UNIFORMS: UNIFORMS,
        ATTRIBUTES: [{
          name: "a_positionStart",
          size: 2,
          type: FLOAT
        }, {
          name: "a_positionEnd",
          size: 2,
          type: FLOAT
        }, {
          name: "a_normal",
          size: 2,
          type: FLOAT
        }, {
          name: "a_color",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }, {
          name: "a_id",
          size: 4,
          type: UNSIGNED_BYTE,
          normalized: true
        }],
        CONSTANT_ATTRIBUTES: [
        // If 0, then position will be a_positionStart
        // If 1, then position will be a_positionEnd
        {
          name: "a_positionCoef",
          size: 1,
          type: FLOAT
        }, {
          name: "a_normalCoef",
          size: 1,
          type: FLOAT
        }],
        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]
      };
    }
  }, {
    key: "processVisibleItem",
    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {
      var thickness = data.size || 1;
      var x1 = sourceData.x;
      var y1 = sourceData.y;
      var x2 = targetData.x;
      var y2 = targetData.y;
      var color = (0,_dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);

      // Computing normals
      var dx = x2 - x1;
      var dy = y2 - y1;
      var len = dx * dx + dy * dy;
      var n1 = 0;
      var n2 = 0;
      if (len) {
        len = 1 / Math.sqrt(len);
        n1 = -dy * len * thickness;
        n2 = dx * len * thickness;
      }
      var array = this.array;

      // First point
      array[startIndex++] = x1;
      array[startIndex++] = y1;
      array[startIndex++] = x2;
      array[startIndex++] = y2;
      array[startIndex++] = n1;
      array[startIndex++] = n2;
      array[startIndex++] = color;
      array[startIndex++] = edgeIndex;
    }
  }, {
    key: "setUniforms",
    value: function setUniforms(params, _ref) {
      var gl = _ref.gl,
        uniformLocations = _ref.uniformLocations;
      var u_matrix = uniformLocations.u_matrix,
        u_sizeRatio = uniformLocations.u_sizeRatio,
        u_correctionRatio = uniformLocations.u_correctionRatio,
        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;
      gl.uniformMatrix3fv(u_matrix, false, params.matrix);
      gl.uniform1f(u_sizeRatio, params.sizeRatio);
      gl.uniform1f(u_correctionRatio, params.correctionRatio);
      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);
    }
  }]);
}(_dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.g);




/***/ }),

/***/ "./node_modules/sigma/settings/dist/sigma-settings.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/settings/dist/sigma-settings.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_EDGE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_EDGE_PROGRAM_CLASSES),
/* harmony export */   DEFAULT_NODE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_NODE_PROGRAM_CLASSES),
/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),
/* harmony export */   resolveSettings: () => (/* binding */ resolveSettings),
/* harmony export */   validateSettings: () => (/* binding */ validateSettings)
/* harmony export */ });
/* harmony import */ var _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-236c62ad.esm.js */ "./node_modules/sigma/dist/index-236c62ad.esm.js");
/* harmony import */ var _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/data-11df7124.esm.js */ "./node_modules/sigma/dist/data-11df7124.esm.js");





/**
 * Sigma.js Settings
 * =================================
 *
 * The list of settings and some handy functions.
 * @module
 */

/**
 * Sigma.js settings
 * =================================
 */

var DEFAULT_SETTINGS = {
  // Performance
  hideEdgesOnMove: false,
  hideLabelsOnMove: false,
  renderLabels: true,
  renderEdgeLabels: false,
  enableEdgeEvents: false,
  // Component rendering
  defaultNodeColor: "#999",
  defaultNodeType: "circle",
  defaultEdgeColor: "#ccc",
  defaultEdgeType: "line",
  labelFont: "Arial",
  labelSize: 14,
  labelWeight: "normal",
  labelColor: {
    color: "#000"
  },
  edgeLabelFont: "Arial",
  edgeLabelSize: 14,
  edgeLabelWeight: "normal",
  edgeLabelColor: {
    attribute: "color"
  },
  stagePadding: 30,
  defaultDrawEdgeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.d,
  defaultDrawNodeLabel: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.b,
  defaultDrawNodeHover: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.c,
  minEdgeThickness: 1.7,
  antiAliasingFeather: 1,
  // Mouse and touch settings
  dragTimeout: 100,
  draggedEventsTolerance: 3,
  inertiaDuration: 200,
  inertiaRatio: 3,
  zoomDuration: 250,
  zoomingRatio: 1.7,
  doubleClickTimeout: 300,
  doubleClickZoomingRatio: 2.2,
  doubleClickZoomingDuration: 200,
  tapMoveTolerance: 10,
  // Size and scaling
  zoomToSizeRatioFunction: Math.sqrt,
  itemSizesReference: "screen",
  autoRescale: true,
  autoCenter: true,
  // Labels
  labelDensity: 1,
  labelGridCellSize: 100,
  labelRenderedSizeThreshold: 6,
  // Reducers
  nodeReducer: null,
  edgeReducer: null,
  // Features
  zIndex: false,
  minCameraRatio: null,
  maxCameraRatio: null,
  enableCameraZooming: true,
  enableCameraPanning: true,
  enableCameraRotation: true,
  cameraPanBoundaries: null,
  // Lifecycle
  allowInvalidContainer: false,
  // Program classes
  nodeProgramClasses: {},
  nodeHoverProgramClasses: {},
  edgeProgramClasses: {}
};
var DEFAULT_NODE_PROGRAM_CLASSES = {
  circle: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.N
};
var DEFAULT_EDGE_PROGRAM_CLASSES = {
  arrow: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.E,
  line: _dist_index_236c62ad_esm_js__WEBPACK_IMPORTED_MODULE_0__.e
};
function validateSettings(settings) {
  if (typeof settings.labelDensity !== "number" || settings.labelDensity < 0) {
    throw new Error("Settings: invalid `labelDensity`. Expecting a positive number.");
  }
  var minCameraRatio = settings.minCameraRatio,
    maxCameraRatio = settings.maxCameraRatio;
  if (typeof minCameraRatio === "number" && typeof maxCameraRatio === "number" && maxCameraRatio < minCameraRatio) {
    throw new Error("Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.");
  }
}
function resolveSettings(settings) {
  var resolvedSettings = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_SETTINGS, settings);
  resolvedSettings.nodeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);
  resolvedSettings.edgeProgramClasses = (0,_dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);
  return resolvedSettings;
}




/***/ }),

/***/ "./node_modules/sigma/types/dist/sigma-types.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/types/dist/sigma-types.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)
/* harmony export */ });
/* harmony import */ var _dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-d1a1e29b.esm.js */ "./node_modules/sigma/dist/inherits-d1a1e29b.esm.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);



/**
 * Util type to represent maps of typed elements, but implemented with
 * JavaScript objects.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

/**
 * Returns a type similar to T, but with the K set of properties of the type
 * T *required*, and the rest optional.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

/**
 * Returns a type similar to Partial<T>, but with at least one key set.
 */

/**
 * Custom event emitter types.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any

var TypedEventEmitter = /*#__PURE__*/function (_ref) {
  function TypedEventEmitter() {
    var _this;
    (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, TypedEventEmitter);
    _this = (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(this, TypedEventEmitter);
    _this.rawEmitter = _this;
    return _this;
  }
  (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(TypedEventEmitter, _ref);
  return (0,_dist_inherits_d1a1e29b_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(TypedEventEmitter);
}(events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter);

/**
 * Event types.
 */

/**
 * Export various other types:
 */




/***/ }),

/***/ "./node_modules/sigma/utils/dist/sigma-utils.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/utils/dist/sigma-utils.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ANIMATE_DEFAULTS: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),
/* harmony export */   HTML_COLORS: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.H),
/* harmony export */   animateNodes: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),
/* harmony export */   assign: () => (/* reexport safe */ _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_2__.a),
/* harmony export */   assignDeep: () => (/* reexport safe */ _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_2__.b),
/* harmony export */   colorToArray: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.d),
/* harmony export */   colorToIndex: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.c),
/* harmony export */   createElement: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),
/* harmony export */   createNormalizationFunction: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),
/* harmony export */   cubicIn: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),
/* harmony export */   cubicInOut: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),
/* harmony export */   cubicOut: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),
/* harmony export */   easings: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),
/* harmony export */   extend: () => (/* reexport safe */ _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_2__.e),
/* harmony export */   extractPixel: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.e),
/* harmony export */   floatColor: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.f),
/* harmony export */   getCorrectionRatio: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),
/* harmony export */   getMatrixImpact: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.a),
/* harmony export */   getPixelColor: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.g),
/* harmony export */   getPixelRatio: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),
/* harmony export */   graphExtent: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),
/* harmony export */   identity: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.i),
/* harmony export */   indexToColor: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.i),
/* harmony export */   isPlainObject: () => (/* reexport safe */ _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_2__.i),
/* harmony export */   linear: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),
/* harmony export */   matrixFromCamera: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),
/* harmony export */   multiply: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),
/* harmony export */   multiplyVec2: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),
/* harmony export */   parseColor: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.p),
/* harmony export */   quadraticIn: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),
/* harmony export */   quadraticInOut: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),
/* harmony export */   quadraticOut: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),
/* harmony export */   rgbaToFloat: () => (/* reexport safe */ _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__.r),
/* harmony export */   rotate: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),
/* harmony export */   scale: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),
/* harmony export */   translate: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.u),
/* harmony export */   validateGraph: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),
/* harmony export */   zIndexOrdering: () => (/* reexport safe */ _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)
/* harmony export */ });
/* harmony import */ var _dist_normalization_be445518_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/normalization-be445518.esm.js */ "./node_modules/sigma/dist/normalization-be445518.esm.js");
/* harmony import */ var _dist_colors_beb06eb2_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/colors-beb06eb2.esm.js */ "./node_modules/sigma/dist/colors-beb06eb2.esm.js");
/* harmony import */ var _dist_data_11df7124_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dist/data-11df7124.esm.js */ "./node_modules/sigma/dist/data-11df7124.esm.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ "./node_modules/graphology-utils/is-graph.js");
/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);






/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var sigma__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! sigma */ "./node_modules/sigma/dist/sigma.esm.js");
/* harmony import */ var graphology__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology */ "./node_modules/graphology/dist/graphology.mjs");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! papaparse */ "./node_modules/papaparse/papaparse.min.js");
/* harmony import */ var papaparse__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(papaparse__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _sigma_edge_curve__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @sigma/edge-curve */ "./node_modules/@sigma/edge-curve/dist/sigma-edge-curve.esm.js");
/* harmony import */ var graphology_layout_force_worker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! graphology-layout-force/worker */ "./node_modules/graphology-layout-force/worker.js");
/* harmony import */ var graphology_layout_force_worker__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(graphology_layout_force_worker__WEBPACK_IMPORTED_MODULE_2__);







window.onload = function () {

    console.log("Hello");

    // Retrieve some useful DOM elements:
    const container = document.getElementById("sigma-container");
    
    // Initialize the graph instance
    const graph = new graphology__WEBPACK_IMPORTED_MODULE_0__["default"].Graph();

    // Type and declare internal state:
    /**
     * @typedef {Object} State
     * @property {string=} hoveredNode
     * @property {string=} selectedNode
     * @property {Set<string>=} suggestions
     * @property {Set<string>=} hoveredNeighbors
     */
    /** @type {State} */
    const state = {};

    let rowSize = {};

    var results = papaparse__WEBPACK_IMPORTED_MODULE_1___default().parse("./jon_sample_data.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        complete: function (results) {
            console.log("CSV Data Parsed:", results.data);
            // Process the parsed data here
            // For example, you can create nodes and edges based on the CSV data
            const graph = new graphology__WEBPACK_IMPORTED_MODULE_0__["default"].Graph();

            // Preprocess nodes and edges from the CSV data:
            // Make the nodes bigger based on the number of edges
            const sourceTargetCount = {};
            results.data.forEach(row => {
                if (row.source && row.target) {
                    if (!sourceTargetCount[row.source]) {
                        sourceTargetCount[row.source] = 10;
                    }
                    sourceTargetCount[row.source]++;
                }
            });

            results.data.forEach(row => {
                if (!graph.hasNode(row.source)) {

                    graph.addNode(row.source, {
                        label: row.source,
                        x: Math.random(),
                        y: Math.random(),
                        size: sourceTargetCount[row.source],
                        color: "blue"
                    });
                }
            });

            results.data.forEach(row => {
                if (row.source && row.target && graph.hasNode (row.source) && graph.hasNode(row.target) && !graph.hasEdge(row.source, row.target)) {
                    graph.addEdge(row.source, row.target, { 
                        size: 2, 
                        label: row.label,
                        curved: true,
                        forceLabel: true
                    });
                }
            });

            // Create the spring layout and start it
            const layout = new (graphology_layout_force_worker__WEBPACK_IMPORTED_MODULE_2___default())(graph, { 
                isNodeFixed: (_, attr) => attr.highlighted,
                settings: {
                    edgeWeightInfluence: 0.5,
                    maxIterations: 50,
                    attraction: 0.00001,
                }

            });
            layout.start();

            // Instantiate sigma:
            const renderer = new sigma__WEBPACK_IMPORTED_MODULE_3__["default"](graph, container, {
                allowInvalidContainer: true,
                renderEdgeLabels: true,
                defaultEdgeType: "curve",
                edgeProgramClasses: {
                    curve: _sigma_edge_curve__WEBPACK_IMPORTED_MODULE_4__["default"]
                },
            });

            // State for drag'n'drop
            let draggedNode = null;
            let isDragging = false;

            // Bind graph interactions:
            renderer.on("enterNode", ({ node }) => {
                if (isDragging) return; // Ignore if dragging
                setHoveredNode(node);
            });
            renderer.on("leaveNode", () => {
                if (isDragging) return; // Ignore if dragging
                setHoveredNode(undefined);
            });

            // Render nodes accordingly to the internal state:
            // 1. If a node is selected, it is highlighted
            // 2. If there is query, all non-matching nodes are greyed
            // 3. If there is a hovered node, all non-neighbor nodes are greyed
            renderer.setSetting("nodeReducer", (node, data) => {
                const res = { ...data };
                
                if (!graph.hasNode(node)) {
                    return { hidden: true };
                }
                if (state.hoveredNeighbors && !state.hoveredNeighbors.has(node) && state.hoveredNode !== node) {
                    res.label = "";
                    res.color = "#f6f6f6";
                }

                if (state.selectedNode === node) {
                    res.highlighted = true;
                } else if (state.suggestions) {
                    if (state.suggestions.has(node)) {
                        res.forceLabel = true;
                    } else {
                        res.label = "";
                        res.color = "#f6f6f6";
                    }
                }

                return res;
            });

            // Render edges accordingly to the internal state:
            // 1. If a node is hovered, the edge is hidden if it is not connected to the
            //    node
            // 2. If there is a query, the edge is only visible if it connects two
            //    suggestions
            renderer.setSetting("edgeReducer", (edge, data) => {
                const res = { ...data };

                if (
                    state.hoveredNode &&
                    !graph.extremities(edge).every((n) => n === state.hoveredNode || graph.areNeighbors(n, state.hoveredNode))
                ) {
                    res.hidden = true;
                }

                if (
                    state.suggestions &&
                    (!state.suggestions.has(graph.source(edge)) || !state.suggestions.has(graph.target(edge)))
                ) {
                    res.hidden = true;
                }

                return res;
            });

            renderer.on("clickNode", ({ node }) => {
                // Get node attributes
                const data = graph.getNodeAttributes(node);

                // Build summary HTML (customize as needed)
                const html = `
                    <strong>Node:</strong> ${node}<br>
                    <strong>Label:</strong> ${data.label}<br>
                    <strong>Size:</strong> ${data.size}<br>
                    <strong>Color:</strong> ${data.color}
                `;

                // Show and update the panel
                const panel = document.getElementById("info-panel");
                panel.innerHTML = html;
                panel.style.display = "block";
            });

            // Optional: Hide the panel when clicking elsewhere
            renderer.on("clickStage", () => {
                document.getElementById("info-panel").style.display = "none";
            });

              //
            // Drag'n'drop feature
            // ~~~~~~~~~~~~~~~~~~~
            //

            // On mouse down on a node
            //  - we enable the drag mode
            //  - save in the dragged node in the state
            //  - highlight the node
            //  - disable the camera so its state is not updated
            renderer.on("downNode", (e) => {
                isDragging = true;
                draggedNode = e.node;
                graph.setNodeAttribute(draggedNode, "highlighted", true);
                if (!renderer.getCustomBBox()) renderer.setCustomBBox(renderer.getBBox());
            });

            // On mouse move, if the drag mode is enabled, we change the position of the draggedNode
            renderer.on("moveBody", ({ event }) => {
                if (!isDragging || !draggedNode) return;

                // Get new position of node
                const pos = renderer.viewportToGraph(event);

                graph.setNodeAttribute(draggedNode, "x", pos.x);
                graph.setNodeAttribute(draggedNode, "y", pos.y);

                // Prevent sigma to move camera:
                event.preventSigmaDefault();
                event.original.preventDefault();
                event.original.stopPropagation();
            });

            // On mouse up, we reset the dragging mode
            const handleUp = () => {
                if (draggedNode) {
                    graph.removeNodeAttribute(draggedNode, "highlighted");
                }
                isDragging = false;
                draggedNode = null;
            };
            renderer.on("upNode", handleUp);
            renderer.on("upStage", handleUp);

            function setHoveredNode(node) {
                if (node) {
                    state.hoveredNode = node;
                    state.hoveredNeighbors = new Set(graph.neighbors(node));
                }

                if (!node) {
                    state.hoveredNode = undefined;
                    state.hoveredNeighbors = undefined;
                }

                // Refresh rendering
                renderer.refresh({
                    // We don't touch the graph data so we can skip its reindexation
                    skipIndexation: true,
                });
            }
        },
        error: function (error) {
            console.error("Error parsing CSV:", error);
        }
    });

};
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXVGO0FBQzlDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixXQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsWUFBWTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELHlCQUF5Qiw0QkFBNEIsMEJBQTBCLHFCQUFxQixxQkFBcUIscUJBQXFCLDhEQUE4RCw2QkFBNkIsd0VBQXdFLDZCQUE2QiwyRUFBMkUsMkNBQTJDLHdDQUF3QyxpQ0FBaUMsR0FBRyx1REFBdUQsd0VBQXdFLDRCQUE0QixxREFBcUQsa0RBQWtELDJCQUEyQixvQ0FBb0MsdUJBQXVCLHVEQUF1RCw2REFBNkQsa0RBQWtELEdBQUcseUVBQXlFLDZEQUE2RCxHQUFHLHNEQUFzRCxxQkFBcUIsa0ZBQWtGLGtDQUFrQyxtR0FBbUcsa0ZBQWtGLDJDQUEyQyw4SEFBOEgsS0FBSyw0R0FBNEcsa0ZBQWtGLDJDQUEyQyw4SEFBOEgsS0FBSyxxREFBcUQsK0JBQStCLHNEQUFzRCxrSEFBa0gsb0RBQW9ELGtCQUFrQixNQUFNLGlDQUFpQyxLQUFLLEdBQUc7QUFDejhFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEMseUJBQXlCLDhCQUE4Qiw4QkFBOEIsMEJBQTBCLDBCQUEwQiw0QkFBNEIsOEJBQThCLDhEQUE4RCwwRUFBMEUscUNBQXFDLDRCQUE0Qiw2QkFBNkIsNEJBQTRCLG1DQUFtQywwQkFBMEIseUJBQXlCLDRCQUE0QiwwQkFBMEIscUJBQXFCLHFCQUFxQixxQkFBcUIsK0RBQStELDZCQUE2Qix3RUFBd0UsNkJBQTZCLDZFQUE2RSw4Q0FBOEMsNEJBQTRCLHlEQUF5RCx1R0FBdUcsR0FBRyx5REFBeUQsbUdBQW1HLEdBQUcsaUJBQWlCLDRDQUE0Qyw0TUFBNE0saURBQWlELHNEQUFzRCxvREFBb0QsMEVBQTBFLG9FQUFvRSxvRUFBb0UseURBQXlELDhCQUE4Qix3REFBd0QsbUNBQW1DLG1EQUFtRCwwRUFBMEUsZ0RBQWdELDBCQUEwQiw2QkFBNkIsc0dBQXNHLDJCQUEyQixnVkFBZ1YsMkVBQTJFLHVDQUF1QyxxR0FBcUcsbUNBQW1DLDBHQUEwRyxtQ0FBbUMsMkdBQTJHLHdFQUF3RSxrQ0FBa0MsR0FBRztBQUNwNUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHNEQUFzRDtBQUNuRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1CQUFtQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQXVCLG9CQUFvQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5REFBeUQ7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLGFBQWE7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUcsQ0FBQyx3REFBVztBQUNmOztBQUVBO0FBQ0E7QUFDQSxhQUFhLG9GQUF1QztBQUNwRCxDQUFDO0FBQ0Q7QUFDQSw2Q0FBNkMsRUFBRSxvRkFBdUMsS0FBSztBQUMzRjtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUUwUTs7Ozs7Ozs7Ozs7O0FDcGhCM1E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMseUJBQXlCO0FBQ2xDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsOERBQThELFlBQVk7QUFDMUU7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNoZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLFNBQVMsc0NBQXNDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUI7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsNEVBQTBCOztBQUV0Qzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDRDQUE0QztBQUNyRCxTQUFTLGtEQUFrRDs7QUFFM0QsT0FBTyw2Q0FBNkM7O0FBRXBEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBOztBQUVBLDBCQUEwQixtQkFBbUI7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7Ozs7Ozs7Ozs7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyw4RUFBMkI7QUFDbkQsd0JBQXdCLG1CQUFPLENBQUMsOEVBQTJCOztBQUUzRCxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBYztBQUN0QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1RUFBYztBQUN0QyxpQkFBaUIsbUJBQU8sQ0FBQyx5RUFBZTs7QUFFeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU8sV0FBVzs7QUFFbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDdkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3Qiw4QkFBOEI7QUFDOUI7QUFDQTs7Ozs7Ozs7Ozs7QUN4SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN0QnNDOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBLHdDQUF3QyxPQUFPO0FBQy9DOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sd0JBQXdCLFdBQVc7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU8sd0JBQXdCLFdBQVc7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUJBQWlCLE9BQU8sU0FBUyxXQUFXLGlDQUFpQyxXQUFXLFVBQVUsT0FBTyxJQUFJLE9BQU87QUFDcEg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTyx3QkFBd0IsV0FBVztBQUMzRDs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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O0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLGVBQWU7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLFdBQVcsaUNBQWlDOztBQUU1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFD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QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLGNBQWM7QUFDMUIsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLFNBQVMsdUJBQXVCOztBQUVoQztBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixLQUFLLHdCQUF3QixLQUFLO0FBQ25EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsU0FBUyx1QkFBdUI7O0FBRWhDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWSx3QkFBd0IsS0FBSztBQUMxRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLFNBQVMsdUJBQXVCOztBQUVoQzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFNBQVMsd0JBQXdCLEtBQUs7QUFDdkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYyxVQUFVO0FBQ3hCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBLFNBQVMsdUJBQXVCOztBQUVoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEIsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixhQUFhLHdCQUF3QixLQUFLO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBLHFDQUFxQzs7QUFFckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUM7O0FBRXJDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxxQkFBcUIsS0FBSztBQUMxQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixLQUFLO0FBQzFCLEdBQUc7QUFDSDtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0EsR0FBRztBQUNIO0FBQ0EscUJBQXFCLEtBQUs7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLFdBQVc7QUFDcEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkIsS0FBSztBQUNsQzs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLGVBQWUsS0FBSyxxREFBcUQsV0FBVztBQUNwRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLG1DQUFtQyxPQUFPO0FBQzlEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsS0FBSyxpQkFBaUIsT0FBTztBQUM1Qzs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLGlCQUFpQixPQUFPO0FBQzVDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxTQUFTLEtBQUs7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLLHFCQUFxQixPQUFPLFFBQVEsT0FBTztBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEtBQUssNERBQTRELFdBQVc7QUFDL0Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLG1CQUFtQixLQUFLLHFEQUFxRCxXQUFXO0FBQ3hGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsS0FBSyxtQ0FBbUMsT0FBTztBQUM5RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixLQUFLLHlEQUF5RCxLQUFLLGVBQWUsT0FBTyxjQUFjLE9BQU8saUJBQWlCLG9CQUFvQixNQUFNLG9CQUFvQjtBQUNsTTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSyxTQUFTLEtBQUs7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLG9EQUFvRDs7QUFFN0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQixZQUFZLFdBQVc7QUFDdkIsWUFBWSxXQUFXO0FBQ3ZCLFlBQVksV0FBVztBQUN2QixZQUFZLFdBQVc7QUFDdkI7QUFDQSxZQUFZLE9BQU87QUFDbkI7QUFDQSxvQkFBb0IsZ0RBQVk7QUFDaEM7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0EsbUZBQW1GLGNBQWM7QUFDakc7O0FBRUE7QUFDQTtBQUNBLG1IQUFtSCxhQUFhO0FBQ2hJOztBQUVBO0FBQ0E7QUFDQSw0RkFBNEYsdUJBQXVCO0FBQ25IOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxpQkFBaUI7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsaUJBQWlCO0FBQ2hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsaUJBQWlCO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxLQUFLO0FBQ25CLGNBQWMsS0FBSztBQUNuQjtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxPQUFPO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsT0FBTztBQUMxRDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTztBQUM1RDs7QUFFQTtBQUNBO0FBQ0EscURBQXFELE9BQU87QUFDNUQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQixjQUFjLEtBQUs7QUFDbkI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsMkRBQTJELEtBQUs7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUs7QUFDM0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkRBQTZELEtBQUs7QUFDbEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELEtBQUs7QUFDeEQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwREFBMEQsS0FBSztBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDJEQUEyRCxLQUFLO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscURBQXFELEtBQUs7QUFDMUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELEtBQUs7QUFDNUQ7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9ELEtBQUs7QUFDekQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGNBQWM7QUFDNUI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsS0FBSztBQUMxRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0RBQStELEtBQUs7QUFDcEU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsZ0VBQWdFLEtBQUs7QUFDckU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUVBQXFFLEtBQUs7QUFDMUU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLEtBQUs7QUFDNUU7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esb0VBQW9FLEtBQUs7QUFDekU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLGNBQWM7QUFDNUI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxRUFBcUUsS0FBSztBQUMxRTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsY0FBYztBQUM1QjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsY0FBYyxVQUFVO0FBQ3hCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLEtBQUs7QUFDbEQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxZQUFZO0FBQzFCO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esa0RBQWtELEtBQUs7QUFDdkQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckIsY0FBYyxPQUFPO0FBQ3JCLGNBQWMsWUFBWTtBQUMxQjtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsS0FBSyxpQ0FBaUMsS0FBSyxVQUFVLE9BQU8sSUFBSSxPQUFPO0FBQ3JHO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjLGNBQWM7QUFDNUI7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRCxLQUFLO0FBQ3hEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxLQUFLO0FBQ3REOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBLGNBQWMsT0FBTztBQUNyQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxXQUFXO0FBQ3hGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFGQUFxRixRQUFRO0FBQzdGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDOztBQUUzQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFFBQVEsT0FBTztBQUN2RTtBQUNBLE1BQU07QUFDTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrQ0FBK0MsZUFBZTtBQUM5RDs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsT0FBTyxRQUFRLE9BQU87QUFDM0U7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0EsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGVBQWU7QUFDaEU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RCxPQUFPLFFBQVEsT0FBTztBQUM3RTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjLFVBQVU7QUFDeEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrUDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUN6Vi9QO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsT0FBTztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV1Rjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEUwRTtBQUNuRjs7QUFFOUU7QUFDQSxjQUFjLDREQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsR0FBRyw0Q0FBNEMsNERBQWUsS0FBSztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsZUFBZSw0REFBZTtBQUM5QjtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1S0FBdUs7QUFDdkssbUNBQW1DLDREQUFZO0FBQy9DLEVBQUUsNERBQWU7QUFDakIsQ0FBQztBQUNEO0FBQ0E7QUFDQSxJQUFJLDREQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLCtCQUErQjtBQUNyRDtBQUNBO0FBQ0Esd0JBQXdCLG1CQUFtQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNERBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0NBQXdDLE1BQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxLQUFLO0FBQ2xELDhDQUE4QyxXQUFXO0FBQ3pELDZDQUE2QyxVQUFVO0FBQ3ZELDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVDQUF1QyxPQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsRSIsInNvdXJjZXMiOlsid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL0BzaWdtYS9lZGdlLWN1cnZlL2Rpc3Qvc2lnbWEtZWRnZS1jdXJ2ZS5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1mb3JjZS9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1mb3JjZS9oZWxwZXJzLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlL2l0ZXJhdGUuanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2Uvd29ya2VyLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktdXRpbHMvZGVmYXVsdHMuanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS11dGlscy9nZXR0ZXJzLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGguanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS9kaXN0L2dyYXBob2xvZ3kubWpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3BhcGFwYXJzZS9wYXBhcGFyc2UubWluLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2RhdGEtMTFkZjcxMjQuZXNtLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvaW5kZXgtMjM2YzYyYWQuZXNtLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzIiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3Qvbm9ybWFsaXphdGlvbi1iZTQ0NTUxOC5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9zaWdtYS5lc20uanMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL2Rpc3Qvc2lnbWEtcmVuZGVyaW5nLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS9zZXR0aW5ncy9kaXN0L3NpZ21hLXNldHRpbmdzLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS90eXBlcy9kaXN0L3NpZ21hLXR5cGVzLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC8uL25vZGVfbW9kdWxlcy9zaWdtYS91dGlscy9kaXN0L3NpZ21hLXV0aWxzLmVzbS5qcyIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vbmV0d29yay1ncmFwaC1hcHAvd2VicGFjay9ydW50aW1lL2hhc093blByb3BlcnR5IHNob3J0aGFuZCIsIndlYnBhY2s6Ly9uZXR3b3JrLWdyYXBoLWFwcC93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL25ldHdvcmstZ3JhcGgtYXBwLy4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVkZ2VQcm9ncmFtLCBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMgfSBmcm9tICdzaWdtYS9yZW5kZXJpbmcnO1xuaW1wb3J0IHsgZmxvYXRDb2xvciB9IGZyb20gJ3NpZ21hL3V0aWxzJztcblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogaSArIFwiXCI7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuXG5mdW5jdGlvbiBvd25LZXlzKGUsIHIpIHtcbiAgdmFyIHQgPSBPYmplY3Qua2V5cyhlKTtcbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgbyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZSk7XG4gICAgciAmJiAobyA9IG8uZmlsdGVyKGZ1bmN0aW9uIChyKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCByKS5lbnVtZXJhYmxlO1xuICAgIH0pKSwgdC5wdXNoLmFwcGx5KHQsIG8pO1xuICB9XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIoZSkge1xuICBmb3IgKHZhciByID0gMTsgciA8IGFyZ3VtZW50cy5sZW5ndGg7IHIrKykge1xuICAgIHZhciB0ID0gbnVsbCAhPSBhcmd1bWVudHNbcl0gPyBhcmd1bWVudHNbcl0gOiB7fTtcbiAgICByICUgMiA/IG93bktleXMoT2JqZWN0KHQpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IHR5cGVvZiBlIHx8IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZSkpIHJldHVybiBlO1xuICBpZiAodm9pZCAwICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHQpO1xufVxuXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cblxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheShyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnZlUG9pbnQodCwgcDAsIHAxLCBwMikge1xuICB2YXIgeCA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHAwLnggKyAyICogKDEgLSB0KSAqIHQgKiBwMS54ICsgTWF0aC5wb3codCwgMikgKiBwMi54O1xuICB2YXIgeSA9IE1hdGgucG93KDEgLSB0LCAyKSAqIHAwLnkgKyAyICogKDEgLSB0KSAqIHQgKiBwMS55ICsgTWF0aC5wb3codCwgMikgKiBwMi55O1xuICByZXR1cm4ge1xuICAgIHg6IHgsXG4gICAgeTogeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q3VydmVMZW5ndGgocDAsIHAxLCBwMikge1xuICB2YXIgc3RlcHMgPSAyMDtcbiAgdmFyIGxlbmd0aCA9IDA7XG4gIHZhciBsYXN0UG9pbnQgPSBwMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7XG4gICAgdmFyIHBvaW50ID0gZ2V0Q3VydmVQb2ludCgoaSArIDEpIC8gc3RlcHMsIHAwLCBwMSwgcDIpO1xuICAgIGxlbmd0aCArPSBNYXRoLnNxcnQoTWF0aC5wb3cobGFzdFBvaW50LnggLSBwb2ludC54LCAyKSArIE1hdGgucG93KGxhc3RQb2ludC55IC0gcG9pbnQueSwgMikpO1xuICAgIGxhc3RQb2ludCA9IHBvaW50O1xuICB9XG4gIHJldHVybiBsZW5ndGg7XG59XG5mdW5jdGlvbiBjcmVhdGVEcmF3Q3VydmVkRWRnZUxhYmVsKF9yZWYpIHtcbiAgdmFyIGN1cnZhdHVyZUF0dHJpYnV0ZSA9IF9yZWYuY3VydmF0dXJlQXR0cmlidXRlLFxuICAgIGRlZmF1bHRDdXJ2YXR1cmUgPSBfcmVmLmRlZmF1bHRDdXJ2YXR1cmUsXG4gICAgX3JlZiRrZWVwTGFiZWxVcHJpZ2h0ID0gX3JlZi5rZWVwTGFiZWxVcHJpZ2h0LFxuICAgIGtlZXBMYWJlbFVwcmlnaHQgPSBfcmVmJGtlZXBMYWJlbFVwcmlnaHQgPT09IHZvaWQgMCA/IHRydWUgOiBfcmVmJGtlZXBMYWJlbFVwcmlnaHQ7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgZWRnZURhdGEsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIHNldHRpbmdzKSB7XG4gICAgdmFyIHNpemUgPSBzZXR0aW5ncy5lZGdlTGFiZWxTaXplLFxuICAgICAgY3VydmF0dXJlID0gZWRnZURhdGFbY3VydmF0dXJlQXR0cmlidXRlXSB8fCBkZWZhdWx0Q3VydmF0dXJlLFxuICAgICAgZm9udCA9IHNldHRpbmdzLmVkZ2VMYWJlbEZvbnQsXG4gICAgICB3ZWlnaHQgPSBzZXR0aW5ncy5lZGdlTGFiZWxXZWlnaHQsXG4gICAgICBjb2xvciA9IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZSA/IGVkZ2VEYXRhW3NldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZV0gfHwgc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuY29sb3IgfHwgXCIjMDAwXCIgOiBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5jb2xvcjtcbiAgICB2YXIgbGFiZWwgPSBlZGdlRGF0YS5sYWJlbDtcbiAgICBpZiAoIWxhYmVsKSByZXR1cm47XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgICBjb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnQpO1xuXG4gICAgLy8gQ29tcHV0aW5nIHBvc2l0aW9ucyB3aXRob3V0IGNvbnNpZGVyaW5nIG5vZGVzIHNpemVzOlxuICAgIHZhciBsdHIgPSAha2VlcExhYmVsVXByaWdodCB8fCBzb3VyY2VEYXRhLnggPCB0YXJnZXREYXRhLng7XG4gICAgdmFyIHNvdXJjZVggPSBsdHIgPyBzb3VyY2VEYXRhLnggOiB0YXJnZXREYXRhLng7XG4gICAgdmFyIHNvdXJjZVkgPSBsdHIgPyBzb3VyY2VEYXRhLnkgOiB0YXJnZXREYXRhLnk7XG4gICAgdmFyIHRhcmdldFggPSBsdHIgPyB0YXJnZXREYXRhLnggOiBzb3VyY2VEYXRhLng7XG4gICAgdmFyIHRhcmdldFkgPSBsdHIgPyB0YXJnZXREYXRhLnkgOiBzb3VyY2VEYXRhLnk7XG4gICAgdmFyIGNlbnRlclggPSAoc291cmNlWCArIHRhcmdldFgpIC8gMjtcbiAgICB2YXIgY2VudGVyWSA9IChzb3VyY2VZICsgdGFyZ2V0WSkgLyAyO1xuICAgIHZhciBkaWZmWCA9IHRhcmdldFggLSBzb3VyY2VYO1xuICAgIHZhciBkaWZmWSA9IHRhcmdldFkgLSBzb3VyY2VZO1xuICAgIHZhciBkaWZmID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZYLCAyKSArIE1hdGgucG93KGRpZmZZLCAyKSk7XG4gICAgLy8gQW5jaG9yIHBvaW50OlxuICAgIHZhciBvcmllbnRhdGlvbiA9IGx0ciA/IDEgOiAtMTtcbiAgICB2YXIgYW5jaG9yWCA9IGNlbnRlclggKyBkaWZmWSAqIGN1cnZhdHVyZSAqIG9yaWVudGF0aW9uO1xuICAgIHZhciBhbmNob3JZID0gY2VudGVyWSAtIGRpZmZYICogY3VydmF0dXJlICogb3JpZW50YXRpb247XG5cbiAgICAvLyBBZGFwdCBjdXJ2ZSBwb2ludHMgdG8gZWRnZSB0aGlja25lc3M6XG4gICAgdmFyIG9mZnNldCA9IGVkZ2VEYXRhLnNpemUgKiAwLjcgKyA1O1xuICAgIHZhciBzb3VyY2VPZmZzZXRWZWN0b3IgPSB7XG4gICAgICB4OiBhbmNob3JZIC0gc291cmNlWSxcbiAgICAgIHk6IC0oYW5jaG9yWCAtIHNvdXJjZVgpXG4gICAgfTtcbiAgICB2YXIgc291cmNlT2Zmc2V0VmVjdG9yTGVuZ3RoID0gTWF0aC5zcXJ0KE1hdGgucG93KHNvdXJjZU9mZnNldFZlY3Rvci54LCAyKSArIE1hdGgucG93KHNvdXJjZU9mZnNldFZlY3Rvci55LCAyKSk7XG4gICAgdmFyIHRhcmdldE9mZnNldFZlY3RvciA9IHtcbiAgICAgIHg6IHRhcmdldFkgLSBhbmNob3JZLFxuICAgICAgeTogLSh0YXJnZXRYIC0gYW5jaG9yWClcbiAgICB9O1xuICAgIHZhciB0YXJnZXRPZmZzZXRWZWN0b3JMZW5ndGggPSBNYXRoLnNxcnQoTWF0aC5wb3codGFyZ2V0T2Zmc2V0VmVjdG9yLngsIDIpICsgTWF0aC5wb3codGFyZ2V0T2Zmc2V0VmVjdG9yLnksIDIpKTtcbiAgICBzb3VyY2VYICs9IG9mZnNldCAqIHNvdXJjZU9mZnNldFZlY3Rvci54IC8gc291cmNlT2Zmc2V0VmVjdG9yTGVuZ3RoO1xuICAgIHNvdXJjZVkgKz0gb2Zmc2V0ICogc291cmNlT2Zmc2V0VmVjdG9yLnkgLyBzb3VyY2VPZmZzZXRWZWN0b3JMZW5ndGg7XG4gICAgdGFyZ2V0WCArPSBvZmZzZXQgKiB0YXJnZXRPZmZzZXRWZWN0b3IueCAvIHRhcmdldE9mZnNldFZlY3Rvckxlbmd0aDtcbiAgICB0YXJnZXRZICs9IG9mZnNldCAqIHRhcmdldE9mZnNldFZlY3Rvci55IC8gdGFyZ2V0T2Zmc2V0VmVjdG9yTGVuZ3RoO1xuICAgIC8vIEZvciBhbmNob3IsIHRoZSB2ZWN0b3IgaXMgc2ltcGxlciwgc28gaXQgaXMgaW5saW5lZDpcbiAgICBhbmNob3JYICs9IG9mZnNldCAqIGRpZmZZIC8gZGlmZjtcbiAgICBhbmNob3JZIC09IG9mZnNldCAqIGRpZmZYIC8gZGlmZjtcblxuICAgIC8vIENvbXB1dGUgY3VydmUgbGVuZ3RoOlxuICAgIHZhciBhbmNob3JQb2ludCA9IHtcbiAgICAgIHg6IGFuY2hvclgsXG4gICAgICB5OiBhbmNob3JZXG4gICAgfTtcbiAgICB2YXIgc291cmNlUG9pbnQgPSB7XG4gICAgICB4OiBzb3VyY2VYLFxuICAgICAgeTogc291cmNlWVxuICAgIH07XG4gICAgdmFyIHRhcmdldFBvaW50ID0ge1xuICAgICAgeDogdGFyZ2V0WCxcbiAgICAgIHk6IHRhcmdldFlcbiAgICB9O1xuICAgIHZhciBjdXJ2ZUxlbmd0aCA9IGdldEN1cnZlTGVuZ3RoKHNvdXJjZVBvaW50LCBhbmNob3JQb2ludCwgdGFyZ2V0UG9pbnQpO1xuICAgIGlmIChjdXJ2ZUxlbmd0aCA8IHNvdXJjZURhdGEuc2l6ZSArIHRhcmdldERhdGEuc2l6ZSkgcmV0dXJuO1xuXG4gICAgLy8gSGFuZGxpbmcgZWxsaXBzaXNcbiAgICB2YXIgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIHZhciBhdmFpbGFibGVUZXh0TGVuZ3RoID0gY3VydmVMZW5ndGggLSBzb3VyY2VEYXRhLnNpemUgLSB0YXJnZXREYXRhLnNpemU7XG4gICAgaWYgKHRleHRMZW5ndGggPiBhdmFpbGFibGVUZXh0TGVuZ3RoKSB7XG4gICAgICB2YXIgZWxsaXBzaXMgPSBcIuKAplwiO1xuICAgICAgbGFiZWwgPSBsYWJlbCArIGVsbGlwc2lzO1xuICAgICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgICAgd2hpbGUgKHRleHRMZW5ndGggPiBhdmFpbGFibGVUZXh0TGVuZ3RoICYmIGxhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbGFiZWwgPSBsYWJlbC5zbGljZSgwLCAtMikgKyBlbGxpcHNpcztcbiAgICAgICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgICAgfVxuICAgICAgaWYgKGxhYmVsLmxlbmd0aCA8IDQpIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBNZWFzdXJlIGVhY2ggY2hhcmFjdGVyOlxuICAgIHZhciBjaGFyYWN0ZXJzTGVuZ3RoQ2FjaGUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gbGFiZWwubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGFyYWN0ZXIgPSBsYWJlbFtpXTtcbiAgICAgIGlmICghY2hhcmFjdGVyc0xlbmd0aENhY2hlW2NoYXJhY3Rlcl0pIHtcbiAgICAgICAgY2hhcmFjdGVyc0xlbmd0aENhY2hlW2NoYXJhY3Rlcl0gPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAoMSArIGN1cnZhdHVyZSAqIDAuMzUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyYXcgZWFjaCBjaGFyYWN0ZXI6XG4gICAgdmFyIHQgPSAwLjUgLSB0ZXh0TGVuZ3RoIC8gY3VydmVMZW5ndGggLyAyO1xuICAgIGZvciAodmFyIF9pID0gMCwgX2xlbmd0aCA9IGxhYmVsLmxlbmd0aDsgX2kgPCBfbGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2NoYXJhY3RlciA9IGxhYmVsW19pXTtcbiAgICAgIHZhciBwb2ludCA9IGdldEN1cnZlUG9pbnQodCwgc291cmNlUG9pbnQsIGFuY2hvclBvaW50LCB0YXJnZXRQb2ludCk7XG4gICAgICB2YXIgdGFuZ2VudFggPSAyICogKDEgLSB0KSAqIChhbmNob3JYIC0gc291cmNlWCkgKyAyICogdCAqICh0YXJnZXRYIC0gYW5jaG9yWCk7XG4gICAgICB2YXIgdGFuZ2VudFkgPSAyICogKDEgLSB0KSAqIChhbmNob3JZIC0gc291cmNlWSkgKyAyICogdCAqICh0YXJnZXRZIC0gYW5jaG9yWSk7XG4gICAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKHRhbmdlbnRZLCB0YW5nZW50WCk7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgY29udGV4dC5yb3RhdGUoYW5nbGUpO1xuXG4gICAgICAvLyBEZXNzaW5lciBsZSBjYXJhY3TDqHJlXG4gICAgICBjb250ZXh0LmZpbGxUZXh0KF9jaGFyYWN0ZXIsIDAsIDApO1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICB0ICs9IGNoYXJhY3RlcnNMZW5ndGhDYWNoZVtfY2hhcmFjdGVyXSAvIGN1cnZlTGVuZ3RoO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0RnJhZ21lbnRTaGFkZXIoX3JlZikge1xuICB2YXIgYXJyb3dIZWFkID0gX3JlZi5hcnJvd0hlYWQ7XG4gIHZhciBoYXNUYXJnZXRBcnJvd0hlYWQgPSAoYXJyb3dIZWFkID09PSBudWxsIHx8IGFycm93SGVhZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJyb3dIZWFkLmV4dHJlbWl0eSkgPT09IFwidGFyZ2V0XCIgfHwgKGFycm93SGVhZCA9PT0gbnVsbCB8fCBhcnJvd0hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycm93SGVhZC5leHRyZW1pdHkpID09PSBcImJvdGhcIjtcbiAgdmFyIGhhc1NvdXJjZUFycm93SGVhZCA9IChhcnJvd0hlYWQgPT09IG51bGwgfHwgYXJyb3dIZWFkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJvd0hlYWQuZXh0cmVtaXR5KSA9PT0gXCJzb3VyY2VcIiB8fCAoYXJyb3dIZWFkID09PSBudWxsIHx8IGFycm93SGVhZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJyb3dIZWFkLmV4dHJlbWl0eSkgPT09IFwiYm90aFwiO1xuXG4gIC8vIGxhbmd1YWdlPUdMU0xcbiAgdmFyIFNIQURFUiA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG52YXJ5aW5nIHZlYzIgdl9jcEE7XFxudmFyeWluZyB2ZWMyIHZfY3BCO1xcbnZhcnlpbmcgdmVjMiB2X2NwQztcXG5cIi5jb25jYXQoaGFzVGFyZ2V0QXJyb3dIZWFkID8gXCJcXG52YXJ5aW5nIGZsb2F0IHZfdGFyZ2V0U2l6ZTtcXG52YXJ5aW5nIHZlYzIgdl90YXJnZXRQb2ludDtcIiA6IFwiXCIsIFwiXFxuXCIpLmNvbmNhdChoYXNTb3VyY2VBcnJvd0hlYWQgPyBcIlxcbnZhcnlpbmcgZmxvYXQgdl9zb3VyY2VTaXplO1xcbnZhcnlpbmcgdmVjMiB2X3NvdXJjZVBvaW50O1wiIDogXCJcIiwgXCJcXG5cIikuY29uY2F0KGFycm93SGVhZCA/IFwiXFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcIiA6IFwiXCIsIFwiXFxuXFxuZmxvYXQgZGV0KHZlYzIgYSwgdmVjMiBiKSB7XFxuICByZXR1cm4gYS54ICogYi55IC0gYi54ICogYS55O1xcbn1cXG5cXG52ZWMyIGdldERpc3RhbmNlVmVjdG9yKHZlYzIgYjAsIHZlYzIgYjEsIHZlYzIgYjIpIHtcXG4gIGZsb2F0IGEgPSBkZXQoYjAsIGIyKSwgYiA9IDIuMCAqIGRldChiMSwgYjApLCBkID0gMi4wICogZGV0KGIyLCBiMSk7XFxuICBmbG9hdCBmID0gYiAqIGQgLSBhICogYTtcXG4gIHZlYzIgZDIxID0gYjIgLSBiMSwgZDEwID0gYjEgLSBiMCwgZDIwID0gYjIgLSBiMDtcXG4gIHZlYzIgZ2YgPSAyLjAgKiAoYiAqIGQyMSArIGQgKiBkMTAgKyBhICogZDIwKTtcXG4gIGdmID0gdmVjMihnZi55LCAtZ2YueCk7XFxuICB2ZWMyIHBwID0gLWYgKiBnZiAvIGRvdChnZiwgZ2YpO1xcbiAgdmVjMiBkMHAgPSBiMCAtIHBwO1xcbiAgZmxvYXQgYXAgPSBkZXQoZDBwLCBkMjApLCBicCA9IDIuMCAqIGRldChkMTAsIGQwcCk7XFxuICBmbG9hdCB0ID0gY2xhbXAoKGFwICsgYnApIC8gKDIuMCAqIGEgKyBiICsgZCksIDAuMCwgMS4wKTtcXG4gIHJldHVybiBtaXgobWl4KGIwLCBiMSwgdCksIG1peChiMSwgYjIsIHQpLCB0KTtcXG59XFxuXFxuZmxvYXQgZGlzdFRvUXVhZHJhdGljQmV6aWVyQ3VydmUodmVjMiBwLCB2ZWMyIGIwLCB2ZWMyIGIxLCB2ZWMyIGIyKSB7XFxuICByZXR1cm4gbGVuZ3RoKGdldERpc3RhbmNlVmVjdG9yKGIwIC0gcCwgYjEgLSBwLCBiMiAtIHApKTtcXG59XFxuXFxuY29uc3QgdmVjNCB0cmFuc3BhcmVudCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZmxvYXQgZGlzdCA9IGRpc3RUb1F1YWRyYXRpY0JlemllckN1cnZlKGdsX0ZyYWdDb29yZC54eSwgdl9jcEEsIHZfY3BCLCB2X2NwQyk7XFxuICBmbG9hdCB0aGlja25lc3MgPSB2X3RoaWNrbmVzcztcXG5cIikuY29uY2F0KGhhc1RhcmdldEFycm93SGVhZCA/IFwiXFxuICBmbG9hdCBkaXN0VG9UYXJnZXQgPSBsZW5ndGgoZ2xfRnJhZ0Nvb3JkLnh5IC0gdl90YXJnZXRQb2ludCk7XFxuICBmbG9hdCB0YXJnZXRBcnJvd0xlbmd0aCA9IHZfdGFyZ2V0U2l6ZSArIHRoaWNrbmVzcyAqIHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcXG4gIGlmIChkaXN0VG9UYXJnZXQgPCB0YXJnZXRBcnJvd0xlbmd0aCkge1xcbiAgICB0aGlja25lc3MgPSAoZGlzdFRvVGFyZ2V0IC0gdl90YXJnZXRTaXplKSAvICh0YXJnZXRBcnJvd0xlbmd0aCAtIHZfdGFyZ2V0U2l6ZSkgKiB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbyAqIHRoaWNrbmVzcztcXG4gIH1cIiA6IFwiXCIsIFwiXFxuXCIpLmNvbmNhdChoYXNTb3VyY2VBcnJvd0hlYWQgPyBcIlxcbiAgZmxvYXQgZGlzdFRvU291cmNlID0gbGVuZ3RoKGdsX0ZyYWdDb29yZC54eSAtIHZfc291cmNlUG9pbnQpO1xcbiAgZmxvYXQgc291cmNlQXJyb3dMZW5ndGggPSB2X3NvdXJjZVNpemUgKyB0aGlja25lc3MgKiB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxuICBpZiAoZGlzdFRvU291cmNlIDwgc291cmNlQXJyb3dMZW5ndGgpIHtcXG4gICAgdGhpY2tuZXNzID0gKGRpc3RUb1NvdXJjZSAtIHZfc291cmNlU2l6ZSkgLyAoc291cmNlQXJyb3dMZW5ndGggLSB2X3NvdXJjZVNpemUpICogdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW8gKiB0aGlja25lc3M7XFxuICB9XCIgOiBcIlwiLCBcIlxcblxcbiAgZmxvYXQgaGFsZlRoaWNrbmVzcyA9IHRoaWNrbmVzcyAvIDIuMDtcXG4gIGlmIChkaXN0IDwgaGFsZlRoaWNrbmVzcykge1xcbiAgICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuICAgICNlbHNlXFxuICAgIGZsb2F0IHQgPSBzbW9vdGhzdGVwKFxcbiAgICAgIGhhbGZUaGlja25lc3MgLSB2X2ZlYXRoZXIsXFxuICAgICAgaGFsZlRoaWNrbmVzcyxcXG4gICAgICBkaXN0XFxuICAgICk7XFxuXFxuICAgIGdsX0ZyYWdDb2xvciA9IG1peCh2X2NvbG9yLCB0cmFuc3BhcmVudCwgdCk7XFxuICAgICNlbmRpZlxcbiAgfSBlbHNlIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdHJhbnNwYXJlbnQ7XFxuICB9XFxufVxcblwiKTtcbiAgcmV0dXJuIFNIQURFUjtcbn1cblxuZnVuY3Rpb24gZ2V0VmVydGV4U2hhZGVyKF9yZWYpIHtcbiAgdmFyIGFycm93SGVhZCA9IF9yZWYuYXJyb3dIZWFkO1xuICB2YXIgaGFzVGFyZ2V0QXJyb3dIZWFkID0gKGFycm93SGVhZCA9PT0gbnVsbCB8fCBhcnJvd0hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycm93SGVhZC5leHRyZW1pdHkpID09PSBcInRhcmdldFwiIHx8IChhcnJvd0hlYWQgPT09IG51bGwgfHwgYXJyb3dIZWFkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJvd0hlYWQuZXh0cmVtaXR5KSA9PT0gXCJib3RoXCI7XG4gIHZhciBoYXNTb3VyY2VBcnJvd0hlYWQgPSAoYXJyb3dIZWFkID09PSBudWxsIHx8IGFycm93SGVhZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJyb3dIZWFkLmV4dHJlbWl0eSkgPT09IFwic291cmNlXCIgfHwgKGFycm93SGVhZCA9PT0gbnVsbCB8fCBhcnJvd0hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycm93SGVhZC5leHRyZW1pdHkpID09PSBcImJvdGhcIjtcblxuICAvLyBsYW5ndWFnZT1HTFNMXG4gIHZhciBTSEFERVIgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX2RpcmVjdGlvbjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV90aGlja25lc3M7XFxuYXR0cmlidXRlIHZlYzIgYV9zb3VyY2U7XFxuYXR0cmlidXRlIHZlYzIgYV90YXJnZXQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfY3VycmVudDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9jdXJ2YXR1cmU7XFxuXCIuY29uY2F0KGhhc1RhcmdldEFycm93SGVhZCA/IFwiYXR0cmlidXRlIGZsb2F0IGFfdGFyZ2V0U2l6ZTtcXG5cIiA6IFwiXCIsIFwiXFxuXCIpLmNvbmNhdChoYXNTb3VyY2VBcnJvd0hlYWQgPyBcImF0dHJpYnV0ZSBmbG9hdCBhX3NvdXJjZVNpemU7XFxuXCIgOiBcIlwiLCBcIlxcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xcbnVuaWZvcm0gdmVjMiB1X2RpbWVuc2lvbnM7XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXI7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG52YXJ5aW5nIHZlYzIgdl9jcEE7XFxudmFyeWluZyB2ZWMyIHZfY3BCO1xcbnZhcnlpbmcgdmVjMiB2X2NwQztcXG5cIikuY29uY2F0KGhhc1RhcmdldEFycm93SGVhZCA/IFwiXFxudmFyeWluZyBmbG9hdCB2X3RhcmdldFNpemU7XFxudmFyeWluZyB2ZWMyIHZfdGFyZ2V0UG9pbnQ7XCIgOiBcIlwiLCBcIlxcblwiKS5jb25jYXQoaGFzU291cmNlQXJyb3dIZWFkID8gXCJcXG52YXJ5aW5nIGZsb2F0IHZfc291cmNlU2l6ZTtcXG52YXJ5aW5nIHZlYzIgdl9zb3VyY2VQb2ludDtcIiA6IFwiXCIsIFwiXFxuXCIpLmNvbmNhdChhcnJvd0hlYWQgPyBcIlxcbnVuaWZvcm0gZmxvYXQgdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW87XCIgOiBcIlwiLCBcIlxcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcbmNvbnN0IGZsb2F0IGVwc2lsb24gPSAwLjc7XFxuXFxudmVjMiBjbGlwc3BhY2VUb1ZpZXdwb3J0KHZlYzIgcG9zLCB2ZWMyIGRpbWVuc2lvbnMpIHtcXG4gIHJldHVybiB2ZWMyKFxcbiAgICAocG9zLnggKyAxLjApICogZGltZW5zaW9ucy54IC8gMi4wLFxcbiAgICAocG9zLnkgKyAxLjApICogZGltZW5zaW9ucy55IC8gMi4wXFxuICApO1xcbn1cXG5cXG52ZWMyIHZpZXdwb3J0VG9DbGlwc3BhY2UodmVjMiBwb3MsIHZlYzIgZGltZW5zaW9ucykge1xcbiAgcmV0dXJuIHZlYzIoXFxuICAgIHBvcy54IC8gZGltZW5zaW9ucy54ICogMi4wIC0gMS4wLFxcbiAgICBwb3MueSAvIGRpbWVuc2lvbnMueSAqIDIuMCAtIDEuMFxcbiAgKTtcXG59XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbWluVGhpY2tuZXNzID0gdV9taW5FZGdlVGhpY2tuZXNzO1xcblxcbiAgLy8gU2VsZWN0aW5nIHRoZSBjb3JyZWN0IHBvc2l0aW9uXFxuICAvLyBCcmFuY2hsZXNzIFxcXCJwb3NpdGlvbiA9IGFfc291cmNlIGlmIGFfY3VycmVudCA9PSAxLjAgZWxzZSBhX3RhcmdldFxcXCJcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3NvdXJjZSAqIG1heCgwLjAsIGFfY3VycmVudCkgKyBhX3RhcmdldCAqIG1heCgwLjAsIDEuMCAtIGFfY3VycmVudCk7XFxuICBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEpKS54eTtcXG5cXG4gIHZlYzIgc291cmNlID0gKHVfbWF0cml4ICogdmVjMyhhX3NvdXJjZSwgMSkpLnh5O1xcbiAgdmVjMiB0YXJnZXQgPSAodV9tYXRyaXggKiB2ZWMzKGFfdGFyZ2V0LCAxKSkueHk7XFxuXFxuICB2ZWMyIHZpZXdwb3J0UG9zaXRpb24gPSBjbGlwc3BhY2VUb1ZpZXdwb3J0KHBvc2l0aW9uLCB1X2RpbWVuc2lvbnMpO1xcbiAgdmVjMiB2aWV3cG9ydFNvdXJjZSA9IGNsaXBzcGFjZVRvVmlld3BvcnQoc291cmNlLCB1X2RpbWVuc2lvbnMpO1xcbiAgdmVjMiB2aWV3cG9ydFRhcmdldCA9IGNsaXBzcGFjZVRvVmlld3BvcnQodGFyZ2V0LCB1X2RpbWVuc2lvbnMpO1xcblxcbiAgdmVjMiBkZWx0YSA9IHZpZXdwb3J0VGFyZ2V0Lnh5IC0gdmlld3BvcnRTb3VyY2UueHk7XFxuICBmbG9hdCBsZW4gPSBsZW5ndGgoZGVsdGEpO1xcbiAgdmVjMiBub3JtYWwgPSB2ZWMyKC1kZWx0YS55LCBkZWx0YS54KSAqIGFfZGlyZWN0aW9uO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gbm9ybWFsIC8gbGVuO1xcbiAgZmxvYXQgYm91bmRpbmdCb3hUaGlja25lc3MgPSBsZW4gKiBhX2N1cnZhdHVyZTtcXG5cXG4gIGZsb2F0IGN1cnZlVGhpY2tuZXNzID0gbWF4KG1pblRoaWNrbmVzcywgYV90aGlja25lc3MgLyB1X3NpemVSYXRpbyk7XFxuICB2X3RoaWNrbmVzcyA9IGN1cnZlVGhpY2tuZXNzICogdV9waXhlbFJhdGlvO1xcbiAgdl9mZWF0aGVyID0gdV9mZWF0aGVyO1xcblxcbiAgdl9jcEEgPSB2aWV3cG9ydFNvdXJjZTtcXG4gIHZfY3BCID0gMC41ICogKHZpZXdwb3J0U291cmNlICsgdmlld3BvcnRUYXJnZXQpICsgdW5pdE5vcm1hbCAqIGFfZGlyZWN0aW9uICogYm91bmRpbmdCb3hUaGlja25lc3M7XFxuICB2X2NwQyA9IHZpZXdwb3J0VGFyZ2V0O1xcblxcbiAgdmVjMiB2aWV3cG9ydE9mZnNldFBvc2l0aW9uID0gKFxcbiAgICB2aWV3cG9ydFBvc2l0aW9uICtcXG4gICAgdW5pdE5vcm1hbCAqIChib3VuZGluZ0JveFRoaWNrbmVzcyAvIDIuMCArIHNpZ24oYm91bmRpbmdCb3hUaGlja25lc3MpICogKFwiKS5jb25jYXQoYXJyb3dIZWFkID8gXCJjdXJ2ZVRoaWNrbmVzcyAqIHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvXCIgOiBcImN1cnZlVGhpY2tuZXNzXCIsIFwiICsgZXBzaWxvbikpICpcXG4gICAgbWF4KDAuMCwgYV9kaXJlY3Rpb24pIC8vIE5PVEU6IGN1dHRpbmcgdGhlIGJvdW5kaW5nIGJveCBpbiBoYWxmIHRvIGF2b2lkIG92ZXJkcmF3XFxuICApO1xcblxcbiAgcG9zaXRpb24gPSB2aWV3cG9ydFRvQ2xpcHNwYWNlKHZpZXdwb3J0T2Zmc2V0UG9zaXRpb24sIHVfZGltZW5zaW9ucyk7XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpO1xcbiAgICBcXG5cIikuY29uY2F0KGhhc1RhcmdldEFycm93SGVhZCA/IFwiXFxuICB2X3RhcmdldFNpemUgPSBhX3RhcmdldFNpemUgKiB1X3BpeGVsUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIHZfdGFyZ2V0UG9pbnQgPSB2aWV3cG9ydFRhcmdldDtcXG5cIiA6IFwiXCIsIFwiXFxuXCIpLmNvbmNhdChoYXNTb3VyY2VBcnJvd0hlYWQgPyBcIlxcbiAgdl9zb3VyY2VTaXplID0gYV9zb3VyY2VTaXplICogdV9waXhlbFJhdGlvIC8gdV9zaXplUmF0aW87XFxuICB2X3NvdXJjZVBvaW50ID0gdmlld3BvcnRTb3VyY2U7XFxuXCIgOiBcIlwiLCBcIlxcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiKTtcbiAgcmV0dXJuIFNIQURFUjtcbn1cblxudmFyIERFRkFVTFRfRURHRV9DVVJWQVRVUkUgPSAwLjI1O1xudmFyIERFRkFVTFRfRURHRV9DVVJWRV9QUk9HUkFNX09QVElPTlMgPSB7XG4gIGFycm93SGVhZDogbnVsbCxcbiAgY3VydmF0dXJlQXR0cmlidXRlOiBcImN1cnZhdHVyZVwiLFxuICBkZWZhdWx0Q3VydmF0dXJlOiBERUZBVUxUX0VER0VfQ1VSVkFUVVJFXG59O1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaGVscHMgdG8gaWRlbnRpZnkgcGFyYWxsZWwgZWRnZXMsIHRvIGFkanVzdCB0aGVpciBjdXJ2YXR1cmVzLlxuICovXG52YXIgREVGQVVMVF9JTkRFWF9QQVJBTExFTF9FREdFU19PUFRJT05TID0ge1xuICBlZGdlSW5kZXhBdHRyaWJ1dGU6IFwicGFyYWxsZWxJbmRleFwiLFxuICBlZGdlTWluSW5kZXhBdHRyaWJ1dGU6IFwicGFyYWxsZWxNaW5JbmRleFwiLFxuICBlZGdlTWF4SW5kZXhBdHRyaWJ1dGU6IFwicGFyYWxsZWxNYXhJbmRleFwiXG59O1xuZnVuY3Rpb24gaW5kZXhQYXJhbGxlbEVkZ2VzSW5kZXgoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdHMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9JTkRFWF9QQVJBTExFTF9FREdFU19PUFRJT05TKSwgb3B0aW9ucyB8fCB7fSk7XG4gIHZhciBub2RlSURzTWFwcGluZyA9IHt9O1xuICB2YXIgZWRnZURpcmVjdGVkSURzTWFwcGluZyA9IHt9O1xuICB2YXIgZWRnZVVuZGlyZWN0ZWRJRHNNYXBwaW5nID0ge307XG5cbiAgLy8gTm9ybWFsaXplIElEczpcbiAgdmFyIGluY3IgPSAwO1xuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgIG5vZGVJRHNNYXBwaW5nW25vZGVdID0gKytpbmNyICsgXCJcIjtcbiAgfSk7XG4gIGdyYXBoLmZvckVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlLCBfYXR0cnMsIHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgdmFyIHNvdXJjZUlkID0gbm9kZUlEc01hcHBpbmdbc291cmNlXTtcbiAgICB2YXIgdGFyZ2V0SWQgPSBub2RlSURzTWFwcGluZ1t0YXJnZXRdO1xuICAgIHZhciBkaXJlY3RlZElkID0gW3NvdXJjZUlkLCB0YXJnZXRJZF0uam9pbihcIi1cIik7XG4gICAgZWRnZURpcmVjdGVkSURzTWFwcGluZ1tlZGdlXSA9IGRpcmVjdGVkSWQ7XG4gICAgZWRnZVVuZGlyZWN0ZWRJRHNNYXBwaW5nW2RpcmVjdGVkSWRdID0gW3NvdXJjZUlkLCB0YXJnZXRJZF0uc29ydCgpLmpvaW4oXCItXCIpO1xuICB9KTtcblxuICAvLyBJbmRleCBlZGdlIHVuaXF1ZSBJRHMsIG9ubHkgYmFzZWQgb24gdGhlaXIgZXh0cmVtaXRpZXM6XG4gIHZhciBkaXJlY3RlZEluZGV4ID0ge307XG4gIHZhciB1bmRpcmVjdGVkSW5kZXggPSB7fTtcbiAgZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICB2YXIgZGlyZWN0ZWRJZCA9IGVkZ2VEaXJlY3RlZElEc01hcHBpbmdbZWRnZV07XG4gICAgdmFyIHVuZGlyZWN0ZWRJZCA9IGVkZ2VVbmRpcmVjdGVkSURzTWFwcGluZ1tkaXJlY3RlZElkXTtcbiAgICBkaXJlY3RlZEluZGV4W2RpcmVjdGVkSWRdID0gZGlyZWN0ZWRJbmRleFtkaXJlY3RlZElkXSB8fCBbXTtcbiAgICBkaXJlY3RlZEluZGV4W2RpcmVjdGVkSWRdLnB1c2goZWRnZSk7XG4gICAgdW5kaXJlY3RlZEluZGV4W3VuZGlyZWN0ZWRJZF0gPSB1bmRpcmVjdGVkSW5kZXhbdW5kaXJlY3RlZElkXSB8fCBbXTtcbiAgICB1bmRpcmVjdGVkSW5kZXhbdW5kaXJlY3RlZElkXS5wdXNoKGVkZ2UpO1xuICB9KTtcblxuICAvLyBTdG9yZSBpbmRleCBhdHRyaWJ1dGVzOlxuICBmb3IgKHZhciBkaXJlY3RlZElkIGluIGRpcmVjdGVkSW5kZXgpIHtcbiAgICB2YXIgZWRnZXMgPSBkaXJlY3RlZEluZGV4W2RpcmVjdGVkSWRdO1xuICAgIHZhciBkaXJlY3RlZENvdW50ID0gZWRnZXMubGVuZ3RoO1xuICAgIHZhciB1bmRpcmVjdGVkQ291bnQgPSB1bmRpcmVjdGVkSW5kZXhbZWRnZVVuZGlyZWN0ZWRJRHNNYXBwaW5nW2RpcmVjdGVkSWRdXS5sZW5ndGg7XG5cbiAgICAvLyBJZiB0aGUgZWRnZSBpcyBhbG9uZSwgaW4gYm90aCBzaWRlOlxuICAgIGlmIChkaXJlY3RlZENvdW50ID09PSAxICYmIHVuZGlyZWN0ZWRDb3VudCA9PT0gMSkge1xuICAgICAgdmFyIGVkZ2UgPSBlZGdlc1swXTtcbiAgICAgIGdyYXBoLnNldEVkZ2VBdHRyaWJ1dGUoZWRnZSwgb3B0cy5lZGdlSW5kZXhBdHRyaWJ1dGUsIG51bGwpO1xuICAgICAgZ3JhcGguc2V0RWRnZUF0dHJpYnV0ZShlZGdlLCBvcHRzLmVkZ2VNYXhJbmRleEF0dHJpYnV0ZSwgbnVsbCk7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGVkZ2UgaXMgYWxvbmUsIGJ1dCB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZWRnZSBpbiB0aGUgb3Bwb3NpdGUgZGlyZWN0aW9uOlxuICAgIGVsc2UgaWYgKGRpcmVjdGVkQ291bnQgPT09IDEpIHtcbiAgICAgIHZhciBfZWRnZSA9IGVkZ2VzWzBdO1xuICAgICAgZ3JhcGguc2V0RWRnZUF0dHJpYnV0ZShfZWRnZSwgb3B0cy5lZGdlSW5kZXhBdHRyaWJ1dGUsIDEpO1xuICAgICAgZ3JhcGguc2V0RWRnZUF0dHJpYnV0ZShfZWRnZSwgb3B0cy5lZGdlTWF4SW5kZXhBdHRyaWJ1dGUsIDEpO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSBlZGdlIGlzIG5vdCBhbG9uZSwgYW5kIGFsbCBlZGdlcyBhcmUgaW4gdGhlIHNhbWUgZGlyZWN0aW9uOlxuICAgIGVsc2UgaWYgKGRpcmVjdGVkQ291bnQgPT09IHVuZGlyZWN0ZWRDb3VudCkge1xuICAgICAgdmFyIG1heCA9IChkaXJlY3RlZENvdW50IC0gMSkgLyAyO1xuICAgICAgdmFyIG1pbiA9IC1tYXg7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGVkQ291bnQ7IGkrKykge1xuICAgICAgICB2YXIgX2VkZ2UyID0gZWRnZXNbaV07XG4gICAgICAgIHZhciBlZGdlSW5kZXggPSAtKGRpcmVjdGVkQ291bnQgLSAxKSAvIDIgKyBpO1xuICAgICAgICBncmFwaC5zZXRFZGdlQXR0cmlidXRlKF9lZGdlMiwgb3B0cy5lZGdlSW5kZXhBdHRyaWJ1dGUsIGVkZ2VJbmRleCk7XG4gICAgICAgIGdyYXBoLnNldEVkZ2VBdHRyaWJ1dGUoX2VkZ2UyLCBvcHRzLmVkZ2VNaW5JbmRleEF0dHJpYnV0ZSwgbWluKTtcbiAgICAgICAgZ3JhcGguc2V0RWRnZUF0dHJpYnV0ZShfZWRnZTIsIG9wdHMuZWRnZU1heEluZGV4QXR0cmlidXRlLCBtYXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBlZGdlIGlzIG5vdCBhbG9uZSwgYW5kIHRoZXJlIGFyZSBlZGdlcyBpbiBib3RoIGRpcmVjdGlvbnM6XG4gICAgZWxzZSB7XG4gICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgZGlyZWN0ZWRDb3VudDsgX2krKykge1xuICAgICAgICB2YXIgX2VkZ2UzID0gZWRnZXNbX2ldO1xuICAgICAgICBncmFwaC5zZXRFZGdlQXR0cmlidXRlKF9lZGdlMywgb3B0cy5lZGdlSW5kZXhBdHRyaWJ1dGUsIF9pICsgMSk7XG4gICAgICAgIGdyYXBoLnNldEVkZ2VBdHRyaWJ1dGUoX2VkZ2UzLCBvcHRzLmVkZ2VNYXhJbmRleEF0dHJpYnV0ZSwgZGlyZWN0ZWRDb3VudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXggPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguVU5TSUdORURfQllURSxcbiAgRkxPQVQgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguRkxPQVQ7XG5mdW5jdGlvbiBjcmVhdGVFZGdlQ3VydmVQcm9ncmFtKGlucHV0T3B0aW9ucykge1xuICB2YXIgb3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0VER0VfQ1VSVkVfUFJPR1JBTV9PUFRJT05TKSwgaW5wdXRPcHRpb25zIHx8IHt9KTtcbiAgdmFyIF9yZWYgPSBvcHRpb25zLFxuICAgIGFycm93SGVhZCA9IF9yZWYuYXJyb3dIZWFkLFxuICAgIGN1cnZhdHVyZUF0dHJpYnV0ZSA9IF9yZWYuY3VydmF0dXJlQXR0cmlidXRlLFxuICAgIGRyYXdMYWJlbCA9IF9yZWYuZHJhd0xhYmVsO1xuICB2YXIgaGFzVGFyZ2V0QXJyb3dIZWFkID0gKGFycm93SGVhZCA9PT0gbnVsbCB8fCBhcnJvd0hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycm93SGVhZC5leHRyZW1pdHkpID09PSBcInRhcmdldFwiIHx8IChhcnJvd0hlYWQgPT09IG51bGwgfHwgYXJyb3dIZWFkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJvd0hlYWQuZXh0cmVtaXR5KSA9PT0gXCJib3RoXCI7XG4gIHZhciBoYXNTb3VyY2VBcnJvd0hlYWQgPSAoYXJyb3dIZWFkID09PSBudWxsIHx8IGFycm93SGVhZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXJyb3dIZWFkLmV4dHJlbWl0eSkgPT09IFwic291cmNlXCIgfHwgKGFycm93SGVhZCA9PT0gbnVsbCB8fCBhcnJvd0hlYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFycm93SGVhZC5leHRyZW1pdHkpID09PSBcImJvdGhcIjtcbiAgdmFyIFVOSUZPUk1TID0gW1widV9tYXRyaXhcIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfZGltZW5zaW9uc1wiLCBcInVfcGl4ZWxSYXRpb1wiLCBcInVfZmVhdGhlclwiLCBcInVfbWluRWRnZVRoaWNrbmVzc1wiXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGFycm93SGVhZCA/IFtcInVfbGVuZ3RoVG9UaGlja25lc3NSYXRpb1wiLCBcInVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvXCJdIDogW10pKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gICAgX2luaGVyaXRzKEVkZ2VDdXJ2ZVByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gICAgZnVuY3Rpb24gRWRnZUN1cnZlUHJvZ3JhbSgpIHtcbiAgICAgIHZhciBfdGhpcztcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQ3VydmVQcm9ncmFtKTtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VDdXJ2ZVByb2dyYW0sIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZHJhd0xhYmVsXCIsIGRyYXdMYWJlbCB8fCBjcmVhdGVEcmF3Q3VydmVkRWRnZUxhYmVsKG9wdGlvbnMpKTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKEVkZ2VDdXJ2ZVByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgVkVSVElDRVM6IDYsXG4gICAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IGdldFZlcnRleFNoYWRlcihvcHRpb25zKSxcbiAgICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBnZXRGcmFnbWVudFNoYWRlcihvcHRpb25zKSxcbiAgICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TLFxuICAgICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfc291cmNlXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfdGFyZ2V0XCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgICB9XS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGhhc1RhcmdldEFycm93SGVhZCA/IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfdGFyZ2V0U2l6ZVwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgICAgfV0gOiBbXSksIF90b0NvbnN1bWFibGVBcnJheShoYXNTb3VyY2VBcnJvd0hlYWQgPyBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX3NvdXJjZVNpemVcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICAgIH1dIDogW10pLCBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX3RoaWNrbmVzc1wiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2N1cnZhdHVyZVwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH1dKSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX2N1cnJlbnRcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gVE9ETzogY291bGQgb3B0aW1pemUgdG8gYm9vbFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9kaXJlY3Rpb25cIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICAgIH0gLy8gVE9ETzogY291bGQgb3B0aW1pemUgdG8gYnl0ZVxuICAgICAgICAgIF0sXG4gICAgICAgICAgQ09OU1RBTlRfREFUQTogW1swLCAxXSwgWzAsIC0xXSwgWzEsIDFdLCBbMCwgLTFdLCBbMSwgMV0sIFsxLCAtMV1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgdmFyIF9kYXRhO1xuICAgICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcbiAgICAgICAgdmFyIGN1cnZhdHVyZSA9IChfZGF0YSA9IGRhdGFbY3VydmF0dXJlQXR0cmlidXRlXSkgIT09IG51bGwgJiYgX2RhdGEgIT09IHZvaWQgMCA/IF9kYXRhIDogREVGQVVMVF9FREdFX0NVUlZBVFVSRTtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcblxuICAgICAgICAvLyBGaXJzdCBwb2ludFxuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGlmIChoYXNUYXJnZXRBcnJvd0hlYWQpIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB0YXJnZXREYXRhLnNpemU7XG4gICAgICAgIGlmIChoYXNTb3VyY2VBcnJvd0hlYWQpIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBzb3VyY2VEYXRhLnNpemU7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB0aGlja25lc3M7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjdXJ2YXR1cmU7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYyKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYyLmdsLFxuICAgICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmMi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICAgIHVfcGl4ZWxSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9waXhlbFJhdGlvLFxuICAgICAgICAgIHVfZmVhdGhlciA9IHVuaWZvcm1Mb2NhdGlvbnMudV9mZWF0aGVyLFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X2RpbWVuc2lvbnMgPSB1bmlmb3JtTG9jYXRpb25zLnVfZGltZW5zaW9ucyxcbiAgICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcztcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9waXhlbFJhdGlvLCBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2ZlYXRoZXIsIHBhcmFtcy5hbnRpQWxpYXNpbmdGZWF0aGVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTJmKHVfZGltZW5zaW9ucywgcGFyYW1zLndpZHRoICogcGFyYW1zLnBpeGVsUmF0aW8sIHBhcmFtcy5oZWlnaHQgKiBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X21pbkVkZ2VUaGlja25lc3MsIHBhcmFtcy5taW5FZGdlVGhpY2tuZXNzKTtcbiAgICAgICAgaWYgKGFycm93SGVhZCkge1xuICAgICAgICAgIHZhciB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbyxcbiAgICAgICAgICAgIHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcbiAgICAgICAgICBnbC51bmlmb3JtMWYodV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLCBhcnJvd0hlYWQubGVuZ3RoVG9UaGlja25lc3NSYXRpbyk7XG4gICAgICAgICAgZ2wudW5pZm9ybTFmKHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvLCBhcnJvd0hlYWQud2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRWRnZUN1cnZlUHJvZ3JhbTtcbiAgfShFZGdlUHJvZ3JhbSk7XG59XG5cbnZhciBFZGdlQ3VydmVQcm9ncmFtID0gY3JlYXRlRWRnZUN1cnZlUHJvZ3JhbSgpO1xudmFyIEVkZ2VDdXJ2ZWRBcnJvd1Byb2dyYW0gPSBjcmVhdGVFZGdlQ3VydmVQcm9ncmFtKHtcbiAgYXJyb3dIZWFkOiBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlNcbn0pO1xudmFyIEVkZ2VDdXJ2ZWREb3VibGVBcnJvd1Byb2dyYW0gPSBjcmVhdGVFZGdlQ3VydmVQcm9ncmFtKHtcbiAgYXJyb3dIZWFkOiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TKSwge30sIHtcbiAgICBleHRyZW1pdHk6IFwiYm90aFwiXG4gIH0pXG59KTtcblxuZXhwb3J0IHsgREVGQVVMVF9FREdFX0NVUlZBVFVSRSwgREVGQVVMVF9FREdFX0NVUlZFX1BST0dSQU1fT1BUSU9OUywgREVGQVVMVF9JTkRFWF9QQVJBTExFTF9FREdFU19PUFRJT05TLCBFZGdlQ3VydmVkQXJyb3dQcm9ncmFtLCBFZGdlQ3VydmVkRG91YmxlQXJyb3dQcm9ncmFtLCBjcmVhdGVEcmF3Q3VydmVkRWRnZUxhYmVsLCBjcmVhdGVFZGdlQ3VydmVQcm9ncmFtLCBFZGdlQ3VydmVQcm9ncmFtIGFzIGRlZmF1bHQsIGluZGV4UGFyYWxsZWxFZGdlc0luZGV4IH07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiLyoqXG4gKiBHcmFwaG9sb2d5IEZvcmNlIExheW91dCBEZWZhdWx0c1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRGVmYXVsdCBvcHRpb25zICYgc2V0dGluZ3MgdXNlZCBieSB0aGUgbGlicmFyeS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vZGVYQXR0cmlidXRlOiAneCcsXG4gIG5vZGVZQXR0cmlidXRlOiAneScsXG4gIGlzTm9kZUZpeGVkOiAnZml4ZWQnLFxuICBzaG91bGRTa2lwTm9kZTogbnVsbCxcbiAgc2hvdWxkU2tpcEVkZ2U6IG51bGwsXG4gIHNldHRpbmdzOiB7XG4gICAgYXR0cmFjdGlvbjogMC4wMDA1LFxuICAgIHJlcHVsc2lvbjogMC4xLFxuICAgIGdyYXZpdHk6IDAuMDAwMSxcbiAgICBpbmVydGlhOiAwLjYsXG4gICAgbWF4TW92ZTogMjAwXG4gIH1cbn07XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgRm9yY2UgTGF5b3V0IEhlbHBlcnNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTWlzY2VsbGFuZW91cyBoZWxwZXIgZnVuY3Rpb25zIHJlbGF0ZWQgdG8gdGhlIGZvcmNlIGxheW91dC5cbiAqL1xuZXhwb3J0cy5hc3NpZ25MYXlvdXRDaGFuZ2VzID0gZnVuY3Rpb24gKGdyYXBoLCBub2RlU3RhdGVzLCBwYXJhbXMpIHtcbiAgY29uc3Qge25vZGVYQXR0cmlidXRlOiB4LCBub2RlWUF0dHJpYnV0ZTogeX0gPSBwYXJhbXM7XG5cbiAgZ3JhcGgudXBkYXRlRWFjaE5vZGVBdHRyaWJ1dGVzKFxuICAgIChuLCBhdHRyKSA9PiB7XG4gICAgICBjb25zdCBzdGF0ZSA9IG5vZGVTdGF0ZXNbbl07XG5cbiAgICAgIGlmICghc3RhdGUgfHwgc3RhdGUuZml4ZWQpIHJldHVybiBhdHRyO1xuXG4gICAgICBhdHRyW3hdID0gc3RhdGUueDtcbiAgICAgIGF0dHJbeV0gPSBzdGF0ZS55O1xuXG4gICAgICByZXR1cm4gYXR0cjtcbiAgICB9LFxuICAgIHthdHRyaWJ1dGVzOiBbJ3gnLCAneSddfVxuICApO1xufTtcblxuZXhwb3J0cy5jb2xsZWN0TGF5b3V0Q2hhbmdlcyA9IGZ1bmN0aW9uIChub2RlU3RhdGVzKSB7XG4gIGNvbnN0IG1hcHBpbmcgPSB7fTtcblxuICBmb3IgKGNvbnN0IG4gaW4gbm9kZVN0YXRlcykge1xuICAgIGNvbnN0IHN0YXRlID0gbm9kZVN0YXRlc1tuXTtcblxuICAgIG1hcHBpbmdbbl0gPSB7eDogc3RhdGUueCwgeTogc3RhdGUueX07XG4gIH1cblxuICByZXR1cm4gbWFwcGluZztcbn07XG4iLCIvKipcbiAqIEdyYXBob2xvZ3kgRm9yY2UgTGF5b3V0IEl0ZXJhdGlvblxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIGRlc2NyaWJpbmcgYSBzaW5nbGUgaXRlcmF0aW9uIG9mIHRoZSBmb3JjZSBsYXlvdXQuXG4gKi9cbmNvbnN0IHtcbiAgY3JlYXRlTm9kZVZhbHVlR2V0dGVyLFxuICBjcmVhdGVFZGdlVmFsdWVHZXR0ZXJcbn0gPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2dldHRlcnMnKTtcblxuLy8gY29uc3QgRVBTSUxPTiA9IC1JbmZpbml0eTtcblxuLy8gZnVuY3Rpb24gaXNWZXJ5Q2xvc2VUb1plcm8oeCkge1xuLy8gICByZXR1cm4gTWF0aC5hYnMoeCkgPCBFUFNJTE9OO1xuLy8gfVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGl0ZXJhdGUoZ3JhcGgsIG5vZGVTdGF0ZXMsIHBhcmFtcykge1xuICBjb25zdCB7bm9kZVhBdHRyaWJ1dGU6IHhLZXksIG5vZGVZQXR0cmlidXRlOiB5S2V5fSA9IHBhcmFtcztcbiAgY29uc3Qge2F0dHJhY3Rpb24sIHJlcHVsc2lvbiwgZ3Jhdml0eSwgaW5lcnRpYSwgbWF4TW92ZX0gPSBwYXJhbXMuc2V0dGluZ3M7XG5cbiAgbGV0IHtzaG91bGRTa2lwTm9kZSwgc2hvdWxkU2tpcEVkZ2UsIGlzTm9kZUZpeGVkfSA9IHBhcmFtcztcblxuICBpc05vZGVGaXhlZCA9IGNyZWF0ZU5vZGVWYWx1ZUdldHRlcihpc05vZGVGaXhlZCk7XG4gIHNob3VsZFNraXBOb2RlID0gY3JlYXRlTm9kZVZhbHVlR2V0dGVyKHNob3VsZFNraXBOb2RlLCBmYWxzZSk7XG4gIHNob3VsZFNraXBFZGdlID0gY3JlYXRlRWRnZVZhbHVlR2V0dGVyKHNob3VsZFNraXBFZGdlLCBmYWxzZSk7XG5cbiAgY29uc3Qgbm9kZXMgPSBncmFwaC5maWx0ZXJOb2RlcygobiwgYXR0cikgPT4ge1xuICAgIHJldHVybiAhc2hvdWxkU2tpcE5vZGUuZnJvbUVudHJ5KG4sIGF0dHIpO1xuICB9KTtcblxuICBjb25zdCBhZGp1c3RlZE9yZGVyID0gbm9kZXMubGVuZ3RoO1xuXG4gIC8vIENoZWNrIG5vZGVTdGF0ZXNzIGFuZCBpbmVydGlhXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYWRqdXN0ZWRPcmRlcjsgaSsrKSB7XG4gICAgY29uc3QgbiA9IG5vZGVzW2ldO1xuICAgIGNvbnN0IGF0dHIgPSBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhuKTtcbiAgICBjb25zdCBub2RlU3RhdGUgPSBub2RlU3RhdGVzW25dO1xuXG4gICAgaWYgKCFub2RlU3RhdGUpXG4gICAgICBub2RlU3RhdGVzW25dID0ge1xuICAgICAgICBkeDogMCxcbiAgICAgICAgZHk6IDAsXG4gICAgICAgIHg6IGF0dHJbeEtleV0gfHwgMCxcbiAgICAgICAgeTogYXR0clt5S2V5XSB8fCAwXG4gICAgICB9O1xuICAgIGVsc2VcbiAgICAgIG5vZGVTdGF0ZXNbbl0gPSB7XG4gICAgICAgIGR4OiBub2RlU3RhdGUuZHggKiBpbmVydGlhLFxuICAgICAgICBkeTogbm9kZVN0YXRlLmR5ICogaW5lcnRpYSxcbiAgICAgICAgeDogYXR0clt4S2V5XSB8fCAwLFxuICAgICAgICB5OiBhdHRyW3lLZXldIHx8IDBcbiAgICAgIH07XG4gIH1cblxuICAvLyBSZXB1bHNpb25cbiAgaWYgKHJlcHVsc2lvbilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkanVzdGVkT3JkZXI7IGkrKykge1xuICAgICAgY29uc3QgbjEgPSBub2Rlc1tpXTtcbiAgICAgIGNvbnN0IG4xU3RhdGUgPSBub2RlU3RhdGVzW24xXTtcblxuICAgICAgZm9yIChsZXQgaiA9IGkgKyAxOyBqIDwgYWRqdXN0ZWRPcmRlcjsgaisrKSB7XG4gICAgICAgIGNvbnN0IG4yID0gbm9kZXNbal07XG4gICAgICAgIGNvbnN0IG4yU3RhdGUgPSBub2RlU3RhdGVzW24yXTtcblxuICAgICAgICAvLyBDb21wdXRlIGRpc3RhbmNlOlxuICAgICAgICBjb25zdCBkeCA9IG4yU3RhdGUueCAtIG4xU3RhdGUueDtcbiAgICAgICAgY29uc3QgZHkgPSBuMlN0YXRlLnkgLSBuMVN0YXRlLnk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KSB8fCAxO1xuXG4gICAgICAgIC8vIFJlcHVsc2Ugbm9kZXMgcmVsYXRpdmVseSB0byAxIC8gZGlzdGFuY2U6XG4gICAgICAgIGNvbnN0IHJlcHVsc2lvblggPSAocmVwdWxzaW9uIC8gZGlzdGFuY2UpICogZHg7XG4gICAgICAgIGNvbnN0IHJlcHVsc2lvblkgPSAocmVwdWxzaW9uIC8gZGlzdGFuY2UpICogZHk7XG4gICAgICAgIG4xU3RhdGUuZHggLT0gcmVwdWxzaW9uWDtcbiAgICAgICAgbjFTdGF0ZS5keSAtPSByZXB1bHNpb25ZO1xuICAgICAgICBuMlN0YXRlLmR4ICs9IHJlcHVsc2lvblg7XG4gICAgICAgIG4yU3RhdGUuZHkgKz0gcmVwdWxzaW9uWTtcbiAgICAgIH1cbiAgICB9XG5cbiAgLy8gQXR0cmFjdGlvblxuICBpZiAoYXR0cmFjdGlvbilcbiAgICBncmFwaC5mb3JFYWNoRWRnZShcbiAgICAgIChlZGdlLCBhdHRyLCBzb3VyY2UsIHRhcmdldCwgc291cmNlQXR0ciwgdGFyZ2V0QXR0ciwgdW5kaXJlY3RlZCkgPT4ge1xuICAgICAgICBpZiAoc291cmNlID09PSB0YXJnZXQpIHJldHVybjtcblxuICAgICAgICBpZiAoXG4gICAgICAgICAgc2hvdWxkU2tpcE5vZGUuZnJvbUVudHJ5KHNvdXJjZSwgc291cmNlQXR0cikgfHxcbiAgICAgICAgICBzaG91bGRTa2lwTm9kZS5mcm9tRW50cnkodGFyZ2V0LCB0YXJnZXRBdHRyKVxuICAgICAgICApXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBzaG91bGRTa2lwRWRnZS5mcm9tRW50cnkoXG4gICAgICAgICAgICBlZGdlLFxuICAgICAgICAgICAgYXR0cixcbiAgICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICAgIHRhcmdldCxcbiAgICAgICAgICAgIHNvdXJjZUF0dHIsXG4gICAgICAgICAgICB0YXJnZXRBdHRyLFxuICAgICAgICAgICAgdW5kaXJlY3RlZFxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjb25zdCBuMVN0YXRlID0gbm9kZVN0YXRlc1tzb3VyY2VdO1xuICAgICAgICBjb25zdCBuMlN0YXRlID0gbm9kZVN0YXRlc1t0YXJnZXRdO1xuXG4gICAgICAgIC8vIENvbXB1dGUgZGlzdGFuY2U6XG4gICAgICAgIGNvbnN0IGR4ID0gbjJTdGF0ZS54IC0gbjFTdGF0ZS54O1xuICAgICAgICBjb25zdCBkeSA9IG4yU3RhdGUueSAtIG4xU3RhdGUueTtcblxuICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSkgfHwgMTtcblxuICAgICAgICAvLyBBdHRyYWN0IG5vZGVzIHJlbGF0aXZlbHkgdG8gdGhlaXIgZGlzdGFuY2U6XG4gICAgICAgIGNvbnN0IGF0dHJhY3Rpb25YID0gYXR0cmFjdGlvbiAqIGRpc3RhbmNlICogZHg7XG4gICAgICAgIGNvbnN0IGF0dHJhY3Rpb25ZID0gYXR0cmFjdGlvbiAqIGRpc3RhbmNlICogZHk7XG4gICAgICAgIG4xU3RhdGUuZHggKz0gYXR0cmFjdGlvblg7XG4gICAgICAgIG4xU3RhdGUuZHkgKz0gYXR0cmFjdGlvblk7XG4gICAgICAgIG4yU3RhdGUuZHggLT0gYXR0cmFjdGlvblg7XG4gICAgICAgIG4yU3RhdGUuZHkgLT0gYXR0cmFjdGlvblk7XG4gICAgICB9XG4gICAgKTtcblxuICAvLyBHcmF2aXR5XG4gIGlmIChncmF2aXR5KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRqdXN0ZWRPcmRlcjsgaSsrKSB7XG4gICAgICBjb25zdCBuID0gbm9kZXNbaV07XG4gICAgICBjb25zdCBub2RlU3RhdGUgPSBub2RlU3RhdGVzW25dO1xuXG4gICAgICAvLyBBdHRyYWN0IG5vZGVzIHRvIFswLCAwXSByZWxhdGl2ZWx5IHRvIHRoZSBkaXN0YW5jZTpcbiAgICAgIGNvbnN0IHt4LCB5fSA9IG5vZGVTdGF0ZTtcbiAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpIHx8IDE7XG4gICAgICBub2RlU3RhdGVzW25dLmR4IC09IHggKiBncmF2aXR5ICogZGlzdGFuY2U7XG4gICAgICBub2RlU3RhdGVzW25dLmR5IC09IHkgKiBncmF2aXR5ICogZGlzdGFuY2U7XG4gICAgfVxuXG4gIC8vIEFwcGx5IGZvcmNlc1xuICBjb25zdCBjb252ZXJnZWQgPSBmYWxzZTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFkanVzdGVkT3JkZXI7IGkrKykge1xuICAgIGNvbnN0IG4gPSBub2Rlc1tpXTtcbiAgICBjb25zdCBub2RlU3RhdGUgPSBub2RlU3RhdGVzW25dO1xuXG4gICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLnNxcnQoXG4gICAgICBub2RlU3RhdGUuZHggKiBub2RlU3RhdGUuZHggKyBub2RlU3RhdGUuZHkgKiBub2RlU3RhdGUuZHlcbiAgICApO1xuXG4gICAgaWYgKGRpc3RhbmNlID4gbWF4TW92ZSkge1xuICAgICAgbm9kZVN0YXRlLmR4ICo9IG1heE1vdmUgLyBkaXN0YW5jZTtcbiAgICAgIG5vZGVTdGF0ZS5keSAqPSBtYXhNb3ZlIC8gZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gaWYgKCFpc1ZlcnlDbG9zZVRvWmVybyhub2RlU3RhdGUuZHgpIHx8ICFpc1ZlcnlDbG9zZVRvWmVybyhub2RlU3RhdGUuZHkpKSB7XG4gICAgLy8gICBjb252ZXJnZWQgPSBmYWxzZTtcbiAgICAvLyB9XG5cbiAgICBpZiAoIWlzTm9kZUZpeGVkLmZyb21HcmFwaChncmFwaCwgbikpIHtcbiAgICAgIG5vZGVTdGF0ZS54ICs9IG5vZGVTdGF0ZS5keDtcbiAgICAgIG5vZGVTdGF0ZS55ICs9IG5vZGVTdGF0ZS5keTtcbiAgICAgIG5vZGVTdGF0ZS5maXhlZCA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlU3RhdGUuZml4ZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IHBvc3NpYmlsaXR5IHRvIGFzc2lnbiBoZXJlIHRvIHNhdmUgb25lIGxvb3AgaW4gdGhlIGZ1dHVyZVxuICB9XG5cbiAgcmV0dXJuIHtjb252ZXJnZWR9O1xufTtcbiIsIi8qKlxuICogR3JhcGhvbG9neSBGb3JjZSBMYXlvdXQgV29ya2VyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQSB3b3JrZXIgbWFkZSBmb3IgcnVubmluZyBhIGZvcmNlIGxheW91dCBsaXZlLlxuICpcbiAqIE5vdGUgdGhhdCBpdCBkb2VzIG5vdCBydW4gaW4gYSB3ZWJ3b3JrZXIgeWV0IGJ1dCByZXNwZWN0IGFuaW1hdGlvbiBmcmFtZXMuXG4gKi9cbmNvbnN0IGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG5jb25zdCByZXNvbHZlRGVmYXVsdHMgPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2RlZmF1bHRzJyk7XG5cbmNvbnN0IGl0ZXJhdGUgPSByZXF1aXJlKCcuL2l0ZXJhdGUuanMnKTtcbmNvbnN0IGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcbmNvbnN0IERFRkFVTFRTID0gcmVxdWlyZSgnLi9kZWZhdWx0cy5qcycpO1xuXG5mdW5jdGlvbiBGb3JjZVN1cGVydmlzb3IoZ3JhcGgsIHBhcmFtcykge1xuICAvLyBWYWxpZGF0aW9uXG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlL3dvcmtlcjogdGhlIGdpdmVuIGdyYXBoIGlzIG5vdCBhIHZhbGlkIGdyYXBob2xvZ3kgaW5zdGFuY2UuJ1xuICAgICk7XG5cbiAgcGFyYW1zID0gcmVzb2x2ZURlZmF1bHRzKHBhcmFtcywgREVGQVVMVFMpO1xuXG4gIHRoaXMuY2FsbGJhY2tzID0ge307XG5cbiAgaWYgKHBhcmFtcy5vbkNvbnZlcmdlZCkgdGhpcy5jYWxsYmFja3Mub25Db252ZXJnZWQgPSBwYXJhbXMub25Db252ZXJnZWQ7XG5cbiAgdGhpcy5ncmFwaCA9IGdyYXBoO1xuICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgdGhpcy5ub2RlU3RhdGVzID0ge307XG4gIHRoaXMuZnJhbWVJRCA9IG51bGw7XG4gIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICB0aGlzLmtpbGxlZCA9IGZhbHNlO1xuXG4gIC8vIFRPRE86IGhvb2sgbGlzdGVuZXJzIG9uIGdyYXBoIHRvIGxpc3RlbiB0byBkcm9wTm9kZSwgZHJvcEVkZ2UsIGNsZWFyLCBjbGVhckVkZ2VzXG59XG5cbkZvcmNlU3VwZXJ2aXNvci5wcm90b3R5cGUuaXNSdW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5ydW5uaW5nO1xufTtcblxuRm9yY2VTdXBlcnZpc29yLnByb3RvdHlwZS5ydW5GcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHtjb252ZXJnZWR9ID0gaXRlcmF0ZSh0aGlzLmdyYXBoLCB0aGlzLm5vZGVTdGF0ZXMsIHRoaXMucGFyYW1zKTtcblxuICBoZWxwZXJzLmFzc2lnbkxheW91dENoYW5nZXModGhpcy5ncmFwaCwgdGhpcy5ub2RlU3RhdGVzLCB0aGlzLnBhcmFtcyk7XG5cbiAgLy8gVE9ETzogZmlndXJlIG91dCBjb252ZXJnZW5jZVxuICBjb252ZXJnZWQgPSBmYWxzZTtcblxuICBpZiAoY29udmVyZ2VkKSB7XG4gICAgaWYgKHRoaXMuY2FsbGJhY2tzLm9uQ29udmVyZ2VkKSB0aGlzLmNhbGxiYWNrcy5vbkNvbnZlcmdlZCgpO1xuICAgIHRoaXMuc3RvcCgpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZnJhbWVJRCA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5ydW5GcmFtZSgpKTtcbiAgfVxufTtcblxuRm9yY2VTdXBlcnZpc29yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICBpZiAodGhpcy5mcmFtZUlEICE9PSBudWxsKSB7XG4gICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuZnJhbWVJRCk7XG4gICAgdGhpcy5mcmFtZUlEID0gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRm9yY2VTdXBlcnZpc29yLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMua2lsbGVkKVxuICAgIHRocm93IG5ldyBFcnJvcignZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2Uvd29ya2VyLnN0YXJ0OiBsYXlvdXQgd2FzIGtpbGxlZC4nKTtcblxuICBpZiAodGhpcy5ydW5uaW5nKSByZXR1cm47XG5cbiAgdGhpcy5ydW5uaW5nID0gdHJ1ZTtcbiAgdGhpcy5ydW5GcmFtZSgpO1xufTtcblxuRm9yY2VTdXBlcnZpc29yLnByb3RvdHlwZS5raWxsID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnN0b3AoKTtcbiAgZGVsZXRlIHRoaXMubm9kZVN0YXRlcztcbiAgdGhpcy5raWxsZWQgPSB0cnVlO1xuXG4gIC8vIFRPRE86IGNsZWFudXAgZXZlbnRzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvcmNlU3VwZXJ2aXNvcjtcbiIsIi8qKlxuICogR3JhcGhvbG9neSBEZWZhdWx0c1xuICogPT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0aHJvdWdob3V0IHRoZSBzdGFuZGFyZCBsaWIgdG8gcmVzb2x2ZSBkZWZhdWx0cy5cbiAqL1xuZnVuY3Rpb24gaXNMZWFmKG8pIHtcbiAgcmV0dXJuIChcbiAgICAhbyB8fFxuICAgIHR5cGVvZiBvICE9PSAnb2JqZWN0JyB8fFxuICAgIHR5cGVvZiBvID09PSAnZnVuY3Rpb24nIHx8XG4gICAgQXJyYXkuaXNBcnJheShvKSB8fFxuICAgIG8gaW5zdGFuY2VvZiBTZXQgfHxcbiAgICBvIGluc3RhbmNlb2YgTWFwIHx8XG4gICAgbyBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgIG8gaW5zdGFuY2VvZiBEYXRlXG4gICk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVEZWZhdWx0cyh0YXJnZXQsIGRlZmF1bHRzKSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcblxuICB2YXIgb3V0cHV0ID0ge307XG5cbiAgZm9yICh2YXIgayBpbiBkZWZhdWx0cykge1xuICAgIHZhciBleGlzdGluZyA9IHRhcmdldFtrXTtcbiAgICB2YXIgZGVmID0gZGVmYXVsdHNba107XG5cbiAgICAvLyBSZWN1cnNpb25cbiAgICBpZiAoIWlzTGVhZihkZWYpKSB7XG4gICAgICBvdXRwdXRba10gPSByZXNvbHZlRGVmYXVsdHMoZXhpc3RpbmcsIGRlZik7XG5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIExlYWZcbiAgICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3V0cHV0W2tdID0gZGVmO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRba10gPSBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlc29sdmVEZWZhdWx0cztcbiIsIi8qKlxuICogR3JhcGhvbG9neSBXZWlnaHQgR2V0dGVyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgd2VpZ2h0IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGNvZXJjZVdlaWdodCh2YWx1ZSkge1xuICAvLyBFbnN1cmluZyB0YXJnZXQgdmFsdWUgaXMgYSBjb3JyZWN0IG51bWJlclxuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fCBpc05hTih2YWx1ZSkpIHJldHVybiAxO1xuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZVZhbHVlR2V0dGVyKG5hbWVPckZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGdldHRlciA9IHt9O1xuXG4gIHZhciBjb2VyY2VUb0RlZmF1bHQgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgY29lcmNlVG9EZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoYXR0cmlidXRlc1tuYW1lT3JGdW5jdGlvbl0pO1xuICB9O1xuXG4gIHZhciByZXR1cm5EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQodW5kZWZpbmVkKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGdldDtcbiAgICBnZXR0ZXIuZnJvbUdyYXBoID0gZnVuY3Rpb24gKGdyYXBoLCBub2RlKSB7XG4gICAgICByZXR1cm4gZ2V0KGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAobm9kZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGdldChhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2dyYXBob2xvZ3ktdXRpbHMvZ2V0dGVycy9jcmVhdGVOb2RlVmFsdWVHZXR0ZXI6IGlycmVsZXZhbnQgdXNhZ2UuJ1xuICAgICAgKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSBmdW5jdGlvbiAoZ3JhcGgsIG5vZGUpIHtcbiAgICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoXG4gICAgICAgIG5hbWVPckZ1bmN0aW9uKG5vZGUsIGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpKVxuICAgICAgKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAobm9kZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihub2RlLCBhdHRyaWJ1dGVzKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIuZnJvbUF0dHJpYnV0ZXMgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSByZXR1cm5EZWZhdWx0O1xuICB9XG5cbiAgcmV0dXJuIGdldHRlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRWRnZVZhbHVlR2V0dGVyKG5hbWVPckZ1bmN0aW9uLCBkZWZhdWx0VmFsdWUpIHtcbiAgdmFyIGdldHRlciA9IHt9O1xuXG4gIHZhciBjb2VyY2VUb0RlZmF1bHQgPSBmdW5jdGlvbiAodikge1xuICAgIGlmICh0eXBlb2YgdiA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBkZWZhdWx0VmFsdWU7XG5cbiAgICByZXR1cm4gdjtcbiAgfTtcblxuICBpZiAodHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJykgY29lcmNlVG9EZWZhdWx0ID0gZGVmYXVsdFZhbHVlO1xuXG4gIHZhciBnZXQgPSBmdW5jdGlvbiAoYXR0cmlidXRlcykge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQoYXR0cmlidXRlc1tuYW1lT3JGdW5jdGlvbl0pO1xuICB9O1xuXG4gIHZhciByZXR1cm5EZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQodW5kZWZpbmVkKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnc3RyaW5nJykge1xuICAgIGdldHRlci5mcm9tQXR0cmlidXRlcyA9IGdldDtcbiAgICBnZXR0ZXIuZnJvbUdyYXBoID0gZnVuY3Rpb24gKGdyYXBoLCBlZGdlKSB7XG4gICAgICByZXR1cm4gZ2V0KGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGVkZ2UpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSBmdW5jdGlvbiAoZWRnZSwgYXR0cmlidXRlcykge1xuICAgICAgcmV0dXJuIGdldChhdHRyaWJ1dGVzKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tUGFydGlhbEVudHJ5ID0gZ2V0dGVyLmZyb21FbnRyeTtcbiAgICBnZXR0ZXIuZnJvbU1pbmltYWxFbnRyeSA9IGdldHRlci5mcm9tRW50cnk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5hbWVPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZ2V0dGVyLmZyb21BdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZ3JhcGhvbG9neS11dGlscy9nZXR0ZXJzL2NyZWF0ZUVkZ2VWYWx1ZUdldHRlcjogaXJyZWxldmFudCB1c2FnZS4nXG4gICAgICApO1xuICAgIH07XG4gICAgZ2V0dGVyLmZyb21HcmFwaCA9IGZ1bmN0aW9uIChncmFwaCwgZWRnZSkge1xuICAgICAgLy8gVE9ETzogd2UgY2FuIGRvIGJldHRlciwgY2hlY2sgIzMxMFxuICAgICAgdmFyIGV4dHJlbWl0aWVzID0gZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSk7XG4gICAgICByZXR1cm4gY29lcmNlVG9EZWZhdWx0KFxuICAgICAgICBuYW1lT3JGdW5jdGlvbihcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIGdyYXBoLmdldEVkZ2VBdHRyaWJ1dGVzKGVkZ2UpLFxuICAgICAgICAgIGV4dHJlbWl0aWVzWzBdLFxuICAgICAgICAgIGV4dHJlbWl0aWVzWzFdLFxuICAgICAgICAgIGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKGV4dHJlbWl0aWVzWzBdKSxcbiAgICAgICAgICBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhleHRyZW1pdGllc1sxXSksXG4gICAgICAgICAgZ3JhcGguaXNVbmRpcmVjdGVkKGVkZ2UpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfTtcbiAgICBnZXR0ZXIuZnJvbUVudHJ5ID0gZnVuY3Rpb24gKGUsIGEsIHMsIHQsIHNhLCB0YSwgdSkge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihlLCBhLCBzLCB0LCBzYSwgdGEsIHUpKTtcbiAgICB9O1xuICAgIGdldHRlci5mcm9tUGFydGlhbEVudHJ5ID0gZnVuY3Rpb24gKGUsIGEsIHMsIHQpIHtcbiAgICAgIHJldHVybiBjb2VyY2VUb0RlZmF1bHQobmFtZU9yRnVuY3Rpb24oZSwgYSwgcywgdCkpO1xuICAgIH07XG4gICAgZ2V0dGVyLmZyb21NaW5pbWFsRW50cnkgPSBmdW5jdGlvbiAoZSwgYSkge1xuICAgICAgcmV0dXJuIGNvZXJjZVRvRGVmYXVsdChuYW1lT3JGdW5jdGlvbihlLCBhKSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBnZXR0ZXIuZnJvbUF0dHJpYnV0ZXMgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tR3JhcGggPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tRW50cnkgPSByZXR1cm5EZWZhdWx0O1xuICAgIGdldHRlci5mcm9tTWluaW1hbEVudHJ5ID0gcmV0dXJuRGVmYXVsdDtcbiAgfVxuXG4gIHJldHVybiBnZXR0ZXI7XG59XG5cbmV4cG9ydHMuY3JlYXRlTm9kZVZhbHVlR2V0dGVyID0gY3JlYXRlTm9kZVZhbHVlR2V0dGVyO1xuZXhwb3J0cy5jcmVhdGVFZGdlVmFsdWVHZXR0ZXIgPSBjcmVhdGVFZGdlVmFsdWVHZXR0ZXI7XG5leHBvcnRzLmNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gY3JlYXRlRWRnZVZhbHVlR2V0dGVyKG5hbWUsIGNvZXJjZVdlaWdodCk7XG59O1xuIiwiLyoqXG4gKiBHcmFwaG9sb2d5IGlzR3JhcGhcbiAqID09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBWZXJ5IHNpbXBsZSBmdW5jdGlvbiBhaW1pbmcgYXQgZW5zdXJpbmcgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGFcbiAqIGdyYXBob2xvZ3kgaW5zdGFuY2UuXG4gKi9cblxuLyoqXG4gKiBDaGVja2luZyB0aGUgdmFsdWUgaXMgYSBncmFwaG9sb2d5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSAge2FueX0gICAgIHZhbHVlIC0gVGFyZ2V0IHZhbHVlLlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0dyYXBoKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgdmFsdWUgIT09IG51bGwgJiZcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIHZhbHVlLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5kcm9wTm9kZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiB2YWx1ZS5tdWx0aSA9PT0gJ2Jvb2xlYW4nXG4gICk7XG59O1xuIiwiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBHcmFwaG9sb2d5IFV0aWxpdGllc1xuICogPT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29sbGVjdGlvbiBvZiBoZWxwZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIE9iamVjdC5hc3NpZ24tbGlrZSBwb2x5ZmlsbC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldCAgICAgICAtIEZpcnN0IG9iamVjdC5cbiAqIEBwYXJhbSAge29iamVjdH0gWy4uLm9iamVjdHNdIC0gT2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduUG9seWZpbGwoKSB7XG4gIGNvbnN0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblxuICBmb3IgKGxldCBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoIWFyZ3VtZW50c1tpXSkgY29udGludWU7XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gYXJndW1lbnRzW2ldKSB0YXJnZXRba10gPSBhcmd1bWVudHNbaV1ba107XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5sZXQgYXNzaWduID0gYXNzaWduUG9seWZpbGw7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGZpcnN0IG1hdGNoaW5nIGVkZ2UgZm9yIGdpdmVuIHBhdGguXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoZSBleGlzdGVuY2Ugb2Ygc291cmNlICYgdGFyZ2V0LiBUaGlzXG4gKiBtdXN0IGJlIHBlcmZvcm1lZCBieSB0aGUgY2FsbGVyLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgICAtIFR5cGUgb2YgdGhlIGVkZ2UgKG1peGVkLCBkaXJlY3RlZCBvciB1bmRpcmVjdGVkKS5cbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBnZXRNYXRjaGluZ0VkZ2UoZ3JhcGgsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKSB7XG4gIGNvbnN0IHNvdXJjZURhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgbGV0IGVkZ2UgPSBudWxsO1xuXG4gIGlmICghc291cmNlRGF0YSkgcmV0dXJuIGVkZ2U7XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcpIHtcbiAgICBlZGdlID1cbiAgICAgIChzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdKSB8fFxuICAgICAgKHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RpcmVjdGVkJykge1xuICAgIGVkZ2UgPSBzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF07XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7bWl4ZWR9ICAgdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIC8vIE5PVEU6IGFzIHBlciBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhvbG9neS9ncmFwaG9sb2d5L2lzc3Vlcy8xNDlcbiAgLy8gdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBsb29zZW5lZCBub3QgdG8gcmVqZWN0IG9iamVjdCBpbnN0YW5jZXNcbiAgLy8gY29taW5nIGZyb20gb3RoZXIgSmF2YVNjcmlwdCBjb250ZXh0cy4gSXQgaGFzIGFsc28gYmVlbiBjaG9zZW5cbiAgLy8gbm90IHRvIGltcHJvdmUgaXQgdG8gYXZvaWQgb2J2aW91cyBmYWxzZSBwb3NpdGl2ZXMgYW5kIGF2b2lkXG4gIC8vIHRha2luZyBhIHBlcmZvcm1hbmNlIGhpdC4gUGVvcGxlIHNob3VsZCByZWFsbHkgdXNlIFR5cGVTY3JpcHRcbiAgLy8gaWYgdGhleSB3YW50IHRvIGF2b2lkIGZlZWRpbmcgc3VidGx5IGlycmVsdmFudCBhdHRyaWJ1dGUgb2JqZWN0cy5cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBvIC0gVGFyZ2V0IE9iamVjdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkobykge1xuICBsZXQgaztcblxuICBmb3IgKGsgaW4gbykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBcInByaXZhdGVcIiBwcm9wZXJ0eSBmb3IgdGhlIGdpdmVuIG1lbWJlciBuYW1lIGJ5IGNvbmNlYWxpbmcgaXRcbiAqIHVzaW5nIHRoZSBgZW51bWVyYWJsZWAgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAtIE1lbWJlciBuYW1lLlxuICovXG5mdW5jdGlvbiBwcml2YXRlUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZC1vbmx5IHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gbWVtYmVyIG5hbWUgJiB0aGUgZ2l2ZW4gZ2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIHRhcmdldCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lICAgLSBNZW1iZXIgbmFtZS5cbiAqIEBwYXJhbSB7bWl4ZWR9ICAgIHZhbHVlICAtIFRoZSBhdHRhY2hlZCBnZXR0ZXIgb3IgZml4ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJlYWRPbmx5UHJvcGVydHkodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlc2NyaXB0b3IuZ2V0ID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnN0aXR1dGUgdmFsaWQgaGludHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGhpbnRzIC0gVGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIaW50cyhoaW50cykge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoaGludHMpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGhpbnRzLmF0dHJpYnV0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGludHMuYXR0cmlidXRlcykpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gZ2VuZXJhdGluZyBpbmNyZW1lbnRhbCBpZHMgZm9yIGVkZ2VzLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBpbmNyZW1lbnRhbElkU3RhcnRpbmdGcm9tUmFuZG9tQnl0ZSgpIHtcbiAgbGV0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpICYgMHhmZjtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59XG5cbi8qKlxuICogQ2hhaW5zIG11bHRpcGxlIGl0ZXJhdG9ycyBpbnRvIGEgc2luZ2xlIGl0ZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7Li4uSXRlcmF0b3J9IGl0ZXJhYmxlc1xuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjaGFpbigpIHtcbiAgY29uc3QgaXRlcmFibGVzID0gYXJndW1lbnRzO1xuICBsZXQgY3VycmVudCA9IG51bGw7XG4gIGxldCBpID0gLTE7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGxldCBzdGVwID0gbnVsbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBpZiAoaSA+PSBpdGVyYWJsZXMubGVuZ3RoKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYWJsZXNbaV1bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBjdXJyZW50Lm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUl0ZXJhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBDdXN0b20gRXJyb3JzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRGVmaW5pbmcgY3VzdG9tIGVycm9ycyBmb3IgZWFzZSBvZiB1c2UgJiBlYXN5IHVuaXQgdGVzdHMgYWNyb3NzXG4gKiBpbXBsZW1lbnRhdGlvbnMgKG5vcm1hbGl6ZWQgdHlwb2xvZ3kgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBlcnJvclxuICogbWVzc2FnZXMgdG8gY2hlY2sgd2hldGhlciB0aGUgY29ycmVjdCBlcnJvciB3YXMgZm91bmQpLlxuICovXG5jbGFzcyBHcmFwaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnR3JhcGhFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvciBleHRlbmRzIEdyYXBoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yJztcblxuICAgIC8vIFRoaXMgaXMgVjggc3BlY2lmaWMgdG8gZW5oYW5jZSBzdGFjayByZWFkYWJpbGl0eVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG4gICAgICApO1xuICB9XG59XG5cbmNsYXNzIE5vdEZvdW5kR3JhcGhFcnJvciBleHRlbmRzIEdyYXBoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ05vdEZvdW5kR3JhcGhFcnJvcic7XG5cbiAgICAvLyBUaGlzIGlzIFY4IHNwZWNpZmljIHRvIGVuaGFuY2Ugc3RhY2sgcmVhZGFiaWxpdHlcbiAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90Rm91bmRHcmFwaEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuY2xhc3MgVXNhZ2VHcmFwaEVycm9yIGV4dGVuZHMgR3JhcGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnVXNhZ2VHcmFwaEVycm9yJztcblxuICAgIC8vIFRoaXMgaXMgVjggc3BlY2lmaWMgdG8gZW5oYW5jZSBzdGFjayByZWFkYWJpbGl0eVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBVc2FnZUdyYXBoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgSW50ZXJuYWwgRGF0YSBDbGFzc2VzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBJbnRlcm5hbCBjbGFzc2VzIGhvcGVmdWxseSByZWR1Y2VkIHRvIHN0cnVjdHMgYnkgZW5naW5lcyAmIHN0b3JpbmdcbiAqIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBmb3Igbm9kZXMgJiBlZGdlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhvc2UgY2xhc3NlcyBkb24ndCByZWx5IG9uIHRoZSBgY2xhc3NgIGtleXdvcmQgdG8gYXZvaWQgc29tZVxuICogY3J1ZnQgaW50cm9kdWNlZCBieSBtb3N0IG9mIEVTMjAxNSB0cmFuc3BpbGVycy5cbiAqL1xuXG4vKipcbiAqIE1peGVkTm9kZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOb2RlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gTWl4ZWROb2RlRGF0YShrZXksIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICB0aGlzLmNsZWFyKCk7XG59XG5cbk1peGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMuaW5EZWdyZWUgPSAwO1xuICB0aGlzLm91dERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZExvb3BzID0gMDtcbiAgdGhpcy5kaXJlY3RlZExvb3BzID0gMDtcblxuICAvLyBJbmRpY2VzXG4gIHRoaXMuaW4gPSB7fTtcbiAgdGhpcy5vdXQgPSB7fTtcbiAgdGhpcy51bmRpcmVjdGVkID0ge307XG59O1xuXG4vKipcbiAqIERpcmVjdGVkTm9kZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOb2RlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gRGlyZWN0ZWROb2RlRGF0YShrZXksIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICB0aGlzLmNsZWFyKCk7XG59XG5cbkRpcmVjdGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMuaW5EZWdyZWUgPSAwO1xuICB0aGlzLm91dERlZ3JlZSA9IDA7XG4gIHRoaXMuZGlyZWN0ZWRMb29wcyA9IDA7XG5cbiAgLy8gSW5kaWNlc1xuICB0aGlzLmluID0ge307XG4gIHRoaXMub3V0ID0ge307XG59O1xuXG4vKipcbiAqIFVuZGlyZWN0ZWROb2RlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE5vZGUncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBVbmRpcmVjdGVkTm9kZURhdGEoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgdGhpcy5jbGVhcigpO1xufVxuXG5VbmRpcmVjdGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMudW5kaXJlY3RlZERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZExvb3BzID0gMDtcblxuICAvLyBJbmRpY2VzXG4gIHRoaXMudW5kaXJlY3RlZCA9IHt9O1xufTtcblxuLyoqXG4gKiBFZGdlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5kaXJlY3RlZCAgIC0gV2hldGhlciB0aGUgZWRnZSBpcyB1bmRpcmVjdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9ICBzdHJpbmcgICAgICAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgc291cmNlICAgICAgIC0gU291cmNlIG9mIHRoZSBlZGdlLlxuICogQHBhcmFtIHtzdHJpbmd9ICB0YXJnZXQgICAgICAgLSBUYXJnZXQgb2YgdGhlIGVkZ2UuXG4gKiBAcGFyYW0ge29iamVjdH0gIGF0dHJpYnV0ZXMgICAtIEVkZ2UncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBFZGdlRGF0YSh1bmRpcmVjdGVkLCBrZXksIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIHRoaXMudW5kaXJlY3RlZCA9IHVuZGlyZWN0ZWQ7XG5cbiAgLy8gRXh0cmVtaXRpZXNcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5FZGdlRGF0YS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3V0S2V5ID0gJ291dCc7XG4gIGxldCBpbktleSA9ICdpbic7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCkgb3V0S2V5ID0gaW5LZXkgPSAndW5kaXJlY3RlZCc7XG5cbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgLy8gSGFuZGxpbmcgc291cmNlXG4gIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCAmJiBzb3VyY2UgPT09IHRhcmdldCkgcmV0dXJuO1xuXG4gIC8vIEhhbmRsaW5nIHRhcmdldFxuICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXM7XG59O1xuXG5FZGdlRGF0YS5wcm90b3R5cGUuYXR0YWNoTXVsdGkgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5rZXk7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LmtleTtcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICAvLyBIYW5kbGluZyBzb3VyY2VcbiAgY29uc3QgYWRqID0gdGhpcy5zb3VyY2Vbb3V0S2V5XTtcbiAgY29uc3QgaGVhZCA9IGFkalt0YXJnZXRdO1xuXG4gIGlmICh0eXBlb2YgaGVhZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhZGpbdGFyZ2V0XSA9IHRoaXM7XG5cbiAgICAvLyBTZWxmLWxvb3Agb3B0aW1pemF0aW9uXG4gICAgaWYgKCEodGhpcy51bmRpcmVjdGVkICYmIHNvdXJjZSA9PT0gdGFyZ2V0KSkge1xuICAgICAgLy8gSGFuZGxpbmcgdGFyZ2V0XG4gICAgICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUHJlcGVuZGluZyB0byBkb3VibHktbGlua2VkIGxpc3RcbiAgaGVhZC5wcmV2aW91cyA9IHRoaXM7XG4gIHRoaXMubmV4dCA9IGhlYWQ7XG5cbiAgLy8gUG9pbnRpbmcgdG8gbmV3IGhlYWRcbiAgLy8gTk9URTogdXNlIG11dGF0aW5nIHN3YXAgbGF0ZXIgdG8gYXZvaWQgbG9va3VwP1xuICBhZGpbdGFyZ2V0XSA9IHRoaXM7XG4gIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcztcbn07XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLmtleTtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQua2V5O1xuXG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICBkZWxldGUgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdO1xuXG4gIC8vIE5vLW9wIGRlbGV0ZSBpbiBjYXNlIG9mIHVuZGlyZWN0ZWQgc2VsZi1sb29wXG4gIGRlbGV0ZSB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXTtcbn07XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5kZXRhY2hNdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgbGV0IG91dEtleSA9ICdvdXQnO1xuICBsZXQgaW5LZXkgPSAnaW4nO1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQpIG91dEtleSA9IGluS2V5ID0gJ3VuZGlyZWN0ZWQnO1xuXG4gIC8vIERlbGV0aW5nIGZyb20gZG91Ymx5LWxpbmtlZCBsaXN0XG4gIGlmICh0aGlzLnByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIHRoZSBoZWFkXG5cbiAgICAvLyBTaG91bGQgd2UgZGVsZXRlIHRoZSBhZGphY2VuY3kgZW50cnkgYmVjYXVzZSBpdCBpcyBub3cgZW1wdHk/XG4gICAgaWYgKHRoaXMubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdO1xuXG4gICAgICAvLyBOby1vcCBkZWxldGUgaW4gY2FzZSBvZiB1bmRpcmVjdGVkIHNlbGYtbG9vcFxuICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZXRhY2hpbmdcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gTk9URTogY291bGQgYXZvaWQgdGhlIGxvb2t1cHMgYnkgY3JlYXRpbmcgYSAjLmJlY29tZSBtdXRhdGluZyBtZXRob2RcbiAgICAgIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XSA9IHRoaXMubmV4dDtcblxuICAgICAgLy8gTm8tb3AgZGVsZXRlIGluIGNhc2Ugb2YgdW5kaXJlY3RlZCBzZWxmLWxvb3BcbiAgICAgIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcy5uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIGFub3RoZXIgbGlzdCBub2RlXG4gICAgdGhpcy5wcmV2aW91cy5uZXh0ID0gdGhpcy5uZXh0O1xuXG4gICAgLy8gSWYgbm90IGxhc3RcbiAgICBpZiAodGhpcy5uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgTm9kZSBBdHRyaWJ1dGVzIG1ldGhvZHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuY29uc3QgTk9ERSA9IDA7XG5jb25zdCBTT1VSQ0UgPSAxO1xuY29uc3QgVEFSR0VUID0gMjtcbmNvbnN0IE9QUE9TSVRFID0gMztcblxuZnVuY3Rpb24gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gIGdyYXBoLFxuICBtZXRob2QsXG4gIG1vZGUsXG4gIG5vZGVPckVkZ2UsXG4gIG5hbWVPckVkZ2UsXG4gIGFkZDEsXG4gIGFkZDJcbikge1xuICBsZXQgbm9kZURhdGEsIGVkZ2VEYXRhLCBhcmcxLCBhcmcyO1xuXG4gIG5vZGVPckVkZ2UgPSAnJyArIG5vZGVPckVkZ2U7XG5cbiAgaWYgKG1vZGUgPT09IE5PREUpIHtcbiAgICBub2RlRGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQobm9kZU9yRWRnZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlT3JFZGdlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBhcmcxID0gbmFtZU9yRWRnZTtcbiAgICBhcmcyID0gYWRkMTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBPUFBPU0lURSkge1xuICAgIG5hbWVPckVkZ2UgPSAnJyArIG5hbWVPckVkZ2U7XG5cbiAgICBlZGdlRGF0YSA9IGdyYXBoLl9lZGdlcy5nZXQobmFtZU9yRWRnZSk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtuYW1lT3JFZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2UgPSBlZGdlRGF0YS5zb3VyY2Uua2V5O1xuICAgIGNvbnN0IHRhcmdldCA9IGVkZ2VEYXRhLnRhcmdldC5rZXk7XG5cbiAgICBpZiAobm9kZU9yRWRnZSA9PT0gc291cmNlKSB7XG4gICAgICBub2RlRGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5vZGVPckVkZ2UgPT09IHRhcmdldCkge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHRoZSBcIiR7bm9kZU9yRWRnZX1cIiBub2RlIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgXCIke25hbWVPckVkZ2V9XCIgZWRnZSAoJHtzb3VyY2V9LCAke3RhcmdldH0pLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXJnMSA9IGFkZDE7XG4gICAgYXJnMiA9IGFkZDI7XG4gIH0gZWxzZSB7XG4gICAgZWRnZURhdGEgPSBncmFwaC5fZWRnZXMuZ2V0KG5vZGVPckVkZ2UpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZU9yRWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKG1vZGUgPT09IFNPVVJDRSkge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVEYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGFyZzEgPSBuYW1lT3JFZGdlO1xuICAgIGFyZzIgPSBhZGQxO1xuICB9XG5cbiAgcmV0dXJuIFtub2RlRGF0YSwgYXJnMSwgYXJnMl07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVHZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc0dldHRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UpIHtcbiAgICBjb25zdCBbZGF0YV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2VcbiAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZUNoZWNrZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlU2V0dGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSwgYWRkMikge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lLCB2YWx1ZV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxLFxuICAgICAgYWRkMlxuICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZVVwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxLCBhZGQyKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWUsIHVwZGF0ZXJdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMSxcbiAgICAgIGFkZDJcbiAgICApO1xuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiB1cGRhdGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZGF0YS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlcihhdHRyaWJ1dGVzW25hbWVdKTtcblxuICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZVJlbW92ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICBkZWxldGUgZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc1JlcGxhY2VyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBhdHRyaWJ1dGVzXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzTWVyZ2VyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBhdHRyaWJ1dGVzXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGFzc2lnbihkYXRhLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgdXBkYXRlcl0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogTGlzdCBvZiBtZXRob2RzIHRvIGF0dGFjaC5cbiAqL1xuY29uc3QgTk9ERV9BVFRSSUJVVEVTX01FVEhPRFMgPSBbXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZUdldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgZ2V0JHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc0dldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgaGFzJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVDaGVja2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBzZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZVNldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVVcGRhdGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGByZW1vdmUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZVJlbW92ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlcGxhY2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVzUmVwbGFjZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYG1lcmdlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc01lcmdlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZXJcbiAgfVxuXTtcblxuLyoqXG4gKiBBdHRhY2ggZXZlcnkgYXR0cmlidXRlcy1yZWxhdGVkIG1ldGhvZHMgdG8gYSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIFRhcmdldCBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKSB7XG4gIE5PREVfQVRUUklCVVRFU19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKHtuYW1lLCBhdHRhY2hlcn0pIHtcbiAgICAvLyBGb3Igbm9kZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnTm9kZScpLCBOT0RFKTtcblxuICAgIC8vIEZvciBzb3VyY2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ1NvdXJjZScpLCBTT1VSQ0UpO1xuXG4gICAgLy8gRm9yIHRhcmdldHNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnVGFyZ2V0JyksIFRBUkdFVCk7XG5cbiAgICAvLyBGb3Igb3Bwb3NpdGVzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ09wcG9zaXRlJyksIE9QUE9TSVRFKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBFZGdlIEF0dHJpYnV0ZXMgbWV0aG9kc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgZ2V0dGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZUdldHRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHttaXhlZH0gICAgICAgICAgLSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGVzIGdldHRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzR2V0dGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhcmdldCBlbGVtZW50J3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIC0gVGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGFyZ3VtZW50c1sxXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBjaGVja2VyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZUNoZWNrZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGlzIHNldCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBzZXR0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlU2V0dGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFNldCB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtICB7bWl4ZWR9ICB2YWx1ZSAgIC0gTmV3IGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSAge21peGVkfSAgdmFsdWUgICAtIE5ldyBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRhdGEuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgdXBkYXRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVVcGRhdGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpIHVzaW5nXG4gICAqIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB1cGRhdGVyKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuICAgICAgdXBkYXRlciA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzW25hbWVdID0gdXBkYXRlcihkYXRhLmF0dHJpYnV0ZXNbbmFtZV0pO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgcmVtb3ZlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVSZW1vdmVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRlbGV0ZSBkYXRhLmF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSByZXBsYWNlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzUmVwbGFjZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogUmVwbGFjZSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAgICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOZXcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgYXR0cmlidXRlcyAtIE5ldyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGF0dHJpYnV0ZXM7XG5cbiAgICAgIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIG1lcmdlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWVyZ2VyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50ICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgdG8gbWVyZ2UuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlICAgICAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIG1lcmdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGF0dHJpYnV0ZXM7XG5cbiAgICAgIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgYXNzaWduKGRhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHVwZGF0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgdXBkYXRlcikge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudCxcbiAgICAgICAgdGFyZ2V0ID0gJycgKyB1cGRhdGVyO1xuXG4gICAgICB1cGRhdGVyID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIG1ldGhvZHMgdG8gYXR0YWNoLlxuICovXG5jb25zdCBFREdFX0FUVFJJQlVURVNfTUVUSE9EUyA9IFtcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGdldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBoYXMke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZUNoZWNrZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHNldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlU2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZVVwZGF0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlbW92ZSR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlUmVtb3ZlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgcmVwbGFjZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZXNSZXBsYWNlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgbWVyZ2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWVyZ2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlclxuICB9XG5dO1xuXG4vKipcbiAqIEF0dGFjaCBldmVyeSBhdHRyaWJ1dGVzLXJlbGF0ZWQgbWV0aG9kcyB0byBhIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gVGFyZ2V0IGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpIHtcbiAgRURHRV9BVFRSSUJVVEVTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAoe25hbWUsIGF0dGFjaGVyfSkge1xuICAgIC8vIEZvciBlZGdlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdFZGdlJyksICdtaXhlZCcpO1xuXG4gICAgLy8gRm9yIGRpcmVjdGVkIGVkZ2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ0RpcmVjdGVkRWRnZScpLCAnZGlyZWN0ZWQnKTtcblxuICAgIC8vIEZvciB1bmRpcmVjdGVkIGVkZ2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ1VuZGlyZWN0ZWRFZGdlJyksICd1bmRpcmVjdGVkJyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgRWRnZSBJdGVyYXRpb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQXR0YWNoaW5nIHNvbWUgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MgdG8gYmUgYWJsZSB0byBpdGVyYXRlIG92ZXIgYVxuICogZ3JhcGgncyBlZGdlcy5cbiAqL1xuXG4vKipcbiAqIERlZmluaXRpb25zLlxuICovXG5jb25zdCBFREdFU19JVEVSQVRJT04gPSBbXG4gIHtcbiAgICBuYW1lOiAnZWRnZXMnLFxuICAgIHR5cGU6ICdtaXhlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbkVkZ2VzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dEVkZ2VzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbmJvdW5kRWRnZXMnLFxuICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0Ym91bmRFZGdlcycsXG4gICAgdHlwZTogJ21peGVkJyxcbiAgICBkaXJlY3Rpb246ICdvdXQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnZGlyZWN0ZWRFZGdlcycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ3VuZGlyZWN0ZWRFZGdlcycsXG4gICAgdHlwZTogJ3VuZGlyZWN0ZWQnXG4gIH1cbl07XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgZWRnZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IHRvIG1hdGNoIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iamVjdCAgIC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFNpbXBsZShicmVha2FibGUsIG9iamVjdCwgY2FsbGJhY2ssIGF2b2lkKSB7XG4gIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgayBpbiBvYmplY3QpIHtcbiAgICBpZiAoayA9PT0gYXZvaWQpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaE11bHRpKGJyZWFrYWJsZSwgb2JqZWN0LCBjYWxsYmFjaywgYXZvaWQpIHtcbiAgbGV0IGVkZ2VEYXRhLCBzb3VyY2UsIHRhcmdldDtcblxuICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGsgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGsgPT09IGF2b2lkKSBjb250aW51ZTtcblxuICAgIGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gICAgZG8ge1xuICAgICAgc291cmNlID0gZWRnZURhdGEuc291cmNlO1xuICAgICAgdGFyZ2V0ID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNvdXJjZS5rZXksXG4gICAgICAgIHRhcmdldC5rZXksXG4gICAgICAgIHNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICB0YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhLmtleTtcblxuICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgIH0gd2hpbGUgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGVkZ2VzIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgb2JqZWN0IC0gVGFyZ2V0IG9iamVjdC5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihvYmplY3QsIGF2b2lkKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBjb25zdCBsID0ga2V5cy5sZW5ndGg7XG5cbiAgbGV0IGVkZ2VEYXRhO1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCFlZGdlRGF0YSkge1xuICAgICAgICAgIGlmIChpID49IGwpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG5cbiAgICAgICAgICBjb25zdCBrID0ga2V5c1tpKytdO1xuXG4gICAgICAgICAgaWYgKGsgPT09IGF2b2lkKSB7XG4gICAgICAgICAgICBlZGdlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoIWVkZ2VEYXRhKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZWRnZTogZWRnZURhdGEua2V5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgc291cmNlOiBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICAgIHRhcmdldDogZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkOiBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBlZ2RlcyBmcm9tIHRoZSBvYmplY3QgYXQgZ2l2ZW4ga2V5IHRvIG1hdGNoXG4gKiBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gICBvYmplY3QgICAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge21peGVkfSAgICBrICAgICAgICAtIE5laWdoYm9yIGtleS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRm9yS2V5U2ltcGxlKGJyZWFrYWJsZSwgb2JqZWN0LCBrLCBjYWxsYmFjaykge1xuICBjb25zdCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICBpZiAoIWVkZ2VEYXRhKSByZXR1cm47XG5cbiAgY29uc3Qgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgY29uc3QgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICBpZiAoXG4gICAgY2FsbGJhY2soXG4gICAgICBlZGdlRGF0YS5rZXksXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICB0YXJnZXREYXRhLmtleSxcbiAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIHRhcmdldERhdGEuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApICYmXG4gICAgYnJlYWthYmxlXG4gIClcbiAgICByZXR1cm4gZWRnZURhdGEua2V5O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoRm9yS2V5TXVsdGkoYnJlYWthYmxlLCBvYmplY3QsIGssIGNhbGxiYWNrKSB7XG4gIGxldCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICBpZiAoIWVkZ2VEYXRhKSByZXR1cm47XG5cbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICBlZGdlRGF0YS5rZXksXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGEua2V5O1xuXG4gICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICB9IHdoaWxlIChlZGdlRGF0YSAhPT0gdW5kZWZpbmVkKTtcblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVnZGVzIGZyb20gdGhlIG9iamVjdCBhdCBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgIG9iamVjdCAgIC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSAge21peGVkfSAgICBrICAgICAgICAtIE5laWdoYm9yIGtleS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvckZvcktleShvYmplY3QsIGspIHtcbiAgbGV0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gIGlmIChlZGdlRGF0YS5uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmICghZWRnZURhdGEpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgICAgZWRnZTogZWRnZURhdGEua2V5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgc291cmNlOiBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICAgIHRhcmdldDogZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkOiBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGlmIChkb25lID09PSB0cnVlKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBlZGdlOiBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgYXR0cmlidXRlczogZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICBzb3VyY2U6IGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHVuZGlyZWN0ZWQ6IGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgLSBBcnJheSBvZiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycmF5KGdyYXBoLCB0eXBlKSB7XG4gIGlmIChncmFwaC5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcgfHwgdHlwZSA9PT0gZ3JhcGgudHlwZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdyYXBoLl9lZGdlcy5rZXlzKCkpO1xuICB9XG5cbiAgY29uc3Qgc2l6ZSA9XG4gICAgdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnID8gZ3JhcGgudW5kaXJlY3RlZFNpemUgOiBncmFwaC5kaXJlY3RlZFNpemU7XG5cbiAgY29uc3QgbGlzdCA9IG5ldyBBcnJheShzaXplKSxcbiAgICBtYXNrID0gdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIGxldCBpID0gMDtcbiAgbGV0IHN0ZXAsIGRhdGE7XG5cbiAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICBkYXRhID0gc3RlcC52YWx1ZTtcblxuICAgIGlmIChkYXRhLnVuZGlyZWN0ZWQgPT09IG1hc2spIGxpc3RbaSsrXSA9IGRhdGEua2V5O1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYSBncmFwaCdzIGVkZ2VzIHVzaW5nIGEgY2FsbGJhY2sgdG8gbWF0Y2ggb25lIG9mXG4gKiB0aGVtLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRWRnZShicmVha2FibGUsIGdyYXBoLCB0eXBlLCBjYWxsYmFjaykge1xuICBpZiAoZ3JhcGguc2l6ZSA9PT0gMCkgcmV0dXJuO1xuXG4gIGNvbnN0IHNob3VsZEZpbHRlciA9IHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gZ3JhcGgudHlwZTtcbiAgY29uc3QgbWFzayA9IHR5cGUgPT09ICd1bmRpcmVjdGVkJztcblxuICBsZXQgc3RlcCwgZGF0YTtcbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgZGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICBpZiAoc2hvdWxkRmlsdGVyICYmIGRhdGEudW5kaXJlY3RlZCAhPT0gbWFzaykgY29udGludWU7XG5cbiAgICBjb25zdCB7a2V5LCBhdHRyaWJ1dGVzLCBzb3VyY2UsIHRhcmdldH0gPSBkYXRhO1xuXG4gICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgIGtleSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBzb3VyY2Uua2V5LFxuICAgICAgdGFyZ2V0LmtleSxcbiAgICAgIHNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgdGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICBkYXRhLnVuZGlyZWN0ZWRcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBpdGVyYXRvciBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlSXRlcmF0b3IoZ3JhcGgsIHR5cGUpIHtcbiAgaWYgKGdyYXBoLnNpemUgPT09IDApIHJldHVybiBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgY29uc3Qgc2hvdWxkRmlsdGVyID0gdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSBncmFwaC50eXBlO1xuICBjb25zdCBtYXNrID0gdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBsZXQgc3RlcCwgZGF0YTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoc3RlcC5kb25lKSByZXR1cm4gc3RlcDtcblxuICAgICAgICBkYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAoc2hvdWxkRmlsdGVyICYmIGRhdGEudW5kaXJlY3RlZCAhPT0gbWFzaykgY29udGludWU7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICBlZGdlOiBkYXRhLmtleSxcbiAgICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBzb3VyY2U6IGRhdGEuc291cmNlLmtleSxcbiAgICAgICAgdGFyZ2V0OiBkYXRhLnRhcmdldC5rZXksXG4gICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGRhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGRhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgIHVuZGlyZWN0ZWQ6IGRhdGEudW5kaXJlY3RlZFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHt2YWx1ZSwgZG9uZTogZmFsc2V9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlcyB1c2luZyBhIGNhbGxiYWNrIHRvIG1hdGNoIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBtdWx0aSAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aSBvciBub3QuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrICAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFZGdlRm9yTm9kZShcbiAgYnJlYWthYmxlLFxuICBtdWx0aSxcbiAgdHlwZSxcbiAgZGlyZWN0aW9uLFxuICBub2RlRGF0YSxcbiAgY2FsbGJhY2tcbikge1xuICBjb25zdCBmbiA9IG11bHRpID8gZm9yRWFjaE11bHRpIDogZm9yRWFjaFNpbXBsZTtcblxuICBsZXQgZm91bmQ7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdvdXQnKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgbm9kZURhdGEuaW4sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nKSB7XG4gICAgICBmb3VuZCA9IGZuKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG5vZGVEYXRhLm91dCxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICFkaXJlY3Rpb24gPyBub2RlRGF0YS5rZXkgOiB1bmRlZmluZWRcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBub2RlRGF0YS51bmRpcmVjdGVkLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiB0eXBlICYgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gbXVsdGkgICAgIC0gV2hldGhlciB0aGUgZ3JhcGggaXMgbXVsdGkgb3Igbm90LlxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gIGRpcmVjdGlvbiAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge2FueX0gICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAtIEFycmF5IG9mIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyYXlGb3JOb2RlKG11bHRpLCB0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIGNvbnN0IGVkZ2VzID0gW107IC8vIFRPRE86IHBvc3NpYmlsaXR5IHRvIGtub3cgc2l6ZSBiZWZvcmVoYW5kIG9yIGZhY3Rvcml6ZSB3aXRoIG1hcFxuXG4gIGZvckVhY2hFZGdlRm9yTm9kZShmYWxzZSwgbXVsdGksIHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBlZGdlcy5wdXNoKGtleSk7XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlcyB1c2luZyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yTm9kZSh0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIGxldCBpdGVyYXRvciA9IGVtcHR5SXRlcmF0b3IoKTtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ291dCcgJiYgdHlwZW9mIG5vZGVEYXRhLmluICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oaXRlcmF0b3IsIGNyZWF0ZUl0ZXJhdG9yKG5vZGVEYXRhLmluKSk7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJyAmJiB0eXBlb2Ygbm9kZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVJdGVyYXRvcihub2RlRGF0YS5vdXQsICFkaXJlY3Rpb24gPyBub2RlRGF0YS5rZXkgOiB1bmRlZmluZWQpXG4gICAgICApO1xuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcgJiYgdHlwZW9mIG5vZGVEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3Iobm9kZURhdGEudW5kaXJlY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gcGF0aCB1c2luZyBhIGNhbGxiYWNrIHRvIG1hdGNoXG4gKiBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgbXVsdGkgICAgICAtIFdoZXRoZXIgdGhlIGdyYXBoIGlzIG11bHRpLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAgLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHtOb2RlRGF0YX0gc291cmNlRGF0YSAtIFNvdXJjZSBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0YXJnZXQgICAgIC0gVGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgYnJlYWthYmxlLFxuICB0eXBlLFxuICBtdWx0aSxcbiAgZGlyZWN0aW9uLFxuICBzb3VyY2VEYXRhLFxuICB0YXJnZXQsXG4gIGNhbGxiYWNrXG4pIHtcbiAgY29uc3QgZm4gPSBtdWx0aSA/IGZvckVhY2hGb3JLZXlNdWx0aSA6IGZvckVhY2hGb3JLZXlTaW1wbGU7XG5cbiAgbGV0IGZvdW5kO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEuaW4gIT09ICd1bmRlZmluZWQnICYmIGRpcmVjdGlvbiAhPT0gJ291dCcpIHtcbiAgICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBzb3VyY2VEYXRhLmluLCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRpcmVjdGlvbiAhPT0gJ2luJyAmJlxuICAgICAgKGRpcmVjdGlvbiB8fCBzb3VyY2VEYXRhLmtleSAhPT0gdGFyZ2V0KVxuICAgICkge1xuICAgICAgZm91bmQgPSBmbihicmVha2FibGUsIHNvdXJjZURhdGEub3V0LCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgc291cmNlRGF0YS51bmRpcmVjdGVkLCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gIG11bHRpICAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7Tm9kZURhdGF9IHNvdXJjZURhdGEgLSBTb3VyY2Ugbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgICAtIFRhcmdldCBub2RlLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgLSBBcnJheSBvZiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycmF5Rm9yUGF0aCh0eXBlLCBtdWx0aSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXQpIHtcbiAgY29uc3QgZWRnZXMgPSBbXTsgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8ga25vdyBzaXplIGJlZm9yZWhhbmQgb3IgZmFjdG9yaXplIHdpdGggbWFwXG5cbiAgZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICAgIGZhbHNlLFxuICAgIHR5cGUsXG4gICAgbXVsdGksXG4gICAgZGlyZWN0aW9uLFxuICAgIHNvdXJjZURhdGEsXG4gICAgdGFyZ2V0LFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGVkZ2VzLnB1c2goa2V5KTtcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uICAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge05vZGVEYXRhfSBzb3VyY2VEYXRhIC0gU291cmNlIG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHRhcmdldCAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yUGF0aCh0eXBlLCBkaXJlY3Rpb24sIHNvdXJjZURhdGEsIHRhcmdldCkge1xuICBsZXQgaXRlcmF0b3IgPSBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLmluICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGlyZWN0aW9uICE9PSAnb3V0JyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEuaW5cbiAgICApXG4gICAgICBpdGVyYXRvciA9IGNoYWluKGl0ZXJhdG9yLCBjcmVhdGVJdGVyYXRvckZvcktleShzb3VyY2VEYXRhLmluLCB0YXJnZXQpKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRpcmVjdGlvbiAhPT0gJ2luJyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEub3V0ICYmXG4gICAgICAoZGlyZWN0aW9uIHx8IHNvdXJjZURhdGEua2V5ICE9PSB0YXJnZXQpXG4gICAgKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3JGb3JLZXkoc291cmNlRGF0YS5vdXQsIHRhcmdldCkpO1xuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc291cmNlRGF0YS51bmRpcmVjdGVkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEudW5kaXJlY3RlZFxuICAgIClcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVJdGVyYXRvckZvcktleShzb3VyY2VEYXRhLnVuZGlyZWN0ZWQsIHRhcmdldClcbiAgICAgICk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGFuIGVkZ2UgYXJyYXkgY3JlYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXJyYXlDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY2VydGFpbiBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMDogUmV0dXJuIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqXG4gICAqIEFyaXR5IDE6IFJldHVybiBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlICAgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQXJpdHkgMjogUmV0dXJuIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheXxudW1iZXJ9IC0gVGhlIGVkZ2VzIG9yIHRoZSBudW1iZXIgb2YgZWRnZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNyZWF0ZUVkZ2VBcnJheSh0aGlzLCB0eXBlKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlQXJyYXlGb3JOb2RlKFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBub2RlRGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gY3JlYXRlRWRnZUFycmF5Rm9yUGF0aChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzb3VyY2VEYXRhLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDAsIDEgb3IgMiBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIGVkZ2UgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRm9yRWFjaEVkZ2UoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgZm9yRWFjaE5hbWUgPSAnZm9yRWFjaCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgYnkgYXBwbHlpbmcgdGhlIGdpdmVuXG4gICAqIGNhbGxiYWNrLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2ZvckVhY2hOYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpIHJldHVybjtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjYWxsYmFjayA9IHNvdXJjZTtcbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZShmYWxzZSwgdGhpcywgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xuXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIC8vIFRPRE86IG1heWJlIGF0dGFjaCB0aGUgc3ViIG1ldGhvZCB0byB0aGUgaW5zdGFuY2UgZHluYW1pY2FsbHk/XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JOb2RlKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc291cmNlRGF0YSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDEsIDIgb3IgMyBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBtYXBwaW5nIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlblxuICAgKiBjYWxsYmFjay5cbiAgICpcbiAgICogQXJpdHkgMTogTWFwIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogTWFwIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogTWFwIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IG1hcE5hbWUgPSAnbWFwJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW21hcE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICAvLyBXZSBrbm93IHRoZSByZXN1bHQgbGVuZ3RoIGJlZm9yZWhhbmRcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykgbGVuZ3RoICs9IHRoaXMudW5kaXJlY3RlZFNpemU7XG4gICAgICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSBsZW5ndGggKz0gdGhpcy5kaXJlY3RlZFNpemU7XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICBsZXQgaSA9IDA7XG5cbiAgICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgICByZXN1bHRbaSsrXSA9IGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgcmVzdWx0IGxlbmd0aCBiZWZvcmVoYW5kXG4gICAgLy8gVE9ETzogd2UgY2FuIGluIHNvbWUgaW5zdGFuY2VzIG9mIHNpbXBsZSBncmFwaHMsIGtub3dpbmcgZGVncmVlXG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gZmlsdGVyaW5nIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEZpbHRlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogRmlsdGVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogRmlsdGVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBmaWx0ZXJOYW1lID0gJ2ZpbHRlcicgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtmaWx0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpKSByZXN1bHQucHVzaChlKTtcbiAgICB9KTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmVkdWNpbmcgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgdXNpbmcgdGhlIHByb3ZpZGVkIGFjY3VtdWxhdG9yXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBSZWR1Y2UgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEFyaXR5IDI6IFJlZHVjZSBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEFyaXR5IDM6IFJlZHVjZSB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgICAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgcmVkdWNlTmFtZSA9ICdyZWR1Y2UnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbcmVkdWNlTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMiB8fCBhcmdzLmxlbmd0aCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7cmVkdWNlTmFtZX06IGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZXhwZWN0aW5nIDIsIDMgb3IgNCBhbmQgZ290ICR7YXJncy5sZW5ndGh9KS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7cmVkdWNlTmFtZX06IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjYWxsYmFjaztcbiAgICBsZXQgaW5pdGlhbFZhbHVlO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgICBpbml0aWFsVmFsdWUgPSBhcmdzWzFdO1xuICAgICAgYXJncyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZ3NbMl07XG4gICAgICBhcmdzID0gW2FyZ3NbMF1dO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJnc1syXTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZ3NbM107XG4gICAgICBhcmdzID0gW2FyZ3NbMF0sIGFyZ3NbMV1dO1xuICAgIH1cblxuICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgfSk7XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBicmVha2FibGUgZWRnZSBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoXG4gKiBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRmluZEVkZ2UoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgZmluZEVkZ2VOYW1lID0gJ2ZpbmQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIG1hdGNoXG4gICAqIG9uZSBvZiB0aGVtIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZmluZEVkZ2VOYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2FsbGJhY2sgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2UodHJ1ZSwgdGhpcywgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xuXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzXG4gICAgICAvLyBUT0RPOiBtYXliZSBhdHRhY2ggdGhlIHN1YiBtZXRob2QgdG8gdGhlIGluc3RhbmNlIGR5bmFtaWNhbGx5P1xuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yTm9kZShcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICAgICAgICB0cnVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNvdXJjZURhdGEsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7ZmluZEVkZ2VOYW1lfTogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMSwgMiBvciAzIGFuZCBnb3QgJHthcmd1bWVudHMubGVuZ3RofSkuYFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIGFzc2VydFxuICAgKiB3aGV0aGVyIGFueSBvbmUgb2YgdGhlbSBtYXRjaGVzIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBzb21lTmFtZSA9ICdzb21lJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtzb21lTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZEVkZ2VOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIGFzc2VydFxuICAgKiB3aGV0aGVyIGFsbCBvZiB0aGVtIG1hdGNoZSB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZXZlcnlOYW1lID0gJ2V2ZXJ5JyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtldmVyeU5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgcmV0dXJuICFjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kRWRnZU5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYW4gZWRnZSBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlSXRlcmF0b3JDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZTogb3JpZ2luYWxOYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgbmFtZSA9IG9yaWdpbmFsTmFtZS5zbGljZSgwLCAtMSkgKyAnRW50cmllcyc7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIHRoZSBncmFwaCdzIGVkZ2VzLlxuICAgKlxuICAgKiBBcml0eSAwOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgICAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fG51bWJlcn0gLSBUaGUgZWRnZXMgb3IgdGhlIG51bWJlciBvZiBlZGdlcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIGVtcHR5SXRlcmF0b3IoKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNyZWF0ZUVkZ2VJdGVyYXRvcih0aGlzLCB0eXBlKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlSXRlcmF0b3JGb3JOb2RlKHR5cGUsIGRpcmVjdGlvbiwgc291cmNlRGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGNyZWF0ZUVkZ2VJdGVyYXRvckZvclBhdGgodHlwZSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAwLCAxIG9yIDIgYW5kIGdvdCAke2FyZ3VtZW50cy5sZW5ndGh9KS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgZXZlcnkgZWRnZSBpdGVyYXRpb24gbWV0aG9kIHRvIHRoZSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIEdyYXBoIGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlSXRlcmF0aW9uTWV0aG9kcyhHcmFwaCkge1xuICBFREdFU19JVEVSQVRJT04uZm9yRWFjaChkZXNjcmlwdGlvbiA9PiB7XG4gICAgYXR0YWNoRWRnZUFycmF5Q3JlYXRvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEZvckVhY2hFZGdlKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRmluZEVkZ2UoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hFZGdlSXRlcmF0b3JDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgTmVpZ2hib3IgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBBdHRhY2hpbmcgc29tZSBtZXRob2RzIHRvIHRoZSBHcmFwaCBjbGFzcyB0byBiZSBhYmxlIHRvIGl0ZXJhdGUgb3ZlclxuICogbmVpZ2hib3JzLlxuICovXG5cbi8qKlxuICogRGVmaW5pdGlvbnMuXG4gKi9cbmNvbnN0IE5FSUdIQk9SU19JVEVSQVRJT04gPSBbXG4gIHtcbiAgICBuYW1lOiAnbmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaW5OZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0TmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbmJvdW5kTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dGJvdW5kTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdkaXJlY3RlZE5laWdoYm9ycycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ3VuZGlyZWN0ZWROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICd1bmRpcmVjdGVkJ1xuICB9XG5dO1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0ZVNldFdyYXBwZXIoKSB7XG4gIHRoaXMuQSA9IG51bGw7XG4gIHRoaXMuQiA9IG51bGw7XG59XG5cbkNvbXBvc2l0ZVNldFdyYXBwZXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIGlmICh0aGlzLkEgPT09IG51bGwpIHRoaXMuQSA9IHNldDtcbiAgZWxzZSBpZiAodGhpcy5CID09PSBudWxsKSB0aGlzLkIgPSBzZXQ7XG59O1xuXG5Db21wb3NpdGVTZXRXcmFwcGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICh0aGlzLkEgIT09IG51bGwgJiYga2V5IGluIHRoaXMuQSkgcmV0dXJuIHRydWU7XG4gIGlmICh0aGlzLkIgIT09IG51bGwgJiYga2V5IGluIHRoaXMuQikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdpdmVuIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnMgdG8gbWF0Y2hcbiAqIG9uZSBvZiB0aGVtIHVzaW5nIGEgcHJlZGljYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBuZWlnaGJvcnMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uIC0gRGlyZWN0aW9uLlxuICogQHBhcmFtICB7YW55fSAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgLSBDYWxsYmFjayB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hJbk9iamVjdE9uY2UoYnJlYWthYmxlLCB2aXNpdGVkLCBub2RlRGF0YSwgb2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGsgaW4gb2JqZWN0KSB7XG4gICAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgIGNvbnN0IHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICBjb25zdCBuZWlnaGJvckRhdGEgPSBzb3VyY2VEYXRhID09PSBub2RlRGF0YSA/IHRhcmdldERhdGEgOiBzb3VyY2VEYXRhO1xuXG4gICAgaWYgKHZpc2l0ZWQgJiYgdmlzaXRlZC5oYXMobmVpZ2hib3JEYXRhLmtleSkpIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhuZWlnaGJvckRhdGEua2V5LCBuZWlnaGJvckRhdGEuYXR0cmlidXRlcyk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gbmVpZ2hib3JEYXRhLmtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaE5laWdoYm9yKGJyZWFrYWJsZSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSwgY2FsbGJhY2spIHtcbiAgLy8gSWYgd2Ugd2FudCBvbmx5IHVuZGlyZWN0ZWQgb3IgaW4gb3Igb3V0LCB3ZSBjYW4gcm9sbCBzb21lIG9wdGltaXphdGlvbnNcbiAgaWYgKHR5cGUgIT09ICdtaXhlZCcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgcmV0dXJuIGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhLnVuZGlyZWN0ZWQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuXG4gICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhW2RpcmVjdGlvbl0sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICB9XG5cbiAgLy8gRWxzZSB3ZSBuZWVkIHRvIGtlZXAgYSBzZXQgb2YgbmVpZ2hib3JzIG5vdCB0byByZXR1cm4gZHVwbGljYXRlc1xuICAvLyBXZSBjaGVhdCBieSBxdWVyeWluZyB0aGUgb3RoZXIgYWRqYWNlbmNpZXNcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBDb21wb3NpdGVTZXRXcmFwcGVyKCk7XG5cbiAgbGV0IGZvdW5kO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YS5pbixcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcblxuICAgICAgdmlzaXRlZC53cmFwKG5vZGVEYXRhLmluKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJykge1xuICAgICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIHZpc2l0ZWQsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YS5vdXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG5cbiAgICAgIHZpc2l0ZWQud3JhcChub2RlRGF0YS5vdXQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgYnJlYWthYmxlLFxuICAgICAgdmlzaXRlZCxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbm9kZURhdGEudW5kaXJlY3RlZCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiByZWxldmFudCBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgdHlwZSAgICAgIC0gVHlwZSBvZiBuZWlnaGJvcnMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGRpcmVjdGlvbiAtIERpcmVjdGlvbi5cbiAqIEBwYXJhbSAge2FueX0gICAgICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgLSBUaGUgbGlzdCBvZiBuZWlnaGJvcnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5laWdoYm9yQXJyYXlGb3JOb2RlKHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEpIHtcbiAgLy8gSWYgd2Ugd2FudCBvbmx5IHVuZGlyZWN0ZWQgb3IgaW4gb3Igb3V0LCB3ZSBjYW4gcm9sbCBzb21lIG9wdGltaXphdGlvbnNcbiAgaWYgKHR5cGUgIT09ICdtaXhlZCcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gT2JqZWN0LmtleXMobm9kZURhdGEudW5kaXJlY3RlZCk7XG5cbiAgICBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBPYmplY3Qua2V5cyhub2RlRGF0YVtkaXJlY3Rpb25dKTtcbiAgfVxuXG4gIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuXG4gIGZvckVhY2hOZWlnaGJvcihmYWxzZSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSwgZnVuY3Rpb24gKGtleSkge1xuICAgIG5laWdoYm9ycy5wdXNoKGtleSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdpdmVuIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAtIFR5cGUgb2YgbmVpZ2hib3JzLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIERpcmVjdGlvbi5cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBvYmplY3QpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGNvbnN0IGwgPSBrZXlzLmxlbmd0aDtcblxuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGxldCBuZWlnaGJvckRhdGEgPSBudWxsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpID49IGwpIHtcbiAgICAgICAgICBpZiAodmlzaXRlZCkgdmlzaXRlZC53cmFwKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVkZ2VEYXRhID0gb2JqZWN0W2tleXNbaSsrXV07XG5cbiAgICAgICAgY29uc3Qgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgICBuZWlnaGJvckRhdGEgPSBzb3VyY2VEYXRhID09PSBub2RlRGF0YSA/IHRhcmdldERhdGEgOiBzb3VyY2VEYXRhO1xuXG4gICAgICAgIGlmICh2aXNpdGVkICYmIHZpc2l0ZWQuaGFzKG5laWdoYm9yRGF0YS5rZXkpKSB7XG4gICAgICAgICAgbmVpZ2hib3JEYXRhID0gbnVsbDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobmVpZ2hib3JEYXRhID09PSBudWxsKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7bmVpZ2hib3I6IG5laWdoYm9yRGF0YS5rZXksIGF0dHJpYnV0ZXM6IG5laWdoYm9yRGF0YS5hdHRyaWJ1dGVzfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5laWdoYm9ySXRlcmF0b3IodHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSkge1xuICAvLyBJZiB3ZSB3YW50IG9ubHkgdW5kaXJlY3RlZCBvciBpbiBvciBvdXQsIHdlIGNhbiByb2xsIHNvbWUgb3B0aW1pemF0aW9uc1xuICBpZiAodHlwZSAhPT0gJ21peGVkJykge1xuICAgIGlmICh0eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgICByZXR1cm4gY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKG51bGwsIG5vZGVEYXRhLCBub2RlRGF0YS51bmRpcmVjdGVkKTtcblxuICAgIGlmICh0eXBlb2YgZGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IobnVsbCwgbm9kZURhdGEsIG5vZGVEYXRhW2RpcmVjdGlvbl0pO1xuICB9XG5cbiAgbGV0IGl0ZXJhdG9yID0gZW1wdHlJdGVyYXRvcigpO1xuXG4gIC8vIEVsc2Ugd2UgbmVlZCB0byBrZWVwIGEgc2V0IG9mIG5laWdoYm9ycyBub3QgdG8gcmV0dXJuIGR1cGxpY2F0ZXNcbiAgLy8gV2UgY2hlYXQgYnkgcXVlcnlpbmcgdGhlIG90aGVyIGFkamFjZW5jaWVzXG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgQ29tcG9zaXRlU2V0V3JhcHBlcigpO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcih2aXNpdGVkLCBub2RlRGF0YSwgbm9kZURhdGEuaW4pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nKSB7XG4gICAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBub2RlRGF0YS5vdXQpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgIGl0ZXJhdG9yLFxuICAgICAgY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBub2RlRGF0YS51bmRpcmVjdGVkKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgbmVpZ2hib3JzIGFycmF5IGNyZWF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTmVpZ2hib3JBcnJheUNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheSBvZiBjZXJ0YWluIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgbmVpZ2hib3JzIG9mIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBub2RlIGlzIG5vdCBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgLy8gSGVyZSwgd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgYSBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzXG4gICAgcmV0dXJuIGNyZWF0ZU5laWdoYm9yQXJyYXlGb3JOb2RlKFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgbmVpZ2hib3JzIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEZvckVhY2hOZWlnaGJvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBmb3JFYWNoTmFtZSA9ICdmb3JFYWNoJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtmb3JFYWNoTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpIHJldHVybjtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIGZvckVhY2hOZWlnaGJvcihcbiAgICAgIGZhbHNlLFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gbWFwcGluZyB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IG1hcE5hbWUgPSAnbWFwJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW21hcE5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogb3B0aW1pemUgd2hlbiBzaXplIGlzIGtub3duIGJlZm9yZWhhbmRcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICByZXN1bHQucHVzaChjYWxsYmFjayhuLCBhKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmaWx0ZXJpbmcgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBmaWx0ZXJOYW1lID0gJ2ZpbHRlcicgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtmaWx0ZXJOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0obm9kZSwgKG4sIGEpID0+IHtcbiAgICAgIGlmIChjYWxsYmFjayhuLCBhKSkgcmVzdWx0LnB1c2gobik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZWR1Y2luZyB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IHJlZHVjZU5hbWUgPSAncmVkdWNlJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3JlZHVjZU5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke3JlZHVjZU5hbWV9OiBtaXNzaW5nIGluaXRpYWwgdmFsdWUuIFlvdSBtdXN0IHByb3ZpZGUgaXQgYmVjYXVzZSB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBhbmQgd2UgY2Fubm90IGluZmVyIHRoZSBpbml0aWFsIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYXMgeW91IGNvdWxkIHdpdGggYSBzaW1wbGUgYXJyYXkuYFxuICAgICAgKTtcblxuICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBuLCBhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBicmVha2FibGUgbmVpZ2hib3JzIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGVcbiAqIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hGaW5kTmVpZ2hib3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgY2FwaXRhbGl6ZWRTaW5ndWxhciA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIGNvbnN0IGZpbmROYW1lID0gJ2ZpbmQnICsgY2FwaXRhbGl6ZWRTaW5ndWxhcjtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZmluZE5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKSByZXR1cm47XG5cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke2ZpbmROYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICAvLyBIZXJlLCB3ZSB3YW50IHRvIGl0ZXJhdGUgb3ZlciBhIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnNcbiAgICByZXR1cm4gZm9yRWFjaE5laWdoYm9yKFxuICAgICAgdHJ1ZSxcbiAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHRvIGZpbmQgaWYgYW55IG9mIHRoZW1cbiAgICogbWF0Y2hlcyB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBzb21lTmFtZSA9ICdzb21lJyArIGNhcGl0YWxpemVkU2luZ3VsYXI7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3NvbWVOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kTmFtZV0obm9kZSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdG8gZmluZCBpZiBhbGwgb2YgdGhlbVxuICAgKiBtYXRjaGUgdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZXZlcnlOYW1lID0gJ2V2ZXJ5JyArIGNhcGl0YWxpemVkU2luZ3VsYXI7XG5cbiAgQ2xhc3MucHJvdG90eXBlW2V2ZXJ5TmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKG4sIGEpO1xuICAgIH0pO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBuZWlnaGJvcnMgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTmVpZ2hib3JJdGVyYXRvckNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgaXRlcmF0b3JOYW1lID0gbmFtZS5zbGljZSgwLCAtMSkgKyAnRW50cmllcyc7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtpdGVyYXRvck5hbWVdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gZW1wdHlJdGVyYXRvcigpO1xuXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtpdGVyYXRvck5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIHJldHVybiBjcmVhdGVOZWlnaGJvckl0ZXJhdG9yKFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGV2ZXJ5IG5laWdoYm9yIGl0ZXJhdGlvbiBtZXRob2QgdG8gdGhlIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gR3JhcGggY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE5laWdoYm9ySXRlcmF0aW9uTWV0aG9kcyhHcmFwaCkge1xuICBORUlHSEJPUlNfSVRFUkFUSU9OLmZvckVhY2goZGVzY3JpcHRpb24gPT4ge1xuICAgIGF0dGFjaE5laWdoYm9yQXJyYXlDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRm9yRWFjaE5laWdoYm9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRmluZE5laWdoYm9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoTmVpZ2hib3JJdGVyYXRvckNyZWF0b3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBBZGphY2VuY3kgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQXR0YWNoaW5nIHNvbWUgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MgdG8gYmUgYWJsZSB0byBpdGVyYXRlIG92ZXIgYVxuICogZ3JhcGgncyBhZGphY2VuY3kuXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIHNpbXBsZSBncmFwaCdzIGFkamFjZW5jeSB1c2luZyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gIGJyZWFrYWJsZSAgICAgICAgIC0gQ2FuIHdlIGJyZWFrP1xuICogQHBhcmFtIHtib29sZWFufSAgYXNzeW1ldHJpYyAgICAgICAgLSBXaGV0aGVyIHRvIGVtaXQgdW5kaXJlY3RlZCBlZGdlcyBvbmx5IG9uY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICBkaXNjb25uZWN0ZWROb2RlcyAtIFdoZXRoZXIgdG8gZW1pdCBkaXNjb25uZWN0ZWQgbm9kZXMuXG4gKiBAcGFyYW0ge0dyYXBofSAgICBncmFwaCAgICAgICAgICAgICAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IGZ1bmN0aW9uICAgICAgICAgIC0gSXRlcmF0aW9uIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWRqYWNlbmN5KFxuICBicmVha2FibGUsXG4gIGFzc3ltZXRyaWMsXG4gIGRpc2Nvbm5lY3RlZE5vZGVzLFxuICBncmFwaCxcbiAgY2FsbGJhY2tcbikge1xuICBjb25zdCBpdGVyYXRvciA9IGdyYXBoLl9ub2Rlcy52YWx1ZXMoKTtcblxuICBjb25zdCB0eXBlID0gZ3JhcGgudHlwZTtcblxuICBsZXQgc3RlcCwgc291cmNlRGF0YSwgbmVpZ2hib3IsIGFkaiwgZWRnZURhdGEsIHRhcmdldERhdGEsIHNob3VsZEJyZWFrO1xuXG4gIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgbGV0IGhhc0VkZ2VzID0gZmFsc2U7XG5cbiAgICBzb3VyY2VEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGFkaiA9IHNvdXJjZURhdGEub3V0O1xuXG4gICAgICBmb3IgKG5laWdoYm9yIGluIGFkaikge1xuICAgICAgICBlZGdlRGF0YSA9IGFkaltuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBoYXNFZGdlcyA9IHRydWU7XG4gICAgICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB0YXJnZXREYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGE7XG5cbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgYWRqID0gc291cmNlRGF0YS51bmRpcmVjdGVkO1xuXG4gICAgICBmb3IgKG5laWdoYm9yIGluIGFkaikge1xuICAgICAgICBpZiAoYXNzeW1ldHJpYyAmJiBzb3VyY2VEYXRhLmtleSA+IG5laWdoYm9yKSBjb250aW51ZTtcblxuICAgICAgICBlZGdlRGF0YSA9IGFkaltuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5rZXkgIT09IG5laWdoYm9yKSB0YXJnZXREYXRhID0gZWRnZURhdGEuc291cmNlO1xuXG4gICAgICAgICAgaGFzRWRnZXMgPSB0cnVlO1xuICAgICAgICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgICAgIHRhcmdldERhdGEua2V5LFxuICAgICAgICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhO1xuXG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc2Nvbm5lY3RlZE5vZGVzICYmICFoYXNFZGdlcykge1xuICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgU2VyaWFsaXphdGlvbiBVdGlsaXRpZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdXNlZCBieSB0aGUgZ3JhcGggc2VyaWFsaXphdGlvbiBzY2hlbWVzLlxuICovXG5cbi8qKlxuICogRm9ybWF0cyBpbnRlcm5hbCBub2RlIGRhdGEgaW50byBhIHNlcmlhbGl6ZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHthbnl9ICAgIGtleSAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAtIEludGVybmFsIG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgIC0gVGhlIHNlcmlhbGl6ZWQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShrZXksIGRhdGEpIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHtrZXl9O1xuXG4gIGlmICghaXNFbXB0eShkYXRhLmF0dHJpYnV0ZXMpKVxuICAgIHNlcmlhbGl6ZWQuYXR0cmlidXRlcyA9IGFzc2lnbih7fSwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGludGVybmFsIGVkZ2UgZGF0YSBpbnRvIGEgc2VyaWFsaXplZCBlZGdlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSAtIFRoZSBncmFwaCdzIHR5cGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgIGtleSAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAtIEludGVybmFsIGVkZ2UncyBkYXRhLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgIC0gVGhlIHNlcmlhbGl6ZWQgZWRnZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRWRnZSh0eXBlLCBrZXksIGRhdGEpIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICBrZXksXG4gICAgc291cmNlOiBkYXRhLnNvdXJjZS5rZXksXG4gICAgdGFyZ2V0OiBkYXRhLnRhcmdldC5rZXlcbiAgfTtcblxuICBpZiAoIWlzRW1wdHkoZGF0YS5hdHRyaWJ1dGVzKSlcbiAgICBzZXJpYWxpemVkLmF0dHJpYnV0ZXMgPSBhc3NpZ24oe30sIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcgJiYgZGF0YS51bmRpcmVjdGVkKSBzZXJpYWxpemVkLnVuZGlyZWN0ZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHNlcmlhbGl6ZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTZXJpYWxpemVkTm9kZSh2YWx1ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBub2RlLiBBIHNlcmlhbGl6ZWQgbm9kZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwia2V5XCIgcHJvcGVydHkuJ1xuICAgICk7XG5cbiAgaWYgKCEoJ2tleScgaW4gdmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IHNlcmlhbGl6ZWQgbm9kZSBpcyBtaXNzaW5nIGl0cyBrZXkuJ1xuICAgICk7XG5cbiAgaWYgKFxuICAgICdhdHRyaWJ1dGVzJyBpbiB2YWx1ZSAmJlxuICAgICghaXNQbGFpbk9iamVjdCh2YWx1ZS5hdHRyaWJ1dGVzKSB8fCB2YWx1ZS5hdHRyaWJ1dGVzID09PSBudWxsKVxuICApXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBhdHRyaWJ1dGVzLiBBdHRyaWJ1dGVzIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCwgbnVsbCBvciBvbWl0dGVkLidcbiAgICApO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHNlcmlhbGl6ZWQgZWRnZS5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTZXJpYWxpemVkRWRnZSh2YWx1ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBlZGdlLiBBIHNlcmlhbGl6ZWQgZWRnZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwic291cmNlXCIgJiBcInRhcmdldFwiIHByb3BlcnR5LidcbiAgICApO1xuXG4gIGlmICghKCdzb3VyY2UnIGluIHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIGVkZ2UgaXMgbWlzc2luZyBpdHMgc291cmNlLidcbiAgICApO1xuXG4gIGlmICghKCd0YXJnZXQnIGluIHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIGVkZ2UgaXMgbWlzc2luZyBpdHMgdGFyZ2V0LidcbiAgICApO1xuXG4gIGlmIChcbiAgICAnYXR0cmlidXRlcycgaW4gdmFsdWUgJiZcbiAgICAoIWlzUGxhaW5PYmplY3QodmFsdWUuYXR0cmlidXRlcykgfHwgdmFsdWUuYXR0cmlidXRlcyA9PT0gbnVsbClcbiAgKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gQXR0cmlidXRlcyBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3QsIG51bGwgb3Igb21pdHRlZC4nXG4gICAgKTtcblxuICBpZiAoJ3VuZGlyZWN0ZWQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS51bmRpcmVjdGVkICE9PSAnYm9vbGVhbicpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCB1bmRpcmVjdGVkbmVzcyBpbmZvcm1hdGlvbi4gVW5kaXJlY3RlZCBzaG91bGQgYmUgYm9vbGVhbiBvciBvbWl0dGVkLidcbiAgICApO1xufVxuXG4vKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbmNvbnN0IElOU1RBTkNFX0lEID0gaW5jcmVtZW50YWxJZFN0YXJ0aW5nRnJvbVJhbmRvbUJ5dGUoKTtcblxuLyoqXG4gKiBFbnVtcy5cbiAqL1xuY29uc3QgVFlQRVMgPSBuZXcgU2V0KFsnZGlyZWN0ZWQnLCAndW5kaXJlY3RlZCcsICdtaXhlZCddKTtcblxuY29uc3QgRU1JVFRFUl9QUk9QUyA9IG5ldyBTZXQoW1xuICAnZG9tYWluJyxcbiAgJ19ldmVudHMnLFxuICAnX2V2ZW50c0NvdW50JyxcbiAgJ19tYXhMaXN0ZW5lcnMnXG5dKTtcblxuY29uc3QgRURHRV9BRERfTUVUSE9EUyA9IFtcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1FZGdlYCxcbiAgICBnZW5lcmF0ZUtleTogdHJ1ZVxuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifURpcmVjdGVkRWRnZWAsXG4gICAgZ2VuZXJhdGVLZXk6IHRydWUsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifVVuZGlyZWN0ZWRFZGdlYCxcbiAgICBnZW5lcmF0ZUtleTogdHJ1ZSxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1FZGdlV2l0aEtleWBcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1EaXJlY3RlZEVkZ2VXaXRoS2V5YCxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9VW5kaXJlY3RlZEVkZ2VXaXRoS2V5YCxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfVxuXTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMuXG4gKi9cbmNvbnN0IERFRkFVTFRTID0ge1xuICBhbGxvd1NlbGZMb29wczogdHJ1ZSxcbiAgbXVsdGk6IGZhbHNlLFxuICB0eXBlOiAnbWl4ZWQnXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBHcmFwaCBjbGFzcyBmb3IgdmFyaW91cyBtZXRob2RzLlxuICovXG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gYWRkIGEgbm9kZSB0byB0aGUgZ2l2ZW4gZ3JhcGhcbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAgICAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gIFthdHRyaWJ1dGVzXSAgICAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtOb2RlRGF0YX0gICAgICAgICAgICAgICAgLSBDcmVhdGVkIG5vZGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSwgYXR0cmlidXRlcykge1xuICBpZiAoYXR0cmlidXRlcyAmJiAhaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguYWRkTm9kZTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgKTtcblxuICAvLyBTdHJpbmcgY29lcmNpb25cbiAgbm9kZSA9ICcnICsgbm9kZTtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKGdyYXBoLl9ub2Rlcy5oYXMobm9kZSkpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5hZGROb2RlOiB0aGUgXCIke25vZGV9XCIgbm9kZSBhbHJlYWR5IGV4aXN0IGluIHRoZSBncmFwaC5gXG4gICAgKTtcblxuICBjb25zdCBkYXRhID0gbmV3IGdyYXBoLk5vZGVEYXRhQ2xhc3Mobm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgLy8gQWRkaW5nIHRoZSBub2RlIHRvIGludGVybmFsIHJlZ2lzdGVyXG4gIGdyYXBoLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgLy8gRW1pdHRpbmdcbiAgZ3JhcGguZW1pdCgnbm9kZUFkZGVkJywge1xuICAgIGtleTogbm9kZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNhbWUgYXMgdGhlIGFib3ZlIGJ1dCB3aXRob3V0IHNhbml0eSBjaGVja3MgYmVjYXVzZSB3ZSBjYWxsIHRoaXMgaW4gY29udGV4dHNcbiAqIHdoZXJlIG5lY2Vzc2FyeSBjaGVja3Mgd2VyZSBhbHJlYWR5IGRvbmUuXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZUFkZE5vZGUoZ3JhcGgsIG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgZGF0YSA9IG5ldyBncmFwaC5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gIGdyYXBoLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgZ3JhcGguZW1pdCgnbm9kZUFkZGVkJywge1xuICAgIGtleTogbm9kZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBhcmJpdHJhcnkgZWRnZSB0byB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgZ3JhcGggICAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgICAgIC0gTmFtZSBvZiB0aGUgY2hpbGQgbWV0aG9kIGZvciBlcnJvcnMuXG4gKiBAcGFyYW0gIHtib29sZWFufSBtdXN0R2VuZXJhdGVLZXkgLSBTaG91bGQgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkP1xuICogQHBhcmFtICB7Ym9vbGVhbn0gdW5kaXJlY3RlZCAgICAgIC0gV2hldGhlciB0aGUgZWRnZSBpcyB1bmRpcmVjdGVkLlxuICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAgICAgICAgICAgIC0gVGhlIGVkZ2UncyBrZXkuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgICAgICAgLSBUaGUgc291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgICAgICAgLSBUaGUgdGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbYXR0cmlidXRlc10gICAgLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVkZ2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgb2YgdGhlIHdyb25nIHR5cGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYW4gb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIGFkZEVkZ2UoXG4gIGdyYXBoLFxuICBuYW1lLFxuICBtdXN0R2VuZXJhdGVLZXksXG4gIHVuZGlyZWN0ZWQsXG4gIGVkZ2UsXG4gIHNvdXJjZSxcbiAgdGFyZ2V0LFxuICBhdHRyaWJ1dGVzXG4pIHtcbiAgLy8gQ2hlY2tpbmcgdmFsaWRpdHkgb2Ygb3BlcmF0aW9uXG4gIGlmICghdW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IGFkZCBhIGRpcmVjdGVkIGVkZ2UgdG8gYW4gdW5kaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLmFkZEVkZ2Ugb3IgIy5hZGRVbmRpcmVjdGVkRWRnZSBpbnN0ZWFkLmBcbiAgICApO1xuXG4gIGlmICh1bmRpcmVjdGVkICYmIGdyYXBoLnR5cGUgPT09ICdkaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IGFkZCBhbiB1bmRpcmVjdGVkIGVkZ2UgdG8gYSBkaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLmFkZEVkZ2Ugb3IgIy5hZGREaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAoYXR0cmlidXRlcyAmJiAhaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgKTtcblxuICAvLyBDb2VyY2lvbiBvZiBzb3VyY2UgJiB0YXJnZXQ6XG4gIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICB0YXJnZXQgPSAnJyArIHRhcmdldDtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKCFncmFwaC5hbGxvd1NlbGZMb29wcyAmJiBzb3VyY2UgPT09IHRhcmdldClcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHNvdXJjZSAmIHRhcmdldCBhcmUgdGhlIHNhbWUgKFwiJHtzb3VyY2V9XCIpLCB0aHVzIGNyZWF0aW5nIGEgbG9vcCBleHBsaWNpdGx5IGZvcmJpZGRlbiBieSB0aGlzIGdyYXBoICdhbGxvd1NlbGZMb29wcycgb3B0aW9uIHNldCB0byBmYWxzZS5gXG4gICAgKTtcblxuICBjb25zdCBzb3VyY2VEYXRhID0gZ3JhcGguX25vZGVzLmdldChzb3VyY2UpLFxuICAgIHRhcmdldERhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHRhcmdldCk7XG5cbiAgaWYgKCFzb3VyY2VEYXRhKVxuICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogc291cmNlIG5vZGUgXCIke3NvdXJjZX1cIiBub3QgZm91bmQuYFxuICAgICk7XG5cbiAgaWYgKCF0YXJnZXREYXRhKVxuICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogdGFyZ2V0IG5vZGUgXCIke3RhcmdldH1cIiBub3QgZm91bmQuYFxuICAgICk7XG5cbiAgLy8gTXVzdCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQgZm9yIHRoaXMgZWRnZT9cbiAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgIGtleTogbnVsbCxcbiAgICB1bmRpcmVjdGVkLFxuICAgIHNvdXJjZSxcbiAgICB0YXJnZXQsXG4gICAgYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmIChtdXN0R2VuZXJhdGVLZXkpIHtcbiAgICAvLyBOT1RFOiBpbiB0aGlzIGNhc2Ugd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBrZXkgZG9lcyBub3QgYWxyZWFkeVxuICAgIC8vIGV4aXN0IGFuZCBpcyBhbHJlYWR5IGNvcnJlY3RseSBjYXN0ZWQgYXMgYSBzdHJpbmdcbiAgICBlZGdlID0gZ3JhcGguX2VkZ2VLZXlHZW5lcmF0b3IoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2lvbiBvZiBlZGdlIGtleVxuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICAvLyBIZXJlLCB3ZSBoYXZlIGEga2V5IGNvbGxpc2lvblxuICAgIGlmIChncmFwaC5fZWRnZXMuaGFzKGVkZ2UpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bmFtZX06IHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuICB9XG5cbiAgLy8gSGVyZSwgd2UgbWlnaHQgaGF2ZSBhIHNvdXJjZSAvIHRhcmdldCBjb2xsaXNpb25cbiAgaWYgKFxuICAgICFncmFwaC5tdWx0aSAmJlxuICAgICh1bmRpcmVjdGVkXG4gICAgICA/IHR5cGVvZiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgIDogdHlwZW9mIHNvdXJjZURhdGEub3V0W3RhcmdldF0gIT09ICd1bmRlZmluZWQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IGFuIGVkZ2UgbGlua2luZyBcIiR7c291cmNlfVwiIHRvIFwiJHt0YXJnZXR9XCIgYWxyZWFkeSBleGlzdHMuIElmIHlvdSByZWFsbHkgd2FudCB0byBhZGQgbXVsdGlwbGUgZWRnZXMgbGlua2luZyB0aG9zZSBub2RlcywgeW91IHNob3VsZCBjcmVhdGUgYSBtdWx0aSBncmFwaCBieSB1c2luZyB0aGUgJ211bHRpJyBvcHRpb24uYFxuICAgICk7XG4gIH1cblxuICAvLyBTdG9yaW5nIHNvbWUgZGF0YVxuICBjb25zdCBlZGdlRGF0YSA9IG5ldyBFZGdlRGF0YShcbiAgICB1bmRpcmVjdGVkLFxuICAgIGVkZ2UsXG4gICAgc291cmNlRGF0YSxcbiAgICB0YXJnZXREYXRhLFxuICAgIGF0dHJpYnV0ZXNcbiAgKTtcblxuICAvLyBBZGRpbmcgdGhlIGVkZ2UgdG8gdGhlIGludGVybmFsIHJlZ2lzdGVyXG4gIGdyYXBoLl9lZGdlcy5zZXQoZWRnZSwgZWRnZURhdGEpO1xuXG4gIC8vIEluY3JlbWVudGluZyBub2RlIGRlZ3JlZSBjb3VudGVyc1xuICBjb25zdCBpc1NlbGZMb29wID0gc291cmNlID09PSB0YXJnZXQ7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIHtcbiAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZURhdGEub3V0RGVncmVlKys7XG4gICAgdGFyZ2V0RGF0YS5pbkRlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX2RpcmVjdGVkU2VsZkxvb3BDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHJlbGV2YW50IGluZGV4XG4gIGlmIChncmFwaC5tdWx0aSkgZWRnZURhdGEuYXR0YWNoTXVsdGkoKTtcbiAgZWxzZSBlZGdlRGF0YS5hdHRhY2goKTtcblxuICBpZiAodW5kaXJlY3RlZCkgZ3JhcGguX3VuZGlyZWN0ZWRTaXplKys7XG4gIGVsc2UgZ3JhcGguX2RpcmVjdGVkU2l6ZSsrO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGV2ZW50RGF0YS5rZXkgPSBlZGdlO1xuXG4gIGdyYXBoLmVtaXQoJ2VkZ2VBZGRlZCcsIGV2ZW50RGF0YSk7XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gYWRkIGFuIGFyYml0cmFyeSBlZGdlIHRvIHRoZSBnaXZlbiBncmFwaC5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgICAgICAgICAgLSBOYW1lIG9mIHRoZSBjaGlsZCBtZXRob2QgZm9yIGVycm9ycy5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IG11c3RHZW5lcmF0ZUtleSAtIFNob3VsZCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQ/XG4gKiBAcGFyYW0gIHtib29sZWFufSB1bmRpcmVjdGVkICAgICAgLSBXaGV0aGVyIHRoZSBlZGdlIGlzIHVuZGlyZWN0ZWQuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlICAgICAgICAgICAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAgICAgICAgICAtIFRoZSBzb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgICAgICAtIFRoZSB0YXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge29iamVjdH0gIFthdHRyaWJ1dGVzXSAgICAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0gIHtib29sZWFufSBbYXNVcGRhdGVyXSAgICAgICAtIEFyZSB3ZSB1cGRhdGluZyBvciBtZXJnaW5nP1xuICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVkZ2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgb2YgdGhlIHdyb25nIHR5cGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYW4gb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRWRnZShcbiAgZ3JhcGgsXG4gIG5hbWUsXG4gIG11c3RHZW5lcmF0ZUtleSxcbiAgdW5kaXJlY3RlZCxcbiAgZWRnZSxcbiAgc291cmNlLFxuICB0YXJnZXQsXG4gIGF0dHJpYnV0ZXMsXG4gIGFzVXBkYXRlclxuKSB7XG4gIC8vIENoZWNraW5nIHZhbGlkaXR5IG9mIG9wZXJhdGlvblxuICBpZiAoIXVuZGlyZWN0ZWQgJiYgZ3JhcGgudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBtZXJnZS91cGRhdGUgYSBkaXJlY3RlZCBlZGdlIHRvIGFuIHVuZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5tZXJnZUVkZ2UvIy51cGRhdGVFZGdlIG9yICMuYWRkVW5kaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAodW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAnZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBtZXJnZS91cGRhdGUgYW4gdW5kaXJlY3RlZCBlZGdlIHRvIGEgZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5tZXJnZUVkZ2UvIy51cGRhdGVFZGdlIG9yICMuYWRkRGlyZWN0ZWRFZGdlIGluc3RlYWQuYFxuICAgICk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXNVcGRhdGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCB1cGRhdGVyIGZ1bmN0aW9uLiBFeHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29lcmNpb24gb2Ygc291cmNlICYgdGFyZ2V0OlxuICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgbGV0IHVwZGF0ZXI7XG5cbiAgaWYgKGFzVXBkYXRlcikge1xuICAgIHVwZGF0ZXIgPSBhdHRyaWJ1dGVzO1xuICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWdyYXBoLmFsbG93U2VsZkxvb3BzICYmIHNvdXJjZSA9PT0gdGFyZ2V0KVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogc291cmNlICYgdGFyZ2V0IGFyZSB0aGUgc2FtZSAoXCIke3NvdXJjZX1cIiksIHRodXMgY3JlYXRpbmcgYSBsb29wIGV4cGxpY2l0bHkgZm9yYmlkZGVuIGJ5IHRoaXMgZ3JhcGggJ2FsbG93U2VsZkxvb3BzJyBvcHRpb24gc2V0IHRvIGZhbHNlLmBcbiAgICApO1xuXG4gIGxldCBzb3VyY2VEYXRhID0gZ3JhcGguX25vZGVzLmdldChzb3VyY2UpO1xuICBsZXQgdGFyZ2V0RGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQodGFyZ2V0KTtcbiAgbGV0IGVkZ2VEYXRhO1xuXG4gIC8vIERvIHdlIG5lZWQgdG8gaGFuZGxlIGR1cGxpY2F0ZT9cbiAgbGV0IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhO1xuXG4gIGlmICghbXVzdEdlbmVyYXRlS2V5KSB7XG4gICAgZWRnZURhdGEgPSBncmFwaC5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSB7XG4gICAgICAvLyBIZXJlLCB3ZSBuZWVkIHRvIGVuc3VyZSwgaWYgdGhlIHVzZXIgZ2F2ZSBhIGtleSwgdGhhdCBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIC8vIGFyZSBjb25zaXN0ZW50XG4gICAgICBpZiAoZWRnZURhdGEuc291cmNlLmtleSAhPT0gc291cmNlIHx8IGVkZ2VEYXRhLnRhcmdldC5rZXkgIT09IHRhcmdldCkge1xuICAgICAgICAvLyBJZiBzb3VyY2Ugb3IgdGFyZ2V0IGluY29uc2lzdGVudFxuICAgICAgICBpZiAoXG4gICAgICAgICAgIXVuZGlyZWN0ZWQgfHxcbiAgICAgICAgICBlZGdlRGF0YS5zb3VyY2Uua2V5ICE9PSB0YXJnZXQgfHxcbiAgICAgICAgICBlZGdlRGF0YS50YXJnZXQua2V5ICE9PSBzb3VyY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgZGlyZWN0ZWQsIG9yIHNvdXJjZS90YXJnZXQgYXJlbid0IGZsaXBwZWRcbiAgICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGluY29uc2lzdGVuY3kgZGV0ZWN0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIG1lcmdlIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIHdpdGggXCIke3NvdXJjZX1cIiBzb3VyY2UgJiBcIiR7dGFyZ2V0fVwiIHRhcmdldCB2cy4gKFwiJHtlZGdlRGF0YS5zb3VyY2Uua2V5fVwiLCBcIiR7ZWRnZURhdGEudGFyZ2V0LmtleX1cIikuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEgPSBlZGdlRGF0YTtcbiAgICB9XG4gIH1cblxuICAvLyBIZXJlLCB3ZSBtaWdodCBoYXZlIGEgc291cmNlIC8gdGFyZ2V0IGNvbGxpc2lvblxuICBpZiAoIWFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhICYmICFncmFwaC5tdWx0aSAmJiBzb3VyY2VEYXRhKSB7XG4gICAgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEgPSB1bmRpcmVjdGVkXG4gICAgICA/IHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdXG4gICAgICA6IHNvdXJjZURhdGEub3V0W3RhcmdldF07XG4gIH1cblxuICAvLyBIYW5kbGluZyBkdXBsaWNhdGVzXG4gIGlmIChhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YSkge1xuICAgIGNvbnN0IGluZm8gPSBbYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEua2V5LCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcblxuICAgIC8vIFdlIGNhbiBza2lwIHRoZSBhdHRyaWJ1dGUgbWVyZ2luZyBwYXJ0IGlmIHRoZSB1c2VyIGRpZCBub3QgcHJvdmlkZSB0aGVtXG4gICAgaWYgKGFzVXBkYXRlciA/ICF1cGRhdGVyIDogIWF0dHJpYnV0ZXMpIHJldHVybiBpbmZvO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIGF0dHJpYnV0ZXNcbiAgICBpZiAoYXNVcGRhdGVyKSB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcztcbiAgICAgIGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKG9sZEF0dHJpYnV0ZXMpO1xuXG4gICAgICBncmFwaC5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgICAga2V5OiBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5rZXksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE1lcmdpbmcgdGhlIGF0dHJpYnV0ZXNcbiAgICBlbHNlIHtcbiAgICAgIGFzc2lnbihhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgZ3JhcGguZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgICBrZXk6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmtleSxcbiAgICAgICAgYXR0cmlidXRlczogYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAoYXNVcGRhdGVyICYmIHVwZGF0ZXIpIGF0dHJpYnV0ZXMgPSB1cGRhdGVyKGF0dHJpYnV0ZXMpO1xuXG4gIC8vIE11c3QgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkIGZvciB0aGlzIGVkZ2U/XG4gIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICBrZXk6IG51bGwsXG4gICAgdW5kaXJlY3RlZCxcbiAgICBzb3VyY2UsXG4gICAgdGFyZ2V0LFxuICAgIGF0dHJpYnV0ZXNcbiAgfTtcblxuICBpZiAobXVzdEdlbmVyYXRlS2V5KSB7XG4gICAgLy8gTk9URTogaW4gdGhpcyBjYXNlIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUga2V5IGRvZXMgbm90IGFscmVhZHlcbiAgICAvLyBleGlzdCBhbmQgaXMgYWxyZWFkeSBjb3JyZWN0bHkgY2FzdGVkIGFzIGEgc3RyaW5nXG4gICAgZWRnZSA9IGdyYXBoLl9lZGdlS2V5R2VuZXJhdG9yKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29lcmNpb24gb2YgZWRnZSBrZXlcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgLy8gSGVyZSwgd2UgaGF2ZSBhIGtleSBjb2xsaXNpb25cbiAgICBpZiAoZ3JhcGguX2VkZ2VzLmhhcyhlZGdlKSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke25hbWV9OiB0aGUgXCIke2VkZ2V9XCIgZWRnZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcbiAgfVxuXG4gIGxldCBzb3VyY2VXYXNBZGRlZCA9IGZhbHNlO1xuICBsZXQgdGFyZ2V0V2FzQWRkZWQgPSBmYWxzZTtcblxuICBpZiAoIXNvdXJjZURhdGEpIHtcbiAgICBzb3VyY2VEYXRhID0gdW5zYWZlQWRkTm9kZShncmFwaCwgc291cmNlLCB7fSk7XG4gICAgc291cmNlV2FzQWRkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgICB0YXJnZXREYXRhID0gc291cmNlRGF0YTtcbiAgICAgIHRhcmdldFdhc0FkZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0YXJnZXREYXRhKSB7XG4gICAgdGFyZ2V0RGF0YSA9IHVuc2FmZUFkZE5vZGUoZ3JhcGgsIHRhcmdldCwge30pO1xuICAgIHRhcmdldFdhc0FkZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN0b3Jpbmcgc29tZSBkYXRhXG4gIGVkZ2VEYXRhID0gbmV3IEVkZ2VEYXRhKHVuZGlyZWN0ZWQsIGVkZ2UsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIEFkZGluZyB0aGUgZWRnZSB0byB0aGUgaW50ZXJuYWwgcmVnaXN0ZXJcbiAgZ3JhcGguX2VkZ2VzLnNldChlZGdlLCBlZGdlRGF0YSk7XG5cbiAgLy8gSW5jcmVtZW50aW5nIG5vZGUgZGVncmVlIGNvdW50ZXJzXG4gIGNvbnN0IGlzU2VsZkxvb3AgPSBzb3VyY2UgPT09IHRhcmdldDtcblxuICBpZiAodW5kaXJlY3RlZCkge1xuICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuICAgIHRhcmdldERhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc291cmNlRGF0YS5vdXREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLmluRGVncmVlKys7XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRpbmcgcmVsZXZhbnQgaW5kZXhcbiAgaWYgKGdyYXBoLm11bHRpKSBlZGdlRGF0YS5hdHRhY2hNdWx0aSgpO1xuICBlbHNlIGVkZ2VEYXRhLmF0dGFjaCgpO1xuXG4gIGlmICh1bmRpcmVjdGVkKSBncmFwaC5fdW5kaXJlY3RlZFNpemUrKztcbiAgZWxzZSBncmFwaC5fZGlyZWN0ZWRTaXplKys7XG5cbiAgLy8gRW1pdHRpbmdcbiAgZXZlbnREYXRhLmtleSA9IGVkZ2U7XG5cbiAgZ3JhcGguZW1pdCgnZWRnZUFkZGVkJywgZXZlbnREYXRhKTtcblxuICByZXR1cm4gW2VkZ2UsIHRydWUsIHNvdXJjZVdhc0FkZGVkLCB0YXJnZXRXYXNBZGRlZF07XG59XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gZHJvcCBhbiBlZGdlLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge0VkZ2VEYXRhfSBlZGdlRGF0YSAtIERhdGEgb2YgdGhlIGVkZ2UgdG8gZHJvcC5cbiAqL1xuZnVuY3Rpb24gZHJvcEVkZ2VGcm9tRGF0YShncmFwaCwgZWRnZURhdGEpIHtcbiAgLy8gRHJvcHBpbmcgdGhlIGVkZ2UgZnJvbSB0aGUgcmVnaXN0ZXJcbiAgZ3JhcGguX2VkZ2VzLmRlbGV0ZShlZGdlRGF0YS5rZXkpO1xuXG4gIC8vIFVwZGF0aW5nIHJlbGF0ZWQgZGVncmVlc1xuICBjb25zdCB7c291cmNlOiBzb3VyY2VEYXRhLCB0YXJnZXQ6IHRhcmdldERhdGEsIGF0dHJpYnV0ZXN9ID0gZWRnZURhdGE7XG5cbiAgY29uc3QgdW5kaXJlY3RlZCA9IGVkZ2VEYXRhLnVuZGlyZWN0ZWQ7XG5cbiAgY29uc3QgaXNTZWxmTG9vcCA9IHNvdXJjZURhdGEgPT09IHRhcmdldERhdGE7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIHtcbiAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWREZWdyZWUtLTtcbiAgICB0YXJnZXREYXRhLnVuZGlyZWN0ZWREZWdyZWUtLTtcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRMb29wcy0tO1xuICAgICAgZ3JhcGguX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50LS07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZURhdGEub3V0RGVncmVlLS07XG4gICAgdGFyZ2V0RGF0YS5pbkRlZ3JlZS0tO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEuZGlyZWN0ZWRMb29wcy0tO1xuICAgICAgZ3JhcGguX2RpcmVjdGVkU2VsZkxvb3BDb3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFyaW5nIGluZGV4XG4gIGlmIChncmFwaC5tdWx0aSkgZWRnZURhdGEuZGV0YWNoTXVsdGkoKTtcbiAgZWxzZSBlZGdlRGF0YS5kZXRhY2goKTtcblxuICBpZiAodW5kaXJlY3RlZCkgZ3JhcGguX3VuZGlyZWN0ZWRTaXplLS07XG4gIGVsc2UgZ3JhcGguX2RpcmVjdGVkU2l6ZS0tO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGdyYXBoLmVtaXQoJ2VkZ2VEcm9wcGVkJywge1xuICAgIGtleTogZWRnZURhdGEua2V5LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgc291cmNlOiBzb3VyY2VEYXRhLmtleSxcbiAgICB0YXJnZXQ6IHRhcmdldERhdGEua2V5LFxuICAgIHVuZGlyZWN0ZWRcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGggY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gIFtvcHRpb25zXSAtIE9wdGlvbnM6XG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFthbGxvd1NlbGZMb29wc10gLSBBbGxvdyBzZWxmIGxvb3BzP1xuICogQHBhcmFtICB7c3RyaW5nfSAgICBbdHlwZV0gICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZ3JhcGguXG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFttYXBdICAgICAgICAgICAgLSBBbGxvdyByZWZlcmVuY2VzIGFzIGtleXM/XG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFttdWx0aV0gICAgICAgICAgLSBBbGxvdyBwYXJhbGxlbCBlZGdlcz9cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCB2YWxpZC5cbiAqL1xuY2xhc3MgR3JhcGggZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vLS0gU29sdmluZyBvcHRpb25zXG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgLy8gRW5mb3JjaW5nIG9wdGlvbnMgdmFsaWRpdHlcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubXVsdGkgIT09ICdib29sZWFuJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvbnN0cnVjdG9yOiBpbnZhbGlkICdtdWx0aScgb3B0aW9uLiBFeHBlY3RpbmcgYSBib29sZWFuIGJ1dCBnb3QgXCIke29wdGlvbnMubXVsdGl9XCIuYFxuICAgICAgKTtcblxuICAgIGlmICghVFlQRVMuaGFzKG9wdGlvbnMudHlwZSkpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAndHlwZScgb3B0aW9uLiBTaG91bGQgYmUgb25lIG9mIFwibWl4ZWRcIiwgXCJkaXJlY3RlZFwiIG9yIFwidW5kaXJlY3RlZFwiIGJ1dCBnb3QgXCIke29wdGlvbnMudHlwZX1cIi5gXG4gICAgICApO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93U2VsZkxvb3BzICE9PSAnYm9vbGVhbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAnYWxsb3dTZWxmTG9vcHMnIG9wdGlvbi4gRXhwZWN0aW5nIGEgYm9vbGVhbiBidXQgZ290IFwiJHtvcHRpb25zLmFsbG93U2VsZkxvb3BzfVwiLmBcbiAgICAgICk7XG5cbiAgICAvLy0tIFByaXZhdGUgcHJvcGVydGllc1xuXG4gICAgLy8gVXRpbGl0aWVzXG4gICAgY29uc3QgTm9kZURhdGFDbGFzcyA9XG4gICAgICBvcHRpb25zLnR5cGUgPT09ICdtaXhlZCdcbiAgICAgICAgPyBNaXhlZE5vZGVEYXRhXG4gICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnZGlyZWN0ZWQnXG4gICAgICAgID8gRGlyZWN0ZWROb2RlRGF0YVxuICAgICAgICA6IFVuZGlyZWN0ZWROb2RlRGF0YTtcblxuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnTm9kZURhdGFDbGFzcycsIE5vZGVEYXRhQ2xhc3MpO1xuXG4gICAgLy8gSW50ZXJuYWwgZWRnZSBrZXkgZ2VuZXJhdG9yXG5cbiAgICAvLyBOT1RFOiB0aGlzIGludGVybmFsIGdlbmVyYXRvciBwcm9kdWNlIGtleXMgdGhhdCBhcmUgc3RyaW5nc1xuICAgIC8vIGNvbXBvc2VkIG9mIGEgd2VpcmQgcHJlZml4LCBhbiBpbmNyZW1lbnRhbCBpbnN0YW5jZSBpZCBzdGFydGluZyBmcm9tXG4gICAgLy8gYSByYW5kb20gYnl0ZSBhbmQgZmluYWxseSBhbiBpbnRlcm5hbCBpbnN0YW5jZSBpbmNyZW1lbnRhbCBpZC5cbiAgICAvLyBBbGwgdGhpcyB0byBhdm9pZCBpbnRyYS1mcmFtZSBhbmQgY3Jvc3MtZnJhbWUgYWR2ZXJzYXJpYWwgaW5wdXRzXG4gICAgLy8gdGhhdCBjYW4gZm9yY2UgYSBzaW5nbGUgIy5hZGRFZGdlIGNhbGwgdG8gZGVnZW5lcmF0ZSBpbnRvIGEgTyhuKVxuICAgIC8vIGF2YWlsYWJsZSBrZXkgc2VhcmNoIGxvb3AuXG5cbiAgICAvLyBJdCBhbHNvIGVuc3VyZXMgdGhhdCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBlZGdlIGtleXMgYXJlIHVubGlrZWx5XG4gICAgLy8gdG8gcHJvZHVjZSBjb2xsaXNpb25zIHdpdGggYXJiaXRyYXJ5IGtleXMgZ2l2ZW4gYnkgdXNlcnMuXG4gICAgY29uc3QgaW5zdGFuY2VQcmVmaXggPSAnZ2VpZF8nICsgSU5TVEFOQ0VfSUQoKSArICdfJztcbiAgICBsZXQgZWRnZUlkID0gMDtcblxuICAgIGNvbnN0IGVkZ2VLZXlHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgYXZhaWxhYmxlRWRnZUtleTtcblxuICAgICAgZG8ge1xuICAgICAgICBhdmFpbGFibGVFZGdlS2V5ID0gaW5zdGFuY2VQcmVmaXggKyBlZGdlSWQrKztcbiAgICAgIH0gd2hpbGUgKHRoaXMuX2VkZ2VzLmhhcyhhdmFpbGFibGVFZGdlS2V5KSk7XG5cbiAgICAgIHJldHVybiBhdmFpbGFibGVFZGdlS2V5O1xuICAgIH07XG5cbiAgICAvLyBJbmRleGVzXG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfYXR0cmlidXRlcycsIHt9KTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19ub2RlcycsIG5ldyBNYXAoKSk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZWRnZXMnLCBuZXcgTWFwKCkpO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2RpcmVjdGVkU2l6ZScsIDApO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX3VuZGlyZWN0ZWRTaXplJywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZGlyZWN0ZWRTZWxmTG9vcENvdW50JywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfdW5kaXJlY3RlZFNlbGZMb29wQ291bnQnLCAwKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19lZGdlS2V5R2VuZXJhdG9yJywgZWRnZUtleUdlbmVyYXRvcik7XG5cbiAgICAvLyBPcHRpb25zXG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfb3B0aW9ucycsIG9wdGlvbnMpO1xuXG4gICAgLy8gRW1pdHRlciBwcm9wZXJ0aWVzXG4gICAgRU1JVFRFUl9QUk9QUy5mb3JFYWNoKHByb3AgPT4gcHJpdmF0ZVByb3BlcnR5KHRoaXMsIHByb3AsIHRoaXNbcHJvcF0pKTtcblxuICAgIC8vLS0gUHJvcGVydGllcyByZWFkZXJzXG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnb3JkZXInLCAoKSA9PiB0aGlzLl9ub2Rlcy5zaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdzaXplJywgKCkgPT4gdGhpcy5fZWRnZXMuc2l6ZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnZGlyZWN0ZWRTaXplJywgKCkgPT4gdGhpcy5fZGlyZWN0ZWRTaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICd1bmRpcmVjdGVkU2l6ZScsICgpID0+IHRoaXMuX3VuZGlyZWN0ZWRTaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdzZWxmTG9vcENvdW50JyxcbiAgICAgICgpID0+IHRoaXMuX2RpcmVjdGVkU2VsZkxvb3BDb3VudCArIHRoaXMuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50XG4gICAgKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdkaXJlY3RlZFNlbGZMb29wQ291bnQnLFxuICAgICAgKCkgPT4gdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50XG4gICAgKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICd1bmRpcmVjdGVkU2VsZkxvb3BDb3VudCcsXG4gICAgICAoKSA9PiB0aGlzLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudFxuICAgICk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnbXVsdGknLCB0aGlzLl9vcHRpb25zLm11bHRpKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICd0eXBlJywgdGhpcy5fb3B0aW9ucy50eXBlKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdhbGxvd1NlbGZMb29wcycsIHRoaXMuX29wdGlvbnMuYWxsb3dTZWxmTG9vcHMpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ2ltcGxlbWVudGF0aW9uJywgKCkgPT4gJ2dyYXBob2xvZ3knKTtcbiAgfVxuXG4gIF9yZXNldEluc3RhbmNlQ291bnRlcnMoKSB7XG4gICAgdGhpcy5fZGlyZWN0ZWRTaXplID0gMDtcbiAgICB0aGlzLl91bmRpcmVjdGVkU2l6ZSA9IDA7XG4gICAgdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50ID0gMDtcbiAgICB0aGlzLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudCA9IDA7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogUmVhZFxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBpcyBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc05vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5oYXMoJycgKyBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGRpcmVjdGVkIGVkZ2UgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICAgKi9cbiAgaGFzRGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlZGdlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgICByZXR1cm4gISFlZGdlRGF0YSAmJiAhZWRnZURhdGEudW5kaXJlY3RlZDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIHNvdXJjZSBvciB0aGUgdGFyZ2V0IGlzIG5vdCBpbiB0aGUgZ3JhcGggd2UgYnJlYWtcbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghbm9kZURhdGEpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSXMgdGhlcmUgYSBkaXJlY3RlZCBlZGdlIHBvaW50aW5nIHRvd2FyZCB0YXJnZXQ/XG4gICAgICByZXR1cm4gbm9kZURhdGEub3V0Lmhhc093blByb3BlcnR5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmhhc0RpcmVjdGVkRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiB1bmRpcmVjdGVkIGVkZ2UgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICAgKi9cbiAgaGFzVW5kaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlZGdlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgICByZXR1cm4gISFlZGdlRGF0YSAmJiBlZGdlRGF0YS51bmRpcmVjdGVkO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgc291cmNlIG9yIHRoZSB0YXJnZXQgaXMgbm90IGluIHRoZSBncmFwaCB3ZSBicmVha1xuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFub2RlRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJcyB0aGVyZSBhIGRpcmVjdGVkIGVkZ2UgcG9pbnRpbmcgdG93YXJkIHRhcmdldD9cbiAgICAgIHJldHVybiBub2RlRGF0YS51bmRpcmVjdGVkLmhhc093blByb3BlcnR5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmhhc0RpcmVjdGVkRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGlzIGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cbiAgICovXG4gIGhhc0VkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZWRnZSA9ICcnICsgc291cmNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5fZWRnZXMuaGFzKGVkZ2UpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgc291cmNlIG9yIHRoZSB0YXJnZXQgaXMgbm90IGluIHRoZSBncmFwaCB3ZSBicmVha1xuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFub2RlRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJcyB0aGVyZSBhIGRpcmVjdGVkIGVkZ2UgcG9pbnRpbmcgdG93YXJkIHRhcmdldD9cbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0eXBlb2Ygbm9kZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIG5vZGVEYXRhLm91dC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpKSB8fFxuICAgICAgICAodHlwZW9mIG5vZGVEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgbm9kZURhdGEudW5kaXJlY3RlZC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguaGFzRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZWRnZSBtYXRjaGluZyBzb3VyY2UgJiB0YXJnZXQgaW4gYSBkaXJlY3RlZCBmYXNoaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl8dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybjtcblxuICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZGlyZWN0ZWRFZGdlOiB0aGlzIG1ldGhvZCBpcyBpcnJlbGV2YW50IHdpdGggbXVsdGlncmFwaHMgc2luY2UgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQuIFNlZSAjLmRpcmVjdGVkRWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IChzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdKSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZWRnZURhdGEpIHJldHVybiBlZGdlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZWRnZSBtYXRjaGluZyBzb3VyY2UgJiB0YXJnZXQgaW4gYSB1bmRpcmVjdGVkIGZhc2hpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueXx1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG11bHRpLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHVuZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51bmRpcmVjdGVkRWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy51bmRpcmVjdGVkRWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPVxuICAgICAgKHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSkgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGVkZ2UgbWF0Y2hpbmcgc291cmNlICYgdGFyZ2V0IGluIGEgbWl4ZWQgZmFzaGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7YW55fHVuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmVkZ2U6IHRoaXMgbWV0aG9kIGlzIGlycmVsZXZhbnQgd2l0aCBtdWx0aWdyYXBocyBzaW5jZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldC4gU2VlICMuZWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPVxuICAgICAgKHNvdXJjZURhdGEub3V0ICYmIHNvdXJjZURhdGEub3V0W3RhcmdldF0pIHx8XG4gICAgICAoc291cmNlRGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdKSB8fFxuICAgICAgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIGRpcmVjdGVkIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlRGlyZWN0ZWROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVEaXJlY3RlZE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS5pbiB8fCBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgb3V0IG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlT3V0TmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlT3V0TmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5laWdoYm9yIGluIG5vZGVEYXRhLm91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBpbiBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZUluTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlSW5OZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmVpZ2hib3IgaW4gbm9kZURhdGEuaW47XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgdW5kaXJlY3RlZCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZVVuZGlyZWN0ZWROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVVbmRpcmVjdGVkTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLmluIHx8IG5laWdoYm9yIGluIG5vZGVEYXRhLm91dCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBpbmJvdW5kIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlSW5ib3VuZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZUluYm91bmROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEuaW4pIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgb3V0Ym91bmQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVPdXRib3VuZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZU91dGJvdW5kTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLm91dCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbkRlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbkRlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3V0RGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEub3V0RGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRpcmVjdGVkRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIHVuZGlyZWN0ZWQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICB1bmRpcmVjdGVkRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW5ib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW5ib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5ib3VuZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbmJvdW5kRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIG91dGJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXRib3VuZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXRib3VuZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5pbkRlZ3JlZSArIG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBpbiBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbkRlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaW5EZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWUgLSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgb3V0RGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEub3V0RGVncmVlIC0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlICsgbm9kZURhdGEub3V0RGVncmVlIC0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcyAqIDI7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIHVuZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgdW5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZSAtIG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGluYm91bmQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbmJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbmJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbmJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcbiAgICBsZXQgbG9vcHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS51bmRpcmVjdGVkTG9vcHMgKiAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLmluRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlIC0gbG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIG91dGJvdW5kIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIG91dGJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXRib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG4gICAgbGV0IGxvb3BzID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEudW5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWUgLSBsb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuICAgIGxldCBsb29wcyA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlIC0gbG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHNvdXJjZShlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguc291cmNlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnNvdXJjZS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHRhcmdldChlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudGFyZ2V0OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnRhcmdldC5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIGV4dHJlbWl0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAtIFRoZSBlZGdlJ3MgZXh0cmVtaXRpZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZXh0cmVtaXRpZXMoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZXh0cmVtaXRpZXM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIFtlZGdlRGF0YS5zb3VyY2Uua2V5LCBlZGdlRGF0YS50YXJnZXQua2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG5vZGUgJiBhbiBlZGdlLCByZXR1cm5zIHRoZSBvdGhlciBleHRyZW1pdHkgb2YgdGhlIGVkZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgIC0gVGhlIHJlbGF0ZWQgbm9kZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGggb3IgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGVkZ2UgJiBub2RlIGFyZSBub3QgcmVsYXRlZC5cbiAgICovXG4gIG9wcG9zaXRlKG5vZGUsIGVkZ2UpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm9wcG9zaXRlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IGRhdGEuc291cmNlLmtleTtcbiAgICBjb25zdCB0YXJnZXQgPSBkYXRhLnRhcmdldC5rZXk7XG5cbiAgICBpZiAobm9kZSA9PT0gc291cmNlKSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChub2RlID09PSB0YXJnZXQpIHJldHVybiBzb3VyY2U7XG5cbiAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLm9wcG9zaXRlOiB0aGUgXCIke25vZGV9XCIgbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIFwiJHtlZGdlfVwiIGVkZ2UgKCR7c291cmNlfSwgJHt0YXJnZXR9KS5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaGFzIHRoZSBnaXZlbiBub2RlIGFzIGV4dHJlbWl0eS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgLSBUaGUgcmVsYXRlZCBub2RlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGVpdGhlciB0aGUgbm9kZSBvciB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBoYXNFeHRyZW1pdHkoZWRnZSwgbm9kZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaGFzRXh0cmVtaXR5OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnNvdXJjZS5rZXkgPT09IG5vZGUgfHwgZGF0YS50YXJnZXQua2V5ID09PSBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyB1bmRpcmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaXNVbmRpcmVjdGVkKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pc1VuZGlyZWN0ZWQ6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEudW5kaXJlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaXMgZGlyZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpc0RpcmVjdGVkKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pc0RpcmVjdGVkOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiAhZGF0YS51bmRpcmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyBhIHNlbGYgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGlzU2VsZkxvb3AoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmlzU2VsZkxvb3A6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuc291cmNlID09PSBkYXRhLnRhcmdldDtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBNdXRhdGlvblxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGFkZCBhIG5vZGUgdG8gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIG5vZGUgICAgICAgICAtIFRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIG5vZGUgYWxyZWFkeSBleGlzdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGFuIG9iamVjdC5cbiAgICovXG4gIGFkZE5vZGUobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gYWRkTm9kZSh0aGlzLCBub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBub2RlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gbWVyZ2UgYSBub2RlIGludG8gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIG5vZGUgICAgICAgICAtIFRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqL1xuICBtZXJnZU5vZGUobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzICYmICFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgubWVyZ2VOb2RlOiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICAgICk7XG5cbiAgICAvLyBTdHJpbmcgY29lcmNpb25cbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgYWxyZWFkeSBleGlzdHMsIHdlIG1lcmdlIHRoZSBhdHRyaWJ1dGVzXG4gICAgbGV0IGRhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXNzaWduKGRhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgICAgICBrZXk6IG5vZGUsXG4gICAgICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25vZGUsIGZhbHNlXTtcbiAgICB9XG5cbiAgICBkYXRhID0gbmV3IHRoaXMuTm9kZURhdGFDbGFzcyhub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEFkZGluZyB0aGUgbm9kZSB0byBpbnRlcm5hbCByZWdpc3RlclxuICAgIHRoaXMuX25vZGVzLnNldChub2RlLCBkYXRhKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQWRkZWQnLCB7XG4gICAgICBrZXk6IG5vZGUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW25vZGUsIHRydWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGFkZCBhIG5vZGUgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGdyYXBoIG9yIGVsc2UgdG9cbiAgICogdXBkYXRlIGl0cyBhdHRyaWJ1dGVzIHVzaW5nIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAgLSBUaGUgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IFt1cGRhdGVyXSAtIE9wdGlvbmFsIHVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICovXG4gIHVwZGF0ZU5vZGUobm9kZSwgdXBkYXRlcikge1xuICAgIGlmICh1cGRhdGVyICYmIHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudXBkYXRlTm9kZTogaW52YWxpZCB1cGRhdGVyIGZ1bmN0aW9uLiBFeHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiJHt1cGRhdGVyfVwiYFxuICAgICAgKTtcblxuICAgIC8vIFN0cmluZyBjb2VyY2lvblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBhbHJlYWR5IGV4aXN0cywgd2UgdXBkYXRlIHRoZSBhdHRyaWJ1dGVzXG4gICAgbGV0IGRhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKHVwZGF0ZXIpIHtcbiAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGRhdGEuYXR0cmlidXRlcztcbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihvbGRBdHRyaWJ1dGVzKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICAgICAga2V5OiBub2RlLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZSwgZmFsc2VdO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB1cGRhdGVyID8gdXBkYXRlcih7fSkgOiB7fTtcblxuICAgIGRhdGEgPSBuZXcgdGhpcy5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gQWRkaW5nIHRoZSBub2RlIHRvIGludGVybmFsIHJlZ2lzdGVyXG4gICAgdGhpcy5fbm9kZXMuc2V0KG5vZGUsIGRhdGEpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBZGRlZCcsIHtcbiAgICAgIGtleTogbm9kZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiBbbm9kZSwgdHJ1ZV07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZHJvcCBhIHNpbmdsZSBub2RlICYgYWxsIGl0cyBhdHRhY2hlZCBlZGdlcyBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBub2RlIC0gVGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wTm9kZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kcm9wTm9kZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZWRnZURhdGE7XG5cbiAgICAvLyBSZW1vdmluZyBhdHRhY2hlZCBlZGdlc1xuICAgIC8vIE5PVEU6IHdlIGNvdWxkIGJlIGZhc3RlciBoZXJlLCBidXQgdGhpcyBpcyBzdWNoIGEgcGFpbiB0byBtYWludGFpblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQpIHtcbiAgICAgICAgZWRnZURhdGEgPSBub2RlRGF0YS5vdXRbbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS5pbikge1xuICAgICAgICBlZGdlRGF0YSA9IG5vZGVEYXRhLmluW25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSB7XG4gICAgICAgIGVkZ2VEYXRhID0gbm9kZURhdGEudW5kaXJlY3RlZFtuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyb3BwaW5nIHRoZSBub2RlIGZyb20gdGhlIHJlZ2lzdGVyXG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKG5vZGUpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVEcm9wcGVkJywge1xuICAgICAga2V5OiBub2RlLFxuICAgICAgYXR0cmlidXRlczogbm9kZURhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgZWRnZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICBlZGdlIC0gVGhlIGVkZ2UuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wRWRnZShlZGdlKSB7XG4gICAgbGV0IGVkZ2VEYXRhO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgYXJndW1lbnRzWzFdO1xuXG4gICAgICBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdGhpcy50eXBlKTtcblxuICAgICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguZHJvcEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIC0+IFwiJHt0YXJnZXR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgICBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguZHJvcEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBkcm9wIGEgc2luZ2xlIGRpcmVjdGVkIGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wRGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gdHJ5IGFuZCBkcm9wIGEgZGlyZWN0ZWQgZWRnZSBieSBrZXkuIFdoYXQgaWYgdGhlIGVkZ2Ugd2l0aCB0aGlzIGtleSBpcyB1bmRpcmVjdGVkPyBVc2UgIy5kcm9wRWRnZSBmb3IgdGhpcyBwdXJwb3NlIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBkcm9wcGluZyBhbiBlZGdlIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCB0byBkZWxldGUgYXMgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgb25lcy4nXG4gICAgICApO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgJ2RpcmVjdGVkJyk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIGEgXCIke3NvdXJjZX1cIiAtPiBcIiR7dGFyZ2V0fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgdW5kaXJlY3RlZCBlZGdlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZHJvcFVuZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BVbmRpcmVjdGVkRWRnZTogaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byBkcm9wIGEgZGlyZWN0ZWQgZWRnZSBieSBrZXkuIFdoYXQgaWYgdGhlIGVkZ2Ugd2l0aCB0aGlzIGtleSBpcyB1bmRpcmVjdGVkPyBVc2UgIy5kcm9wRWRnZSBmb3IgdGhpcyBwdXJwb3NlIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BVbmRpcmVjdGVkRWRnZTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGRyb3BwaW5nIGFuIGVkZ2UgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IHRvIGRlbGV0ZSBhcyB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBvbmVzLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgJ3VuZGlyZWN0ZWQnKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZHJvcFVuZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCBhIFwiJHtzb3VyY2V9XCIgLT4gXCIke3RhcmdldH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byByZW1vdmUgZXZlcnkgZWRnZSAmIGV2ZXJ5IG5vZGUgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgLy8gQ2xlYXJpbmcgZWRnZXNcbiAgICB0aGlzLl9lZGdlcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXJpbmcgbm9kZXNcbiAgICB0aGlzLl9ub2Rlcy5jbGVhcigpO1xuXG4gICAgLy8gUmVzZXQgY291bnRlcnNcbiAgICB0aGlzLl9yZXNldEluc3RhbmNlQ291bnRlcnMoKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdjbGVhcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gcmVtb3ZlIGV2ZXJ5IGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgY2xlYXJFZGdlcygpIHtcbiAgICAvLyBDbGVhcmluZyBzdHJ1Y3R1cmUgaW5kZXhcbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXA7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgc3RlcC52YWx1ZS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8vIENsZWFyaW5nIGVkZ2VzXG4gICAgdGhpcy5fZWRnZXMuY2xlYXIoKTtcblxuICAgIC8vIFJlc2V0IGNvdW50ZXJzXG4gICAgdGhpcy5fcmVzZXRJbnN0YW5jZUNvdW50ZXJzKCk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZXNDbGVhcmVkJyk7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXR0cmlidXRlcy1yZWxhdGVkIG1ldGhvZHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ3JhcGggaGFzIHRoZSBkZXNpcmVkIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0F0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHNldHRpbmcgYSB2YWx1ZSBmb3IgdGhlIGRlc2lyZWQgZ3JhcGgncyBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB2YWx1ZSAtIFZhbHVlIGZvciB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2luZyBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgZGVzaXJlZCBncmFwaCdzIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZSAgICAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBGdW5jdGlvbiB1c2UgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGUobmFtZSwgdXBkYXRlcikge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUF0dHJpYnV0ZTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHVwZGF0ZXIodmFsdWUpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJlbW92aW5nIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmVwbGFjaW5nIHRoZSBncmFwaCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIE5ldyBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXG4gICAqL1xuICByZXBsYWNlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgucmVwbGFjZUF0dHJpYnV0ZXM6IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC4nXG4gICAgICApO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgbWVyZ2luZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIG1lcmdlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXG4gICAqL1xuICBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLm1lcmdlQXR0cmlidXRlczogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LidcbiAgICAgICk7XG5cbiAgICBhc3NpZ24odGhpcy5fYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1cGRhdGluZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIEZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdXBkYXRlQXR0cmlidXRlcyh1cGRhdGVyKSB7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlQXR0cmlidXRlczogcHJvdmlkZWQgdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHVwZGF0ZXIodGhpcy5fYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIHVwZGF0ZSBlYWNoIG5vZGUncyBhdHRyaWJ1dGVzIHVzaW5nIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgIFtoaW50c10gLSBPcHRpb25hbCBoaW50cy5cbiAgICovXG4gIHVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyh1cGRhdGVyLCBoaW50cykge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlczogZXhwZWN0aW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24uJ1xuICAgICAgKTtcblxuICAgIGlmIChoaW50cyAmJiAhdmFsaWRhdGVIaW50cyhoaW50cykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXM6IGludmFsaWQgaGludHMuIEV4cGVjdGluZyBhbiBvYmplY3QgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2hhcGU6IHthdHRyaWJ1dGVzPzogW3N0cmluZ119J1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgbm9kZURhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2VhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBoaW50czogaGludHMgPyBoaW50cyA6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byB1cGRhdGUgZWFjaCBlZGdlJ3MgYXR0cmlidXRlcyB1c2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBbaGludHNdIC0gT3B0aW9uYWwgaGludHMuXG4gICAqL1xuICB1cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXModXBkYXRlciwgaGludHMpIHtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXM6IGV4cGVjdGluZyBhbiB1cGRhdGVyIGZ1bmN0aW9uLidcbiAgICAgICk7XG5cbiAgICBpZiAoaGludHMgJiYgIXZhbGlkYXRlSGludHMoaGludHMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlRWFjaEVkZ2VBdHRyaWJ1dGVzOiBpbnZhbGlkIGhpbnRzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGhhdmluZyB0aGUgZm9sbG93aW5nIHNoYXBlOiB7YXR0cmlidXRlcz86IFtzdHJpbmddfSdcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2VkZ2VzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIGVkZ2VEYXRhLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIGVkZ2VEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIHNvdXJjZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgICB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihcbiAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGhpbnRzOiBoaW50cyA/IGhpbnRzIDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEl0ZXJhdGlvbi1yZWxhdGVkIG1ldGhvZHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgYWRqYWNlbmN5IHVzaW5nIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICovXG4gIGZvckVhY2hBZGphY2VuY3lFbnRyeShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQWRqYWNlbmN5RW50cnk6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBmb3JFYWNoQWRqYWNlbmN5KGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuICBmb3JFYWNoQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFucyhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFuczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIGZhbHNlLCB0cnVlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIGFzc3ltZXRyaWMgYWRqYWNlbmN5IHVzaW5nIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICovXG4gIGZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIHRydWUsIGZhbHNlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cbiAgZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFuczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIHRydWUsIHRydWUsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBsaXN0IG9mIHRoZSBncmFwaCdzIG5vZGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgbm9kZXMuXG4gICAqL1xuICBub2RlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9ub2Rlcy5rZXlzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyBub2RlcyB1c2luZyB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzLCBpbmRleCkuXG4gICAqL1xuICBmb3JFYWNoTm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBhdHRlbXB0aW5nIHRvIGZpbmQgYSBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIGZpbmROb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZpbmROb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKSByZXR1cm4gbm9kZURhdGEua2V5O1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgbWFwcGluZyBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgbWFwTm9kZXMoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgubWFwTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5vcmRlcik7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIHJlc3VsdFtpKytdID0gY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciBzb21lIG5vZGUgdmVyaWZ5IHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIHNvbWVOb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnNvbWVOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIGFsbCBub2RlIHZlcmlmeSB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBldmVyeU5vZGUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZXZlcnlOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmaWx0ZXJpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIGZpbHRlck5vZGVzKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZpbHRlck5vZGVzOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcykpXG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGVEYXRhLmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmVkdWNpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoYWNjdW11bGF0b3IsIGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICByZWR1Y2VOb2RlcyhjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnJlZHVjZU5vZGVzOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgucmVkdWNlTm9kZXM6IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS4nXG4gICAgICApO1xuXG4gICAgbGV0IGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdyYXBoJ3Mgbm9kZSBlbnRyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAgICovXG4gIG5vZGVFbnRyaWVzKCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHJldHVybiBzdGVwO1xuICAgICAgICBjb25zdCBkYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZToge25vZGU6IGRhdGEua2V5LCBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXN9LFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBTZXJpYWxpemF0aW9uXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZXhwb3J0IHRoZSB3aG9sZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBzZXJpYWxpemVkIGdyYXBoLlxuICAgKi9cbiAgZXhwb3J0KCkge1xuICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KHRoaXMuX25vZGVzLnNpemUpO1xuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBub2Rlc1tpKytdID0gc2VyaWFsaXplTm9kZShrZXksIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZWRnZXMgPSBuZXcgQXJyYXkodGhpcy5fZWRnZXMuc2l6ZSk7XG5cbiAgICBpID0gMDtcblxuICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgZWRnZXNbaSsrXSA9IHNlcmlhbGl6ZUVkZ2UodGhpcy50eXBlLCBrZXksIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBtdWx0aTogdGhpcy5tdWx0aSxcbiAgICAgICAgYWxsb3dTZWxmTG9vcHM6IHRoaXMuYWxsb3dTZWxmTG9vcHNcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJpYnV0ZXMoKSxcbiAgICAgIG5vZGVzLFxuICAgICAgZWRnZXNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGltcG9ydCBhIHNlcmlhbGl6ZWQgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdHxHcmFwaH0gZGF0YSAgLSBUaGUgc2VyaWFsaXplZCBncmFwaC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBtZXJnZSAtIFdoZXRoZXIgdG8gbWVyZ2UgZGF0YS5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGltcG9ydChkYXRhLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgLy8gSW1wb3J0aW5nIGEgR3JhcGggaW5zdGFuY2UgZGlyZWN0bHlcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEdyYXBoKSB7XG4gICAgICAvLyBOb2Rlc1xuICAgICAgZGF0YS5mb3JFYWNoTm9kZSgobiwgYSkgPT4ge1xuICAgICAgICBpZiAobWVyZ2UpIHRoaXMubWVyZ2VOb2RlKG4sIGEpO1xuICAgICAgICBlbHNlIHRoaXMuYWRkTm9kZShuLCBhKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFZGdlc1xuICAgICAgZGF0YS5mb3JFYWNoRWRnZSgoZSwgYSwgcywgdCwgX3NhLCBfdGEsIHUpID0+IHtcbiAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgaWYgKHUpIHRoaXMubWVyZ2VVbmRpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgICAgZWxzZSB0aGlzLm1lcmdlRGlyZWN0ZWRFZGdlV2l0aEtleShlLCBzLCB0LCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodSkgdGhpcy5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgICAgZWxzZSB0aGlzLmFkZERpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbXBvcnRpbmcgYSBzZXJpYWxpemVkIGdyYXBoXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGFyZ3VtZW50LiBFeHBlY3RpbmcgYSBzZXJpYWxpemVkIGdyYXBoIG9yLCBhbHRlcm5hdGl2ZWx5LCBhIEdyYXBoIGluc3RhbmNlLidcbiAgICAgICk7XG5cbiAgICBpZiAoZGF0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YS5hdHRyaWJ1dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGEgcGxhaW4gb2JqZWN0LidcbiAgICAgICAgKTtcblxuICAgICAgaWYgKG1lcmdlKSB0aGlzLm1lcmdlQXR0cmlidXRlcyhkYXRhLmF0dHJpYnV0ZXMpO1xuICAgICAgZWxzZSB0aGlzLnJlcGxhY2VBdHRyaWJ1dGVzKGRhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgbGV0IGksIGwsIGxpc3QsIG5vZGUsIGVkZ2U7XG5cbiAgICBpZiAoZGF0YS5ub2Rlcykge1xuICAgICAgbGlzdCA9IGRhdGEubm9kZXM7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgbm9kZXMuIEV4cGVjdGluZyBhbiBhcnJheS4nXG4gICAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBub2RlID0gbGlzdFtpXTtcblxuICAgICAgICAvLyBWYWxpZGF0aW5nXG4gICAgICAgIHZhbGlkYXRlU2VyaWFsaXplZE5vZGUobm9kZSk7XG5cbiAgICAgICAgLy8gQWRkaW5nIHRoZSBub2RlXG4gICAgICAgIGNvbnN0IHtrZXksIGF0dHJpYnV0ZXN9ID0gbm9kZTtcblxuICAgICAgICBpZiAobWVyZ2UpIHRoaXMubWVyZ2VOb2RlKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGVsc2UgdGhpcy5hZGROb2RlKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuZWRnZXMpIHtcbiAgICAgIGxldCB1bmRpcmVjdGVkQnlEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgICB1bmRpcmVjdGVkQnlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbGlzdCA9IGRhdGEuZWRnZXM7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgZWRnZXMuIEV4cGVjdGluZyBhbiBhcnJheS4nXG4gICAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBlZGdlID0gbGlzdFtpXTtcblxuICAgICAgICAvLyBWYWxpZGF0aW5nXG4gICAgICAgIHZhbGlkYXRlU2VyaWFsaXplZEVkZ2UoZWRnZSk7XG5cbiAgICAgICAgLy8gQWRkaW5nIHRoZSBlZGdlXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgdW5kaXJlY3RlZCA9IHVuZGlyZWN0ZWRCeURlZmF1bHRcbiAgICAgICAgfSA9IGVkZ2U7XG5cbiAgICAgICAgbGV0IG1ldGhvZDtcblxuICAgICAgICBpZiAoJ2tleScgaW4gZWRnZSkge1xuICAgICAgICAgIG1ldGhvZCA9IG1lcmdlXG4gICAgICAgICAgICA/IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgICAgPyB0aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VXaXRoS2V5XG4gICAgICAgICAgICAgIDogdGhpcy5tZXJnZURpcmVjdGVkRWRnZVdpdGhLZXlcbiAgICAgICAgICAgIDogdW5kaXJlY3RlZFxuICAgICAgICAgICAgPyB0aGlzLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleVxuICAgICAgICAgICAgOiB0aGlzLmFkZERpcmVjdGVkRWRnZVdpdGhLZXk7XG5cbiAgICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlZGdlLmtleSwgc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IG1lcmdlXG4gICAgICAgICAgICA/IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgICAgPyB0aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VcbiAgICAgICAgICAgICAgOiB0aGlzLm1lcmdlRGlyZWN0ZWRFZGdlXG4gICAgICAgICAgICA6IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgID8gdGhpcy5hZGRVbmRpcmVjdGVkRWRnZVxuICAgICAgICAgICAgOiB0aGlzLmFkZERpcmVjdGVkRWRnZTtcblxuICAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFV0aWxzXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBhIG51bGwgY29weSBvZiB0aGUgZ3JhcGgsIGkuZS4gYSBncmFwaCB3aXRob3V0IG5vZGVzXG4gICAqICYgZWRnZXMgYnV0IHdpdGggdGhlIGV4YWN0IHNhbWUgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBtZXJnZSB3aXRoIHRoZSBjdXJyZW50IG9uZXMuXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFRoZSBudWxsIGNvcHkuXG4gICAqL1xuICBudWxsQ29weShvcHRpb25zKSB7XG4gICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKSk7XG4gICAgZ3JhcGgucmVwbGFjZUF0dHJpYnV0ZXMoYXNzaWduKHt9LCB0aGlzLmdldEF0dHJpYnV0ZXMoKSkpO1xuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGFuIGVtcHR5IGNvcHkgb2YgdGhlIGdyYXBoLCBpLmUuIGEgZ3JhcGggd2l0aG91dCBlZGdlcyBidXRcbiAgICogd2l0aCB0aGUgZXhhY3Qgc2FtZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIG1lcmdlIHdpdGggdGhlIGN1cnJlbnQgb25lcy5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gVGhlIGVtcHR5IGNvcHkuXG4gICAqL1xuICBlbXB0eUNvcHkob3B0aW9ucykge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5udWxsQ29weShvcHRpb25zKTtcblxuICAgIHRoaXMuX25vZGVzLmZvckVhY2goKG5vZGVEYXRhLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhc3NpZ24oe30sIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBOT1RFOiBubyBuZWVkIHRvIGVtaXQgZXZlbnRzIHNpbmNlIHVzZXIgY2Fubm90IGFjY2VzcyB0aGUgaW5zdGFuY2UgeWV0XG4gICAgICBub2RlRGF0YSA9IG5ldyBncmFwaC5Ob2RlRGF0YUNsYXNzKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICBncmFwaC5fbm9kZXMuc2V0KGtleSwgbm9kZURhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgYW4gZXhhY3QgY29weSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAtIFVwZ3JhZGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gVGhlIGNvcHkuXG4gICAqL1xuICBjb3B5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICBvcHRpb25zLnR5cGUgIT09IHRoaXMudHlwZSAmJlxuICAgICAgb3B0aW9ucy50eXBlICE9PSAnbWl4ZWQnXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvcHk6IGNhbm5vdCBjcmVhdGUgYW4gaW5jb21wYXRpYmxlIGNvcHkgZnJvbSBcIiR7dGhpcy50eXBlfVwiIHR5cGUgdG8gXCIke29wdGlvbnMudHlwZX1cIiBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLm11bHRpID09PSAnYm9vbGVhbicgJiZcbiAgICAgIG9wdGlvbnMubXVsdGkgIT09IHRoaXMubXVsdGkgJiZcbiAgICAgIG9wdGlvbnMubXVsdGkgIT09IHRydWVcbiAgICApXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguY29weTogY2Fubm90IGNyZWF0ZSBhbiBpbmNvbXBhdGlibGUgY29weSBieSBkb3duZ3JhZGluZyBhIG11bHRpIGdyYXBoIHRvIGEgc2ltcGxlIG9uZSBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguJ1xuICAgICAgKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmFsbG93U2VsZkxvb3BzID09PSAnYm9vbGVhbicgJiZcbiAgICAgIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgIT09IHRoaXMuYWxsb3dTZWxmTG9vcHMgJiZcbiAgICAgIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgIT09IHRydWVcbiAgICApXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguY29weTogY2Fubm90IGNyZWF0ZSBhbiBpbmNvbXBhdGlibGUgY29weSBmcm9tIGEgZ3JhcGggYWxsb3dpbmcgc2VsZiBsb29wcyB0byBvbmUgdGhhdCBkb2VzIG5vdCBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5lbXB0eUNvcHkob3B0aW9ucyk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2VkZ2VzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIGVkZ2VEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIGVkZ2VEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgLy8gTk9URTogbm8gbmVlZCB0byBlbWl0IGV2ZW50cyBzaW5jZSB1c2VyIGNhbm5vdCBhY2Nlc3MgdGhlIGluc3RhbmNlIHlldFxuICAgICAgYWRkRWRnZShcbiAgICAgICAgZ3JhcGgsXG4gICAgICAgICdjb3B5JyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWQsXG4gICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgICAgZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgYXNzaWduKHt9LCBlZGdlRGF0YS5hdHRyaWJ1dGVzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogS25vd24gbWV0aG9kc1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIGJ5IEphdmFTY3JpcHQgdG8gcGVyZm9ybSBKU09OIHNlcmlhbGl6YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgc2VyaWFsaXplZCBncmFwaC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5leHBvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIFtvYmplY3QgR3JhcGhdLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IEdyYXBoXSc7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBub2RlJ3MgY29uc29sZSB0byBkaXNwbGF5IGEgY3VzdG9tIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIEZvcm1hdHRlZCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHt9O1xuICAgIHRoaXMuX25vZGVzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgbm9kZXNba2V5XSA9IGRhdGEuYXR0cmlidXRlcztcbiAgICB9KTtcblxuICAgIGNvbnN0IGVkZ2VzID0ge30sXG4gICAgICBtdWx0aUluZGV4ID0ge307XG5cbiAgICB0aGlzLl9lZGdlcy5mb3JFYWNoKChkYXRhLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRhdGEudW5kaXJlY3RlZCA/ICctLScgOiAnLT4nO1xuXG4gICAgICBsZXQgbGFiZWwgPSAnJztcblxuICAgICAgbGV0IHNvdXJjZSA9IGRhdGEuc291cmNlLmtleTtcbiAgICAgIGxldCB0YXJnZXQgPSBkYXRhLnRhcmdldC5rZXk7XG4gICAgICBsZXQgdG1wO1xuXG4gICAgICBpZiAoZGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZSA+IHRhcmdldCkge1xuICAgICAgICB0bXAgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IHRhcmdldDtcbiAgICAgICAgdGFyZ2V0ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXNjID0gYCgke3NvdXJjZX0pJHtkaXJlY3Rpb259KCR7dGFyZ2V0fSlgO1xuXG4gICAgICBpZiAoIWtleS5zdGFydHNXaXRoKCdnZWlkXycpKSB7XG4gICAgICAgIGxhYmVsICs9IGBbJHtrZXl9XTogYDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICBpZiAodHlwZW9mIG11bHRpSW5kZXhbZGVzY10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbXVsdGlJbmRleFtkZXNjXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsdGlJbmRleFtkZXNjXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwgKz0gYCR7bXVsdGlJbmRleFtkZXNjXX0uIGA7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsICs9IGRlc2M7XG5cbiAgICAgIGVkZ2VzW2xhYmVsXSA9IGRhdGEuYXR0cmlidXRlcztcbiAgICB9KTtcblxuICAgIGNvbnN0IGR1bW15ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gdGhpcykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmhhc093blByb3BlcnR5KGspICYmXG4gICAgICAgICFFTUlUVEVSX1BST1BTLmhhcyhrKSAmJlxuICAgICAgICB0eXBlb2YgdGhpc1trXSAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgayAhPT0gJ3N5bWJvbCdcbiAgICAgIClcbiAgICAgICAgZHVtbXlba10gPSB0aGlzW2tdO1xuICAgIH1cblxuICAgIGR1bW15LmF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzO1xuICAgIGR1bW15Lm5vZGVzID0gbm9kZXM7XG4gICAgZHVtbXkuZWRnZXMgPSBlZGdlcztcblxuICAgIHByaXZhdGVQcm9wZXJ0eShkdW1teSwgJ2NvbnN0cnVjdG9yJywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgICByZXR1cm4gZHVtbXk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2hpbmcgbWV0aG9kcyB0byB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEhlcmUsIHdlIGFyZSBhdHRhY2hpbmcgYSB3aWRlIHZhcmlldHkgb2YgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MnXG4gKiBwcm90b3R5cGUgd2hlbiB0aG9zZSBhcmUgdmVyeSBudW1lcm91cyBhbmQgd2hlbiB0aGVpciBjcmVhdGlvbiBpc1xuICogYWJzdHJhY3RlZC5cbiAqL1xuXG4vKipcbiAqIEF0dGFjaGluZyBjdXN0b20gaW5zcGVjdCBtZXRob2QgZm9yIG5vZGUgPj0gMTAuXG4gKi9cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJylcbiAgR3JhcGgucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID1cbiAgICBHcmFwaC5wcm90b3R5cGUuaW5zcGVjdDtcblxuLyoqXG4gKiBSZWxhdGVkIHRvIGVkZ2UgYWRkaXRpb24uXG4gKi9cbkVER0VfQUREX01FVEhPRFMuZm9yRWFjaChtZXRob2QgPT4ge1xuICBbJ2FkZCcsICdtZXJnZScsICd1cGRhdGUnXS5mb3JFYWNoKHZlcmIgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBtZXRob2QubmFtZSh2ZXJiKTtcbiAgICBjb25zdCBmbiA9IHZlcmIgPT09ICdhZGQnID8gYWRkRWRnZSA6IG1lcmdlRWRnZTtcblxuICAgIGlmIChtZXRob2QuZ2VuZXJhdGVLZXkpIHtcbiAgICAgIEdyYXBoLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgKG1ldGhvZC50eXBlIHx8IHRoaXMudHlwZSkgPT09ICd1bmRpcmVjdGVkJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB2ZXJiID09PSAndXBkYXRlJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgR3JhcGgucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKG1ldGhvZC50eXBlIHx8IHRoaXMudHlwZSkgPT09ICd1bmRpcmVjdGVkJyxcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB2ZXJiID09PSAndXBkYXRlJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQXR0cmlidXRlcy1yZWxhdGVkLlxuICovXG5hdHRhY2hOb2RlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpO1xuYXR0YWNoRWRnZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKTtcblxuLyoqXG4gKiBFZGdlIGl0ZXJhdGlvbi1yZWxhdGVkLlxuICovXG5hdHRhY2hFZGdlSXRlcmF0aW9uTWV0aG9kcyhHcmFwaCk7XG5cbi8qKlxuICogTmVpZ2hib3IgaXRlcmF0aW9uLXJlbGF0ZWQuXG4gKi9cbmF0dGFjaE5laWdoYm9ySXRlcmF0aW9uTWV0aG9kcyhHcmFwaCk7XG5cbi8qKlxuICogR3JhcGhvbG9neSBIZWxwZXIgQ2xhc3Nlc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCdWlsZGluZyBzb21lIGhpZ2hlci1vcmRlciBjbGFzc2VzIGluc3RhbnRpYXRpbmcgdGhlIGdyYXBoIHdpdGhcbiAqIHByZWRlZmluaXRlIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBBbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvcnMuXG4gKi9cbmNsYXNzIERpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICdkaXJlY3RlZCd9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgbXVsdGkgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgaWYgKGZpbmFsT3B0aW9ucy50eXBlICE9PSAnZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgVW5kaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAndW5kaXJlY3RlZCd9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBtdWx0aSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBpZiAoZmluYWxPcHRpb25zLnR5cGUgIT09ICd1bmRpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ1VuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7bXVsdGk6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aUdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBzaW1wbGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlEaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAnZGlyZWN0ZWQnLCBtdWx0aTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gdHJ1ZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ2RpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlVbmRpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICd1bmRpcmVjdGVkJywgbXVsdGk6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aVVuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlVbmRpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJyArXG4gICAgICAgICAgZmluYWxPcHRpb25zLnR5cGUgK1xuICAgICAgICAgICdcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2hpbmcgc3RhdGljICMuZnJvbSBtZXRob2QgdG8gZWFjaCBvZiB0aGUgY29uc3RydWN0b3JzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hTdGF0aWNGcm9tTWV0aG9kKENsYXNzKSB7XG4gIC8qKlxuICAgKiBCdWlsZHMgYSBncmFwaCBmcm9tIHNlcmlhbGl6ZWQgZGF0YSBvciBhbm90aGVyIGdyYXBoJ3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7R3JhcGh8U2VyaWFsaXplZEdyYXBofSBkYXRhICAgICAgLSBIeWRyYXRhdGlvbiBkYXRhLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgIFtvcHRpb25zXSAtIE9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0NsYXNzfVxuICAgKi9cbiAgQ2xhc3MuZnJvbSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgLy8gTWVyZ2luZyBnaXZlbiBvcHRpb25zIHdpdGggc2VyaWFsaXplZCBvbmVzXG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt9LCBkYXRhLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2xhc3MoZmluYWxPcHRpb25zKTtcbiAgICBpbnN0YW5jZS5pbXBvcnQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChEaXJlY3RlZEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoVW5kaXJlY3RlZEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoTXVsdGlHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKE11bHRpRGlyZWN0ZWRHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKE11bHRpVW5kaXJlY3RlZEdyYXBoKTtcblxuR3JhcGguR3JhcGggPSBHcmFwaDtcbkdyYXBoLkRpcmVjdGVkR3JhcGggPSBEaXJlY3RlZEdyYXBoO1xuR3JhcGguVW5kaXJlY3RlZEdyYXBoID0gVW5kaXJlY3RlZEdyYXBoO1xuR3JhcGguTXVsdGlHcmFwaCA9IE11bHRpR3JhcGg7XG5HcmFwaC5NdWx0aURpcmVjdGVkR3JhcGggPSBNdWx0aURpcmVjdGVkR3JhcGg7XG5HcmFwaC5NdWx0aVVuZGlyZWN0ZWRHcmFwaCA9IE11bHRpVW5kaXJlY3RlZEdyYXBoO1xuXG5HcmFwaC5JbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvciA9IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yO1xuR3JhcGguTm90Rm91bmRHcmFwaEVycm9yID0gTm90Rm91bmRHcmFwaEVycm9yO1xuR3JhcGguVXNhZ2VHcmFwaEVycm9yID0gVXNhZ2VHcmFwaEVycm9yO1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgRVNNIEVuZG9pbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRW5kcG9pbnQgZm9yIEVTTSBtb2R1bGVzIGNvbnN1bWVycy5cbiAqL1xuXG5leHBvcnQgeyBEaXJlY3RlZEdyYXBoLCBHcmFwaCwgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IsIE11bHRpRGlyZWN0ZWRHcmFwaCwgTXVsdGlHcmFwaCwgTXVsdGlVbmRpcmVjdGVkR3JhcGgsIE5vdEZvdW5kR3JhcGhFcnJvciwgVW5kaXJlY3RlZEdyYXBoLCBVc2FnZUdyYXBoRXJyb3IsIEdyYXBoIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBob2xvZ3kubWpzLm1hcFxuIiwiLyogQGxpY2Vuc2VcblBhcGEgUGFyc2VcbnY1LjUuM1xuaHR0cHM6Ly9naXRodWIuY29tL21ob2x0L1BhcGFQYXJzZVxuTGljZW5zZTogTUlUXG4qL1xuKChlLHQpPT57XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSx0KTpcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlJiZcInVuZGVmaW5lZFwiIT10eXBlb2YgZXhwb3J0cz9tb2R1bGUuZXhwb3J0cz10KCk6ZS5QYXBhPXQoKX0pKHRoaXMsZnVuY3Rpb24gcigpe3ZhciBuPVwidW5kZWZpbmVkXCIhPXR5cGVvZiBzZWxmP3NlbGY6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwIT09bj9uOnt9O3ZhciBkLHM9IW4uZG9jdW1lbnQmJiEhbi5wb3N0TWVzc2FnZSxhPW4uSVNfUEFQQV9XT1JLRVJ8fCExLG89e30saD0wLHY9e307ZnVuY3Rpb24gdShlKXt0aGlzLl9oYW5kbGU9bnVsbCx0aGlzLl9maW5pc2hlZD0hMSx0aGlzLl9jb21wbGV0ZWQ9ITEsdGhpcy5faGFsdGVkPSExLHRoaXMuX2lucHV0PW51bGwsdGhpcy5fYmFzZUluZGV4PTAsdGhpcy5fcGFydGlhbExpbmU9XCJcIix0aGlzLl9yb3dDb3VudD0wLHRoaXMuX3N0YXJ0PTAsdGhpcy5fbmV4dENodW5rPW51bGwsdGhpcy5pc0ZpcnN0Q2h1bms9ITAsdGhpcy5fY29tcGxldGVSZXN1bHRzPXtkYXRhOltdLGVycm9yczpbXSxtZXRhOnt9fSxmdW5jdGlvbihlKXt2YXIgdD1iKGUpO3QuY2h1bmtTaXplPXBhcnNlSW50KHQuY2h1bmtTaXplKSxlLnN0ZXB8fGUuY2h1bmt8fCh0LmNodW5rU2l6ZT1udWxsKTt0aGlzLl9oYW5kbGU9bmV3IGkodCksKHRoaXMuX2hhbmRsZS5zdHJlYW1lcj10aGlzKS5fY29uZmlnPXR9LmNhbGwodGhpcyxlKSx0aGlzLnBhcnNlQ2h1bms9ZnVuY3Rpb24odCxlKXt2YXIgaT1wYXJzZUludCh0aGlzLl9jb25maWcuc2tpcEZpcnN0TkxpbmVzKXx8MDtpZih0aGlzLmlzRmlyc3RDaHVuayYmMDxpKXtsZXQgZT10aGlzLl9jb25maWcubmV3bGluZTtlfHwocj10aGlzLl9jb25maWcucXVvdGVDaGFyfHwnXCInLGU9dGhpcy5faGFuZGxlLmd1ZXNzTGluZUVuZGluZ3ModCxyKSksdD1bLi4udC5zcGxpdChlKS5zbGljZShpKV0uam9pbihlKX10aGlzLmlzRmlyc3RDaHVuayYmVSh0aGlzLl9jb25maWcuYmVmb3JlRmlyc3RDaHVuaykmJnZvaWQgMCE9PShyPXRoaXMuX2NvbmZpZy5iZWZvcmVGaXJzdENodW5rKHQpKSYmKHQ9ciksdGhpcy5pc0ZpcnN0Q2h1bms9ITEsdGhpcy5faGFsdGVkPSExO3ZhciBpPXRoaXMuX3BhcnRpYWxMaW5lK3Qscj0odGhpcy5fcGFydGlhbExpbmU9XCJcIix0aGlzLl9oYW5kbGUucGFyc2UoaSx0aGlzLl9iYXNlSW5kZXgsIXRoaXMuX2ZpbmlzaGVkKSk7aWYoIXRoaXMuX2hhbmRsZS5wYXVzZWQoKSYmIXRoaXMuX2hhbmRsZS5hYm9ydGVkKCkpe3Q9ci5tZXRhLmN1cnNvcixpPSh0aGlzLl9maW5pc2hlZHx8KHRoaXMuX3BhcnRpYWxMaW5lPWkuc3Vic3RyaW5nKHQtdGhpcy5fYmFzZUluZGV4KSx0aGlzLl9iYXNlSW5kZXg9dCksciYmci5kYXRhJiYodGhpcy5fcm93Q291bnQrPXIuZGF0YS5sZW5ndGgpLHRoaXMuX2ZpbmlzaGVkfHx0aGlzLl9jb25maWcucHJldmlldyYmdGhpcy5fcm93Q291bnQ+PXRoaXMuX2NvbmZpZy5wcmV2aWV3KTtpZihhKW4ucG9zdE1lc3NhZ2Uoe3Jlc3VsdHM6cix3b3JrZXJJZDp2LldPUktFUl9JRCxmaW5pc2hlZDppfSk7ZWxzZSBpZihVKHRoaXMuX2NvbmZpZy5jaHVuaykmJiFlKXtpZih0aGlzLl9jb25maWcuY2h1bmsocix0aGlzLl9oYW5kbGUpLHRoaXMuX2hhbmRsZS5wYXVzZWQoKXx8dGhpcy5faGFuZGxlLmFib3J0ZWQoKSlyZXR1cm4gdm9pZCh0aGlzLl9oYWx0ZWQ9ITApO3RoaXMuX2NvbXBsZXRlUmVzdWx0cz1yPXZvaWQgMH1yZXR1cm4gdGhpcy5fY29uZmlnLnN0ZXB8fHRoaXMuX2NvbmZpZy5jaHVua3x8KHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhPXRoaXMuX2NvbXBsZXRlUmVzdWx0cy5kYXRhLmNvbmNhdChyLmRhdGEpLHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5lcnJvcnM9dGhpcy5fY29tcGxldGVSZXN1bHRzLmVycm9ycy5jb25jYXQoci5lcnJvcnMpLHRoaXMuX2NvbXBsZXRlUmVzdWx0cy5tZXRhPXIubWV0YSksdGhpcy5fY29tcGxldGVkfHwhaXx8IVUodGhpcy5fY29uZmlnLmNvbXBsZXRlKXx8ciYmci5tZXRhLmFib3J0ZWR8fCh0aGlzLl9jb25maWcuY29tcGxldGUodGhpcy5fY29tcGxldGVSZXN1bHRzLHRoaXMuX2lucHV0KSx0aGlzLl9jb21wbGV0ZWQ9ITApLGl8fHImJnIubWV0YS5wYXVzZWR8fHRoaXMuX25leHRDaHVuaygpLHJ9dGhpcy5faGFsdGVkPSEwfSx0aGlzLl9zZW5kRXJyb3I9ZnVuY3Rpb24oZSl7VSh0aGlzLl9jb25maWcuZXJyb3IpP3RoaXMuX2NvbmZpZy5lcnJvcihlKTphJiZ0aGlzLl9jb25maWcuZXJyb3ImJm4ucG9zdE1lc3NhZ2Uoe3dvcmtlcklkOnYuV09SS0VSX0lELGVycm9yOmUsZmluaXNoZWQ6ITF9KX19ZnVuY3Rpb24gZihlKXt2YXIgcjsoZT1lfHx7fSkuY2h1bmtTaXplfHwoZS5jaHVua1NpemU9di5SZW1vdGVDaHVua1NpemUpLHUuY2FsbCh0aGlzLGUpLHRoaXMuX25leHRDaHVuaz1zP2Z1bmN0aW9uKCl7dGhpcy5fcmVhZENodW5rKCksdGhpcy5fY2h1bmtMb2FkZWQoKX06ZnVuY3Rpb24oKXt0aGlzLl9yZWFkQ2h1bmsoKX0sdGhpcy5zdHJlYW09ZnVuY3Rpb24oZSl7dGhpcy5faW5wdXQ9ZSx0aGlzLl9uZXh0Q2h1bmsoKX0sdGhpcy5fcmVhZENodW5rPWZ1bmN0aW9uKCl7aWYodGhpcy5fZmluaXNoZWQpdGhpcy5fY2h1bmtMb2FkZWQoKTtlbHNle2lmKHI9bmV3IFhNTEh0dHBSZXF1ZXN0LHRoaXMuX2NvbmZpZy53aXRoQ3JlZGVudGlhbHMmJihyLndpdGhDcmVkZW50aWFscz10aGlzLl9jb25maWcud2l0aENyZWRlbnRpYWxzKSxzfHwoci5vbmxvYWQ9eSh0aGlzLl9jaHVua0xvYWRlZCx0aGlzKSxyLm9uZXJyb3I9eSh0aGlzLl9jaHVua0Vycm9yLHRoaXMpKSxyLm9wZW4odGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEJvZHk/XCJQT1NUXCI6XCJHRVRcIix0aGlzLl9pbnB1dCwhcyksdGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEhlYWRlcnMpe3ZhciBlLHQ9dGhpcy5fY29uZmlnLmRvd25sb2FkUmVxdWVzdEhlYWRlcnM7Zm9yKGUgaW4gdClyLnNldFJlcXVlc3RIZWFkZXIoZSx0W2VdKX12YXIgaTt0aGlzLl9jb25maWcuY2h1bmtTaXplJiYoaT10aGlzLl9zdGFydCt0aGlzLl9jb25maWcuY2h1bmtTaXplLTEsci5zZXRSZXF1ZXN0SGVhZGVyKFwiUmFuZ2VcIixcImJ5dGVzPVwiK3RoaXMuX3N0YXJ0K1wiLVwiK2kpKTt0cnl7ci5zZW5kKHRoaXMuX2NvbmZpZy5kb3dubG9hZFJlcXVlc3RCb2R5KX1jYXRjaChlKXt0aGlzLl9jaHVua0Vycm9yKGUubWVzc2FnZSl9cyYmMD09PXIuc3RhdHVzJiZ0aGlzLl9jaHVua0Vycm9yKCl9fSx0aGlzLl9jaHVua0xvYWRlZD1mdW5jdGlvbigpezQ9PT1yLnJlYWR5U3RhdGUmJihyLnN0YXR1czwyMDB8fDQwMDw9ci5zdGF0dXM/dGhpcy5fY2h1bmtFcnJvcigpOih0aGlzLl9zdGFydCs9dGhpcy5fY29uZmlnLmNodW5rU2l6ZXx8ci5yZXNwb25zZVRleHQubGVuZ3RoLHRoaXMuX2ZpbmlzaGVkPSF0aGlzLl9jb25maWcuY2h1bmtTaXplfHx0aGlzLl9zdGFydD49KGU9Pm51bGwhPT0oZT1lLmdldFJlc3BvbnNlSGVhZGVyKFwiQ29udGVudC1SYW5nZVwiKSk/cGFyc2VJbnQoZS5zdWJzdHJpbmcoZS5sYXN0SW5kZXhPZihcIi9cIikrMSkpOi0xKShyKSx0aGlzLnBhcnNlQ2h1bmsoci5yZXNwb25zZVRleHQpKSl9LHRoaXMuX2NodW5rRXJyb3I9ZnVuY3Rpb24oZSl7ZT1yLnN0YXR1c1RleHR8fGU7dGhpcy5fc2VuZEVycm9yKG5ldyBFcnJvcihlKSl9fWZ1bmN0aW9uIGwoZSl7KGU9ZXx8e30pLmNodW5rU2l6ZXx8KGUuY2h1bmtTaXplPXYuTG9jYWxDaHVua1NpemUpLHUuY2FsbCh0aGlzLGUpO3ZhciBpLHIsbj1cInVuZGVmaW5lZFwiIT10eXBlb2YgRmlsZVJlYWRlcjt0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXt0aGlzLl9pbnB1dD1lLHI9ZS5zbGljZXx8ZS53ZWJraXRTbGljZXx8ZS5tb3pTbGljZSxuPygoaT1uZXcgRmlsZVJlYWRlcikub25sb2FkPXkodGhpcy5fY2h1bmtMb2FkZWQsdGhpcyksaS5vbmVycm9yPXkodGhpcy5fY2h1bmtFcnJvcix0aGlzKSk6aT1uZXcgRmlsZVJlYWRlclN5bmMsdGhpcy5fbmV4dENodW5rKCl9LHRoaXMuX25leHRDaHVuaz1mdW5jdGlvbigpe3RoaXMuX2ZpbmlzaGVkfHx0aGlzLl9jb25maWcucHJldmlldyYmISh0aGlzLl9yb3dDb3VudDx0aGlzLl9jb25maWcucHJldmlldyl8fHRoaXMuX3JlYWRDaHVuaygpfSx0aGlzLl9yZWFkQ2h1bms9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9pbnB1dCx0PSh0aGlzLl9jb25maWcuY2h1bmtTaXplJiYodD1NYXRoLm1pbih0aGlzLl9zdGFydCt0aGlzLl9jb25maWcuY2h1bmtTaXplLHRoaXMuX2lucHV0LnNpemUpLGU9ci5jYWxsKGUsdGhpcy5fc3RhcnQsdCkpLGkucmVhZEFzVGV4dChlLHRoaXMuX2NvbmZpZy5lbmNvZGluZykpO258fHRoaXMuX2NodW5rTG9hZGVkKHt0YXJnZXQ6e3Jlc3VsdDp0fX0pfSx0aGlzLl9jaHVua0xvYWRlZD1mdW5jdGlvbihlKXt0aGlzLl9zdGFydCs9dGhpcy5fY29uZmlnLmNodW5rU2l6ZSx0aGlzLl9maW5pc2hlZD0hdGhpcy5fY29uZmlnLmNodW5rU2l6ZXx8dGhpcy5fc3RhcnQ+PXRoaXMuX2lucHV0LnNpemUsdGhpcy5wYXJzZUNodW5rKGUudGFyZ2V0LnJlc3VsdCl9LHRoaXMuX2NodW5rRXJyb3I9ZnVuY3Rpb24oKXt0aGlzLl9zZW5kRXJyb3IoaS5lcnJvcil9fWZ1bmN0aW9uIGMoZSl7dmFyIGk7dS5jYWxsKHRoaXMsZT1lfHx7fSksdGhpcy5zdHJlYW09ZnVuY3Rpb24oZSl7cmV0dXJuIGk9ZSx0aGlzLl9uZXh0Q2h1bmsoKX0sdGhpcy5fbmV4dENodW5rPWZ1bmN0aW9uKCl7dmFyIGUsdDtpZighdGhpcy5fZmluaXNoZWQpcmV0dXJuIGU9dGhpcy5fY29uZmlnLmNodW5rU2l6ZSxpPWU/KHQ9aS5zdWJzdHJpbmcoMCxlKSxpLnN1YnN0cmluZyhlKSk6KHQ9aSxcIlwiKSx0aGlzLl9maW5pc2hlZD0haSx0aGlzLnBhcnNlQ2h1bmsodCl9fWZ1bmN0aW9uIHAoZSl7dS5jYWxsKHRoaXMsZT1lfHx7fSk7dmFyIHQ9W10saT0hMCxyPSExO3RoaXMucGF1c2U9ZnVuY3Rpb24oKXt1LnByb3RvdHlwZS5wYXVzZS5hcHBseSh0aGlzLGFyZ3VtZW50cyksdGhpcy5faW5wdXQucGF1c2UoKX0sdGhpcy5yZXN1bWU9ZnVuY3Rpb24oKXt1LnByb3RvdHlwZS5yZXN1bWUuYXBwbHkodGhpcyxhcmd1bWVudHMpLHRoaXMuX2lucHV0LnJlc3VtZSgpfSx0aGlzLnN0cmVhbT1mdW5jdGlvbihlKXt0aGlzLl9pbnB1dD1lLHRoaXMuX2lucHV0Lm9uKFwiZGF0YVwiLHRoaXMuX3N0cmVhbURhdGEpLHRoaXMuX2lucHV0Lm9uKFwiZW5kXCIsdGhpcy5fc3RyZWFtRW5kKSx0aGlzLl9pbnB1dC5vbihcImVycm9yXCIsdGhpcy5fc3RyZWFtRXJyb3IpfSx0aGlzLl9jaGVja0lzRmluaXNoZWQ9ZnVuY3Rpb24oKXtyJiYxPT09dC5sZW5ndGgmJih0aGlzLl9maW5pc2hlZD0hMCl9LHRoaXMuX25leHRDaHVuaz1mdW5jdGlvbigpe3RoaXMuX2NoZWNrSXNGaW5pc2hlZCgpLHQubGVuZ3RoP3RoaXMucGFyc2VDaHVuayh0LnNoaWZ0KCkpOmk9ITB9LHRoaXMuX3N0cmVhbURhdGE9eShmdW5jdGlvbihlKXt0cnl7dC5wdXNoKFwic3RyaW5nXCI9PXR5cGVvZiBlP2U6ZS50b1N0cmluZyh0aGlzLl9jb25maWcuZW5jb2RpbmcpKSxpJiYoaT0hMSx0aGlzLl9jaGVja0lzRmluaXNoZWQoKSx0aGlzLnBhcnNlQ2h1bmsodC5zaGlmdCgpKSl9Y2F0Y2goZSl7dGhpcy5fc3RyZWFtRXJyb3IoZSl9fSx0aGlzKSx0aGlzLl9zdHJlYW1FcnJvcj15KGZ1bmN0aW9uKGUpe3RoaXMuX3N0cmVhbUNsZWFuVXAoKSx0aGlzLl9zZW5kRXJyb3IoZSl9LHRoaXMpLHRoaXMuX3N0cmVhbUVuZD15KGZ1bmN0aW9uKCl7dGhpcy5fc3RyZWFtQ2xlYW5VcCgpLHI9ITAsdGhpcy5fc3RyZWFtRGF0YShcIlwiKX0sdGhpcyksdGhpcy5fc3RyZWFtQ2xlYW5VcD15KGZ1bmN0aW9uKCl7dGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoXCJkYXRhXCIsdGhpcy5fc3RyZWFtRGF0YSksdGhpcy5faW5wdXQucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIix0aGlzLl9zdHJlYW1FbmQpLHRoaXMuX2lucHV0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIix0aGlzLl9zdHJlYW1FcnJvcil9LHRoaXMpfWZ1bmN0aW9uIGkobSl7dmFyIG4scyxhLHQsbz1NYXRoLnBvdygyLDUzKSxoPS1vLHU9L15cXHMqLT8oXFxkK1xcLj98XFwuXFxkK3xcXGQrXFwuXFxkKykoW2VFXVstK10/XFxkKyk/XFxzKiQvLGQ9L14oKFxcZHs0fS1bMDFdXFxkLVswLTNdXFxkVFswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkXFwuXFxkKyhbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpfChcXGR7NH0tWzAxXVxcZC1bMC0zXVxcZFRbMC0yXVxcZDpbMC01XVxcZChbKy1dWzAtMl1cXGQ6WzAtNV1cXGR8WikpKSQvLGk9dGhpcyxyPTAsZj0wLGw9ITEsZT0hMSxjPVtdLHA9e2RhdGE6W10sZXJyb3JzOltdLG1ldGE6e319O2Z1bmN0aW9uIHkoZSl7cmV0dXJuXCJncmVlZHlcIj09PW0uc2tpcEVtcHR5TGluZXM/XCJcIj09PWUuam9pbihcIlwiKS50cmltKCk6MT09PWUubGVuZ3RoJiYwPT09ZVswXS5sZW5ndGh9ZnVuY3Rpb24gZygpe2lmKHAmJmEmJihrKFwiRGVsaW1pdGVyXCIsXCJVbmRldGVjdGFibGVEZWxpbWl0ZXJcIixcIlVuYWJsZSB0byBhdXRvLWRldGVjdCBkZWxpbWl0aW5nIGNoYXJhY3RlcjsgZGVmYXVsdGVkIHRvICdcIit2LkRlZmF1bHREZWxpbWl0ZXIrXCInXCIpLGE9ITEpLG0uc2tpcEVtcHR5TGluZXMmJihwLmRhdGE9cC5kYXRhLmZpbHRlcihmdW5jdGlvbihlKXtyZXR1cm4heShlKX0pKSxfKCkpe2lmKHApaWYoQXJyYXkuaXNBcnJheShwLmRhdGFbMF0pKXtmb3IodmFyIGU9MDtfKCkmJmU8cC5kYXRhLmxlbmd0aDtlKyspcC5kYXRhW2VdLmZvckVhY2godCk7cC5kYXRhLnNwbGljZSgwLDEpfWVsc2UgcC5kYXRhLmZvckVhY2godCk7ZnVuY3Rpb24gdChlLHQpe1UobS50cmFuc2Zvcm1IZWFkZXIpJiYoZT1tLnRyYW5zZm9ybUhlYWRlcihlLHQpKSxjLnB1c2goZSl9fWZ1bmN0aW9uIGkoZSx0KXtmb3IodmFyIGk9bS5oZWFkZXI/e306W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgbj1yLHM9ZVtyXSxzPSgoZSx0KT0+KGU9PihtLmR5bmFtaWNUeXBpbmdGdW5jdGlvbiYmdm9pZCAwPT09bS5keW5hbWljVHlwaW5nW2VdJiYobS5keW5hbWljVHlwaW5nW2VdPW0uZHluYW1pY1R5cGluZ0Z1bmN0aW9uKGUpKSwhMD09PShtLmR5bmFtaWNUeXBpbmdbZV18fG0uZHluYW1pY1R5cGluZykpKShlKT9cInRydWVcIj09PXR8fFwiVFJVRVwiPT09dHx8XCJmYWxzZVwiIT09dCYmXCJGQUxTRVwiIT09dCYmKChlPT57aWYodS50ZXN0KGUpKXtlPXBhcnNlRmxvYXQoZSk7aWYoaDxlJiZlPG8pcmV0dXJuIDF9fSkodCk/cGFyc2VGbG9hdCh0KTpkLnRlc3QodCk/bmV3IERhdGUodCk6XCJcIj09PXQ/bnVsbDp0KTp0KShuPW0uaGVhZGVyP3I+PWMubGVuZ3RoP1wiX19wYXJzZWRfZXh0cmFcIjpjW3JdOm4scz1tLnRyYW5zZm9ybT9tLnRyYW5zZm9ybShzLG4pOnMpO1wiX19wYXJzZWRfZXh0cmFcIj09PW4/KGlbbl09aVtuXXx8W10saVtuXS5wdXNoKHMpKTppW25dPXN9cmV0dXJuIG0uaGVhZGVyJiYocj5jLmxlbmd0aD9rKFwiRmllbGRNaXNtYXRjaFwiLFwiVG9vTWFueUZpZWxkc1wiLFwiVG9vIG1hbnkgZmllbGRzOiBleHBlY3RlZCBcIitjLmxlbmd0aCtcIiBmaWVsZHMgYnV0IHBhcnNlZCBcIityLGYrdCk6cjxjLmxlbmd0aCYmayhcIkZpZWxkTWlzbWF0Y2hcIixcIlRvb0Zld0ZpZWxkc1wiLFwiVG9vIGZldyBmaWVsZHM6IGV4cGVjdGVkIFwiK2MubGVuZ3RoK1wiIGZpZWxkcyBidXQgcGFyc2VkIFwiK3IsZit0KSksaX12YXIgcjtwJiYobS5oZWFkZXJ8fG0uZHluYW1pY1R5cGluZ3x8bS50cmFuc2Zvcm0pJiYocj0xLCFwLmRhdGEubGVuZ3RofHxBcnJheS5pc0FycmF5KHAuZGF0YVswXSk/KHAuZGF0YT1wLmRhdGEubWFwKGkpLHI9cC5kYXRhLmxlbmd0aCk6cC5kYXRhPWkocC5kYXRhLDApLG0uaGVhZGVyJiZwLm1ldGEmJihwLm1ldGEuZmllbGRzPWMpLGYrPXIpfWZ1bmN0aW9uIF8oKXtyZXR1cm4gbS5oZWFkZXImJjA9PT1jLmxlbmd0aH1mdW5jdGlvbiBrKGUsdCxpLHIpe2U9e3R5cGU6ZSxjb2RlOnQsbWVzc2FnZTppfTt2b2lkIDAhPT1yJiYoZS5yb3c9cikscC5lcnJvcnMucHVzaChlKX1VKG0uc3RlcCkmJih0PW0uc3RlcCxtLnN0ZXA9ZnVuY3Rpb24oZSl7cD1lLF8oKT9nKCk6KGcoKSwwIT09cC5kYXRhLmxlbmd0aCYmKHIrPWUuZGF0YS5sZW5ndGgsbS5wcmV2aWV3JiZyPm0ucHJldmlldz9zLmFib3J0KCk6KHAuZGF0YT1wLmRhdGFbMF0sdChwLGkpKSkpfSksdGhpcy5wYXJzZT1mdW5jdGlvbihlLHQsaSl7dmFyIHI9bS5xdW90ZUNoYXJ8fCdcIicscj0obS5uZXdsaW5lfHwobS5uZXdsaW5lPXRoaXMuZ3Vlc3NMaW5lRW5kaW5ncyhlLHIpKSxhPSExLG0uZGVsaW1pdGVyP1UobS5kZWxpbWl0ZXIpJiYobS5kZWxpbWl0ZXI9bS5kZWxpbWl0ZXIoZSkscC5tZXRhLmRlbGltaXRlcj1tLmRlbGltaXRlcik6KChyPSgoZSx0LGkscixuKT0+e3ZhciBzLGEsbyxoO249bnx8W1wiLFwiLFwiXFx0XCIsXCJ8XCIsXCI7XCIsdi5SRUNPUkRfU0VQLHYuVU5JVF9TRVBdO2Zvcih2YXIgdT0wO3U8bi5sZW5ndGg7dSsrKXtmb3IodmFyIGQsZj1uW3VdLGw9MCxjPTAscD0wLGc9KG89dm9pZCAwLG5ldyBFKHtjb21tZW50czpyLGRlbGltaXRlcjpmLG5ld2xpbmU6dCxwcmV2aWV3OjEwfSkucGFyc2UoZSkpLF89MDtfPGcuZGF0YS5sZW5ndGg7XysrKWkmJnkoZy5kYXRhW19dKT9wKys6KGQ9Zy5kYXRhW19dLmxlbmd0aCxjKz1kLHZvaWQgMD09PW8/bz1kOjA8ZCYmKGwrPU1hdGguYWJzKGQtbyksbz1kKSk7MDxnLmRhdGEubGVuZ3RoJiYoYy89Zy5kYXRhLmxlbmd0aC1wKSwodm9pZCAwPT09YXx8bDw9YSkmJih2b2lkIDA9PT1ofHxoPGMpJiYxLjk5PGMmJihhPWwscz1mLGg9Yyl9cmV0dXJue3N1Y2Nlc3NmdWw6ISEobS5kZWxpbWl0ZXI9cyksYmVzdERlbGltaXRlcjpzfX0pKGUsbS5uZXdsaW5lLG0uc2tpcEVtcHR5TGluZXMsbS5jb21tZW50cyxtLmRlbGltaXRlcnNUb0d1ZXNzKSkuc3VjY2Vzc2Z1bD9tLmRlbGltaXRlcj1yLmJlc3REZWxpbWl0ZXI6KGE9ITAsbS5kZWxpbWl0ZXI9di5EZWZhdWx0RGVsaW1pdGVyKSxwLm1ldGEuZGVsaW1pdGVyPW0uZGVsaW1pdGVyKSxiKG0pKTtyZXR1cm4gbS5wcmV2aWV3JiZtLmhlYWRlciYmci5wcmV2aWV3Kyssbj1lLHM9bmV3IEUocikscD1zLnBhcnNlKG4sdCxpKSxnKCksbD97bWV0YTp7cGF1c2VkOiEwfX06cHx8e21ldGE6e3BhdXNlZDohMX19fSx0aGlzLnBhdXNlZD1mdW5jdGlvbigpe3JldHVybiBsfSx0aGlzLnBhdXNlPWZ1bmN0aW9uKCl7bD0hMCxzLmFib3J0KCksbj1VKG0uY2h1bmspP1wiXCI6bi5zdWJzdHJpbmcocy5nZXRDaGFySW5kZXgoKSl9LHRoaXMucmVzdW1lPWZ1bmN0aW9uKCl7aS5zdHJlYW1lci5faGFsdGVkPyhsPSExLGkuc3RyZWFtZXIucGFyc2VDaHVuayhuLCEwKSk6c2V0VGltZW91dChpLnJlc3VtZSwzKX0sdGhpcy5hYm9ydGVkPWZ1bmN0aW9uKCl7cmV0dXJuIGV9LHRoaXMuYWJvcnQ9ZnVuY3Rpb24oKXtlPSEwLHMuYWJvcnQoKSxwLm1ldGEuYWJvcnRlZD0hMCxVKG0uY29tcGxldGUpJiZtLmNvbXBsZXRlKHApLG49XCJcIn0sdGhpcy5ndWVzc0xpbmVFbmRpbmdzPWZ1bmN0aW9uKGUsdCl7ZT1lLnN1YnN0cmluZygwLDEwNDg1NzYpO3ZhciB0PW5ldyBSZWdFeHAoUCh0KStcIihbXl0qPylcIitQKHQpLFwiZ21cIiksaT0oZT1lLnJlcGxhY2UodCxcIlwiKSkuc3BsaXQoXCJcXHJcIiksdD1lLnNwbGl0KFwiXFxuXCIpLGU9MTx0Lmxlbmd0aCYmdFswXS5sZW5ndGg8aVswXS5sZW5ndGg7aWYoMT09PWkubGVuZ3RofHxlKXJldHVyblwiXFxuXCI7Zm9yKHZhciByPTAsbj0wO248aS5sZW5ndGg7bisrKVwiXFxuXCI9PT1pW25dWzBdJiZyKys7cmV0dXJuIHI+PWkubGVuZ3RoLzI/XCJcXHJcXG5cIjpcIlxcclwifX1mdW5jdGlvbiBQKGUpe3JldHVybiBlLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLFwiXFxcXCQmXCIpfWZ1bmN0aW9uIEUoQyl7dmFyIFM9KEM9Q3x8e30pLmRlbGltaXRlcixPPUMubmV3bGluZSx4PUMuY29tbWVudHMsST1DLnN0ZXAsQT1DLnByZXZpZXcsVD1DLmZhc3RNb2RlLEQ9bnVsbCxMPSExLEY9bnVsbD09Qy5xdW90ZUNoYXI/J1wiJzpDLnF1b3RlQ2hhcixqPUY7aWYodm9pZCAwIT09Qy5lc2NhcGVDaGFyJiYoaj1DLmVzY2FwZUNoYXIpLChcInN0cmluZ1wiIT10eXBlb2YgU3x8LTE8di5CQURfREVMSU1JVEVSUy5pbmRleE9mKFMpKSYmKFM9XCIsXCIpLHg9PT1TKXRocm93IG5ldyBFcnJvcihcIkNvbW1lbnQgY2hhcmFjdGVyIHNhbWUgYXMgZGVsaW1pdGVyXCIpOyEwPT09eD94PVwiI1wiOihcInN0cmluZ1wiIT10eXBlb2YgeHx8LTE8di5CQURfREVMSU1JVEVSUy5pbmRleE9mKHgpKSYmKHg9ITEpLFwiXFxuXCIhPT1PJiZcIlxcclwiIT09TyYmXCJcXHJcXG5cIiE9PU8mJihPPVwiXFxuXCIpO3ZhciB6PTAsTT0hMTt0aGlzLnBhcnNlPWZ1bmN0aW9uKGksdCxyKXtpZihcInN0cmluZ1wiIT10eXBlb2YgaSl0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBtdXN0IGJlIGEgc3RyaW5nXCIpO3ZhciBuPWkubGVuZ3RoLGU9Uy5sZW5ndGgscz1PLmxlbmd0aCxhPXgubGVuZ3RoLG89VShJKSxoPVtdLHU9W10sZD1bXSxmPXo9MDtpZighaSlyZXR1cm4gdygpO2lmKFR8fCExIT09VCYmLTE9PT1pLmluZGV4T2YoRikpe2Zvcih2YXIgbD1pLnNwbGl0KE8pLGM9MDtjPGwubGVuZ3RoO2MrKyl7aWYoZD1sW2NdLHorPWQubGVuZ3RoLGMhPT1sLmxlbmd0aC0xKXorPU8ubGVuZ3RoO2Vsc2UgaWYocilyZXR1cm4gdygpO2lmKCF4fHxkLnN1YnN0cmluZygwLGEpIT09eCl7aWYobyl7aWYoaD1bXSxrKGQuc3BsaXQoUykpLFIoKSxNKXJldHVybiB3KCl9ZWxzZSBrKGQuc3BsaXQoUykpO2lmKEEmJkE8PWMpcmV0dXJuIGg9aC5zbGljZSgwLEEpLHcoITApfX1yZXR1cm4gdygpfWZvcih2YXIgcD1pLmluZGV4T2YoUyx6KSxnPWkuaW5kZXhPZihPLHopLF89bmV3IFJlZ0V4cChQKGopK1AoRiksXCJnXCIpLG09aS5pbmRleE9mKEYseik7OylpZihpW3pdPT09Rilmb3IobT16LHorKzs7KXtpZigtMT09PShtPWkuaW5kZXhPZihGLG0rMSkpKXJldHVybiByfHx1LnB1c2goe3R5cGU6XCJRdW90ZXNcIixjb2RlOlwiTWlzc2luZ1F1b3Rlc1wiLG1lc3NhZ2U6XCJRdW90ZWQgZmllbGQgdW50ZXJtaW5hdGVkXCIscm93OmgubGVuZ3RoLGluZGV4Onp9KSxFKCk7aWYobT09PW4tMSlyZXR1cm4gRShpLnN1YnN0cmluZyh6LG0pLnJlcGxhY2UoXyxGKSk7aWYoRj09PWomJmlbbSsxXT09PWopbSsrO2Vsc2UgaWYoRj09PWp8fDA9PT1tfHxpW20tMV0hPT1qKXstMSE9PXAmJnA8bSsxJiYocD1pLmluZGV4T2YoUyxtKzEpKTt2YXIgeT12KC0xPT09KGc9LTEhPT1nJiZnPG0rMT9pLmluZGV4T2YoTyxtKzEpOmcpP3A6TWF0aC5taW4ocCxnKSk7aWYoaS5zdWJzdHIobSsxK3ksZSk9PT1TKXtkLnB1c2goaS5zdWJzdHJpbmcoeixtKS5yZXBsYWNlKF8sRikpLGlbej1tKzEreStlXSE9PUYmJihtPWkuaW5kZXhPZihGLHopKSxwPWkuaW5kZXhPZihTLHopLGc9aS5pbmRleE9mKE8seik7YnJlYWt9eT12KGcpO2lmKGkuc3Vic3RyaW5nKG0rMSt5LG0rMSt5K3MpPT09Tyl7aWYoZC5wdXNoKGkuc3Vic3RyaW5nKHosbSkucmVwbGFjZShfLEYpKSxiKG0rMSt5K3MpLHA9aS5pbmRleE9mKFMseiksbT1pLmluZGV4T2YoRix6KSxvJiYoUigpLE0pKXJldHVybiB3KCk7aWYoQSYmaC5sZW5ndGg+PUEpcmV0dXJuIHcoITApO2JyZWFrfXUucHVzaCh7dHlwZTpcIlF1b3Rlc1wiLGNvZGU6XCJJbnZhbGlkUXVvdGVzXCIsbWVzc2FnZTpcIlRyYWlsaW5nIHF1b3RlIG9uIHF1b3RlZCBmaWVsZCBpcyBtYWxmb3JtZWRcIixyb3c6aC5sZW5ndGgsaW5kZXg6en0pLG0rK319ZWxzZSBpZih4JiYwPT09ZC5sZW5ndGgmJmkuc3Vic3RyaW5nKHoseithKT09PXgpe2lmKC0xPT09ZylyZXR1cm4gdygpO3o9ZytzLGc9aS5pbmRleE9mKE8seikscD1pLmluZGV4T2YoUyx6KX1lbHNlIGlmKC0xIT09cCYmKHA8Z3x8LTE9PT1nKSlkLnB1c2goaS5zdWJzdHJpbmcoeixwKSksej1wK2UscD1pLmluZGV4T2YoUyx6KTtlbHNle2lmKC0xPT09ZylicmVhaztpZihkLnB1c2goaS5zdWJzdHJpbmcoeixnKSksYihnK3MpLG8mJihSKCksTSkpcmV0dXJuIHcoKTtpZihBJiZoLmxlbmd0aD49QSlyZXR1cm4gdyghMCl9cmV0dXJuIEUoKTtmdW5jdGlvbiBrKGUpe2gucHVzaChlKSxmPXp9ZnVuY3Rpb24gdihlKXt2YXIgdD0wO3JldHVybiB0PS0xIT09ZSYmKGU9aS5zdWJzdHJpbmcobSsxLGUpKSYmXCJcIj09PWUudHJpbSgpP2UubGVuZ3RoOnR9ZnVuY3Rpb24gRShlKXtyZXR1cm4gcnx8KHZvaWQgMD09PWUmJihlPWkuc3Vic3RyaW5nKHopKSxkLnB1c2goZSksej1uLGsoZCksbyYmUigpKSx3KCl9ZnVuY3Rpb24gYihlKXt6PWUsayhkKSxkPVtdLGc9aS5pbmRleE9mKE8seil9ZnVuY3Rpb24gdyhlKXtpZihDLmhlYWRlciYmIXQmJmgubGVuZ3RoJiYhTCl7dmFyIHM9aFswXSxhPU9iamVjdC5jcmVhdGUobnVsbCksbz1uZXcgU2V0KHMpO2xldCBuPSExO2ZvcihsZXQgcj0wO3I8cy5sZW5ndGg7cisrKXtsZXQgaT1zW3JdO2lmKGFbaT1VKEMudHJhbnNmb3JtSGVhZGVyKT9DLnRyYW5zZm9ybUhlYWRlcihpLHIpOmldKXtsZXQgZSx0PWFbaV07Zm9yKDtlPWkrXCJfXCIrdCx0Kyssby5oYXMoZSk7KTtvLmFkZChlKSxzW3JdPWUsYVtpXSsrLG49ITAsKEQ9bnVsbD09PUQ/e306RClbZV09aX1lbHNlIGFbaV09MSxzW3JdPWk7by5hZGQoaSl9biYmY29uc29sZS53YXJuKFwiRHVwbGljYXRlIGhlYWRlcnMgZm91bmQgYW5kIHJlbmFtZWQuXCIpLEw9ITB9cmV0dXJue2RhdGE6aCxlcnJvcnM6dSxtZXRhOntkZWxpbWl0ZXI6UyxsaW5lYnJlYWs6TyxhYm9ydGVkOk0sdHJ1bmNhdGVkOiEhZSxjdXJzb3I6ZisodHx8MCkscmVuYW1lZEhlYWRlcnM6RH19fWZ1bmN0aW9uIFIoKXtJKHcoKSksaD1bXSx1PVtdfX0sdGhpcy5hYm9ydD1mdW5jdGlvbigpe009ITB9LHRoaXMuZ2V0Q2hhckluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHp9fWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZS5kYXRhLGk9b1t0LndvcmtlcklkXSxyPSExO2lmKHQuZXJyb3IpaS51c2VyRXJyb3IodC5lcnJvcix0LmZpbGUpO2Vsc2UgaWYodC5yZXN1bHRzJiZ0LnJlc3VsdHMuZGF0YSl7dmFyIG49e2Fib3J0OmZ1bmN0aW9uKCl7cj0hMCxfKHQud29ya2VySWQse2RhdGE6W10sZXJyb3JzOltdLG1ldGE6e2Fib3J0ZWQ6ITB9fSl9LHBhdXNlOm0scmVzdW1lOm19O2lmKFUoaS51c2VyU3RlcCkpe2Zvcih2YXIgcz0wO3M8dC5yZXN1bHRzLmRhdGEubGVuZ3RoJiYoaS51c2VyU3RlcCh7ZGF0YTp0LnJlc3VsdHMuZGF0YVtzXSxlcnJvcnM6dC5yZXN1bHRzLmVycm9ycyxtZXRhOnQucmVzdWx0cy5tZXRhfSxuKSwhcik7cysrKTtkZWxldGUgdC5yZXN1bHRzfWVsc2UgVShpLnVzZXJDaHVuaykmJihpLnVzZXJDaHVuayh0LnJlc3VsdHMsbix0LmZpbGUpLGRlbGV0ZSB0LnJlc3VsdHMpfXQuZmluaXNoZWQmJiFyJiZfKHQud29ya2VySWQsdC5yZXN1bHRzKX1mdW5jdGlvbiBfKGUsdCl7dmFyIGk9b1tlXTtVKGkudXNlckNvbXBsZXRlKSYmaS51c2VyQ29tcGxldGUodCksaS50ZXJtaW5hdGUoKSxkZWxldGUgb1tlXX1mdW5jdGlvbiBtKCl7dGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkLlwiKX1mdW5jdGlvbiBiKGUpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBlfHxudWxsPT09ZSlyZXR1cm4gZTt2YXIgdCxpPUFycmF5LmlzQXJyYXkoZSk/W106e307Zm9yKHQgaW4gZSlpW3RdPWIoZVt0XSk7cmV0dXJuIGl9ZnVuY3Rpb24geShlLHQpe3JldHVybiBmdW5jdGlvbigpe2UuYXBwbHkodCxhcmd1bWVudHMpfX1mdW5jdGlvbiBVKGUpe3JldHVyblwiZnVuY3Rpb25cIj09dHlwZW9mIGV9cmV0dXJuIHYucGFyc2U9ZnVuY3Rpb24oZSx0KXt2YXIgaT0odD10fHx7fSkuZHluYW1pY1R5cGluZ3x8ITE7VShpKSYmKHQuZHluYW1pY1R5cGluZ0Z1bmN0aW9uPWksaT17fSk7aWYodC5keW5hbWljVHlwaW5nPWksdC50cmFuc2Zvcm09ISFVKHQudHJhbnNmb3JtKSYmdC50cmFuc2Zvcm0sIXQud29ya2VyfHwhdi5XT1JLRVJTX1NVUFBPUlRFRClyZXR1cm4gaT1udWxsLHYuTk9ERV9TVFJFQU1fSU5QVVQsXCJzdHJpbmdcIj09dHlwZW9mIGU/KGU9KGU9PjY1Mjc5IT09ZS5jaGFyQ29kZUF0KDApP2U6ZS5zbGljZSgxKSkoZSksaT1uZXcodC5kb3dubG9hZD9mOmMpKHQpKTohMD09PWUucmVhZGFibGUmJlUoZS5yZWFkKSYmVShlLm9uKT9pPW5ldyBwKHQpOihuLkZpbGUmJmUgaW5zdGFuY2VvZiBGaWxlfHxlIGluc3RhbmNlb2YgT2JqZWN0KSYmKGk9bmV3IGwodCkpLGkuc3RyZWFtKGUpOyhpPSgoKT0+e3ZhciBlO3JldHVybiEhdi5XT1JLRVJTX1NVUFBPUlRFRCYmKGU9KCgpPT57dmFyIGU9bi5VUkx8fG4ud2Via2l0VVJMfHxudWxsLHQ9ci50b1N0cmluZygpO3JldHVybiB2LkJMT0JfVVJMfHwodi5CTE9CX1VSTD1lLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbXCJ2YXIgZ2xvYmFsID0gKGZ1bmN0aW9uKCkgeyBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSB7IHJldHVybiBzZWxmOyB9IGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gd2luZG93OyB9IGlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykgeyByZXR1cm4gZ2xvYmFsOyB9IHJldHVybiB7fTsgfSkoKTsgZ2xvYmFsLklTX1BBUEFfV09SS0VSPXRydWU7IFwiLFwiKFwiLHQsXCIpKCk7XCJdLHt0eXBlOlwidGV4dC9qYXZhc2NyaXB0XCJ9KSkpfSkoKSwoZT1uZXcgbi5Xb3JrZXIoZSkpLm9ubWVzc2FnZT1nLGUuaWQ9aCsrLG9bZS5pZF09ZSl9KSgpKS51c2VyU3RlcD10LnN0ZXAsaS51c2VyQ2h1bms9dC5jaHVuayxpLnVzZXJDb21wbGV0ZT10LmNvbXBsZXRlLGkudXNlckVycm9yPXQuZXJyb3IsdC5zdGVwPVUodC5zdGVwKSx0LmNodW5rPVUodC5jaHVuayksdC5jb21wbGV0ZT1VKHQuY29tcGxldGUpLHQuZXJyb3I9VSh0LmVycm9yKSxkZWxldGUgdC53b3JrZXIsaS5wb3N0TWVzc2FnZSh7aW5wdXQ6ZSxjb25maWc6dCx3b3JrZXJJZDppLmlkfSl9LHYudW5wYXJzZT1mdW5jdGlvbihlLHQpe3ZhciBuPSExLF89ITAsbT1cIixcIix5PVwiXFxyXFxuXCIscz0nXCInLGE9cytzLGk9ITEscj1udWxsLG89ITEsaD0oKCgpPT57aWYoXCJvYmplY3RcIj09dHlwZW9mIHQpe2lmKFwic3RyaW5nXCIhPXR5cGVvZiB0LmRlbGltaXRlcnx8di5CQURfREVMSU1JVEVSUy5maWx0ZXIoZnVuY3Rpb24oZSl7cmV0dXJuLTEhPT10LmRlbGltaXRlci5pbmRleE9mKGUpfSkubGVuZ3RofHwobT10LmRlbGltaXRlciksXCJib29sZWFuXCIhPXR5cGVvZiB0LnF1b3RlcyYmXCJmdW5jdGlvblwiIT10eXBlb2YgdC5xdW90ZXMmJiFBcnJheS5pc0FycmF5KHQucXVvdGVzKXx8KG49dC5xdW90ZXMpLFwiYm9vbGVhblwiIT10eXBlb2YgdC5za2lwRW1wdHlMaW5lcyYmXCJzdHJpbmdcIiE9dHlwZW9mIHQuc2tpcEVtcHR5TGluZXN8fChpPXQuc2tpcEVtcHR5TGluZXMpLFwic3RyaW5nXCI9PXR5cGVvZiB0Lm5ld2xpbmUmJih5PXQubmV3bGluZSksXCJzdHJpbmdcIj09dHlwZW9mIHQucXVvdGVDaGFyJiYocz10LnF1b3RlQ2hhciksXCJib29sZWFuXCI9PXR5cGVvZiB0LmhlYWRlciYmKF89dC5oZWFkZXIpLEFycmF5LmlzQXJyYXkodC5jb2x1bW5zKSl7aWYoMD09PXQuY29sdW1ucy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiT3B0aW9uIGNvbHVtbnMgaXMgZW1wdHlcIik7cj10LmNvbHVtbnN9dm9pZCAwIT09dC5lc2NhcGVDaGFyJiYoYT10LmVzY2FwZUNoYXIrcyksdC5lc2NhcGVGb3JtdWxhZSBpbnN0YW5jZW9mIFJlZ0V4cD9vPXQuZXNjYXBlRm9ybXVsYWU6XCJib29sZWFuXCI9PXR5cGVvZiB0LmVzY2FwZUZvcm11bGFlJiZ0LmVzY2FwZUZvcm11bGFlJiYobz0vXls9K1xcLUBcXHRcXHJdLiokLyl9fSkoKSxuZXcgUmVnRXhwKFAocyksXCJnXCIpKTtcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9SlNPTi5wYXJzZShlKSk7aWYoQXJyYXkuaXNBcnJheShlKSl7aWYoIWUubGVuZ3RofHxBcnJheS5pc0FycmF5KGVbMF0pKXJldHVybiB1KG51bGwsZSxpKTtpZihcIm9iamVjdFwiPT10eXBlb2YgZVswXSlyZXR1cm4gdShyfHxPYmplY3Qua2V5cyhlWzBdKSxlLGkpfWVsc2UgaWYoXCJvYmplY3RcIj09dHlwZW9mIGUpcmV0dXJuXCJzdHJpbmdcIj09dHlwZW9mIGUuZGF0YSYmKGUuZGF0YT1KU09OLnBhcnNlKGUuZGF0YSkpLEFycmF5LmlzQXJyYXkoZS5kYXRhKSYmKGUuZmllbGRzfHwoZS5maWVsZHM9ZS5tZXRhJiZlLm1ldGEuZmllbGRzfHxyKSxlLmZpZWxkc3x8KGUuZmllbGRzPUFycmF5LmlzQXJyYXkoZS5kYXRhWzBdKT9lLmZpZWxkczpcIm9iamVjdFwiPT10eXBlb2YgZS5kYXRhWzBdP09iamVjdC5rZXlzKGUuZGF0YVswXSk6W10pLEFycmF5LmlzQXJyYXkoZS5kYXRhWzBdKXx8XCJvYmplY3RcIj09dHlwZW9mIGUuZGF0YVswXXx8KGUuZGF0YT1bZS5kYXRhXSkpLHUoZS5maWVsZHN8fFtdLGUuZGF0YXx8W10saSk7dGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIHNlcmlhbGl6ZSB1bnJlY29nbml6ZWQgaW5wdXRcIik7ZnVuY3Rpb24gdShlLHQsaSl7dmFyIHI9XCJcIixuPShcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9SlNPTi5wYXJzZShlKSksXCJzdHJpbmdcIj09dHlwZW9mIHQmJih0PUpTT04ucGFyc2UodCkpLEFycmF5LmlzQXJyYXkoZSkmJjA8ZS5sZW5ndGgpLHM9IUFycmF5LmlzQXJyYXkodFswXSk7aWYobiYmXyl7Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDthKyspMDxhJiYocis9bSkscis9ayhlW2FdLGEpOzA8dC5sZW5ndGgmJihyKz15KX1mb3IodmFyIG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIGg9KG4/ZTp0W29dKS5sZW5ndGgsdT0hMSxkPW4/MD09PU9iamVjdC5rZXlzKHRbb10pLmxlbmd0aDowPT09dFtvXS5sZW5ndGg7aWYoaSYmIW4mJih1PVwiZ3JlZWR5XCI9PT1pP1wiXCI9PT10W29dLmpvaW4oXCJcIikudHJpbSgpOjE9PT10W29dLmxlbmd0aCYmMD09PXRbb11bMF0ubGVuZ3RoKSxcImdyZWVkeVwiPT09aSYmbil7Zm9yKHZhciBmPVtdLGw9MDtsPGg7bCsrKXt2YXIgYz1zP2VbbF06bDtmLnB1c2godFtvXVtjXSl9dT1cIlwiPT09Zi5qb2luKFwiXCIpLnRyaW0oKX1pZighdSl7Zm9yKHZhciBwPTA7cDxoO3ArKyl7MDxwJiYhZCYmKHIrPW0pO3ZhciBnPW4mJnM/ZVtwXTpwO3IrPWsodFtvXVtnXSxwKX1vPHQubGVuZ3RoLTEmJighaXx8MDxoJiYhZCkmJihyKz15KX19cmV0dXJuIHJ9ZnVuY3Rpb24gayhlLHQpe3ZhciBpLHI7cmV0dXJuIG51bGw9PWU/XCJcIjplLmNvbnN0cnVjdG9yPT09RGF0ZT9KU09OLnN0cmluZ2lmeShlKS5zbGljZSgxLDI1KToocj0hMSxvJiZcInN0cmluZ1wiPT10eXBlb2YgZSYmby50ZXN0KGUpJiYoZT1cIidcIitlLHI9ITApLGk9ZS50b1N0cmluZygpLnJlcGxhY2UoaCxhKSwocj1yfHwhMD09PW58fFwiZnVuY3Rpb25cIj09dHlwZW9mIG4mJm4oZSx0KXx8QXJyYXkuaXNBcnJheShuKSYmblt0XXx8KChlLHQpPT57Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspaWYoLTE8ZS5pbmRleE9mKHRbaV0pKXJldHVybiEwO3JldHVybiExfSkoaSx2LkJBRF9ERUxJTUlURVJTKXx8LTE8aS5pbmRleE9mKG0pfHxcIiBcIj09PWkuY2hhckF0KDApfHxcIiBcIj09PWkuY2hhckF0KGkubGVuZ3RoLTEpKT9zK2krczppKX19LHYuUkVDT1JEX1NFUD1TdHJpbmcuZnJvbUNoYXJDb2RlKDMwKSx2LlVOSVRfU0VQPVN0cmluZy5mcm9tQ2hhckNvZGUoMzEpLHYuQllURV9PUkRFUl9NQVJLPVwiXFx1ZmVmZlwiLHYuQkFEX0RFTElNSVRFUlM9W1wiXFxyXCIsXCJcXG5cIiwnXCInLHYuQllURV9PUkRFUl9NQVJLXSx2LldPUktFUlNfU1VQUE9SVEVEPSFzJiYhIW4uV29ya2VyLHYuTk9ERV9TVFJFQU1fSU5QVVQ9MSx2LkxvY2FsQ2h1bmtTaXplPTEwNDg1NzYwLHYuUmVtb3RlQ2h1bmtTaXplPTUyNDI4ODAsdi5EZWZhdWx0RGVsaW1pdGVyPVwiLFwiLHYuUGFyc2VyPUUsdi5QYXJzZXJIYW5kbGU9aSx2Lk5ldHdvcmtTdHJlYW1lcj1mLHYuRmlsZVN0cmVhbWVyPWwsdi5TdHJpbmdTdHJlYW1lcj1jLHYuUmVhZGFibGVTdHJlYW1TdHJlYW1lcj1wLG4ualF1ZXJ5JiYoKGQ9bi5qUXVlcnkpLmZuLnBhcnNlPWZ1bmN0aW9uKG8pe3ZhciBpPW8uY29uZmlnfHx7fSxoPVtdO3JldHVybiB0aGlzLmVhY2goZnVuY3Rpb24oZSl7aWYoIShcIklOUFVUXCI9PT1kKHRoaXMpLnByb3AoXCJ0YWdOYW1lXCIpLnRvVXBwZXJDYXNlKCkmJlwiZmlsZVwiPT09ZCh0aGlzKS5hdHRyKFwidHlwZVwiKS50b0xvd2VyQ2FzZSgpJiZuLkZpbGVSZWFkZXIpfHwhdGhpcy5maWxlc3x8MD09PXRoaXMuZmlsZXMubGVuZ3RoKXJldHVybiEwO2Zvcih2YXIgdD0wO3Q8dGhpcy5maWxlcy5sZW5ndGg7dCsrKWgucHVzaCh7ZmlsZTp0aGlzLmZpbGVzW3RdLGlucHV0RWxlbTp0aGlzLGluc3RhbmNlQ29uZmlnOmQuZXh0ZW5kKHt9LGkpfSl9KSxlKCksdGhpcztmdW5jdGlvbiBlKCl7aWYoMD09PWgubGVuZ3RoKVUoby5jb21wbGV0ZSkmJm8uY29tcGxldGUoKTtlbHNle3ZhciBlLHQsaSxyLG49aFswXTtpZihVKG8uYmVmb3JlKSl7dmFyIHM9by5iZWZvcmUobi5maWxlLG4uaW5wdXRFbGVtKTtpZihcIm9iamVjdFwiPT10eXBlb2Ygcyl7aWYoXCJhYm9ydFwiPT09cy5hY3Rpb24pcmV0dXJuIGU9XCJBYm9ydEVycm9yXCIsdD1uLmZpbGUsaT1uLmlucHV0RWxlbSxyPXMucmVhc29uLHZvaWQoVShvLmVycm9yKSYmby5lcnJvcih7bmFtZTplfSx0LGkscikpO2lmKFwic2tpcFwiPT09cy5hY3Rpb24pcmV0dXJuIHZvaWQgdSgpO1wib2JqZWN0XCI9PXR5cGVvZiBzLmNvbmZpZyYmKG4uaW5zdGFuY2VDb25maWc9ZC5leHRlbmQobi5pbnN0YW5jZUNvbmZpZyxzLmNvbmZpZykpfWVsc2UgaWYoXCJza2lwXCI9PT1zKXJldHVybiB2b2lkIHUoKX12YXIgYT1uLmluc3RhbmNlQ29uZmlnLmNvbXBsZXRlO24uaW5zdGFuY2VDb25maWcuY29tcGxldGU9ZnVuY3Rpb24oZSl7VShhKSYmYShlLG4uZmlsZSxuLmlucHV0RWxlbSksdSgpfSx2LnBhcnNlKG4uZmlsZSxuLmluc3RhbmNlQ29uZmlnKX19ZnVuY3Rpb24gdSgpe2guc3BsaWNlKDAsMSksZSgpfX0pLGEmJihuLm9ubWVzc2FnZT1mdW5jdGlvbihlKXtlPWUuZGF0YTt2b2lkIDA9PT12LldPUktFUl9JRCYmZSYmKHYuV09SS0VSX0lEPWUud29ya2VySWQpO1wic3RyaW5nXCI9PXR5cGVvZiBlLmlucHV0P24ucG9zdE1lc3NhZ2Uoe3dvcmtlcklkOnYuV09SS0VSX0lELHJlc3VsdHM6di5wYXJzZShlLmlucHV0LGUuY29uZmlnKSxmaW5pc2hlZDohMH0pOihuLkZpbGUmJmUuaW5wdXQgaW5zdGFuY2VvZiBGaWxlfHxlLmlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSYmKGU9di5wYXJzZShlLmlucHV0LGUuY29uZmlnKSkmJm4ucG9zdE1lc3NhZ2Uoe3dvcmtlcklkOnYuV09SS0VSX0lELHJlc3VsdHM6ZSxmaW5pc2hlZDohMH0pfSksKGYucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1mLChsLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHUucHJvdG90eXBlKSkuY29uc3RydWN0b3I9bCwoYy5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShjLnByb3RvdHlwZSkpLmNvbnN0cnVjdG9yPWMsKHAucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodS5wcm90b3R5cGUpKS5jb25zdHJ1Y3Rvcj1wLHZ9KTsiLCJmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChyLCBsKSB7XG4gIHZhciB0ID0gbnVsbCA9PSByID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiByW1N5bWJvbC5pdGVyYXRvcl0gfHwgcltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IHQpIHtcbiAgICB2YXIgZSxcbiAgICAgIG4sXG4gICAgICBpLFxuICAgICAgdSxcbiAgICAgIGEgPSBbXSxcbiAgICAgIGYgPSAhMCxcbiAgICAgIG8gPSAhMTtcbiAgICB0cnkge1xuICAgICAgaWYgKGkgPSAodCA9IHQuY2FsbChyKSkubmV4dCwgMCA9PT0gbCkge1xuICAgICAgICBpZiAoT2JqZWN0KHQpICE9PSB0KSByZXR1cm47XG4gICAgICAgIGYgPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShmID0gKGUgPSBpLmNhbGwodCkpLmRvbmUpICYmIChhLnB1c2goZS52YWx1ZSksIGEubGVuZ3RoICE9PSBsKTsgZiA9ICEwKTtcbiAgICB9IGNhdGNoIChyKSB7XG4gICAgICBvID0gITAsIG4gPSByO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWYgJiYgbnVsbCAhPSB0LnJldHVybiAmJiAodSA9IHQucmV0dXJuKCksIE9iamVjdCh1KSAhPT0gdSkpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvKSB0aHJvdyBuO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShyLCBlKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMocikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGUpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBlKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5cbnZhciBIVE1MX0NPTE9SUyA9IHtcbiAgYmxhY2s6IFwiIzAwMDAwMFwiLFxuICBzaWx2ZXI6IFwiI0MwQzBDMFwiLFxuICBncmF5OiBcIiM4MDgwODBcIixcbiAgZ3JleTogXCIjODA4MDgwXCIsXG4gIHdoaXRlOiBcIiNGRkZGRkZcIixcbiAgbWFyb29uOiBcIiM4MDAwMDBcIixcbiAgcmVkOiBcIiNGRjAwMDBcIixcbiAgcHVycGxlOiBcIiM4MDAwODBcIixcbiAgZnVjaHNpYTogXCIjRkYwMEZGXCIsXG4gIGdyZWVuOiBcIiMwMDgwMDBcIixcbiAgbGltZTogXCIjMDBGRjAwXCIsXG4gIG9saXZlOiBcIiM4MDgwMDBcIixcbiAgeWVsbG93OiBcIiNGRkZGMDBcIixcbiAgbmF2eTogXCIjMDAwMDgwXCIsXG4gIGJsdWU6IFwiIzAwMDBGRlwiLFxuICB0ZWFsOiBcIiMwMDgwODBcIixcbiAgYXF1YTogXCIjMDBGRkZGXCIsXG4gIGRhcmtibHVlOiBcIiMwMDAwOEJcIixcbiAgbWVkaXVtYmx1ZTogXCIjMDAwMENEXCIsXG4gIGRhcmtncmVlbjogXCIjMDA2NDAwXCIsXG4gIGRhcmtjeWFuOiBcIiMwMDhCOEJcIixcbiAgZGVlcHNreWJsdWU6IFwiIzAwQkZGRlwiLFxuICBkYXJrdHVycXVvaXNlOiBcIiMwMENFRDFcIixcbiAgbWVkaXVtc3ByaW5nZ3JlZW46IFwiIzAwRkE5QVwiLFxuICBzcHJpbmdncmVlbjogXCIjMDBGRjdGXCIsXG4gIGN5YW46IFwiIzAwRkZGRlwiLFxuICBtaWRuaWdodGJsdWU6IFwiIzE5MTk3MFwiLFxuICBkb2RnZXJibHVlOiBcIiMxRTkwRkZcIixcbiAgbGlnaHRzZWFncmVlbjogXCIjMjBCMkFBXCIsXG4gIGZvcmVzdGdyZWVuOiBcIiMyMjhCMjJcIixcbiAgc2VhZ3JlZW46IFwiIzJFOEI1N1wiLFxuICBkYXJrc2xhdGVncmF5OiBcIiMyRjRGNEZcIixcbiAgZGFya3NsYXRlZ3JleTogXCIjMkY0RjRGXCIsXG4gIGxpbWVncmVlbjogXCIjMzJDRDMyXCIsXG4gIG1lZGl1bXNlYWdyZWVuOiBcIiMzQ0IzNzFcIixcbiAgdHVycXVvaXNlOiBcIiM0MEUwRDBcIixcbiAgcm95YWxibHVlOiBcIiM0MTY5RTFcIixcbiAgc3RlZWxibHVlOiBcIiM0NjgyQjRcIixcbiAgZGFya3NsYXRlYmx1ZTogXCIjNDgzRDhCXCIsXG4gIG1lZGl1bXR1cnF1b2lzZTogXCIjNDhEMUNDXCIsXG4gIGluZGlnbzogXCIjNEIwMDgyXCIsXG4gIGRhcmtvbGl2ZWdyZWVuOiBcIiM1NTZCMkZcIixcbiAgY2FkZXRibHVlOiBcIiM1RjlFQTBcIixcbiAgY29ybmZsb3dlcmJsdWU6IFwiIzY0OTVFRFwiLFxuICByZWJlY2NhcHVycGxlOiBcIiM2NjMzOTlcIixcbiAgbWVkaXVtYXF1YW1hcmluZTogXCIjNjZDREFBXCIsXG4gIGRpbWdyYXk6IFwiIzY5Njk2OVwiLFxuICBkaW1ncmV5OiBcIiM2OTY5NjlcIixcbiAgc2xhdGVibHVlOiBcIiM2QTVBQ0RcIixcbiAgb2xpdmVkcmFiOiBcIiM2QjhFMjNcIixcbiAgc2xhdGVncmF5OiBcIiM3MDgwOTBcIixcbiAgc2xhdGVncmV5OiBcIiM3MDgwOTBcIixcbiAgbGlnaHRzbGF0ZWdyYXk6IFwiIzc3ODg5OVwiLFxuICBsaWdodHNsYXRlZ3JleTogXCIjNzc4ODk5XCIsXG4gIG1lZGl1bXNsYXRlYmx1ZTogXCIjN0I2OEVFXCIsXG4gIGxhd25ncmVlbjogXCIjN0NGQzAwXCIsXG4gIGNoYXJ0cmV1c2U6IFwiIzdGRkYwMFwiLFxuICBhcXVhbWFyaW5lOiBcIiM3RkZGRDRcIixcbiAgc2t5Ymx1ZTogXCIjODdDRUVCXCIsXG4gIGxpZ2h0c2t5Ymx1ZTogXCIjODdDRUZBXCIsXG4gIGJsdWV2aW9sZXQ6IFwiIzhBMkJFMlwiLFxuICBkYXJrcmVkOiBcIiM4QjAwMDBcIixcbiAgZGFya21hZ2VudGE6IFwiIzhCMDA4QlwiLFxuICBzYWRkbGVicm93bjogXCIjOEI0NTEzXCIsXG4gIGRhcmtzZWFncmVlbjogXCIjOEZCQzhGXCIsXG4gIGxpZ2h0Z3JlZW46IFwiIzkwRUU5MFwiLFxuICBtZWRpdW1wdXJwbGU6IFwiIzkzNzBEQlwiLFxuICBkYXJrdmlvbGV0OiBcIiM5NDAwRDNcIixcbiAgcGFsZWdyZWVuOiBcIiM5OEZCOThcIixcbiAgZGFya29yY2hpZDogXCIjOTkzMkNDXCIsXG4gIHllbGxvd2dyZWVuOiBcIiM5QUNEMzJcIixcbiAgc2llbm5hOiBcIiNBMDUyMkRcIixcbiAgYnJvd246IFwiI0E1MkEyQVwiLFxuICBkYXJrZ3JheTogXCIjQTlBOUE5XCIsXG4gIGRhcmtncmV5OiBcIiNBOUE5QTlcIixcbiAgbGlnaHRibHVlOiBcIiNBREQ4RTZcIixcbiAgZ3JlZW55ZWxsb3c6IFwiI0FERkYyRlwiLFxuICBwYWxldHVycXVvaXNlOiBcIiNBRkVFRUVcIixcbiAgbGlnaHRzdGVlbGJsdWU6IFwiI0IwQzRERVwiLFxuICBwb3dkZXJibHVlOiBcIiNCMEUwRTZcIixcbiAgZmlyZWJyaWNrOiBcIiNCMjIyMjJcIixcbiAgZGFya2dvbGRlbnJvZDogXCIjQjg4NjBCXCIsXG4gIG1lZGl1bW9yY2hpZDogXCIjQkE1NUQzXCIsXG4gIHJvc3licm93bjogXCIjQkM4RjhGXCIsXG4gIGRhcmtraGFraTogXCIjQkRCNzZCXCIsXG4gIG1lZGl1bXZpb2xldHJlZDogXCIjQzcxNTg1XCIsXG4gIGluZGlhbnJlZDogXCIjQ0Q1QzVDXCIsXG4gIHBlcnU6IFwiI0NEODUzRlwiLFxuICBjaG9jb2xhdGU6IFwiI0QyNjkxRVwiLFxuICB0YW46IFwiI0QyQjQ4Q1wiLFxuICBsaWdodGdyYXk6IFwiI0QzRDNEM1wiLFxuICBsaWdodGdyZXk6IFwiI0QzRDNEM1wiLFxuICB0aGlzdGxlOiBcIiNEOEJGRDhcIixcbiAgb3JjaGlkOiBcIiNEQTcwRDZcIixcbiAgZ29sZGVucm9kOiBcIiNEQUE1MjBcIixcbiAgcGFsZXZpb2xldHJlZDogXCIjREI3MDkzXCIsXG4gIGNyaW1zb246IFwiI0RDMTQzQ1wiLFxuICBnYWluc2Jvcm86IFwiI0RDRENEQ1wiLFxuICBwbHVtOiBcIiNEREEwRERcIixcbiAgYnVybHl3b29kOiBcIiNERUI4ODdcIixcbiAgbGlnaHRjeWFuOiBcIiNFMEZGRkZcIixcbiAgbGF2ZW5kZXI6IFwiI0U2RTZGQVwiLFxuICBkYXJrc2FsbW9uOiBcIiNFOTk2N0FcIixcbiAgdmlvbGV0OiBcIiNFRTgyRUVcIixcbiAgcGFsZWdvbGRlbnJvZDogXCIjRUVFOEFBXCIsXG4gIGxpZ2h0Y29yYWw6IFwiI0YwODA4MFwiLFxuICBraGFraTogXCIjRjBFNjhDXCIsXG4gIGFsaWNlYmx1ZTogXCIjRjBGOEZGXCIsXG4gIGhvbmV5ZGV3OiBcIiNGMEZGRjBcIixcbiAgYXp1cmU6IFwiI0YwRkZGRlwiLFxuICBzYW5keWJyb3duOiBcIiNGNEE0NjBcIixcbiAgd2hlYXQ6IFwiI0Y1REVCM1wiLFxuICBiZWlnZTogXCIjRjVGNURDXCIsXG4gIHdoaXRlc21va2U6IFwiI0Y1RjVGNVwiLFxuICBtaW50Y3JlYW06IFwiI0Y1RkZGQVwiLFxuICBnaG9zdHdoaXRlOiBcIiNGOEY4RkZcIixcbiAgc2FsbW9uOiBcIiNGQTgwNzJcIixcbiAgYW50aXF1ZXdoaXRlOiBcIiNGQUVCRDdcIixcbiAgbGluZW46IFwiI0ZBRjBFNlwiLFxuICBsaWdodGdvbGRlbnJvZHllbGxvdzogXCIjRkFGQUQyXCIsXG4gIG9sZGxhY2U6IFwiI0ZERjVFNlwiLFxuICBtYWdlbnRhOiBcIiNGRjAwRkZcIixcbiAgZGVlcHBpbms6IFwiI0ZGMTQ5M1wiLFxuICBvcmFuZ2VyZWQ6IFwiI0ZGNDUwMFwiLFxuICB0b21hdG86IFwiI0ZGNjM0N1wiLFxuICBob3RwaW5rOiBcIiNGRjY5QjRcIixcbiAgY29yYWw6IFwiI0ZGN0Y1MFwiLFxuICBkYXJrb3JhbmdlOiBcIiNGRjhDMDBcIixcbiAgbGlnaHRzYWxtb246IFwiI0ZGQTA3QVwiLFxuICBvcmFuZ2U6IFwiI0ZGQTUwMFwiLFxuICBsaWdodHBpbms6IFwiI0ZGQjZDMVwiLFxuICBwaW5rOiBcIiNGRkMwQ0JcIixcbiAgZ29sZDogXCIjRkZENzAwXCIsXG4gIHBlYWNocHVmZjogXCIjRkZEQUI5XCIsXG4gIG5hdmFqb3doaXRlOiBcIiNGRkRFQURcIixcbiAgbW9jY2FzaW46IFwiI0ZGRTRCNVwiLFxuICBiaXNxdWU6IFwiI0ZGRTRDNFwiLFxuICBtaXN0eXJvc2U6IFwiI0ZGRTRFMVwiLFxuICBibGFuY2hlZGFsbW9uZDogXCIjRkZFQkNEXCIsXG4gIHBhcGF5YXdoaXA6IFwiI0ZGRUZENVwiLFxuICBsYXZlbmRlcmJsdXNoOiBcIiNGRkYwRjVcIixcbiAgc2Vhc2hlbGw6IFwiI0ZGRjVFRVwiLFxuICBjb3Juc2lsazogXCIjRkZGOERDXCIsXG4gIGxlbW9uY2hpZmZvbjogXCIjRkZGQUNEXCIsXG4gIGZsb3JhbHdoaXRlOiBcIiNGRkZBRjBcIixcbiAgc25vdzogXCIjRkZGQUZBXCIsXG4gIGxpZ2h0eWVsbG93OiBcIiNGRkZGRTBcIixcbiAgaXZvcnk6IFwiI0ZGRkZGMFwiXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIGV4dHJhY3RpbmcgdGhlIGNvbG9yIGF0IHRoZSBnaXZlbiBwaXhlbC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFBpeGVsKGdsLCB4LCB5LCBhcnJheSkge1xuICB2YXIgZGF0YSA9IGFycmF5IHx8IG5ldyBVaW50OEFycmF5KDQpO1xuICBnbC5yZWFkUGl4ZWxzKHgsIHksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNZW1vaXplZCBmdW5jdGlvbiByZXR1cm5pbmcgYSBmbG9hdC1lbmNvZGVkIGNvbG9yIGZyb20gdmFyaW91cyBzdHJpbmdcbiAqIGZvcm1hdHMgZGVzY3JpYmluZyBjb2xvcnMuXG4gKi9cbnZhciBJTlQ4ID0gbmV3IEludDhBcnJheSg0KTtcbnZhciBJTlQzMiA9IG5ldyBJbnQzMkFycmF5KElOVDguYnVmZmVyLCAwLCAxKTtcbnZhciBGTE9BVDMyID0gbmV3IEZsb2F0MzJBcnJheShJTlQ4LmJ1ZmZlciwgMCwgMSk7XG52YXIgUkdCQV9URVNUX1JFR0VYID0gL15cXHMqcmdiYT9cXHMqXFwoLztcbnZhciBSR0JBX0VYVFJBQ1RfUkVHRVggPSAvXlxccypyZ2JhP1xccypcXChcXHMqKFswLTldKilcXHMqLFxccyooWzAtOV0qKVxccyosXFxzKihbMC05XSopKD86XFxzKixcXHMqKC4qKT8pP1xcKVxccyokLztcbmZ1bmN0aW9uIHBhcnNlQ29sb3IodmFsKSB7XG4gIHZhciByID0gMDsgLy8gYnl0ZVxuICB2YXIgZyA9IDA7IC8vIGJ5dGVcbiAgdmFyIGIgPSAwOyAvLyBieXRlXG4gIHZhciBhID0gMTsgLy8gZmxvYXRcblxuICAvLyBIYW5kbGluZyBoZXhhZGVjaW1hbCBub3RhdGlvblxuICBpZiAodmFsWzBdID09PSBcIiNcIikge1xuICAgIGlmICh2YWwubGVuZ3RoID09PSA0KSB7XG4gICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMSksIDE2KTtcbiAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDIpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMykgKyB2YWwuY2hhckF0KDMpLCAxNik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHIgPSBwYXJzZUludCh2YWwuY2hhckF0KDEpICsgdmFsLmNoYXJBdCgyKSwgMTYpO1xuICAgICAgZyA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMykgKyB2YWwuY2hhckF0KDQpLCAxNik7XG4gICAgICBiID0gcGFyc2VJbnQodmFsLmNoYXJBdCg1KSArIHZhbC5jaGFyQXQoNiksIDE2KTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDkpIHtcbiAgICAgIGEgPSBwYXJzZUludCh2YWwuY2hhckF0KDcpICsgdmFsLmNoYXJBdCg4KSwgMTYpIC8gMjU1O1xuICAgIH1cbiAgfVxuXG4gIC8vIEhhbmRsaW5nIHJnYiBub3RhdGlvblxuICBlbHNlIGlmIChSR0JBX1RFU1RfUkVHRVgudGVzdCh2YWwpKSB7XG4gICAgdmFyIG1hdGNoID0gdmFsLm1hdGNoKFJHQkFfRVhUUkFDVF9SRUdFWCk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByID0gK21hdGNoWzFdO1xuICAgICAgZyA9ICttYXRjaFsyXTtcbiAgICAgIGIgPSArbWF0Y2hbM107XG4gICAgICBpZiAobWF0Y2hbNF0pIGEgPSArbWF0Y2hbNF07XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgcjogcixcbiAgICBnOiBnLFxuICAgIGI6IGIsXG4gICAgYTogYVxuICB9O1xufVxudmFyIEZMT0FUX0NPTE9SX0NBQ0hFID0ge307XG5mb3IgKHZhciBodG1sQ29sb3IgaW4gSFRNTF9DT0xPUlMpIHtcbiAgRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXSA9IGZsb2F0Q29sb3IoSFRNTF9DT0xPUlNbaHRtbENvbG9yXSk7XG4gIC8vIFJlcGxpY2F0aW5nIGNhY2hlIGZvciBoZXggdmFsdWVzIGZvciBmcmVlXG4gIEZMT0FUX0NPTE9SX0NBQ0hFW0hUTUxfQ09MT1JTW2h0bWxDb2xvcl1dID0gRkxPQVRfQ09MT1JfQ0FDSEVbaHRtbENvbG9yXTtcbn1cbmZ1bmN0aW9uIHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIG1hc2tpbmcpIHtcbiAgSU5UMzJbMF0gPSBhIDw8IDI0IHwgYiA8PCAxNiB8IGcgPDwgOCB8IHI7XG4gIGlmIChtYXNraW5nKSBJTlQzMlswXSA9IElOVDMyWzBdICYgMHhmZWZmZmZmZjtcbiAgcmV0dXJuIEZMT0FUMzJbMF07XG59XG5mdW5jdGlvbiBmbG9hdENvbG9yKHZhbCkge1xuICAvLyBUaGUgaHRtbCBjb2xvciBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuICB2YWwgPSB2YWwudG9Mb3dlckNhc2UoKTtcblxuICAvLyBJZiB0aGUgY29sb3IgaXMgYWxyZWFkeSBjb21wdXRlZCwgd2UgeWllbGQgaXRcbiAgaWYgKHR5cGVvZiBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gRkxPQVRfQ09MT1JfQ0FDSEVbdmFsXTtcbiAgdmFyIHBhcnNlZCA9IHBhcnNlQ29sb3IodmFsKTtcbiAgdmFyIHIgPSBwYXJzZWQucixcbiAgICBnID0gcGFyc2VkLmcsXG4gICAgYiA9IHBhcnNlZC5iO1xuICB2YXIgYSA9IHBhcnNlZC5hO1xuICBhID0gYSAqIDI1NSB8IDA7XG4gIHZhciBjb2xvciA9IHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIHRydWUpO1xuICBGTE9BVF9DT0xPUl9DQUNIRVt2YWxdID0gY29sb3I7XG4gIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIGNvbG9yVG9BcnJheSh2YWwsIG1hc2tpbmcpIHtcbiAgRkxPQVQzMlswXSA9IGZsb2F0Q29sb3IodmFsKTtcbiAgdmFyIGludFZhbHVlID0gSU5UMzJbMF07XG4gIGlmIChtYXNraW5nKSB7XG4gICAgaW50VmFsdWUgPSBpbnRWYWx1ZSB8IDB4MDEwMDAwMDA7XG4gIH1cbiAgdmFyIHIgPSBpbnRWYWx1ZSAmIDB4ZmY7XG4gIHZhciBnID0gaW50VmFsdWUgPj4gOCAmIDB4ZmY7XG4gIHZhciBiID0gaW50VmFsdWUgPj4gMTYgJiAweGZmO1xuICB2YXIgYSA9IGludFZhbHVlID4+IDI0ICYgMHhmZjtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cbnZhciBGTE9BVF9JTkRFWF9DQUNIRSA9IHt9O1xuZnVuY3Rpb24gaW5kZXhUb0NvbG9yKGluZGV4KSB7XG4gIC8vIElmIHRoZSBpbmRleCBpcyBhbHJlYWR5IGNvbXB1dGVkLCB3ZSB5aWVsZCBpdFxuICBpZiAodHlwZW9mIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEZMT0FUX0lOREVYX0NBQ0hFW2luZGV4XTtcblxuICAvLyBUbyBhZGRyZXNzIGlzc3VlICMxMzk3LCBvbmUgc3RyYXRlZ3kgaXMgdG8ga2VlcCBlbmNvZGluZyA0IGJ5dGVzIGNvbG9ycyxcbiAgLy8gYnV0IHdpdGggYWxwaGEgaGFyZC1zZXQgdG8gMS4wIChvciAyNTUpOlxuICB2YXIgciA9IChpbmRleCAmIDB4MDBmZjAwMDApID4+PiAxNjtcbiAgdmFyIGcgPSAoaW5kZXggJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgdmFyIGIgPSBpbmRleCAmIDB4MDAwMDAwZmY7XG4gIHZhciBhID0gMHgwMDAwMDBmZjtcblxuICAvLyBUaGUgb3JpZ2luYWwgNCBieXRlcyBjb2xvciBlbmNvZGluZyB3YXMgdGhlIGZvbGxvd2luZzpcbiAgLy8gY29uc3QgciA9IChpbmRleCAmIDB4ZmYwMDAwMDApID4+PiAyNDtcbiAgLy8gY29uc3QgZyA9IChpbmRleCAmIDB4MDBmZjAwMDApID4+PiAxNjtcbiAgLy8gY29uc3QgYiA9IChpbmRleCAmIDB4MDAwMGZmMDApID4+PiA4O1xuICAvLyBjb25zdCBhID0gaW5kZXggJiAweDAwMDAwMGZmO1xuXG4gIHZhciBjb2xvciA9IHJnYmFUb0Zsb2F0KHIsIGcsIGIsIGEsIHRydWUpO1xuICBGTE9BVF9JTkRFWF9DQUNIRVtpbmRleF0gPSBjb2xvcjtcbiAgcmV0dXJuIGNvbG9yO1xufVxuZnVuY3Rpb24gY29sb3JUb0luZGV4KHIsIGcsIGIsIF9hKSB7XG4gIC8vIEFzIGZvciB0aGUgZnVuY3Rpb24gaW5kZXhUb0NvbG9yLCBiZWNhdXNlIG9mICMxMzk3IGFuZCB0aGUgXCJhbHBoYSBpcyBhbHdheXNcbiAgLy8gMS4wXCIgc3RyYXRlZ3ksIHdlIG5lZWQgdG8gZml4IHRoaXMgZnVuY3Rpb24gYXMgd2VsbDpcbiAgcmV0dXJuIGIgKyAoZyA8PCA4KSArIChyIDw8IDE2KTtcblxuICAvLyBUaGUgb3JpZ2luYWwgNCBieXRlcyBjb2xvciBkZWNvZGluZyBpcyB0aGUgZm9sbG93aW5nOlxuICAvLyByZXR1cm4gYSArIChiIDw8IDgpICsgKGcgPDwgMTYpICsgKHIgPDwgMjQpO1xufVxuZnVuY3Rpb24gZ2V0UGl4ZWxDb2xvcihnbCwgZnJhbWVCdWZmZXIsIHgsIHksIHBpeGVsUmF0aW8sIGRvd25TaXppbmdSYXRpbykge1xuICB2YXIgYnVmZmVyWCA9IE1hdGguZmxvb3IoeCAvIGRvd25TaXppbmdSYXRpbyAqIHBpeGVsUmF0aW8pO1xuICB2YXIgYnVmZmVyWSA9IE1hdGguZmxvb3IoZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCAvIGRvd25TaXppbmdSYXRpbyAtIHkgLyBkb3duU2l6aW5nUmF0aW8gKiBwaXhlbFJhdGlvKTtcbiAgdmFyIHBpeGVsID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICBnbC5yZWFkUGl4ZWxzKGJ1ZmZlclgsIGJ1ZmZlclksIDEsIDEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVsKTtcbiAgdmFyIF9waXhlbCA9IF9zbGljZWRUb0FycmF5KHBpeGVsLCA0KSxcbiAgICByID0gX3BpeGVsWzBdLFxuICAgIGcgPSBfcGl4ZWxbMV0sXG4gICAgYiA9IF9waXhlbFsyXSxcbiAgICBhID0gX3BpeGVsWzNdO1xuICByZXR1cm4gW3IsIGcsIGIsIGFdO1xufVxuXG5leHBvcnQgeyBIVE1MX0NPTE9SUyBhcyBILCBfc2xpY2VkVG9BcnJheSBhcyBfLCBfYXJyYXlMaWtlVG9BcnJheSBhcyBhLCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgYXMgYiwgY29sb3JUb0luZGV4IGFzIGMsIGNvbG9yVG9BcnJheSBhcyBkLCBleHRyYWN0UGl4ZWwgYXMgZSwgZmxvYXRDb2xvciBhcyBmLCBnZXRQaXhlbENvbG9yIGFzIGcsIGluZGV4VG9Db2xvciBhcyBpLCBwYXJzZUNvbG9yIGFzIHAsIHJnYmFUb0Zsb2F0IGFzIHIgfTtcbiIsImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbi8qKlxuICogRXh0ZW5kcyB0aGUgdGFyZ2V0IGFycmF5IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGwyID0gdmFsdWVzLnNpemU7XG4gIGlmIChsMiA9PT0gMCkgcmV0dXJuO1xuICB2YXIgbDEgPSBhcnJheS5sZW5ndGg7XG4gIGFycmF5Lmxlbmd0aCArPSBsMjtcbiAgdmFyIGkgPSAwO1xuICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhcnJheVtsMSArIGldID0gdmFsdWU7XG4gICAgaSsrO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHVzZSBgT2JqZWN0LmFzc2lnbmAgd2l0aCBtb3JlIHRoYW4gdHdvIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgIHZhciBvID0gaSArIDEgPCAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdO1xuICAgIGlmICghbykgY29udGludWU7XG4gICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIG8pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcmVjdXJzaXZlIGBPYmplY3QuYXNzaWduYCBsaWtlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NpZ25EZWVwKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG8gPSBpICsgMSA8IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKCFvKSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9ba10pKSB7XG4gICAgICAgIHRhcmdldFtrXSA9IGFzc2lnbkRlZXAodGFyZ2V0W2tdLCBvW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrXSA9IG9ba107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IF90eXBlb2YgYXMgXywgYXNzaWduIGFzIGEsIGFzc2lnbkRlZXAgYXMgYiwgZXh0ZW5kIGFzIGUsIGlzUGxhaW5PYmplY3QgYXMgaSB9O1xuIiwiaW1wb3J0IHsgZCBhcyBfdG9Qcm9wZXJ0eUtleSwgZSBhcyBfZ2V0UHJvdG90eXBlT2YsIGEgYXMgX2NyZWF0ZUNsYXNzLCBiIGFzIF9jbGFzc0NhbGxDaGVjaywgXyBhcyBfaW5oZXJpdHMsIGMgYXMgX2NhbGxTdXBlciB9IGZyb20gJy4vaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCB7IGkgYXMgaW5kZXhUb0NvbG9yLCBmIGFzIGZsb2F0Q29sb3IgfSBmcm9tICcuL2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkoZSwgciwgdCkge1xuICByZXR1cm4gKHIgPSBfdG9Qcm9wZXJ0eUtleShyKSkgaW4gZSA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCB7XG4gICAgdmFsdWU6IHQsXG4gICAgZW51bWVyYWJsZTogITAsXG4gICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICB3cml0YWJsZTogITBcbiAgfSkgOiBlW3JdID0gdCwgZTtcbn1cblxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2UodCwgbykge1xuICBmb3IgKDsgIXt9Lmhhc093blByb3BlcnR5LmNhbGwodCwgbykgJiYgbnVsbCAhPT0gKHQgPSBfZ2V0UHJvdG90eXBlT2YodCkpOyk7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICByZXR1cm4gX2dldCA9IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFJlZmxlY3QgJiYgUmVmbGVjdC5nZXQgPyBSZWZsZWN0LmdldC5iaW5kKCkgOiBmdW5jdGlvbiAoZSwgdCwgcikge1xuICAgIHZhciBwID0gX3N1cGVyUHJvcEJhc2UoZSwgdCk7XG4gICAgaWYgKHApIHtcbiAgICAgIHZhciBuID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwLCB0KTtcbiAgICAgIHJldHVybiBuLmdldCA/IG4uZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyBlIDogcikgOiBuLnZhbHVlO1xuICAgIH1cbiAgfSwgX2dldC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufVxuXG5mdW5jdGlvbiBfc3VwZXJQcm9wR2V0KHQsIG8sIGUsIHIpIHtcbiAgdmFyIHAgPSBfZ2V0KF9nZXRQcm90b3R5cGVPZigxICYgciA/IHQucHJvdG90eXBlIDogdCksIG8sIGUpO1xuICByZXR1cm4gMiAmIHIgJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBwID8gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gcC5hcHBseShlLCB0KTtcbiAgfSA6IHA7XG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZUl0ZW1zQ291bnQoYXR0cikge1xuICByZXR1cm4gYXR0ci5ub3JtYWxpemVkID8gMSA6IGF0dHIuc2l6ZTtcbn1cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KGF0dHJzKSB7XG4gIHZhciByZXMgPSAwO1xuICBhdHRycy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgcmV0dXJuIHJlcyArPSBnZXRBdHRyaWJ1dGVJdGVtc0NvdW50KGF0dHIpO1xuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGxvYWRTaGFkZXIodHlwZSwgZ2wsIHNvdXJjZSkge1xuICB2YXIgZ2xUeXBlID0gdHlwZSA9PT0gXCJWRVJURVhcIiA/IGdsLlZFUlRFWF9TSEFERVIgOiBnbC5GUkFHTUVOVF9TSEFERVI7XG5cbiAgLy8gQ3JlYXRpbmcgdGhlIHNoYWRlclxuICB2YXIgc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsVHlwZSk7XG4gIGlmIChzaGFkZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkU2hhZGVyOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgc2hhZGVyXCIpO1xuICB9XG5cbiAgLy8gTG9hZGluZyBzb3VyY2VcbiAgZ2wuc2hhZGVyU291cmNlKHNoYWRlciwgc291cmNlKTtcblxuICAvLyBDb21waWxpbmcgdGhlIHNoYWRlclxuICBnbC5jb21waWxlU2hhZGVyKHNoYWRlcik7XG5cbiAgLy8gUmV0cmlldmluZyBjb21waWxhdGlvbiBzdGF0dXNcbiAgdmFyIHN1Y2Nlc3NmdWxseUNvbXBpbGVkID0gZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpO1xuXG4gIC8vIFRocm93aW5nIGlmIHNvbWV0aGluZyB3ZW50IGF3cnlcbiAgaWYgKCFzdWNjZXNzZnVsbHlDb21waWxlZCkge1xuICAgIHZhciBpbmZvTG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgIGdsLmRlbGV0ZVNoYWRlcihzaGFkZXIpO1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTaGFkZXI6IGVycm9yIHdoaWxlIGNvbXBpbGluZyB0aGUgc2hhZGVyOlxcblwiLmNvbmNhdChpbmZvTG9nLCBcIlxcblwiKS5jb25jYXQoc291cmNlKSk7XG4gIH1cbiAgcmV0dXJuIHNoYWRlcjtcbn1cbmZ1bmN0aW9uIGxvYWRWZXJ0ZXhTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICByZXR1cm4gbG9hZFNoYWRlcihcIlZFUlRFWFwiLCBnbCwgc291cmNlKTtcbn1cbmZ1bmN0aW9uIGxvYWRGcmFnbWVudFNoYWRlcihnbCwgc291cmNlKSB7XG4gIHJldHVybiBsb2FkU2hhZGVyKFwiRlJBR01FTlRcIiwgZ2wsIHNvdXJjZSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBsb2FkIGEgcHJvZ3JhbS5cbiAqL1xuZnVuY3Rpb24gbG9hZFByb2dyYW0oZ2wsIHNoYWRlcnMpIHtcbiAgdmFyIHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKCk7XG4gIGlmIChwcm9ncmFtID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFByb2dyYW06IGVycm9yIHdoaWxlIGNyZWF0aW5nIHRoZSBwcm9ncmFtLlwiKTtcbiAgfVxuICB2YXIgaSwgbDtcblxuICAvLyBBdHRhY2hpbmcgdGhlIHNoYWRlcnNcbiAgZm9yIChpID0gMCwgbCA9IHNoYWRlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgc2hhZGVyc1tpXSk7XG4gIGdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuXG4gIC8vIENoZWNraW5nIHN0YXR1c1xuICB2YXIgc3VjY2Vzc2Z1bGx5TGlua2VkID0gZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5MSU5LX1NUQVRVUyk7XG4gIGlmICghc3VjY2Vzc2Z1bGx5TGlua2VkKSB7XG4gICAgZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkUHJvZ3JhbTogZXJyb3Igd2hpbGUgbGlua2luZyB0aGUgcHJvZ3JhbS5cIik7XG4gIH1cbiAgcmV0dXJuIHByb2dyYW07XG59XG5mdW5jdGlvbiBraWxsUHJvZ3JhbShfcmVmKSB7XG4gIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgYnVmZmVyID0gX3JlZi5idWZmZXIsXG4gICAgcHJvZ3JhbSA9IF9yZWYucHJvZ3JhbSxcbiAgICB2ZXJ0ZXhTaGFkZXIgPSBfcmVmLnZlcnRleFNoYWRlcixcbiAgICBmcmFnbWVudFNoYWRlciA9IF9yZWYuZnJhZ21lbnRTaGFkZXI7XG4gIGdsLmRlbGV0ZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpO1xuICBnbC5kZWxldGVTaGFkZXIoZnJhZ21lbnRTaGFkZXIpO1xuICBnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pO1xuICBnbC5kZWxldGVCdWZmZXIoYnVmZmVyKTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiB1c2UgdG8gcHJpbnQgYSBmbG9hdCBmb3IgaW5zZXJ0aW5nIGluIGEgR0xTTCBwcm9ncmFtLlxuICovXG5mdW5jdGlvbiBudW1iZXJUb0dMU0xGbG9hdChuKSB7XG4gIHJldHVybiBuICUgMSA9PT0gMCA/IG4udG9GaXhlZCgxKSA6IG4udG9TdHJpbmcoKTtcbn1cblxudmFyIFBJQ0tJTkdfUFJFRklYID0gXCIjZGVmaW5lIFBJQ0tJTkdfTU9ERVxcblwiO1xudmFyIFNJWkVfRkFDVE9SX1BFUl9BVFRSSUJVVEVfVFlQRSA9IF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoe30sIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQk9PTCwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuQllURSwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfQllURSwgMSksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuU0hPUlQsIDIpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX1NIT1JULCAyKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5JTlQsIDQpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LlVOU0lHTkVEX0lOVCwgNCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuRkxPQVQsIDQpO1xudmFyIEFic3RyYWN0UHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9fY3JlYXRlQ2xhc3MoZnVuY3Rpb24gQWJzdHJhY3RQcm9ncmFtKF9nbCwgX3BpY2tHbCwgX3JlbmRlcmVyKSB7XG4gIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdFByb2dyYW0pO1xufSk7XG52YXIgUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFByb2dyYW0pO1xuICAgIC8vIEdMZW51bVxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImFycmF5XCIsIG5ldyBGbG9hdDMyQXJyYXkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiY29uc3RhbnRBcnJheVwiLCBuZXcgRmxvYXQzMkFycmF5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNhcGFjaXR5XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZlcnRpY2VzQ291bnRcIiwgMCk7XG4gICAgLy8gUmVhZGluZyBhbmQgY2FjaGluZyBwcm9ncmFtIGRlZmluaXRpb25cbiAgICB2YXIgZGVmID0gdGhpcy5nZXREZWZpbml0aW9uKCk7XG4gICAgdGhpcy5WRVJUSUNFUyA9IGRlZi5WRVJUSUNFUztcbiAgICB0aGlzLlZFUlRFWF9TSEFERVJfU09VUkNFID0gZGVmLlZFUlRFWF9TSEFERVJfU09VUkNFO1xuICAgIHRoaXMuRlJBR01FTlRfU0hBREVSX1NPVVJDRSA9IGRlZi5GUkFHTUVOVF9TSEFERVJfU09VUkNFO1xuICAgIHRoaXMuVU5JRk9STVMgPSBkZWYuVU5JRk9STVM7XG4gICAgdGhpcy5BVFRSSUJVVEVTID0gZGVmLkFUVFJJQlVURVM7XG4gICAgdGhpcy5NRVRIT0QgPSBkZWYuTUVUSE9EO1xuICAgIHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUyA9IFwiQ09OU1RBTlRfQVRUUklCVVRFU1wiIGluIGRlZiA/IGRlZi5DT05TVEFOVF9BVFRSSUJVVEVTIDogW107XG4gICAgdGhpcy5DT05TVEFOVF9EQVRBID0gXCJDT05TVEFOVF9EQVRBXCIgaW4gZGVmID8gZGVmLkNPTlNUQU5UX0RBVEEgOiBbXTtcbiAgICB0aGlzLmlzSW5zdGFuY2VkID0gXCJDT05TVEFOVF9BVFRSSUJVVEVTXCIgaW4gZGVmO1xuXG4gICAgLy8gQ29tcHV0aW5nIHN0cmlkZVxuICAgIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA9IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQVRUUklCVVRFUyk7XG4gICAgdGhpcy5TVFJJREUgPSB0aGlzLlZFUlRJQ0VTICogdGhpcy5BVFRSSUJVVEVTX0lURU1TX0NPVU5UO1xuXG4gICAgLy8gTWVtYmVyc1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLm5vcm1hbFByb2dyYW0gPSB0aGlzLmdldFByb2dyYW1JbmZvKFwibm9ybWFsXCIsIGdsLCBkZWYuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIGRlZi5GUkFHTUVOVF9TSEFERVJfU09VUkNFLCBudWxsKTtcbiAgICB0aGlzLnBpY2tQcm9ncmFtID0gcGlja2luZ0J1ZmZlciA/IHRoaXMuZ2V0UHJvZ3JhbUluZm8oXCJwaWNrXCIsIGdsLCBQSUNLSU5HX1BSRUZJWCArIGRlZi5WRVJURVhfU0hBREVSX1NPVVJDRSwgUElDS0lOR19QUkVGSVggKyBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgcGlja2luZ0J1ZmZlcikgOiBudWxsO1xuXG4gICAgLy8gRm9yIGluc3RhbmNlZCBwcm9ncmFtczpcbiAgICBpZiAodGhpcy5pc0luc3RhbmNlZCkge1xuICAgICAgdmFyIGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQgPSBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCh0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMpO1xuICAgICAgaWYgKHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGggIT09IHRoaXMuVkVSVElDRVMpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29uc3RhbnQgZGF0YSAoZXhwZWN0ZWQgXCIuY29uY2F0KHRoaXMuVkVSVElDRVMsIFwiIGl0ZW1zLCByZWNlaXZlZCBcIikuY29uY2F0KHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGgsIFwiIGluc3RlYWQpXCIpKTtcbiAgICAgIHRoaXMuY29uc3RhbnRBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkodGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aCAqIGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHZlY3RvciA9IHRoaXMuQ09OU1RBTlRfREFUQVtpXTtcbiAgICAgICAgaWYgKHZlY3Rvci5sZW5ndGggIT09IGNvbnN0YW50QXR0cmlidXRlc0l0ZW1zQ291bnQpIHRocm93IG5ldyBFcnJvcihcIlByb2dyYW06IGVycm9yIHdoaWxlIGdldHRpbmcgY29uc3RhbnQgZGF0YSAob25lIHZlY3RvciBoYXMgXCIuY29uY2F0KHZlY3Rvci5sZW5ndGgsIFwiIGl0ZW1zIGluc3RlYWQgb2YgXCIpLmNvbmNhdChjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50LCBcIilcIikpO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZlY3Rvci5sZW5ndGg7IGorKykgdGhpcy5jb25zdGFudEFycmF5W2kgKiBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50ICsgal0gPSB2ZWN0b3Jbal07XG4gICAgICB9XG4gICAgICB0aGlzLlNUUklERSA9IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBraWxsUHJvZ3JhbSh0aGlzLm5vcm1hbFByb2dyYW0pO1xuICAgICAgaWYgKHRoaXMucGlja1Byb2dyYW0pIHtcbiAgICAgICAga2lsbFByb2dyYW0odGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMucGlja1Byb2dyYW0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcm9ncmFtSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9ncmFtSW5mbyhuYW1lLCBnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgZnJhbWVCdWZmZXIpIHtcbiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgICAgLy8gV2ViR0wgYnVmZmVyc1xuICAgICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGJ1ZmZlci5cIik7XG5cbiAgICAgIC8vIFNoYWRlcnMgYW5kIHByb2dyYW1cbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBsb2FkVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gbG9hZEZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICB2YXIgcHJvZ3JhbSA9IGxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICAvLyBJbml0aWFsaXppbmcgbG9jYXRpb25zXG4gICAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLlVOSUZPUk1TLmZvckVhY2goZnVuY3Rpb24gKHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbikgdW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV0gPSBsb2NhdGlvbjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHIubmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGluc3RhbmNlZCBwcm9ncmFtczpcbiAgICAgIHZhciBjb25zdGFudEJ1ZmZlcjtcbiAgICAgIGlmIChcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0ci5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0YW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmIChjb25zdGFudEJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGNvbnN0YW50IGJ1ZmZlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyOiBmcmFtZUJ1ZmZlcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIGNvbnN0YW50QnVmZmVyOiBjb25zdGFudEJ1ZmZlciB8fCB7fSxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9ucyxcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICAgIGlzUGlja2luZzogbmFtZSA9PT0gXCJwaWNrXCIsXG4gICAgICAgIHZlcnRleFNoYWRlcjogdmVydGV4U2hhZGVyLFxuICAgICAgICBmcmFnbWVudFNoYWRlcjogZnJhZ21lbnRTaGFkZXJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2wsXG4gICAgICAgIGJ1ZmZlciA9IHByb2dyYW0uYnVmZmVyO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXksIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgY29uc3RhbnQgZGF0YSAodGhpbmdzIHRoYXQgcmVtYWluIHVuY2hhbmdlZCBmb3IgYWxsIGl0ZW1zKTpcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHByb2dyYW0uY29uc3RhbnRCdWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbnN0YW50QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBIYW5kbGUgXCJpbnN0YW5jZSBzcGVjaWZpY1wiIGRhdGEgKHRoaW5ncyB0aGF0IHZhcnkgZm9yIGVhY2ggaXRlbSk6XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwcm9ncmFtLmJ1ZmZlcik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCArPSBfdGhpcy5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hcnJheSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi51bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgc2V0RGl2aXNvcikge1xuICAgICAgdmFyIHNpemVGYWN0b3IgPSBTSVpFX0ZBQ1RPUl9QRVJfQVRUUklCVVRFX1RZUEVbYXR0ci50eXBlXTtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZUZhY3RvciAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbS5iaW5kOiB5ZXQgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGUgXFxcIlwiLmNvbmNhdChhdHRyLnR5cGUsIFwiXFxcIlwiKSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdO1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbS5nbDtcbiAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICB2YXIgc3RyaWRlID0gIXRoaXMuaXNJbnN0YW5jZWQgPyB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAoc2V0RGl2aXNvciA/IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUykpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHNldERpdmlzb3IpIHtcbiAgICAgICAgICBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICAgICAgICBpZiAoZXh0KSBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyLnNpemUgKiBzaXplRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHVuc2V0RGl2aXNvcikge1xuICAgICAgdmFyIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXTtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2w7XG4gICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHVuc2V0RGl2aXNvcikge1xuICAgICAgICAgIGlmIChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICAgIGlmIChleHQpIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUobG9jYXRpb24sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgIC8vIElmIGRlc2lyZWQgY2FwYWNpdHkgaGFzIG5vdCBjaGFuZ2VkIHdlIGRvIG5vdGhpbmdcbiAgICAgIC8vIE5PVEU6IGl0J3MgcG9zc2libGUgaGVyZSB0byBpbXBsZW1lbnQgbW9yZSBzdWJ0bGUgcmVhbGxvY2F0aW9uIHNjaGVtZXNcbiAgICAgIC8vIHdoZW4gdGhlIG51bWJlciBvZiByZW5kZXJlZCBpdGVtcyBpbmNyZWFzZSBvciBkZWNyZWFzZVxuICAgICAgaWYgKGNhcGFjaXR5ID09PSB0aGlzLmNhcGFjaXR5KSByZXR1cm47XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSB0aGlzLlZFUlRJQ0VTICogY2FwYWNpdHk7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSghdGhpcy5pc0luc3RhbmNlZCA/IHRoaXMudmVydGljZXNDb3VudCAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IHRoaXMuY2FwYWNpdHkgKiB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNOb3RoaW5nVG9SZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTm90aGluZ1RvUmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNDb3VudCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQcm9ncmFtKHBhcmFtcywgcHJvZ3JhbUluZm8pIHtcbiAgICAgIHZhciBnbCA9IHByb2dyYW1JbmZvLmdsLFxuICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm8ucHJvZ3JhbTtcblxuICAgICAgLy8gV2l0aCB0aGUgY3VycmVudCBmaXggZm9yICMxMzk3LCB0aGUgYWxwaGEgYmxlbmRpbmcgaXMgZW5hYmxlZCBmb3IgdGhlXG4gICAgICAvLyBwaWNraW5nIGxheWVyOlxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcblxuICAgICAgLy8gT3JpZ2luYWwgY29kZTpcbiAgICAgIC8vIGlmICghaXNQaWNraW5nKSBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgLy8gZWxzZSBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMocGFyYW1zLCBwcm9ncmFtSW5mbyk7XG4gICAgICB0aGlzLmRyYXdXZWJHTCh0aGlzLk1FVEhPRCwgcHJvZ3JhbUluZm8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgaWYgKHRoaXMuaGFzTm90aGluZ1RvUmVuZGVyKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnBpY2tQcm9ncmFtKSB7XG4gICAgICAgIHRoaXMucGlja1Byb2dyYW0uZ2wudmlld3BvcnQoMCwgMCwgcGFyYW1zLndpZHRoICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvLCBwYXJhbXMuaGVpZ2h0ICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvKTtcbiAgICAgICAgdGhpcy5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5yZW5kZXJQcm9ncmFtKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgIHBpeGVsUmF0aW86IHBhcmFtcy5waXhlbFJhdGlvIC8gcGFyYW1zLmRvd25TaXppbmdSYXRpb1xuICAgICAgICB9KSwgdGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMudW5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsUHJvZ3JhbS5nbC52aWV3cG9ydCgwLCAwLCBwYXJhbXMud2lkdGggKiBwYXJhbXMucGl4ZWxSYXRpbywgcGFyYW1zLmhlaWdodCAqIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHRoaXMuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICAgIHRoaXMucmVuZGVyUHJvZ3JhbShwYXJhbXMsIHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgICB0aGlzLnVuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1dlYkdMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXZWJHTChtZXRob2QsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyID0gX3JlZi5mcmFtZUJ1ZmZlcjtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmRyYXdBcnJheXMobWV0aG9kLCAwLCB0aGlzLnZlcnRpY2VzQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQobWV0aG9kLCAwLCB0aGlzLlZFUlRJQ0VTLCB0aGlzLmNhcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICBpZiAoZXh0KSBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKG1ldGhvZCwgMCwgdGhpcy5WRVJUSUNFUywgdGhpcy5jYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxudmFyIEFic3RyYWN0Tm9kZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFByb2dyYW0pIHtcbiAgZnVuY3Rpb24gQWJzdHJhY3ROb2RlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoQWJzdHJhY3ROb2RlUHJvZ3JhbSwgX0Fic3RyYWN0UHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJzdHJhY3ROb2RlUHJvZ3JhbSk7XG59KEFic3RyYWN0UHJvZ3JhbSk7XG52YXIgTm9kZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9yZWYpIHtcbiAgZnVuY3Rpb24gTm9kZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBOb2RlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoTm9kZVByb2dyYW0sIF9yZWYpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKE5vZGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICBfc3VwZXJQcm9wR2V0KE5vZGVQcm9ncmFtLCBcImtpbGxcIiwgdGhpcywgMykoW10pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpIHtcbiAgICAgIHZhciBpID0gb2Zmc2V0ICogdGhpcy5TVFJJREU7XG4gICAgICAvLyBOT1RFOiBkZWFsaW5nIHdpdGggaGlkZGVuIGl0ZW1zIGF1dG9tYXRpY2FsbHlcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBsID0gaSArIHRoaXMuU1RSSURFOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Zpc2libGVJdGVtKGluZGV4VG9Db2xvcihub2RlSW5kZXgpLCBpLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcbn0oUHJvZ3JhbSk7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBjb21iaW5pbmcgdHdvIG9yIG1vcmUgcHJvZ3JhbXMgaW50byBhIHNpbmdsZSBjb21wb3VuZCBvbmUuXG4gKiBOb3RlIHRoYXQgdGhpcyBpcyBtb3JlIGEgcXVpY2sgJiBlYXN5IHdheSB0byBjb21iaW5lIHByb2dyYW0gdGhhbiBhIHJlYWxseVxuICogcGVyZm9ybWFudCBvcHRpb24uIE1vcmUgcGVyZm9ybWFudCBwcm9ncmFtcyBjYW4gYmUgd3JpdHRlbiBlbnRpcmVseS5cbiAqXG4gKiBAcGFyYW0gIHthcnJheX0gICAgcHJvZ3JhbUNsYXNzZXMgLSBQcm9ncmFtIGNsYXNzZXMgdG8gY29tYmluZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBkcmF3TGFiZWwgLSBBbiBvcHRpb25hbCBub2RlIFwiZHJhdyBsYWJlbFwiIGZ1bmN0aW9uLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdIb3ZlciAtIEFuIG9wdGlvbmFsIG5vZGUgXCJkcmF3IGhvdmVyXCIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbShwcm9ncmFtQ2xhc3NlcywgZHJhd0xhYmVsLCBkcmF3SG92ZXIpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZUNvbXBvdW5kUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlQ29tcG91bmRQcm9ncmFtKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdMYWJlbFwiLCBkcmF3TGFiZWwpO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0hvdmVyXCIsIGRyYXdIb3Zlcik7XG4gICAgICB0aGlzLnByb2dyYW1zID0gcHJvZ3JhbUNsYXNzZXMubWFwKGZ1bmN0aW9uIChQcm9ncmFtKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZUNvbXBvdW5kUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhbGxvY2F0ZShjYXBhY2l0eSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZWFsbG9jYXRlKGNhcGFjaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKG5vZGVJbmRleCwgb2Zmc2V0LCBkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImtpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfSgpO1xufVxuXG52YXIgQWJzdHJhY3RFZGdlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Fic3RyYWN0UHJvZ3JhbSkge1xuICBmdW5jdGlvbiBBYnN0cmFjdEVkZ2VQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhBYnN0cmFjdEVkZ2VQcm9ncmFtLCBfQWJzdHJhY3RQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhBYnN0cmFjdEVkZ2VQcm9ncmFtKTtcbn0oQWJzdHJhY3RQcm9ncmFtKTtcbnZhciBFZGdlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3JlZikge1xuICBmdW5jdGlvbiBFZGdlUHJvZ3JhbSgpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VQcm9ncmFtKTtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBFZGdlUHJvZ3JhbSwgW10uY29uY2F0KGFyZ3MpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZHJhd0xhYmVsXCIsIHVuZGVmaW5lZCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9pbmhlcml0cyhFZGdlUHJvZ3JhbSwgX3JlZik7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIF9zdXBlclByb3BHZXQoRWRnZVByb2dyYW0sIFwia2lsbFwiLCB0aGlzLCAzKShbXSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgdmFyIGkgPSBvZmZzZXQgKiB0aGlzLlNUUklERTtcbiAgICAgIC8vIE5PVEU6IGRlYWxpbmcgd2l0aCBoaWRkZW4gaXRlbXMgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGRhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBpICsgdGhpcy5TVFJJREU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFycmF5W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzVmlzaWJsZUl0ZW0oaW5kZXhUb0NvbG9yKGVkZ2VJbmRleCksIGksIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xufShQcm9ncmFtKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGNvbWJpbmluZyB0d28gb3IgbW9yZSBwcm9ncmFtcyBpbnRvIGEgc2luZ2xlIGNvbXBvdW5kIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG1vcmUgYSBxdWljayAmIGVhc3kgd2F5IHRvIGNvbWJpbmUgcHJvZ3JhbSB0aGFuIGEgcmVhbGx5XG4gKiBwZXJmb3JtYW50IG9wdGlvbi4gTW9yZSBwZXJmb3JtYW50IHByb2dyYW1zIGNhbiBiZSB3cml0dGVuIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBwcm9ncmFtQ2xhc3NlcyAtIFByb2dyYW0gY2xhc3NlcyB0byBjb21iaW5lLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdMYWJlbCAtIEFuIG9wdGlvbmFsIGVkZ2UgXCJkcmF3IGxhYmVsXCIgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUNvbXBvdW5kUHJvZ3JhbShwcm9ncmFtQ2xhc3NlcywgZHJhd0xhYmVsKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVkZ2VDb21wb3VuZFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUNvbXBvdW5kUHJvZ3JhbSk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3TGFiZWxcIiwgZHJhd0xhYmVsKTtcbiAgICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlQ29tcG91bmRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcInJlYWxsb2NhdGVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZWFsbG9jYXRlKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlYWxsb2NhdGUoY2FwYWNpdHkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3MoZWRnZUluZGV4LCBvZmZzZXQsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJyZW5kZXJcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIocGFyYW1zKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnJlbmRlcihwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2lsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLmtpbGwoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdTdHJhaWdodEVkZ2VMYWJlbChjb250ZXh0LCBlZGdlRGF0YSwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNpemUgPSBzZXR0aW5ncy5lZGdlTGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5lZGdlTGFiZWxGb250LFxuICAgIHdlaWdodCA9IHNldHRpbmdzLmVkZ2VMYWJlbFdlaWdodCxcbiAgICBjb2xvciA9IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZSA/IGVkZ2VEYXRhW3NldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmF0dHJpYnV0ZV0gfHwgc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuY29sb3IgfHwgXCIjMDAwXCIgOiBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5jb2xvcjtcbiAgdmFyIGxhYmVsID0gZWRnZURhdGEubGFiZWw7XG4gIGlmICghbGFiZWwpIHJldHVybjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcblxuICAvLyBDb21wdXRpbmcgcG9zaXRpb25zIHdpdGhvdXQgY29uc2lkZXJpbmcgbm9kZXMgc2l6ZXM6XG4gIHZhciBzU2l6ZSA9IHNvdXJjZURhdGEuc2l6ZTtcbiAgdmFyIHRTaXplID0gdGFyZ2V0RGF0YS5zaXplO1xuICB2YXIgc3ggPSBzb3VyY2VEYXRhLng7XG4gIHZhciBzeSA9IHNvdXJjZURhdGEueTtcbiAgdmFyIHR4ID0gdGFyZ2V0RGF0YS54O1xuICB2YXIgdHkgPSB0YXJnZXREYXRhLnk7XG4gIHZhciBjeCA9IChzeCArIHR4KSAvIDI7XG4gIHZhciBjeSA9IChzeSArIHR5KSAvIDI7XG4gIHZhciBkeCA9IHR4IC0gc3g7XG4gIHZhciBkeSA9IHR5IC0gc3k7XG4gIHZhciBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcbiAgaWYgKGQgPCBzU2l6ZSArIHRTaXplKSByZXR1cm47XG5cbiAgLy8gQWRkaW5nIG5vZGVzIHNpemVzOlxuICBzeCArPSBkeCAqIHNTaXplIC8gZDtcbiAgc3kgKz0gZHkgKiBzU2l6ZSAvIGQ7XG4gIHR4IC09IGR4ICogdFNpemUgLyBkO1xuICB0eSAtPSBkeSAqIHRTaXplIC8gZDtcbiAgY3ggPSAoc3ggKyB0eCkgLyAyO1xuICBjeSA9IChzeSArIHR5KSAvIDI7XG4gIGR4ID0gdHggLSBzeDtcbiAgZHkgPSB0eSAtIHN5O1xuICBkID0gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblxuICAvLyBIYW5kbGluZyBlbGxpcHNpc1xuICB2YXIgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICBpZiAodGV4dExlbmd0aCA+IGQpIHtcbiAgICB2YXIgZWxsaXBzaXMgPSBcIuKAplwiO1xuICAgIGxhYmVsID0gbGFiZWwgKyBlbGxpcHNpcztcbiAgICB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgd2hpbGUgKHRleHRMZW5ndGggPiBkICYmIGxhYmVsLmxlbmd0aCA+IDEpIHtcbiAgICAgIGxhYmVsID0gbGFiZWwuc2xpY2UoMCwgLTIpICsgZWxsaXBzaXM7XG4gICAgICB0ZXh0TGVuZ3RoID0gY29udGV4dC5tZWFzdXJlVGV4dChsYWJlbCkud2lkdGg7XG4gICAgfVxuICAgIGlmIChsYWJlbC5sZW5ndGggPCA0KSByZXR1cm47XG4gIH1cbiAgdmFyIGFuZ2xlO1xuICBpZiAoZHggPiAwKSB7XG4gICAgaWYgKGR5ID4gMCkgYW5nbGUgPSBNYXRoLmFjb3MoZHggLyBkKTtlbHNlIGFuZ2xlID0gTWF0aC5hc2luKGR5IC8gZCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGR5ID4gMCkgYW5nbGUgPSBNYXRoLmFjb3MoZHggLyBkKSArIE1hdGguUEk7ZWxzZSBhbmdsZSA9IE1hdGguYXNpbihkeCAvIGQpICsgTWF0aC5QSSAvIDI7XG4gIH1cbiAgY29udGV4dC5zYXZlKCk7XG4gIGNvbnRleHQudHJhbnNsYXRlKGN4LCBjeSk7XG4gIGNvbnRleHQucm90YXRlKGFuZ2xlKTtcbiAgY29udGV4dC5maWxsVGV4dChsYWJlbCwgLXRleHRMZW5ndGggLyAyLCBlZGdlRGF0YS5zaXplIC8gMiArIHNpemUpO1xuICBjb250ZXh0LnJlc3RvcmUoKTtcbn1cblxuZnVuY3Rpb24gZHJhd0Rpc2NOb2RlTGFiZWwoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgaWYgKCFkYXRhLmxhYmVsKSByZXR1cm47XG4gIHZhciBzaXplID0gc2V0dGluZ3MubGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5sYWJlbEZvbnQsXG4gICAgd2VpZ2h0ID0gc2V0dGluZ3MubGFiZWxXZWlnaHQsXG4gICAgY29sb3IgPSBzZXR0aW5ncy5sYWJlbENvbG9yLmF0dHJpYnV0ZSA/IGRhdGFbc2V0dGluZ3MubGFiZWxDb2xvci5hdHRyaWJ1dGVdIHx8IHNldHRpbmdzLmxhYmVsQ29sb3IuY29sb3IgfHwgXCIjMDAwXCIgOiBzZXR0aW5ncy5sYWJlbENvbG9yLmNvbG9yO1xuICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xuICBjb250ZXh0LmZvbnQgPSBcIlwiLmNvbmNhdCh3ZWlnaHQsIFwiIFwiKS5jb25jYXQoc2l6ZSwgXCJweCBcIikuY29uY2F0KGZvbnQpO1xuICBjb250ZXh0LmZpbGxUZXh0KGRhdGEubGFiZWwsIGRhdGEueCArIGRhdGEuc2l6ZSArIDMsIGRhdGEueSArIHNpemUgLyAzKTtcbn1cblxuLyoqXG4gKiBEcmF3IGFuIGhvdmVyZWQgbm9kZS5cbiAqIC0gaWYgdGhlcmUgaXMgbm8gbGFiZWwgPT4gZGlzcGxheSBhIHNoYWRvdyBvbiB0aGUgbm9kZVxuICogLSBpZiB0aGUgbGFiZWwgYm94IGlzIGJpZ2dlciB0aGFuIG5vZGUgc2l6ZSA9PiBkaXNwbGF5IGEgbGFiZWwgYm94IHRoYXQgY29udGFpbnMgdGhlIG5vZGUgd2l0aCBhIHNoYWRvd1xuICogLSBlbHNlIG5vZGUgd2l0aCBzaGFkb3cgYW5kIHRoZSBsYWJlbCBib3hcbiAqL1xuZnVuY3Rpb24gZHJhd0Rpc2NOb2RlSG92ZXIoY29udGV4dCwgZGF0YSwgc2V0dGluZ3MpIHtcbiAgdmFyIHNpemUgPSBzZXR0aW5ncy5sYWJlbFNpemUsXG4gICAgZm9udCA9IHNldHRpbmdzLmxhYmVsRm9udCxcbiAgICB3ZWlnaHQgPSBzZXR0aW5ncy5sYWJlbFdlaWdodDtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcblxuICAvLyBUaGVuIHdlIGRyYXcgdGhlIGxhYmVsIGJhY2tncm91bmRcbiAgY29udGV4dC5maWxsU3R5bGUgPSBcIiNGRkZcIjtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgY29udGV4dC5zaGFkb3dCbHVyID0gODtcbiAgY29udGV4dC5zaGFkb3dDb2xvciA9IFwiIzAwMFwiO1xuICB2YXIgUEFERElORyA9IDI7XG4gIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHZhciB0ZXh0V2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGRhdGEubGFiZWwpLndpZHRoLFxuICAgICAgYm94V2lkdGggPSBNYXRoLnJvdW5kKHRleHRXaWR0aCArIDUpLFxuICAgICAgYm94SGVpZ2h0ID0gTWF0aC5yb3VuZChzaXplICsgMiAqIFBBRERJTkcpLFxuICAgICAgcmFkaXVzID0gTWF0aC5tYXgoZGF0YS5zaXplLCBzaXplIC8gMikgKyBQQURESU5HO1xuICAgIHZhciBhbmdsZVJhZGlhbiA9IE1hdGguYXNpbihib3hIZWlnaHQgLyAyIC8gcmFkaXVzKTtcbiAgICB2YXIgeERlbHRhQ29vcmQgPSBNYXRoLnNxcnQoTWF0aC5hYnMoTWF0aC5wb3cocmFkaXVzLCAyKSAtIE1hdGgucG93KGJveEhlaWdodCAvIDIsIDIpKSk7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0Lm1vdmVUbyhkYXRhLnggKyB4RGVsdGFDb29yZCwgZGF0YS55ICsgYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgcmFkaXVzICsgYm94V2lkdGgsIGRhdGEueSArIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHJhZGl1cyArIGJveFdpZHRoLCBkYXRhLnkgLSBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyB4RGVsdGFDb29yZCwgZGF0YS55IC0gYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5hcmMoZGF0YS54LCBkYXRhLnksIHJhZGl1cywgYW5nbGVSYWRpYW4sIC1hbmdsZVJhZGlhbik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIGNvbnRleHQuYXJjKGRhdGEueCwgZGF0YS55LCBkYXRhLnNpemUgKyBQQURESU5HLCAwLCBNYXRoLlBJICogMik7XG4gICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICBjb250ZXh0LmZpbGwoKTtcbiAgfVxuICBjb250ZXh0LnNoYWRvd09mZnNldFggPSAwO1xuICBjb250ZXh0LnNoYWRvd09mZnNldFkgPSAwO1xuICBjb250ZXh0LnNoYWRvd0JsdXIgPSAwO1xuXG4gIC8vIEFuZCBmaW5hbGx5IHdlIGRyYXcgdGhlIGxhYmVsXG4gIGRyYXdEaXNjTm9kZUxhYmVsKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKTtcbn1cblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNiA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfZGlmZlZlY3RvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO1xcblxcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxuY29uc3QgdmVjNCB0cmFuc3BhcmVudCA9IHZlYzQoMC4wLCAwLjAsIDAuMCwgMC4wKTtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZmxvYXQgYm9yZGVyID0gdV9jb3JyZWN0aW9uUmF0aW8gKiAyLjA7XFxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfZGlmZlZlY3RvcikgLSB2X3JhZGl1cyArIGJvcmRlcjtcXG5cXG4gIC8vIE5vIGFudGlhbGlhc2luZyBmb3IgcGlja2luZyBtb2RlOlxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgaWYgKGRpc3QgPiBib3JkZXIpXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRyYW5zcGFyZW50O1xcbiAgZWxzZVxcbiAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcblxcbiAgI2Vsc2VcXG4gIGZsb2F0IHQgPSAwLjA7XFxuICBpZiAoZGlzdCA+IGJvcmRlcilcXG4gICAgdCA9IDEuMDtcXG4gIGVsc2UgaWYgKGRpc3QgPiAwLjApXFxuICAgIHQgPSBkaXN0IC8gYm9yZGVyO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZfY29sb3IsIHRyYW5zcGFyZW50LCB0KTtcXG4gICNlbmRpZlxcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIgPSBTSEFERVJfU09VUkNFJDY7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDUgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIGZsb2F0IGFfc2l6ZTtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9hbmdsZTtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X2RpZmZWZWN0b3I7XFxudmFyeWluZyBmbG9hdCB2X3JhZGl1cztcXG52YXJ5aW5nIGZsb2F0IHZfYm9yZGVyO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IHNpemUgPSBhX3NpemUgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvICogNC4wO1xcbiAgdmVjMiBkaWZmVmVjdG9yID0gc2l6ZSAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb24gKyBkaWZmVmVjdG9yO1xcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KFxcbiAgICAodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uLCAxKSkueHksXFxuICAgIDAsXFxuICAgIDFcXG4gICk7XFxuXFxuICB2X2RpZmZWZWN0b3IgPSBkaWZmVmVjdG9yO1xcbiAgdl9yYWRpdXMgPSBzaXplIC8gMi4wO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDMgPSBTSEFERVJfU09VUkNFJDU7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMyA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQzID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMyA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzLkZMT0FUO1xudmFyIFVOSUZPUk1TJDMgPSBbXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9tYXRyaXhcIl07XG52YXIgTm9kZUNpcmNsZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9Ob2RlUHJvZ3JhbSkge1xuICBmdW5jdGlvbiBOb2RlQ2lyY2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNpcmNsZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE5vZGVDaXJjbGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9pbmhlcml0cyhOb2RlQ2lyY2xlUHJvZ3JhbSwgX05vZGVQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhOb2RlQ2lyY2xlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQzLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDMsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfc2l6ZVwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfYW5nbGVcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDNcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbTm9kZUNpcmNsZVByb2dyYW0uQU5HTEVfMV0sIFtOb2RlQ2lyY2xlUHJvZ3JhbS5BTkdMRV8yXSwgW05vZGVDaXJjbGVQcm9ncmFtLkFOR0xFXzNdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShub2RlSW5kZXgsIHN0YXJ0SW5kZXgsIGRhdGEpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEueDtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS5zaXplO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG5vZGVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXg7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICB9XG4gIH1dKTtcbn0oTm9kZVByb2dyYW0pO1xuX2RlZmluZVByb3BlcnR5KE5vZGVDaXJjbGVQcm9ncmFtLCBcIkFOR0xFXzFcIiwgMCk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfMlwiLCAyICogTWF0aC5QSSAvIDMpO1xuX2RlZmluZVByb3BlcnR5KE5vZGVDaXJjbGVQcm9ncmFtLCBcIkFOR0xFXzNcIiwgNCAqIE1hdGguUEkgLyAzKTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNCA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQ0O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQzID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb247XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzO1xcbmF0dHJpYnV0ZSB2ZWMzIGFfYmFyeWNlbnRyaWM7XFxuXFxuI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuI2Vsc2VcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbiNlbmRpZlxcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBtaW5UaGlja25lc3MgPSB1X21pbkVkZ2VUaGlja25lc3M7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgoYV9ub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gYV9ub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuXFxuICAvLyBUaGVzZSBmaXJzdCBjb21wdXRhdGlvbnMgYXJlIHRha2VuIGZyb20gZWRnZS52ZXJ0Lmdsc2wgYW5kXFxuICAvLyBlZGdlLmNsYW1wZWQudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0byBnZXQgYmV0dGVyIGNvbW1lbnRzIG9uIHdoYXQnc1xcbiAgLy8gaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCAvIHVfc2l6ZVJhdGlvLCBtaW5UaGlja25lc3MpO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbztcXG4gIGZsb2F0IHdlYkdMTm9kZVJhZGl1cyA9IGFfcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gKiAyLjA7XFxuICBmbG9hdCB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzICogdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW87XFxuXFxuICBmbG9hdCBkYSA9IGFfYmFyeWNlbnRyaWMueDtcXG4gIGZsb2F0IGRiID0gYV9iYXJ5Y2VudHJpYy55O1xcbiAgZmxvYXQgZGMgPSBhX2JhcnljZW50cmljLno7XFxuXFxuICB2ZWMyIGRlbHRhID0gdmVjMihcXG4gICAgICBkYSAqICh3ZWJHTE5vZGVSYWRpdXMgKiB1bml0Tm9ybWFsLnkpXFxuICAgICsgZGIgKiAoKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueSArIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC54KVxcbiAgICArIGRjICogKCh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnkgLSB3ZWJHTEFycm93SGVhZFRoaWNrbmVzcyAqIHVuaXROb3JtYWwueCksXFxuXFxuICAgICAgZGEgKiAoLXdlYkdMTm9kZVJhZGl1cyAqIHVuaXROb3JtYWwueClcXG4gICAgKyBkYiAqICgtKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueCArIHdlYkdMQXJyb3dIZWFkVGhpY2tuZXNzICogdW5pdE5vcm1hbC55KVxcbiAgICArIGRjICogKC0od2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC54IC0gd2ViR0xBcnJvd0hlYWRUaGlja25lc3MgKiB1bml0Tm9ybWFsLnkpXFxuICApO1xcblxcbiAgdmVjMiBwb3NpdGlvbiA9ICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiArIGRlbHRhLCAxKSkueHk7XFxuXFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQocG9zaXRpb24sIDAsIDEpO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDIgPSBTSEFERVJfU09VUkNFJDM7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMiA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQyID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMiA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyLkZMT0FUO1xudmFyIFVOSUZPUk1TJDIgPSBbXCJ1X21hdHJpeFwiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIiwgXCJ1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW9cIiwgXCJ1X3dpZGVuZXNzVG9UaGlja25lc3NSYXRpb1wiXTtcbnZhciBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMgPSB7XG4gIGV4dHJlbWl0eTogXCJ0YXJnZXRcIixcbiAgbGVuZ3RoVG9UaGlja25lc3NSYXRpbzogMi41LFxuICB3aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW86IDJcbn07XG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbShpbnB1dE9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TKSwgaW5wdXRPcHRpb25zIHx8IHt9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gICAgZnVuY3Rpb24gRWRnZUFycm93SGVhZFByb2dyYW0oKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUFycm93SGVhZFByb2dyYW0pO1xuICAgICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZUFycm93SGVhZFByb2dyYW0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9pbmhlcml0cyhFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFZFUlRJQ0VTOiAzLFxuICAgICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQyLFxuICAgICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMSxcbiAgICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDIsXG4gICAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQyLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX2JhcnljZW50cmljXCIsXG4gICAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICAgIH1dLFxuICAgICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMSwgMCwgMF0sIFswLCAxLCAwXSwgWzAsIDAsIDFdXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmV4dHJlbWl0eSA9PT0gXCJzb3VyY2VcIikge1xuICAgICAgICAgIHZhciBfcmVmID0gW3RhcmdldERhdGEsIHNvdXJjZURhdGFdO1xuICAgICAgICAgIHNvdXJjZURhdGEgPSBfcmVmWzBdO1xuICAgICAgICAgIHRhcmdldERhdGEgPSBfcmVmWzFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgICB2YXIgbjEgPSAwO1xuICAgICAgICB2YXIgbjIgPSAwO1xuICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSAtbjE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSAtbjI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSByYWRpdXM7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYyKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYyLmdsLFxuICAgICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmMi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgICAgdV9taW5FZGdlVGhpY2tuZXNzID0gdW5pZm9ybUxvY2F0aW9ucy51X21pbkVkZ2VUaGlja25lc3MsXG4gICAgICAgICAgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8sXG4gICAgICAgICAgdV93aWRlbmVzc1RvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvO1xuICAgICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X21pbkVkZ2VUaGlja25lc3MsIHBhcmFtcy5taW5FZGdlVGhpY2tuZXNzKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbywgb3B0aW9ucy5sZW5ndGhUb1RoaWNrbmVzc1JhdGlvKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfd2lkZW5lc3NUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLndpZGVuZXNzVG9UaGlja25lc3NSYXRpbyk7XG4gICAgICB9XG4gICAgfV0pO1xuICB9KEVkZ2VQcm9ncmFtKTtcbn1cbnZhciBFZGdlQXJyb3dIZWFkUHJvZ3JhbSA9IGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtKCk7XG52YXIgRWRnZUFycm93SGVhZFByb2dyYW0kMSA9IEVkZ2VBcnJvd0hlYWRQcm9ncmFtO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQyID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9mZWF0aGVyO1xcblxcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIC8vIFdlIG9ubHkgaGFuZGxlIGFudGlhbGlhc2luZyBmb3Igbm9ybWFsIG1vZGU6XFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbiAgI2Vsc2VcXG4gIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9ub3JtYWwpICogdl90aGlja25lc3M7XFxuXFxuICBmbG9hdCB0ID0gc21vb3Roc3RlcChcXG4gICAgdl90aGlja25lc3MgLSB2X2ZlYXRoZXIsXFxuICAgIHZfdGhpY2tuZXNzLFxcbiAgICBkaXN0XFxuICApO1xcblxcbiAgZ2xfRnJhZ0NvbG9yID0gbWl4KHZfY29sb3IsIHRyYW5zcGFyZW50LCB0KTtcXG4gICNlbmRpZlxcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRSQyO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQxID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9ub3JtYWxDb2VmO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25TdGFydDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uRW5kO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3Bvc2l0aW9uQ29lZjtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzQ29lZjtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3pvb21SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9waXhlbFJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X21pbkVkZ2VUaGlja25lc3M7XFxudW5pZm9ybSBmbG9hdCB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2ZlYXRoZXI7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfbm9ybWFsO1xcbnZhcnlpbmcgZmxvYXQgdl90aGlja25lc3M7XFxudmFyeWluZyBmbG9hdCB2X2ZlYXRoZXI7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbWluVGhpY2tuZXNzID0gdV9taW5FZGdlVGhpY2tuZXNzO1xcblxcbiAgZmxvYXQgcmFkaXVzID0gYV9yYWRpdXMgKiBhX3JhZGl1c0NvZWY7XFxuICB2ZWMyIG5vcm1hbCA9IGFfbm9ybWFsICogYV9ub3JtYWxDb2VmO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb25TdGFydCAqICgxLjAgLSBhX3Bvc2l0aW9uQ29lZikgKyBhX3Bvc2l0aW9uRW5kICogYV9wb3NpdGlvbkNvZWY7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgobm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IG5vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFRoZXNlIGZpcnN0IGNvbXB1dGF0aW9ucyBhcmUgdGFrZW4gZnJvbSBlZGdlLnZlcnQuZ2xzbC4gUGxlYXNlIHJlYWQgaXQgdG9cXG4gIC8vIGdldCBiZXR0ZXIgY29tbWVudHMgb24gd2hhdCdzIGhhcHBlbmluZzpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG5cXG4gIC8vIEhlcmUsIHdlIG1vdmUgdGhlIHBvaW50IHRvIGxlYXZlIHNwYWNlIGZvciB0aGUgYXJyb3cgaGVhZDpcXG4gIGZsb2F0IGRpcmVjdGlvbiA9IHNpZ24ocmFkaXVzKTtcXG4gIGZsb2F0IHdlYkdMTm9kZVJhZGl1cyA9IGRpcmVjdGlvbiAqIHJhZGl1cyAqIDIuMCAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuICBmbG9hdCB3ZWJHTEFycm93SGVhZExlbmd0aCA9IHdlYkdMVGhpY2tuZXNzICogdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvICogMi4wO1xcblxcbiAgdmVjMiBjb21wZW5zYXRpb25WZWN0b3IgPSB2ZWMyKC1kaXJlY3Rpb24gKiB1bml0Tm9ybWFsLnksIGRpcmVjdGlvbiAqIHVuaXROb3JtYWwueCkgKiAod2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzICsgY29tcGVuc2F0aW9uVmVjdG9yLCAxKSkueHksIDAsIDEpO1xcblxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfem9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcblxcbiAgdl9mZWF0aGVyID0gdV9mZWF0aGVyICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3pvb21SYXRpbyAvIHVfcGl4ZWxSYXRpbyAqIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQxO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDEgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMS5GTE9BVDtcbnZhciBVTklGT1JNUyQxID0gW1widV9tYXRyaXhcIiwgXCJ1X3pvb21SYXRpb1wiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X3BpeGVsUmF0aW9cIiwgXCJ1X2ZlYXRoZXJcIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIiwgXCJ1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW9cIl07XG52YXIgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TID0ge1xuICBsZW5ndGhUb1RoaWNrbmVzc1JhdGlvOiBERUZBVUxUX0VER0VfQVJST1dfSEVBRF9QUk9HUkFNX09QVElPTlMubGVuZ3RoVG9UaGlja25lc3NSYXRpb1xufTtcbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbShpbnB1dE9wdGlvbnMpIHtcbiAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TKSwgaW5wdXRPcHRpb25zIHx8IHt9KTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0VkZ2VQcm9ncmFtKSB7XG4gICAgZnVuY3Rpb24gRWRnZUNsYW1wZWRQcm9ncmFtKCkge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VDbGFtcGVkUHJvZ3JhbSk7XG4gICAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZGdlQ2xhbXBlZFByb2dyYW0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIF9pbmhlcml0cyhFZGdlQ2xhbXBlZFByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlQ2xhbXBlZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgVkVSVElDRVM6IDYsXG4gICAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDEsXG4gICAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblN0YXJ0XCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkVuZFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDEsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3JhZGl1c1wiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAgIC8vIElmIDEsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uRW5kXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcmFkaXVzQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzAsIDEsIDBdLCBbMCwgLTEsIDBdLCBbMSwgMSwgMV0sIFsxLCAxLCAxXSwgWzAsIC0xLCAwXSwgWzEsIC0xLCAtMV1dXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgICAgdmFyIHRoaWNrbmVzcyA9IGRhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciBuMSA9IDA7XG4gICAgICAgIHZhciBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSByYWRpdXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgICB1X3pvb21SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV96b29tUmF0aW8sXG4gICAgICAgICAgdV9mZWF0aGVyID0gdW5pZm9ybUxvY2F0aW9ucy51X2ZlYXRoZXIsXG4gICAgICAgICAgdV9waXhlbFJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sXG4gICAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcyxcbiAgICAgICAgICB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV96b29tUmF0aW8sIHBhcmFtcy56b29tUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9waXhlbFJhdGlvLCBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2ZlYXRoZXIsIHBhcmFtcy5hbnRpQWxpYXNpbmdGZWF0aGVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW8pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShFZGdlUHJvZ3JhbSk7XG59XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtID0gY3JlYXRlRWRnZUNsYW1wZWRQcm9ncmFtKCk7XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtJDEgPSBFZGdlQ2xhbXBlZFByb2dyYW07XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VBcnJvd1Byb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKFtjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0oaW5wdXRPcHRpb25zKSwgY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oaW5wdXRPcHRpb25zKV0pO1xufVxudmFyIEVkZ2VBcnJvd1Byb2dyYW0gPSBjcmVhdGVFZGdlQXJyb3dQcm9ncmFtKCk7XG52YXIgRWRnZUFycm93UHJvZ3JhbSQxID0gRWRnZUFycm93UHJvZ3JhbTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX25vcm1hbENvZWY7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvblN0YXJ0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25FbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcG9zaXRpb25Db2VmO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3BpeGVsUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfbWluRWRnZVRoaWNrbmVzcztcXG51bmlmb3JtIGZsb2F0IHVfZmVhdGhlcjtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG52YXJ5aW5nIGZsb2F0IHZfZmVhdGhlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBtaW5UaGlja25lc3MgPSB1X21pbkVkZ2VUaGlja25lc3M7XFxuXFxuICB2ZWMyIG5vcm1hbCA9IGFfbm9ybWFsICogYV9ub3JtYWxDb2VmO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb25TdGFydCAqICgxLjAgLSBhX3Bvc2l0aW9uQ29lZikgKyBhX3Bvc2l0aW9uRW5kICogYV9wb3NpdGlvbkNvZWY7XFxuXFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgobm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IG5vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG5cXG4gIC8vIFdlIHJlcXVpcmUgZWRnZXMgdG8gYmUgYXQgbGVhc3QgXFxcIm1pblRoaWNrbmVzc1xcXCIgcGl4ZWxzIHRoaWNrICpvbiBzY3JlZW4qXFxuICAvLyAoc28gd2UgbmVlZCB0byBjb21wZW5zYXRlIHRoZSBzaXplIHJhdGlvKTpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG5cXG4gIC8vIFRoZW4sIHdlIG5lZWQgdG8gcmV0cmlldmUgdGhlIG5vcm1hbGl6ZWQgdGhpY2tuZXNzIG9mIHRoZSBlZGdlIGluIHRoZSBXZWJHTFxcbiAgLy8gcmVmZXJlbnRpYWwgKGluIGEgKFswLCAxXSwgWzAsIDFdKSBzcGFjZSksIHVzaW5nIG91ciBcXFwibWFnaWNcXFwiIGNvcnJlY3Rpb25cXG4gIC8vIHJhdGlvOlxcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzLCAxKSkueHksIDAsIDEpO1xcblxcbiAgLy8gRm9yIHRoZSBmcmFnbWVudCBzaGFkZXIgdGhvdWdoLCB3ZSBuZWVkIGEgdGhpY2tuZXNzIHRoYXQgdGFrZXMgdGhlIFxcXCJtYWdpY1xcXCJcXG4gIC8vIGNvcnJlY3Rpb24gcmF0aW8gaW50byBhY2NvdW50IChhcyBpbiB3ZWJHTFRoaWNrbmVzcyksIGJ1dCBzbyB0aGF0IHRoZVxcbiAgLy8gYW50aWFsaWFzaW5nIGVmZmVjdCBkb2VzIG5vdCBkZXBlbmQgb24gdGhlIHpvb20gbGV2ZWwuIFNvIGhlcmUncyB5ZXRcXG4gIC8vIGFub3RoZXIgdGhpY2tuZXNzIHZlcnNpb246XFxuICB2X3RoaWNrbmVzcyA9IHdlYkdMVGhpY2tuZXNzIC8gdV96b29tUmF0aW87XFxuXFxuICB2X25vcm1hbCA9IHVuaXROb3JtYWw7XFxuXFxuICB2X2ZlYXRoZXIgPSB1X2ZlYXRoZXIgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfem9vbVJhdGlvIC8gdV9waXhlbFJhdGlvICogMi4wO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5GTE9BVDtcbnZhciBVTklGT1JNUyA9IFtcInVfbWF0cml4XCIsIFwidV96b29tUmF0aW9cIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9waXhlbFJhdGlvXCIsIFwidV9mZWF0aGVyXCIsIFwidV9taW5FZGdlVGhpY2tuZXNzXCJdO1xudmFyIEVkZ2VSZWN0YW5nbGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgZnVuY3Rpb24gRWRnZVJlY3RhbmdsZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkZ2VSZWN0YW5nbGVQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRWRnZVJlY3RhbmdsZVByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoRWRnZVJlY3RhbmdsZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIFZFUlRJQ0VTOiA2LFxuICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TLFxuICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblN0YXJ0XCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uRW5kXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX25vcm1hbFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW1xuICAgICAgICAvLyBJZiAwLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvblN0YXJ0XG4gICAgICAgIC8vIElmIDIsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uRW5kXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25Db2VmXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX25vcm1hbENvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzAsIDFdLCBbMCwgLTFdLCBbMSwgMV0sIFsxLCAxXSwgWzAsIC0xXSwgWzEsIC0xXV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICB1X3pvb21SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV96b29tUmF0aW8sXG4gICAgICAgIHVfZmVhdGhlciA9IHVuaWZvcm1Mb2NhdGlvbnMudV9mZWF0aGVyLFxuICAgICAgICB1X3BpeGVsUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfcGl4ZWxSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgIHVfbWluRWRnZVRoaWNrbmVzcyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9taW5FZGdlVGhpY2tuZXNzO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfem9vbVJhdGlvLCBwYXJhbXMuem9vbVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfcGl4ZWxSYXRpbywgcGFyYW1zLnBpeGVsUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfZmVhdGhlciwgcGFyYW1zLmFudGlBbGlhc2luZ0ZlYXRoZXIpO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgIH1cbiAgfV0pO1xufShFZGdlUHJvZ3JhbSk7XG5cbmV4cG9ydCB7IEFic3RyYWN0Tm9kZVByb2dyYW0gYXMgQSwgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TIGFzIEQsIEVkZ2VBcnJvd1Byb2dyYW0kMSBhcyBFLCBGUkFHTUVOVF9TSEFERVJfU09VUkNFIGFzIEYsIE5vZGVDaXJjbGVQcm9ncmFtIGFzIE4sIFByb2dyYW0gYXMgUCwgX29iamVjdFNwcmVhZDIgYXMgXywgX2RlZmluZVByb3BlcnR5IGFzIGEsIGRyYXdEaXNjTm9kZUxhYmVsIGFzIGIsIGRyYXdEaXNjTm9kZUhvdmVyIGFzIGMsIGRyYXdTdHJhaWdodEVkZ2VMYWJlbCBhcyBkLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSBhcyBlLCBOb2RlUHJvZ3JhbSBhcyBmLCBFZGdlUHJvZ3JhbSBhcyBnLCBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtIGFzIGgsIGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtIGFzIGksIGNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0gYXMgaiwgQWJzdHJhY3RFZGdlUHJvZ3JhbSBhcyBrLCBBYnN0cmFjdFByb2dyYW0gYXMgbCwgRWRnZUFycm93SGVhZFByb2dyYW0kMSBhcyBtLCBFZGdlQ2xhbXBlZFByb2dyYW0kMSBhcyBuLCBjcmVhdGVFZGdlQ2xhbXBlZFByb2dyYW0gYXMgbywgREVGQVVMVF9FREdFX0NMQU1QRURfUFJPR1JBTV9PUFRJT05TIGFzIHAsIGNyZWF0ZUVkZ2VBcnJvd1Byb2dyYW0gYXMgcSwgZ2V0QXR0cmlidXRlSXRlbXNDb3VudCBhcyByLCBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCBhcyBzLCBsb2FkVmVydGV4U2hhZGVyIGFzIHQsIGxvYWRGcmFnbWVudFNoYWRlciBhcyB1LCBsb2FkUHJvZ3JhbSBhcyB2LCBraWxsUHJvZ3JhbSBhcyB3LCBudW1iZXJUb0dMU0xGbG9hdCBhcyB4IH07XG4iLCJmdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cblxuZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKHQpIHtcbiAgcmV0dXJuIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7XG4gIH0sIF9nZXRQcm90b3R5cGVPZih0KTtcbn1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0O1xuICB9KSgpO1xufVxuXG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odCwgZSkge1xuICBpZiAoZSAmJiAoXCJvYmplY3RcIiA9PSB0eXBlb2YgZSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cblxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5cbmZ1bmN0aW9uIF9pbmhlcml0cyh0LCBlKSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUgJiYgbnVsbCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXCIpO1xuICB0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoZSAmJiBlLnByb3RvdHlwZSwge1xuICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICB2YWx1ZTogdCxcbiAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICB9XG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZSAmJiBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG5cbmV4cG9ydCB7IF9pbmhlcml0cyBhcyBfLCBfY3JlYXRlQ2xhc3MgYXMgYSwgX2NsYXNzQ2FsbENoZWNrIGFzIGIsIF9jYWxsU3VwZXIgYXMgYywgX3RvUHJvcGVydHlLZXkgYXMgZCwgX2dldFByb3RvdHlwZU9mIGFzIGUgfTtcbiIsImltcG9ydCBpc0dyYXBoIGZyb20gJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnO1xuaW1wb3J0IHsgXyBhcyBfc2xpY2VkVG9BcnJheSB9IGZyb20gJy4vY29sb3JzLWJlYjA2ZWIyLmVzbS5qcyc7XG5cbnZhciBsaW5lYXIgPSBmdW5jdGlvbiBsaW5lYXIoaykge1xuICByZXR1cm4gaztcbn07XG52YXIgcXVhZHJhdGljSW4gPSBmdW5jdGlvbiBxdWFkcmF0aWNJbihrKSB7XG4gIHJldHVybiBrICogaztcbn07XG52YXIgcXVhZHJhdGljT3V0ID0gZnVuY3Rpb24gcXVhZHJhdGljT3V0KGspIHtcbiAgcmV0dXJuIGsgKiAoMiAtIGspO1xufTtcbnZhciBxdWFkcmF0aWNJbk91dCA9IGZ1bmN0aW9uIHF1YWRyYXRpY0luT3V0KGspIHtcbiAgaWYgKChrICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIGsgKiBrO1xuICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XG59O1xudmFyIGN1YmljSW4gPSBmdW5jdGlvbiBjdWJpY0luKGspIHtcbiAgcmV0dXJuIGsgKiBrICogaztcbn07XG52YXIgY3ViaWNPdXQgPSBmdW5jdGlvbiBjdWJpY091dChrKSB7XG4gIHJldHVybiAtLWsgKiBrICogayArIDE7XG59O1xudmFyIGN1YmljSW5PdXQgPSBmdW5jdGlvbiBjdWJpY0luT3V0KGspIHtcbiAgaWYgKChrICo9IDIpIDwgMSkgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcbiAgcmV0dXJuIDAuNSAqICgoayAtPSAyKSAqIGsgKiBrICsgMik7XG59O1xudmFyIGVhc2luZ3MgPSB7XG4gIGxpbmVhcjogbGluZWFyLFxuICBxdWFkcmF0aWNJbjogcXVhZHJhdGljSW4sXG4gIHF1YWRyYXRpY091dDogcXVhZHJhdGljT3V0LFxuICBxdWFkcmF0aWNJbk91dDogcXVhZHJhdGljSW5PdXQsXG4gIGN1YmljSW46IGN1YmljSW4sXG4gIGN1YmljT3V0OiBjdWJpY091dCxcbiAgY3ViaWNJbk91dDogY3ViaWNJbk91dFxufTtcblxuLyoqXG4gKiBEZWZhdWx0cy5cbiAqL1xuXG52YXIgQU5JTUFURV9ERUZBVUxUUyA9IHtcbiAgZWFzaW5nOiBcInF1YWRyYXRpY0luT3V0XCIsXG4gIGR1cmF0aW9uOiAxNTBcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBhbmltYXRlIHRoZSBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZU5vZGVzKGdyYXBoLCB0YXJnZXRzLCBvcHRzLCBjYWxsYmFjaykge1xuICB2YXIgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIEFOSU1BVEVfREVGQVVMVFMsIG9wdHMpO1xuICB2YXIgZWFzaW5nID0gdHlwZW9mIG9wdGlvbnMuZWFzaW5nID09PSBcImZ1bmN0aW9uXCIgPyBvcHRpb25zLmVhc2luZyA6IGVhc2luZ3Nbb3B0aW9ucy5lYXNpbmddO1xuICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpO1xuICB2YXIgc3RhcnRQb3NpdGlvbnMgPSB7fTtcbiAgZm9yICh2YXIgbm9kZSBpbiB0YXJnZXRzKSB7XG4gICAgdmFyIGF0dHJzID0gdGFyZ2V0c1tub2RlXTtcbiAgICBzdGFydFBvc2l0aW9uc1tub2RlXSA9IHt9O1xuICAgIGZvciAodmFyIF9rIGluIGF0dHJzKSBzdGFydFBvc2l0aW9uc1tub2RlXVtfa10gPSBncmFwaC5nZXROb2RlQXR0cmlidXRlKG5vZGUsIF9rKTtcbiAgfVxuICB2YXIgZnJhbWUgPSBudWxsO1xuICB2YXIgX3N0ZXAgPSBmdW5jdGlvbiBzdGVwKCkge1xuICAgIGZyYW1lID0gbnVsbDtcbiAgICB2YXIgcCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICBpZiAocCA+PSAxKSB7XG4gICAgICAvLyBBbmltYXRpb24gaXMgZG9uZVxuICAgICAgZm9yICh2YXIgX25vZGUgaW4gdGFyZ2V0cykge1xuICAgICAgICB2YXIgX2F0dHJzID0gdGFyZ2V0c1tfbm9kZV07XG5cbiAgICAgICAgLy8gV2UgdXNlIGdpdmVuIHZhbHVlcyB0byBhdm9pZCBwcmVjaXNpb24gaXNzdWVzIGFuZCBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgZm9yICh2YXIgX2syIGluIF9hdHRycykgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShfbm9kZSwgX2syLCBfYXR0cnNbX2syXSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHAgPSBlYXNpbmcocCk7XG4gICAgZm9yICh2YXIgX25vZGUyIGluIHRhcmdldHMpIHtcbiAgICAgIHZhciBfYXR0cnMyID0gdGFyZ2V0c1tfbm9kZTJdO1xuICAgICAgdmFyIHMgPSBzdGFydFBvc2l0aW9uc1tfbm9kZTJdO1xuICAgICAgZm9yICh2YXIgX2szIGluIF9hdHRyczIpIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUoX25vZGUyLCBfazMsIF9hdHRyczJbX2szXSAqIHAgKyBzW19rM10gKiAoMSAtIHApKTtcbiAgICB9XG4gICAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3N0ZXApO1xuICB9O1xuICBfc3RlcCgpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChmcmFtZSkgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpZGVudGl0eSgpIHtcbiAgcmV0dXJuIEZsb2F0MzJBcnJheS5vZigxLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAxKTtcbn1cblxuLy8gVE9ETzogb3B0aW1pemVcbmZ1bmN0aW9uIHNjYWxlKG0sIHgsIHkpIHtcbiAgbVswXSA9IHg7XG4gIG1bNF0gPSB0eXBlb2YgeSA9PT0gXCJudW1iZXJcIiA/IHkgOiB4O1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHJvdGF0ZShtLCByKSB7XG4gIHZhciBzID0gTWF0aC5zaW4ociksXG4gICAgYyA9IE1hdGguY29zKHIpO1xuICBtWzBdID0gYztcbiAgbVsxXSA9IHM7XG4gIG1bM10gPSAtcztcbiAgbVs0XSA9IGM7XG4gIHJldHVybiBtO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlKG0sIHgsIHkpIHtcbiAgbVs2XSA9IHg7XG4gIG1bN10gPSB5O1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIG11bHRpcGx5KGEsIGIpIHtcbiAgdmFyIGEwMCA9IGFbMF0sXG4gICAgYTAxID0gYVsxXSxcbiAgICBhMDIgPSBhWzJdO1xuICB2YXIgYTEwID0gYVszXSxcbiAgICBhMTEgPSBhWzRdLFxuICAgIGExMiA9IGFbNV07XG4gIHZhciBhMjAgPSBhWzZdLFxuICAgIGEyMSA9IGFbN10sXG4gICAgYTIyID0gYVs4XTtcbiAgdmFyIGIwMCA9IGJbMF0sXG4gICAgYjAxID0gYlsxXSxcbiAgICBiMDIgPSBiWzJdO1xuICB2YXIgYjEwID0gYlszXSxcbiAgICBiMTEgPSBiWzRdLFxuICAgIGIxMiA9IGJbNV07XG4gIHZhciBiMjAgPSBiWzZdLFxuICAgIGIyMSA9IGJbN10sXG4gICAgYjIyID0gYls4XTtcbiAgYVswXSA9IGIwMCAqIGEwMCArIGIwMSAqIGExMCArIGIwMiAqIGEyMDtcbiAgYVsxXSA9IGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMTtcbiAgYVsyXSA9IGIwMCAqIGEwMiArIGIwMSAqIGExMiArIGIwMiAqIGEyMjtcbiAgYVszXSA9IGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMDtcbiAgYVs0XSA9IGIxMCAqIGEwMSArIGIxMSAqIGExMSArIGIxMiAqIGEyMTtcbiAgYVs1XSA9IGIxMCAqIGEwMiArIGIxMSAqIGExMiArIGIxMiAqIGEyMjtcbiAgYVs2XSA9IGIyMCAqIGEwMCArIGIyMSAqIGExMCArIGIyMiAqIGEyMDtcbiAgYVs3XSA9IGIyMCAqIGEwMSArIGIyMSAqIGExMSArIGIyMiAqIGEyMTtcbiAgYVs4XSA9IGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMjtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBtdWx0aXBseVZlYzIoYSwgYikge1xuICB2YXIgeiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgdmFyIGEwMCA9IGFbMF07XG4gIHZhciBhMDEgPSBhWzFdO1xuICB2YXIgYTEwID0gYVszXTtcbiAgdmFyIGExMSA9IGFbNF07XG4gIHZhciBhMjAgPSBhWzZdO1xuICB2YXIgYTIxID0gYVs3XTtcbiAgdmFyIGIwID0gYi54O1xuICB2YXIgYjEgPSBiLnk7XG4gIHJldHVybiB7XG4gICAgeDogYjAgKiBhMDAgKyBiMSAqIGExMCArIGEyMCAqIHosXG4gICAgeTogYjAgKiBhMDEgKyBiMSAqIGExMSArIGEyMSAqIHpcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBzaWdtYSwgdGhlIGdyYXBoIGlzIG5vcm1hbGl6ZWQgaW50byBhIFswLCAxXSwgWzAsIDFdIHNxdWFyZSwgYmVmb3JlIGJlaW5nIGdpdmVuIHRvIHRoZSB2YXJpb3VzIHJlbmRlcmVycy4gVGhpc1xuICogaGVscHMgdG8gZGVhbCB3aXRoIHF1YWR0cmVlIGluIHBhcnRpY3VsYXIuXG4gKiBCdXQgYXQgc29tZSBwb2ludCwgd2UgbmVlZCB0byByZXNjYWxlIGl0IHNvIHRoYXQgaXQgdGFrZXMgdGhlIGJlc3QgcGxhY2UgaW4gdGhlIHNjcmVlbiwgaS5lLiB3ZSBhbHdheXMgd2FudCB0byBzZWUgdHdvXG4gKiBub2RlcyBcInRvdWNoaW5nXCIgb3Bwb3NpdGUgc2lkZXMgb2YgdGhlIGdyYXBoLCB3aXRoIHRoZSBjYW1lcmEgYmVpbmcgYXQgaXRzIGRlZmF1bHQgc3RhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoaXMgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldENvcnJlY3Rpb25SYXRpbyh2aWV3cG9ydERpbWVuc2lvbnMsIGdyYXBoRGltZW5zaW9ucykge1xuICB2YXIgdmlld3BvcnRSYXRpbyA9IHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQgLyB2aWV3cG9ydERpbWVuc2lvbnMud2lkdGg7XG4gIHZhciBncmFwaFJhdGlvID0gZ3JhcGhEaW1lbnNpb25zLmhlaWdodCAvIGdyYXBoRGltZW5zaW9ucy53aWR0aDtcblxuICAvLyBJZiB0aGUgc3RhZ2UgYW5kIHRoZSBncmFwaHMgYXJlIGluIGRpZmZlcmVudCBkaXJlY3Rpb25zIChzdWNoIGFzIHRoZSBncmFwaCBiZWluZyB3aWRlciB0aGF0IHRhbGwgd2hpbGUgdGhlIHN0YWdlXG4gIC8vIGlzIHRhbGxlciB0aGFuIHdpZGUpLCB3ZSBjYW4gc3RvcCBoZXJlIHRvIGhhdmUgaW5kZWVkIG5vZGVzIHRvdWNoaW5nIG9wcG9zaXRlIHNpZGVzOlxuICBpZiAodmlld3BvcnRSYXRpbyA8IDEgJiYgZ3JhcGhSYXRpbyA+IDEgfHwgdmlld3BvcnRSYXRpbyA+IDEgJiYgZ3JhcGhSYXRpbyA8IDEpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIC8vIEVsc2UsIHdlIG5lZWQgdG8gZml0IHRoZSBncmFwaCBpbnNpZGUgdGhlIHN0YWdlOlxuICAvLyAxLiBJZiB0aGUgZ3JhcGggaXMgXCJzcXVhcmVyXCIgKGkuZS4gd2l0aCBhIHJhdGlvIGNsb3NlciB0byAxKSwgd2UgbmVlZCB0byBtYWtlIHRoZSBsYXJnZXN0IHNpZGVzIHRvdWNoO1xuICAvLyAyLiBJZiB0aGUgc3RhZ2UgaXMgXCJzcXVhcmVyXCIsIHdlIG5lZWQgdG8gbWFrZSB0aGUgc21hbGxlc3Qgc2lkZXMgdG91Y2guXG4gIHJldHVybiBNYXRoLm1pbihNYXRoLm1heChncmFwaFJhdGlvLCAxIC8gZ3JhcGhSYXRpbyksIE1hdGgubWF4KDEgLyB2aWV3cG9ydFJhdGlvLCB2aWV3cG9ydFJhdGlvKSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGEgbWF0cml4IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGNhbWVyYS5cbiAqL1xuZnVuY3Rpb24gbWF0cml4RnJvbUNhbWVyYShzdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMsIHBhZGRpbmcsIGludmVyc2UpIHtcbiAgLy8gVE9ETzogaXQncyBwb3NzaWJsZSB0byBvcHRpbWl6ZSB0aGlzIGRyYXN0aWNhbGx5IVxuICB2YXIgYW5nbGUgPSBzdGF0ZS5hbmdsZSxcbiAgICByYXRpbyA9IHN0YXRlLnJhdGlvLFxuICAgIHggPSBzdGF0ZS54LFxuICAgIHkgPSBzdGF0ZS55O1xuICB2YXIgd2lkdGggPSB2aWV3cG9ydERpbWVuc2lvbnMud2lkdGgsXG4gICAgaGVpZ2h0ID0gdmlld3BvcnREaW1lbnNpb25zLmhlaWdodDtcbiAgdmFyIG1hdHJpeCA9IGlkZW50aXR5KCk7XG4gIHZhciBzbWFsbGVzdERpbWVuc2lvbiA9IE1hdGgubWluKHdpZHRoLCBoZWlnaHQpIC0gMiAqIHBhZGRpbmc7XG4gIHZhciBjb3JyZWN0aW9uUmF0aW8gPSBnZXRDb3JyZWN0aW9uUmF0aW8odmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMpO1xuICBpZiAoIWludmVyc2UpIHtcbiAgICBtdWx0aXBseShtYXRyaXgsIHNjYWxlKGlkZW50aXR5KCksIDIgKiAoc21hbGxlc3REaW1lbnNpb24gLyB3aWR0aCkgKiBjb3JyZWN0aW9uUmF0aW8sIDIgKiAoc21hbGxlc3REaW1lbnNpb24gLyBoZWlnaHQpICogY29ycmVjdGlvblJhdGlvKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCByb3RhdGUoaWRlbnRpdHkoKSwgLWFuZ2xlKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCBzY2FsZShpZGVudGl0eSgpLCAxIC8gcmF0aW8pKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHRyYW5zbGF0ZShpZGVudGl0eSgpLCAteCwgLXkpKTtcbiAgfSBlbHNlIHtcbiAgICBtdWx0aXBseShtYXRyaXgsIHRyYW5zbGF0ZShpZGVudGl0eSgpLCB4LCB5KSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCBzY2FsZShpZGVudGl0eSgpLCByYXRpbykpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgcm90YXRlKGlkZW50aXR5KCksIGFuZ2xlKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCBzY2FsZShpZGVudGl0eSgpLCB3aWR0aCAvIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGNvcnJlY3Rpb25SYXRpbywgaGVpZ2h0IC8gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gY29ycmVjdGlvblJhdGlvKSk7XG4gIH1cbiAgcmV0dXJuIG1hdHJpeDtcbn1cblxuLyoqXG4gKiBBbGwgdGhlc2UgdHJhbnNmb3JtYXRpb25zIHdlIGFwcGx5IG9uIHRoZSBtYXRyaXggdG8gZ2V0IGl0IHJlc2NhbGUgdGhlIGdyYXBoXG4gKiBhcyB3ZSB3YW50IG1ha2UgaXQgdmVyeSBoYXJkIHRvIGdldCBwaXhlbC1wZXJmZWN0IGRpc3RhbmNlcyBpbiBXZWJHTC4gVGhpc1xuICogZnVuY3Rpb24gcmV0dXJucyBhIGZhY3RvciB0aGF0IHByb3Blcmx5IGNhbmNlbHMgdGhlIG1hdHJpeCBlZmZlY3Qgb24gbGVuZ3Rocy5cbiAqXG4gKiBbamFjb215YWxdXG4gKiBUbyBiZSBmdWxseSBob25lc3QsIEkgY2FuJ3QgcmVhbGx5IGV4cGxhaW4gaGFwcGVucyBoZXJlLi4uIEkgbm90aWNlIHRoYXQgdGhlXG4gKiBmb2xsb3dpbmcgcmF0aW8gd29ya3MgKGkuZS4gaXQgY29ycmVjdGx5IGNvbXBlbnNhdGVzIHRoZSBtYXRyaXggaW1wYWN0IG9uIGFsbFxuICogY2FtZXJhIHN0YXRlcyBJIGNvdWxkIHRyeSk6XG4gKiA+IGBSID0gc2l6ZShWKSAvIHNpemUoTSAqIFYpIC8gV2BcbiAqIGFzIGxvbmcgYXMgYE0gKiBWYCBpcyBpbiB0aGUgZGlyZWN0aW9uIG9mIFcgKGllLiBwYXJhbGxlbCB0byAoT3gpKS4gSXQgd29ya3NcbiAqIGFzIHdlbGwgd2l0aCBIIGFuZCBhIHZlY3RvciB0aGF0IHRyYW5zZm9ybXMgaW50byBzb21ldGhpbmcgcGFyYWxsZWwgdG8gKE95KS5cbiAqXG4gKiBBbHNvLCBub3RlIHRoYXQgd2UgdXNlIGBhbmdsZWAgYW5kIG5vdCBgLWFuZ2xlYCAodGhhdCB3b3VsZCBzZWVtIGxvZ2ljYWwsXG4gKiBzaW5jZSB3ZSB3YW50IHRvIGFudGljaXBhdGUgdGhlIHJvdGF0aW9uKSwgYmVjYXVzZSB0aGUgaW1hZ2UgaXMgdmVydGljYWxseVxuICogc3dhcHBlZCBpbiBXZWJHTC5cbiAqL1xuZnVuY3Rpb24gZ2V0TWF0cml4SW1wYWN0KG1hdHJpeCwgY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucykge1xuICB2YXIgX211bHRpcGx5VmVjID0gbXVsdGlwbHlWZWMyKG1hdHJpeCwge1xuICAgICAgeDogTWF0aC5jb3MoY2FtZXJhU3RhdGUuYW5nbGUpLFxuICAgICAgeTogTWF0aC5zaW4oY2FtZXJhU3RhdGUuYW5nbGUpXG4gICAgfSwgMCksXG4gICAgeCA9IF9tdWx0aXBseVZlYy54LFxuICAgIHkgPSBfbXVsdGlwbHlWZWMueTtcbiAgcmV0dXJuIDEgLyBNYXRoLnNxcnQoTWF0aC5wb3coeCwgMikgKyBNYXRoLnBvdyh5LCAyKSkgLyB2aWV3cG9ydERpbWVuc2lvbnMud2lkdGg7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBncmFwaCdzIG5vZGUgZXh0ZW50IGluIHggJiB5LlxuICovXG5mdW5jdGlvbiBncmFwaEV4dGVudChncmFwaCkge1xuICBpZiAoIWdyYXBoLm9yZGVyKSByZXR1cm4ge1xuICAgIHg6IFswLCAxXSxcbiAgICB5OiBbMCwgMV1cbiAgfTtcbiAgdmFyIHhNaW4gPSBJbmZpbml0eTtcbiAgdmFyIHhNYXggPSAtSW5maW5pdHk7XG4gIHZhciB5TWluID0gSW5maW5pdHk7XG4gIHZhciB5TWF4ID0gLUluZmluaXR5O1xuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAoXywgYXR0cikge1xuICAgIHZhciB4ID0gYXR0ci54LFxuICAgICAgeSA9IGF0dHIueTtcbiAgICBpZiAoeCA8IHhNaW4pIHhNaW4gPSB4O1xuICAgIGlmICh4ID4geE1heCkgeE1heCA9IHg7XG4gICAgaWYgKHkgPCB5TWluKSB5TWluID0geTtcbiAgICBpZiAoeSA+IHlNYXgpIHlNYXggPSB5O1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB4OiBbeE1pbiwgeE1heF0sXG4gICAgeTogW3lNaW4sIHlNYXhdXG4gIH07XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdyYXBoIHZhcmlhYmxlIGlzIGEgdmFsaWQgZ3JhcGgsIGFuZCBpZiBzaWdtYSBjYW4gcmVuZGVyIGl0LlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUdyYXBoKGdyYXBoKSB7XG4gIC8vIGNoZWNrIGlmIGl0J3MgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlXG4gIGlmICghaXNHcmFwaChncmFwaCkpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBpbnZhbGlkIGdyYXBoIGluc3RhbmNlLlwiKTtcblxuICAvLyBjaGVjayBpZiBub2RlcyBoYXZlIHgveSBhdHRyaWJ1dGVzXG4gIGdyYXBoLmZvckVhY2hOb2RlKGZ1bmN0aW9uIChrZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShhdHRyaWJ1dGVzLngpIHx8ICFOdW1iZXIuaXNGaW5pdGUoYXR0cmlidXRlcy55KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IENvb3JkaW5hdGVzIG9mIG5vZGUgXCIuY29uY2F0KGtleSwgXCIgYXJlIGludmFsaWQuIEEgbm9kZSBtdXN0IGhhdmUgYSBudW1lcmljICd4JyBhbmQgJ3knIGF0dHJpYnV0ZS5cIikpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgRE9NIGVsZW1lbnRzIGVhc2lseS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIHN0eWxlLCBhdHRyaWJ1dGVzKSB7XG4gIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAoc3R5bGUpIHtcbiAgICBmb3IgKHZhciBrIGluIHN0eWxlKSB7XG4gICAgICBlbGVtZW50LnN0eWxlW2tdID0gc3R5bGVba107XG4gICAgfVxuICB9XG4gIGlmIChhdHRyaWJ1dGVzKSB7XG4gICAgZm9yICh2YXIgX2sgaW4gYXR0cmlidXRlcykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoX2ssIGF0dHJpYnV0ZXNbX2tdKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHRoZSBicm93c2VyJ3MgcGl4ZWwgcmF0aW8uXG4gKi9cbmZ1bmN0aW9uIGdldFBpeGVsUmF0aW8oKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93LmRldmljZVBpeGVsUmF0aW8gIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgcmV0dXJuIDE7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gb3JkZXJpbmcgdGhlIGdpdmVuIGVsZW1lbnRzIGluIHJldmVyc2Ugei1vcmRlciBzbyB0aGV5IGRyYXduXG4gKiB0aGUgY29ycmVjdCB3YXkuXG4gKi9cbmZ1bmN0aW9uIHpJbmRleE9yZGVyaW5nKF9leHRlbnQsIGdldHRlciwgZWxlbWVudHMpIHtcbiAgLy8gSWYgayBpcyA+IG4sIHdlJ2xsIHVzZSBhIHN0YW5kYXJkIHNvcnRcbiAgcmV0dXJuIGVsZW1lbnRzLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICB2YXIgekEgPSBnZXR0ZXIoYSkgfHwgMCxcbiAgICAgIHpCID0gZ2V0dGVyKGIpIHx8IDA7XG4gICAgaWYgKHpBIDwgekIpIHJldHVybiAtMTtcbiAgICBpZiAoekEgPiB6QikgcmV0dXJuIDE7XG4gICAgcmV0dXJuIDA7XG4gIH0pO1xuXG4gIC8vIFRPRE86IGNvdW50aW5nIHNvcnQgb3B0aW1pemF0aW9uXG59XG5cbi8qKlxuICogRmFjdG9yeSByZXR1cm5pbmcgYSBmdW5jdGlvbiBub3JtYWxpemluZyB0aGUgZ2l2ZW4gbm9kZSdzIHBvc2l0aW9uICYgc2l6ZS5cbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24oZXh0ZW50KSB7XG4gIHZhciBfZXh0ZW50JHggPSBfc2xpY2VkVG9BcnJheShleHRlbnQueCwgMiksXG4gICAgbWluWCA9IF9leHRlbnQkeFswXSxcbiAgICBtYXhYID0gX2V4dGVudCR4WzFdLFxuICAgIF9leHRlbnQkeSA9IF9zbGljZWRUb0FycmF5KGV4dGVudC55LCAyKSxcbiAgICBtaW5ZID0gX2V4dGVudCR5WzBdLFxuICAgIG1heFkgPSBfZXh0ZW50JHlbMV07XG4gIHZhciByYXRpbyA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSksXG4gICAgZFggPSAobWF4WCArIG1pblgpIC8gMixcbiAgICBkWSA9IChtYXhZICsgbWluWSkgLyAyO1xuICBpZiAocmF0aW8gPT09IDAgfHwgTWF0aC5hYnMocmF0aW8pID09PSBJbmZpbml0eSB8fCBpc05hTihyYXRpbykpIHJhdGlvID0gMTtcbiAgaWYgKGlzTmFOKGRYKSkgZFggPSAwO1xuICBpZiAoaXNOYU4oZFkpKSBkWSA9IDA7XG4gIHZhciBmbiA9IGZ1bmN0aW9uIGZuKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogMC41ICsgKGRhdGEueCAtIGRYKSAvIHJhdGlvLFxuICAgICAgeTogMC41ICsgKGRhdGEueSAtIGRZKSAvIHJhdGlvXG4gICAgfTtcbiAgfTtcblxuICAvLyBUT0RPOiBwb3NzaWJpbGl0eSB0byBhcHBseSB0aGlzIGluIGJhdGNoIG92ZXIgYXJyYXkgb2YgaW5kaWNlc1xuICBmbi5hcHBseVRvID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhLnggPSAwLjUgKyAoZGF0YS54IC0gZFgpIC8gcmF0aW87XG4gICAgZGF0YS55ID0gMC41ICsgKGRhdGEueSAtIGRZKSAvIHJhdGlvO1xuICB9O1xuICBmbi5pbnZlcnNlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZFggKyByYXRpbyAqIChkYXRhLnggLSAwLjUpLFxuICAgICAgeTogZFkgKyByYXRpbyAqIChkYXRhLnkgLSAwLjUpXG4gICAgfTtcbiAgfTtcbiAgZm4ucmF0aW8gPSByYXRpbztcbiAgcmV0dXJuIGZuO1xufVxuXG5leHBvcnQgeyBBTklNQVRFX0RFRkFVTFRTIGFzIEEsIGdldE1hdHJpeEltcGFjdCBhcyBhLCBjcmVhdGVFbGVtZW50IGFzIGIsIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbiBhcyBjLCBnZXRQaXhlbFJhdGlvIGFzIGQsIGVhc2luZ3MgYXMgZSwgbXVsdGlwbHlWZWMyIGFzIGYsIGdyYXBoRXh0ZW50IGFzIGcsIGFuaW1hdGVOb2RlcyBhcyBoLCBpZGVudGl0eSBhcyBpLCBnZXRDb3JyZWN0aW9uUmF0aW8gYXMgaiwgcXVhZHJhdGljT3V0IGFzIGssIGxpbmVhciBhcyBsLCBtYXRyaXhGcm9tQ2FtZXJhIGFzIG0sIHF1YWRyYXRpY0luT3V0IGFzIG4sIGN1YmljSW4gYXMgbywgY3ViaWNPdXQgYXMgcCwgcXVhZHJhdGljSW4gYXMgcSwgY3ViaWNJbk91dCBhcyByLCBzY2FsZSBhcyBzLCByb3RhdGUgYXMgdCwgdHJhbnNsYXRlIGFzIHUsIHZhbGlkYXRlR3JhcGggYXMgdiwgbXVsdGlwbHkgYXMgdywgekluZGV4T3JkZXJpbmcgYXMgeiB9O1xuIiwiaW1wb3J0IHsgXyBhcyBfb2JqZWN0U3ByZWFkMiwgYSBhcyBfZGVmaW5lUHJvcGVydHkgfSBmcm9tICcuL2luZGV4LTIzNmM2MmFkLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9jYWxsU3VwZXIsIGQgYXMgX3RvUHJvcGVydHlLZXkgfSBmcm9tICcuL2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9IGZyb20gJy4uL3R5cGVzL2Rpc3Qvc2lnbWEtdHlwZXMuZXNtLmpzJztcbmltcG9ydCB7IEEgYXMgQU5JTUFURV9ERUZBVUxUUywgZSBhcyBlYXNpbmdzLCBnIGFzIGdyYXBoRXh0ZW50LCBjIGFzIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbiwgbSBhcyBtYXRyaXhGcm9tQ2FtZXJhLCB6IGFzIHpJbmRleE9yZGVyaW5nLCBhIGFzIGdldE1hdHJpeEltcGFjdCwgYiBhcyBjcmVhdGVFbGVtZW50LCBkIGFzIGdldFBpeGVsUmF0aW8sIGYgYXMgbXVsdGlwbHlWZWMyLCBpIGFzIGlkZW50aXR5LCB2IGFzIHZhbGlkYXRlR3JhcGggfSBmcm9tICcuL25vcm1hbGl6YXRpb24tYmU0NDU1MTguZXNtLmpzJztcbmltcG9ydCB7IERFRkFVTFRfU0VUVElOR1MsIHZhbGlkYXRlU2V0dGluZ3MsIHJlc29sdmVTZXR0aW5ncyB9IGZyb20gJy4uL3NldHRpbmdzL2Rpc3Qvc2lnbWEtc2V0dGluZ3MuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3NsaWNlZFRvQXJyYXksIGEgYXMgX2FycmF5TGlrZVRvQXJyYXksIGIgYXMgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LCBnIGFzIGdldFBpeGVsQ29sb3IsIGMgYXMgY29sb3JUb0luZGV4IH0gZnJvbSAnLi9jb2xvcnMtYmViMDZlYjIuZXNtLmpzJztcbmltcG9ydCB7IF8gYXMgX3R5cGVvZiwgZSBhcyBleHRlbmQgfSBmcm9tICcuL2RhdGEtMTFkZjcxMjQuZXNtLmpzJztcbmltcG9ydCAnZXZlbnRzJztcbmltcG9ydCAnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCc7XG5cbi8qKlxuICogRGVmYXVsdHMuXG4gKi9cbnZhciBERUZBVUxUX1pPT01JTkdfUkFUSU8gPSAxLjU7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogQ2FtZXJhIGNsYXNzXG4gKi9cbnZhciBDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBmdW5jdGlvbiBDYW1lcmEoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW1lcmEpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDYW1lcmEpO1xuXG4gICAgLy8gU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwieFwiLCAwLjUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ5XCIsIDAuNSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImFuZ2xlXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibWluUmF0aW9cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm1heFJhdGlvXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbmFibGVkWm9vbWluZ1wiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFBhbm5pbmdcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRSb3RhdGlvblwiLCB0cnVlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2xlYW5cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5leHRGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicHJldmlvdXNTdGF0ZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZW5hYmxlZFwiLCB0cnVlKTtcbiAgICBfdGhpcy5wcmV2aW91c1N0YXRlID0gX3RoaXMuZ2V0U3RhdGUoKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICAvKipcbiAgICogU3RhdGljIG1ldGhvZCB1c2VkIHRvIGNyZWF0ZSBhIENhbWVyYSBvYmplY3Qgd2l0aCBhIGdpdmVuIHN0YXRlLlxuICAgKi9cbiAgX2luaGVyaXRzKENhbWVyYSwgX1R5cGVkRXZlbnRFbWl0dGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDYW1lcmEsIFt7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGVuYWJsZSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBkaXNhYmxlIHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSB0aGUgY2FtZXJhJ3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55LFxuICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGhhcyB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU3RhdGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnggPT09IHN0YXRlLnggJiYgdGhpcy55ID09PSBzdGF0ZS55ICYmIHRoaXMucmF0aW8gPT09IHN0YXRlLnJhdGlvICYmIHRoaXMuYW5nbGUgPT09IHN0YXRlLmFuZ2xlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcmV2aW91c1N0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZXZpb3VzU3RhdGUoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnByZXZpb3VzU3RhdGU7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHN0YXRlLngsXG4gICAgICAgIHk6IHN0YXRlLnksXG4gICAgICAgIGFuZ2xlOiBzdGF0ZS5hbmdsZSxcbiAgICAgICAgcmF0aW86IHN0YXRlLnJhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIG1pblJhdGlvIGFuZCBtYXhSYXRpbyB2YWx1ZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRlZFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kZWRSYXRpbyhyYXRpbykge1xuICAgICAgdmFyIHIgPSByYXRpbztcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5taW5SYXRpbyA9PT0gXCJudW1iZXJcIikgciA9IE1hdGgubWF4KHIsIHRoaXMubWluUmF0aW8pO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1heFJhdGlvID09PSBcIm51bWJlclwiKSByID0gTWF0aC5taW4ociwgdGhpcy5tYXhSYXRpbyk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayB2YXJpb3VzIHRoaW5ncyB0byByZXR1cm4gYSBsZWdpdCBzdGF0ZSBjYW5kaWRhdGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgdmFsaWRhdGVkU3RhdGUgPSB7fTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQYW5uaW5nICYmIHR5cGVvZiBzdGF0ZS54ID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS54ID0gc3RhdGUueDtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQYW5uaW5nICYmIHR5cGVvZiBzdGF0ZS55ID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS55ID0gc3RhdGUueTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRab29taW5nICYmIHR5cGVvZiBzdGF0ZS5yYXRpbyA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUucmF0aW8gPSB0aGlzLmdldEJvdW5kZWRSYXRpbyhzdGF0ZS5yYXRpbyk7XG4gICAgICBpZiAodGhpcy5lbmFibGVkUm90YXRpb24gJiYgdHlwZW9mIHN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSB2YWxpZGF0ZWRTdGF0ZS5hbmdsZSA9IHN0YXRlLmFuZ2xlO1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYW4gPyB0aGlzLmNsZWFuKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLmdldFN0YXRlKCkpLCB2YWxpZGF0ZWRTdGF0ZSkpIDogdmFsaWRhdGVkU3RhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpc0FuaW1hdGVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQW5pbWF0ZWQoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLm5leHRGcmFtZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzZXQgdGhlIGNhbWVyYSdzIHN0YXRlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFN0YXRlKHN0YXRlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIEtlZXBpbmcgdHJhY2sgb2YgbGFzdCBzdGF0ZVxuICAgICAgdGhpcy5wcmV2aW91c1N0YXRlID0gdGhpcy5nZXRTdGF0ZSgpO1xuICAgICAgdmFyIHZhbGlkU3RhdGUgPSB0aGlzLnZhbGlkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnggPT09IFwibnVtYmVyXCIpIHRoaXMueCA9IHZhbGlkU3RhdGUueDtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKSB0aGlzLnkgPSB2YWxpZFN0YXRlLnk7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIHRoaXMucmF0aW8gPSB2YWxpZFN0YXRlLnJhdGlvO1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSB0aGlzLmFuZ2xlID0gdmFsaWRTdGF0ZS5hbmdsZTtcblxuICAgICAgLy8gRW1pdHRpbmdcbiAgICAgIGlmICghdGhpcy5oYXNTdGF0ZSh0aGlzLnByZXZpb3VzU3RhdGUpKSB0aGlzLmVtaXQoXCJ1cGRhdGVkXCIsIHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1cGRhdGUgdGhlIGNhbWVyYSdzIHN0YXRlIHVzaW5nIGEgZnVuY3Rpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUodXBkYXRlcikge1xuICAgICAgdGhpcy5zZXRTdGF0ZSh1cGRhdGVyKHRoaXMuZ2V0U3RhdGUoKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gYW5pbWF0ZSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYW5pbWF0ZShzdGF0ZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB2YXIgb3B0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmICghY2FsbGJhY2spIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmFuaW1hdGUoc3RhdGUsIG9wdHMsIHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIG9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgQU5JTUFURV9ERUZBVUxUUyksIG9wdHMpO1xuICAgICAgdmFyIHZhbGlkU3RhdGUgPSB0aGlzLnZhbGlkYXRlU3RhdGUoc3RhdGUpO1xuICAgICAgdmFyIGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5lYXNpbmcgOiBlYXNpbmdzW29wdGlvbnMuZWFzaW5nXTtcblxuICAgICAgLy8gU3RhdGVcbiAgICAgIHZhciBzdGFydCA9IERhdGUubm93KCksXG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gRnVuY3Rpb24gcGVyZm9ybWluZyB0aGUgYW5pbWF0aW9uXG4gICAgICB2YXIgX2ZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICAgIC8vIFRoZSBhbmltYXRpb24gaXMgb3ZlcjpcbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgIF90aGlzMi5uZXh0RnJhbWUgPSBudWxsO1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh2YWxpZFN0YXRlKTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmFuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfdGhpczIuYW5pbWF0aW9uQ2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgIF90aGlzMi5hbmltYXRpb25DYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudCA9IGVhc2luZyh0KTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS54ID0gaW5pdGlhbFN0YXRlLnggKyAodmFsaWRTdGF0ZS54IC0gaW5pdGlhbFN0YXRlLngpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS55ID0gaW5pdGlhbFN0YXRlLnkgKyAodmFsaWRTdGF0ZS55IC0gaW5pdGlhbFN0YXRlLnkpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmIChfdGhpczIuZW5hYmxlZFJvdGF0aW9uICYmIHR5cGVvZiB2YWxpZFN0YXRlLmFuZ2xlID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS5hbmdsZSA9IGluaXRpYWxTdGF0ZS5hbmdsZSArICh2YWxpZFN0YXRlLmFuZ2xlIC0gaW5pdGlhbFN0YXRlLmFuZ2xlKSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIG5ld1N0YXRlLnJhdGlvID0gaW5pdGlhbFN0YXRlLnJhdGlvICsgKHZhbGlkU3RhdGUucmF0aW8gLSBpbml0aWFsU3RhdGUucmF0aW8pICogY29lZmZpY2llbnQ7XG4gICAgICAgIF90aGlzMi5zZXRTdGF0ZShuZXdTdGF0ZSk7XG4gICAgICAgIF90aGlzMi5uZXh0RnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX2ZuKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uZXh0RnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5uZXh0RnJhbWUpO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25DYWxsYmFjaykgdGhpcy5hbmltYXRpb25DYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICB0aGlzLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShfZm4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX2ZuKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmFuaW1hdGlvbkNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gem9vbSB0aGUgY2FtZXJhLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkWm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFpvb20oZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICBpZiAoIWZhY3Rvck9yT3B0aW9ucykgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gREVGQVVMVF9aT09NSU5HX1JBVElPXG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgZmFjdG9yT3JPcHRpb25zID09PSBcIm51bWJlclwiKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gLyBmYWN0b3JPck9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gKGZhY3Rvck9yT3B0aW9ucy5mYWN0b3IgfHwgREVGQVVMVF9aT09NSU5HX1JBVElPKVxuICAgICAgfSwgZmFjdG9yT3JPcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1bnpvb20gdGhlIGNhbWVyYS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhbmltYXRlZFVuem9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFVuem9vbShmYWN0b3JPck9wdGlvbnMpIHtcbiAgICAgIGlmICghZmFjdG9yT3JPcHRpb25zKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiBERUZBVUxUX1pPT01JTkdfUkFUSU9cbiAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBmYWN0b3JPck9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIGZhY3Rvck9yT3B0aW9uc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiAoZmFjdG9yT3JPcHRpb25zLmZhY3RvciB8fCBERUZBVUxUX1pPT01JTkdfUkFUSU8pXG4gICAgICB9LCBmYWN0b3JPck9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlc2V0IHRoZSBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZWRSZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFJlc2V0KG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICB4OiAwLjUsXG4gICAgICAgIHk6IDAuNSxcbiAgICAgICAgcmF0aW86IDEsXG4gICAgICAgIGFuZ2xlOiAwXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbmV3IENhbWVyYSBpbnN0YW5jZSwgd2l0aCB0aGUgc2FtZSBzdGF0ZSBhcyB0aGUgY3VycmVudCBjYW1lcmEuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29weVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb3B5KCkge1xuICAgICAgcmV0dXJuIENhbWVyYS5mcm9tKHRoaXMuZ2V0U3RhdGUoKSk7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKHN0YXRlKSB7XG4gICAgICB2YXIgY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgcmV0dXJuIGNhbWVyYS5zZXRTdGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9XSk7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBDYXB0b3IgdXRpbHMgZnVuY3Rpb25zXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSBsb2NhbCBYIGFuZCBZIGNvb3JkaW5hdGVzIGZyb20gYSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuIElmXG4gKiBhIERPTSBlbGVtZW50IGlzIGdpdmVuLCBpdCB1c2VzIHRoaXMgZWxlbWVudCdzIG9mZnNldCB0byBjb21wdXRlIHRoZSBwb3NpdGlvblxuICogKHRoaXMgYWxsb3dzIHVzaW5nIGV2ZW50cyB0aGF0IGFyZSBub3QgYm91bmQgdG8gdGhlIGNvbnRhaW5lciBpdHNlbGYgYW5kXG4gKiBzdGlsbCBoYXZlIGEgcHJvcGVyIHBvc2l0aW9uKS5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge251bWJlcn0gICAgICBUaGUgbG9jYWwgWSB2YWx1ZSBvZiB0aGUgbW91c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFBvc2l0aW9uKGUsIGRvbSkge1xuICB2YXIgYmJveCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgcmV0dXJuIHtcbiAgICB4OiBlLmNsaWVudFggLSBiYm94LmxlZnQsXG4gICAgeTogZS5jbGllbnRZIC0gYmJveC50b3BcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IG1vdXNlIGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW91c2VDb29yZHMoZSwgZG9tKSB7XG4gIHZhciByZXMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZ2V0UG9zaXRpb24oZSwgZG9tKSksIHt9LCB7XG4gICAgc2lnbWFEZWZhdWx0UHJldmVudGVkOiBmYWxzZSxcbiAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgcmVzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBvcmlnaW5hbDogZVxuICB9KTtcbiAgcmV0dXJuIHJlcztcbn1cblxuLyoqXG4gKiBUYWtlcyBhIHRvdWNoIGNvb3JkcyBvciBhIG1vdXNlIGNvb3JkcywgYW5kIGFsd2F5cyByZXR1cm5zIGEgY2xlYW4gbW91c2UgY29vcmRzIG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gY2xlYW5Nb3VzZUNvb3JkcyhlKSB7XG4gIHZhciByZXMgPSBcInhcIiBpbiBlID8gZSA6IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBlLnRvdWNoZXNbMF0gfHwgZS5wcmV2aW91c1RvdWNoZXNbMF0pLCB7fSwge1xuICAgIG9yaWdpbmFsOiBlLm9yaWdpbmFsLFxuICAgIHNpZ21hRGVmYXVsdFByZXZlbnRlZDogZS5zaWdtYURlZmF1bHRQcmV2ZW50ZWQsXG4gICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgIGUuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICAgIHJlcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQ29udmVydCBtb3VzZSB3aGVlbCBldmVudCBjb29yZHMgdG8gc2lnbWEgY29vcmRzLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlICAgLSBBIHdoZWVsIG1vdXNlIGV2ZW50LlxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGRvbSAtIEEgRE9NIGVsZW1lbnQgdG8gY29tcHV0ZSBvZmZzZXQgcmVsYXRpdmVseSB0by5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0V2hlZWxDb29yZHMoZSwgZG9tKSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZ2V0TW91c2VDb29yZHMoZSwgZG9tKSksIHt9LCB7XG4gICAgZGVsdGE6IGdldFdoZWVsRGVsdGEoZSlcbiAgfSk7XG59XG52YXIgTUFYX1RPVUNIRVMgPSAyO1xuZnVuY3Rpb24gZ2V0VG91Y2hlc0FycmF5KHRvdWNoZXMpIHtcbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKHRvdWNoZXMubGVuZ3RoLCBNQVhfVE9VQ0hFUyk7IGkgPCBsOyBpKyspIGFyci5wdXNoKHRvdWNoZXNbaV0pO1xuICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIENvbnZlcnQgdG91Y2ggY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgICAgICAgICAgICAgIC0gQSB0b3VjaCBldmVudC5cbiAqIEBwYXJhbSAge1RvdWNoW119ICAgICBwcmV2aW91c1RvdWNoZXMgLSBBbiBhcnJheSBvZiB0aGUgcHJldmlvdXNseSBzdG9yZWQgdG91Y2hlcy5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gICAgICAgICAgICAgLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFRvdWNoQ29vcmRzKGUsIHByZXZpb3VzVG91Y2hlcywgZG9tKSB7XG4gIHZhciByZXMgPSB7XG4gICAgdG91Y2hlczogZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcykubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBkb20pO1xuICAgIH0pLFxuICAgIHByZXZpb3VzVG91Y2hlczogcHJldmlvdXNUb3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgZG9tKTtcbiAgICB9KSxcbiAgICBzaWdtYURlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICByZXMuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9yaWdpbmFsOiBlXG4gIH07XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgd2hlZWwgZGVsdGEgZnJvbSBhIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gIGUgLSBBIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC5cbiAqIEByZXR1cm4ge251bWJlcn0gICAgIFRoZSB3aGVlbCBkZWx0YSBvZiB0aGUgbW91c2UuXG4gKi9cbmZ1bmN0aW9uIGdldFdoZWVsRGVsdGEoZSkge1xuICAvLyBUT0RPOiBjaGVjayB0aG9zZSByYXRpb3MgYWdhaW4gdG8gZW5zdXJlIGEgY2xlYW4gQ2hyb21lL0ZpcmVmb3ggY29tcGF0XG4gIGlmICh0eXBlb2YgZS5kZWx0YVkgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBlLmRlbHRhWSAqIC0zIC8gMzYwO1xuICBpZiAodHlwZW9mIGUuZGV0YWlsICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gZS5kZXRhaWwgLyAtOTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiQ2FwdG9yOiBjb3VsZCBub3QgZXh0cmFjdCBkZWx0YSBmcm9tIGV2ZW50LlwiKTtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyByZXByZXNlbnRpbmcgYSBjYXB0b3IgbGlrZSB0aGUgdXNlcidzIG1vdXNlIG9yIHRvdWNoIGNvbnRyb2xzLlxuICovXG52YXIgQ2FwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZWRFdmVudEVtaXR0ZXIpIHtcbiAgZnVuY3Rpb24gQ2FwdG9yKGNvbnRhaW5lciwgcmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENhcHRvcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIENhcHRvcik7XG4gICAgLy8gUHJvcGVydGllc1xuICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICBfdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoQ2FwdG9yLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKENhcHRvcik7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxudmFyIE1PVVNFX1NFVFRJTkdTX0tFWVMgPSBbXCJkb3VibGVDbGlja1RpbWVvdXRcIiwgXCJkb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblwiLCBcImRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvXCIsIFwiZHJhZ1RpbWVvdXRcIiwgXCJkcmFnZ2VkRXZlbnRzVG9sZXJhbmNlXCIsIFwiaW5lcnRpYUR1cmF0aW9uXCIsIFwiaW5lcnRpYVJhdGlvXCIsIFwiem9vbUR1cmF0aW9uXCIsIFwiem9vbWluZ1JhdGlvXCJdO1xudmFyIERFRkFVTFRfTU9VU0VfU0VUVElOR1MgPSBNT1VTRV9TRVRUSU5HU19LRVlTLnJlZHVjZShmdW5jdGlvbiAoaXRlciwga2V5KSB7XG4gIHJldHVybiBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgaXRlciksIHt9LCBfZGVmaW5lUHJvcGVydHkoe30sIGtleSwgREVGQVVMVF9TRVRUSU5HU1trZXldKSk7XG59LCB7fSk7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogTW91c2UgY2FwdG9yIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTW91c2VDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DYXB0b3IpIHtcbiAgZnVuY3Rpb24gTW91c2VDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VDYXB0b3IpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBNb3VzZUNhcHRvciwgW2NvbnRhaW5lciwgcmVuZGVyZXJdKTtcblxuICAgIC8vIEJpbmRpbmcgbWV0aG9kc1xuICAgIC8vIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRyYWdnZWRFdmVudHNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRvd25TdGFydFRpbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RNb3VzZVhcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RNb3VzZVlcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlzTW91c2VEb3duXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaXNNb3ZpbmdcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtb3ZpbmdUaW1lb3V0XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzdGFydENhbWVyYVN0YXRlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjbGlja3NcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImRvdWJsZUNsaWNrVGltZW91dFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY3VycmVudFdoZWVsRGlyZWN0aW9uXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJzZXR0aW5nc1wiLCBERUZBVUxUX01PVVNFX1NFVFRJTkdTKTtcbiAgICBfdGhpcy5oYW5kbGVDbGljayA9IF90aGlzLmhhbmRsZUNsaWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2sgPSBfdGhpcy5oYW5kbGVSaWdodENsaWNrLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZURvd24gPSBfdGhpcy5oYW5kbGVEb3duLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZVVwID0gX3RoaXMuaGFuZGxlVXAuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlTW92ZSA9IF90aGlzLmhhbmRsZU1vdmUuYmluZChfdGhpcyk7XG4gICAgX3RoaXMuaGFuZGxlV2hlZWwgPSBfdGhpcy5oYW5kbGVXaGVlbC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVMZWF2ZSA9IF90aGlzLmhhbmRsZUxlYXZlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZUVudGVyID0gX3RoaXMuaGFuZGxlRW50ZXIuYmluZChfdGhpcyk7XG5cbiAgICAvLyBCaW5kaW5nIGV2ZW50c1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgX3RoaXMuaGFuZGxlQ2xpY2ssIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCBfdGhpcy5oYW5kbGVSaWdodENsaWNrLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLmhhbmRsZURvd24sIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ3aGVlbFwiLCBfdGhpcy5oYW5kbGVXaGVlbCwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIF90aGlzLmhhbmRsZUVudGVyLCB7XG4gICAgICBjYXB0dXJlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgX3RoaXMuaGFuZGxlTW92ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBfdGhpcy5oYW5kbGVVcCwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKE1vdXNlQ2FwdG9yLCBfQ2FwdG9yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhNb3VzZUNhcHRvciwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmhhbmRsZUNsaWNrKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgdGhpcy5oYW5kbGVSaWdodENsaWNrKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIHRoaXMuaGFuZGxlRG93bik7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIHRoaXMuaGFuZGxlV2hlZWwpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuaGFuZGxlTGVhdmUpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuaGFuZGxlRW50ZXIpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCB0aGlzLmhhbmRsZU1vdmUpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdGhpcy5oYW5kbGVVcCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUNsaWNrKGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHRoaXMuY2xpY2tzKys7XG4gICAgICBpZiAodGhpcy5jbGlja3MgPT09IDIpIHtcbiAgICAgICAgdGhpcy5jbGlja3MgPSAwO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLmRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlRG91YmxlQ2xpY2soZSk7XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLmNsaWNrcyA9IDA7XG4gICAgICAgIF90aGlzMi5kb3VibGVDbGlja1RpbWVvdXQgPSBudWxsO1xuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1RpbWVvdXQpO1xuXG4gICAgICAvLyBOT1RFOiB0aGlzIGlzIGhlcmUgdG8gcHJldmVudCBjbGljayBldmVudHMgb24gZHJhZ1xuICAgICAgaWYgKHRoaXMuZHJhZ2dlZEV2ZW50cyA8IHRoaXMuc2V0dGluZ3MuZHJhZ2dlZEV2ZW50c1RvbGVyYW5jZSkgdGhpcy5lbWl0KFwiY2xpY2tcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlUmlnaHRDbGlja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVSaWdodENsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICB0aGlzLmVtaXQoXCJyaWdodENsaWNrXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZURvdWJsZUNsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURvdWJsZUNsaWNrKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgdGhpcy5lbWl0KFwiZG91YmxlQ2xpY2tcIiwgbW91c2VDb29yZHMpO1xuICAgICAgaWYgKG1vdXNlQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHZhciBuZXdSYXRpbyA9IGNhbWVyYS5nZXRCb3VuZGVkUmF0aW8oY2FtZXJhLmdldFN0YXRlKCkucmF0aW8gLyB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrWm9vbWluZ1JhdGlvKTtcbiAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksIG5ld1JhdGlvKSwge1xuICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgZHVyYXRpb246IHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb25cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVEb3duXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZURvd24oZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgLy8gV2Ugb25seSBzdGFydCBkcmFnZ2luZyBvbiBsZWZ0IGJ1dHRvblxuICAgICAgaWYgKGUuYnV0dG9uID09PSAwKSB7XG4gICAgICAgIHRoaXMuc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCkuZ2V0U3RhdGUoKTtcbiAgICAgICAgdmFyIF9nZXRQb3NpdGlvbiA9IGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgICB4ID0gX2dldFBvc2l0aW9uLngsXG4gICAgICAgICAgeSA9IF9nZXRQb3NpdGlvbi55O1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVggPSB4O1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSB5O1xuICAgICAgICB0aGlzLmRyYWdnZWRFdmVudHMgPSAwO1xuICAgICAgICB0aGlzLmRvd25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmlzTW91c2VEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlZG93blwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVVcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVVcChlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLmlzTW91c2VEb3duKSByZXR1cm47XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHRoaXMuaXNNb3VzZURvd24gPSBmYWxzZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5tb3ZpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgICB0aGlzLm1vdmluZ1RpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9nZXRQb3NpdGlvbjIgPSBnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgIHggPSBfZ2V0UG9zaXRpb24yLngsXG4gICAgICAgIHkgPSBfZ2V0UG9zaXRpb24yLnk7XG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0U3RhdGUoKSxcbiAgICAgICAgcHJldmlvdXNDYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRQcmV2aW91c1N0YXRlKCkgfHwge1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgICAgaWYgKHRoaXMuaXNNb3ZpbmcpIHtcbiAgICAgICAgY2FtZXJhLmFuaW1hdGUoe1xuICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLnggKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55ICsgdGhpcy5zZXR0aW5ncy5pbmVydGlhUmF0aW8gKiAoY2FtZXJhU3RhdGUueSAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueSlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmluZXJ0aWFEdXJhdGlvbixcbiAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCJcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMubGFzdE1vdXNlWCAhPT0geCB8fCB0aGlzLmxhc3RNb3VzZVkgIT09IHkpIHtcbiAgICAgICAgY2FtZXJhLnNldFN0YXRlKHtcbiAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54LFxuICAgICAgICAgIHk6IGNhbWVyYVN0YXRlLnlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNob3VsZFJlZnJlc2ggPSBfdGhpczMuZHJhZ2dlZEV2ZW50cyA+IDA7XG4gICAgICAgIF90aGlzMy5kcmFnZ2VkRXZlbnRzID0gMDtcblxuICAgICAgICAvLyBOT1RFOiB0aGlzIHJlZnJlc2ggaXMgaGVyZSB0byBtYWtlIHN1cmUgYGhpZGVFZGdlc09uTW92ZWAgY2FuIHdvcmtcbiAgICAgICAgLy8gd2hlbiBzb21lb25lIHJlbGVhc2VzIGNhbWVyYSBwYW4gZHJhZyBhZnRlciBoYXZpbmcgc3RvcHBlZCBtb3ZpbmcuXG4gICAgICAgIC8vIFNlZSBjb21taXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9zaWdtYS5qcy9jb21taXQvY2ZkOTE5N2Y3MDMxOTEwOWRiNmI2NzVkZDdjODJiZTQ5M2NhOTVhMlxuICAgICAgICAvLyBTZWUgYWxzbyBpc3N1ZTogaHR0cHM6Ly9naXRodWIuY29tL2phY29teWFsL3NpZ21hLmpzL2lzc3Vlcy8xMjkwXG4gICAgICAgIC8vIEl0IGNvdWxkIGJlIHBvc3NpYmxlIHRvIHJlbmRlciBpbnN0ZWFkIG9mIHNjaGVkdWxpbmcgYSByZWZyZXNoIGJ1dCBmb3JcbiAgICAgICAgLy8gbm93IGl0IHNlZW1zIGdvb2QgZW5vdWdoLlxuICAgICAgICBpZiAoc2hvdWxkUmVmcmVzaCAmJiBfdGhpczMucmVuZGVyZXIuZ2V0U2V0dGluZyhcImhpZGVFZGdlc09uTW92ZVwiKSkgX3RoaXMzLnJlbmRlcmVyLnJlZnJlc2goKTtcbiAgICAgIH0sIDApO1xuICAgICAgdGhpcy5lbWl0KFwibW91c2V1cFwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoZSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIG1vdXNlQ29vcmRzID0gZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpO1xuXG4gICAgICAvLyBBbHdheXMgdHJpZ2dlciBhIFwibW91c2Vtb3ZlYm9keVwiIGV2ZW50LCBzbyB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIGRldmVsb3BcbiAgICAgIC8vIGEgZHJhZy1hbmQtZHJvcCBlZmZlY3QgdGhhdCB3b3JrcyBldmVuIHdoZW4gdGhlIG1vdXNlIGlzIG91dCBvZiB0aGVcbiAgICAgIC8vIGNvbnRhaW5lcjpcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlbW92ZWJvZHlcIiwgbW91c2VDb29yZHMpO1xuXG4gICAgICAvLyBPbmx5IHRyaWdnZXIgdGhlIFwibW91c2Vtb3ZlXCIgZXZlbnQgd2hlbiB0aGUgbW91c2UgaXMgYWN0dWFsbHkgaG92ZXJpbmdcbiAgICAgIC8vIHRoZSBjb250YWluZXIsIHRvIGF2b2lkIHdlaXJkbHkgaG92ZXJpbmcgbm9kZXMgYW5kL29yIGVkZ2VzIHdoZW4gdGhlXG4gICAgICAvLyBtb3VzZSBpcyBub3QgaG92ZXIgdGhlIGNvbnRhaW5lcjpcbiAgICAgIGlmIChlLnRhcmdldCA9PT0gdGhpcy5jb250YWluZXIgfHwgZS5jb21wb3NlZFBhdGgoKVswXSA9PT0gdGhpcy5jb250YWluZXIpIHtcbiAgICAgICAgdGhpcy5lbWl0KFwibW91c2Vtb3ZlXCIsIG1vdXNlQ29vcmRzKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb3VzZUNvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdoZW4gXCJpc01vdXNlRG93blwiIGFsbCB0aGUgdGltZSwgdG8gYWxsb3cgZHJhZ2dpbmcgdGhlXG4gICAgICAvLyBzdGFnZSB3aGlsZSB0aGUgbW91c2UgaXMgbm90IGhvdmVyIHRoZSBjb250YWluZXI6XG4gICAgICBpZiAodGhpcy5pc01vdXNlRG93bikge1xuICAgICAgICB0aGlzLmlzTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkRXZlbnRzKys7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5tb3ZpbmdUaW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzNC5tb3ZpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICBfdGhpczQuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kcmFnVGltZW91dCk7XG4gICAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgICB2YXIgX2dldFBvc2l0aW9uMyA9IGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSxcbiAgICAgICAgICBlWCA9IF9nZXRQb3NpdGlvbjMueCxcbiAgICAgICAgICBlWSA9IF9nZXRQb3NpdGlvbjMueTtcbiAgICAgICAgdmFyIGxhc3RNb3VzZSA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiB0aGlzLmxhc3RNb3VzZVgsXG4gICAgICAgICAgeTogdGhpcy5sYXN0TW91c2VZXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbW91c2UgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogZVgsXG4gICAgICAgICAgeTogZVlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBvZmZzZXRYID0gbGFzdE1vdXNlLnggLSBtb3VzZS54LFxuICAgICAgICAgIG9mZnNldFkgPSBsYXN0TW91c2UueSAtIG1vdXNlLnk7XG4gICAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRTdGF0ZSgpO1xuICAgICAgICB2YXIgeCA9IGNhbWVyYVN0YXRlLnggKyBvZmZzZXRYLFxuICAgICAgICAgIHkgPSBjYW1lcmFTdGF0ZS55ICsgb2Zmc2V0WTtcbiAgICAgICAgY2FtZXJhLnNldFN0YXRlKHtcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWCA9IGVYO1xuICAgICAgICB0aGlzLmxhc3RNb3VzZVkgPSBlWTtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZShlKSB7XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZWxlYXZlXCIsIGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUVudGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUVudGVyKGUpIHtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlZW50ZXJcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlV2hlZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlV2hlZWwoZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjYW1lcmEuZW5hYmxlZFpvb21pbmcpIHJldHVybjtcbiAgICAgIHZhciBkZWx0YSA9IGdldFdoZWVsRGVsdGEoZSk7XG4gICAgICBpZiAoIWRlbHRhKSByZXR1cm47XG4gICAgICB2YXIgd2hlZWxDb29yZHMgPSBnZXRXaGVlbENvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJ3aGVlbFwiLCB3aGVlbENvb3Jkcyk7XG4gICAgICBpZiAod2hlZWxDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yXG4gICAgICB2YXIgY3VycmVudFJhdGlvID0gY2FtZXJhLmdldFN0YXRlKCkucmF0aW87XG4gICAgICB2YXIgcmF0aW9EaWZmID0gZGVsdGEgPiAwID8gMSAvIHRoaXMuc2V0dGluZ3Muem9vbWluZ1JhdGlvIDogdGhpcy5zZXR0aW5ncy56b29taW5nUmF0aW87XG4gICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKGN1cnJlbnRSYXRpbyAqIHJhdGlvRGlmZik7XG4gICAgICB2YXIgd2hlZWxEaXJlY3Rpb24gPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gRXhpdCBlYXJseSB3aXRob3V0IHByZXZlbnRpbmcgZGVmYXVsdCBiZWhhdmlvciB3aGVuIHJhdGlvIGRvZXNuJ3QgY2hhbmdlOlxuICAgICAgaWYgKGN1cnJlbnRSYXRpbyA9PT0gbmV3UmF0aW8pIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIC8vIENhbmNlbCBldmVudHMgdGhhdCBhcmUgdG9vIGNsb3NlIGVhY2ggb3RoZXIgYW5kIGluIHRoZSBzYW1lIGRpcmVjdGlvbjpcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9PT0gd2hlZWxEaXJlY3Rpb24gJiYgdGhpcy5sYXN0V2hlZWxUcmlnZ2VyVGltZSAmJiBub3cgLSB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lIDwgdGhpcy5zZXR0aW5ncy56b29tRHVyYXRpb24gLyA1KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksIG5ld1JhdGlvKSwge1xuICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljT3V0XCIsXG4gICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLnpvb21EdXJhdGlvblxuICAgICAgfSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczUuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gMDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5jdXJyZW50V2hlZWxEaXJlY3Rpb24gPSB3aGVlbERpcmVjdGlvbjtcbiAgICAgIHRoaXMubGFzdFdoZWVsVHJpZ2dlclRpbWUgPSBub3c7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmdzKHNldHRpbmdzKSB7XG4gICAgICB0aGlzLnNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgfVxuICB9XSk7XG59KENhcHRvcik7XG5cbnZhciBUT1VDSF9TRVRUSU5HU19LRVlTID0gW1wiZHJhZ1RpbWVvdXRcIiwgXCJpbmVydGlhRHVyYXRpb25cIiwgXCJpbmVydGlhUmF0aW9cIiwgXCJkb3VibGVDbGlja1RpbWVvdXRcIiwgXCJkb3VibGVDbGlja1pvb21pbmdSYXRpb1wiLCBcImRvdWJsZUNsaWNrWm9vbWluZ0R1cmF0aW9uXCIsIFwidGFwTW92ZVRvbGVyYW5jZVwiXTtcbnZhciBERUZBVUxUX1RPVUNIX1NFVFRJTkdTID0gVE9VQ0hfU0VUVElOR1NfS0VZUy5yZWR1Y2UoZnVuY3Rpb24gKGl0ZXIsIGtleSkge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGl0ZXIpLCB7fSwgX2RlZmluZVByb3BlcnR5KHt9LCBrZXksIERFRkFVTFRfU0VUVElOR1Nba2V5XSkpO1xufSwge30pO1xuXG4vKipcbiAqIEV2ZW50IHR5cGVzLlxuICovXG4vKipcbiAqIFRvdWNoIGNhcHRvciBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRvdWNoQ2FwdG9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQ2FwdG9yKSB7XG4gIGZ1bmN0aW9uIFRvdWNoQ2FwdG9yKGNvbnRhaW5lciwgcmVuZGVyZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvdWNoQ2FwdG9yKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVG91Y2hDYXB0b3IsIFtjb250YWluZXIsIHJlbmRlcmVyXSk7XG5cbiAgICAvLyBCaW5kaW5nIG1ldGhvZHM6XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImlzTW92aW5nXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaGFzTW92ZWRcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJ0b3VjaE1vZGVcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1wiLCBbXSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImxhc3RUb3VjaGVzXCIsIFtdKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibGFzdFRhcFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwic2V0dGluZ3NcIiwgREVGQVVMVF9UT1VDSF9TRVRUSU5HUyk7XG4gICAgX3RoaXMuaGFuZGxlU3RhcnQgPSBfdGhpcy5oYW5kbGVTdGFydC5iaW5kKF90aGlzKTtcbiAgICBfdGhpcy5oYW5kbGVMZWF2ZSA9IF90aGlzLmhhbmRsZUxlYXZlLmJpbmQoX3RoaXMpO1xuICAgIF90aGlzLmhhbmRsZU1vdmUgPSBfdGhpcy5oYW5kbGVNb3ZlLmJpbmQoX3RoaXMpO1xuXG4gICAgLy8gQmluZGluZyBldmVudHNcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoc3RhcnRcIiwgX3RoaXMuaGFuZGxlU3RhcnQsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlXG4gICAgfSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCBfdGhpcy5oYW5kbGVMZWF2ZSwge1xuICAgICAgY2FwdHVyZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2htb3ZlXCIsIF90aGlzLmhhbmRsZU1vdmUsIHtcbiAgICAgIGNhcHR1cmU6IGZhbHNlLFxuICAgICAgcGFzc2l2ZTogZmFsc2VcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFRvdWNoQ2FwdG9yLCBfQ2FwdG9yKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUb3VjaENhcHRvciwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuaGFuZGxlU3RhcnQpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGNhbmNlbFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaG1vdmVcIiwgdGhpcy5oYW5kbGVNb3ZlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuY29udGFpbmVyLm9mZnNldFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlU3RhcnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlU3RhcnQoZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHRoaXMudG91Y2hNb2RlID0gdG91Y2hlcy5sZW5ndGg7XG4gICAgICB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpLmdldFN0YXRlKCk7XG4gICAgICB0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXMubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIF90aGlzMi5jb250YWluZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIHR3byB0b3VjaGVzIGRvd24sIGxldCdzIHJlY29yZCBkaXN0YW5jZSBhbmQgYW5nbGUgYXMgd2VsbDpcbiAgICAgIGlmICh0aGlzLnRvdWNoTW9kZSA9PT0gMikge1xuICAgICAgICB2YXIgX3RoaXMkc3RhcnRUb3VjaGVzUG9zID0gX3NsaWNlZFRvQXJyYXkodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMsIDIpLFxuICAgICAgICAgIF90aGlzJHN0YXJ0VG91Y2hlc1BvczIgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3NbMF0sXG4gICAgICAgICAgeDAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLngsXG4gICAgICAgICAgeTAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLnksXG4gICAgICAgICAgX3RoaXMkc3RhcnRUb3VjaGVzUG9zMyA9IF90aGlzJHN0YXJ0VG91Y2hlc1Bvc1sxXSxcbiAgICAgICAgICB4MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueCxcbiAgICAgICAgICB5MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueTtcbiAgICAgICAgdGhpcy5zdGFydFRvdWNoZXNBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCk7XG4gICAgICAgIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaGRvd25cIiwgZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpKTtcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSB0b3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlc1Bvc2l0aW9ucyA9IHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVMZWF2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVMZWF2ZShlKSB7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMubGVuZ3RoKSByZXR1cm47XG4gICAgICBpZiAoZS5jYW5jZWxhYmxlKSBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBpZiAodGhpcy5tb3ZpbmdUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKHRoaXMudG91Y2hNb2RlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlU3RhcnQoZSk7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmICh0aGlzLmlzTW92aW5nKSB7XG4gICAgICAgICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgICAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRTdGF0ZSgpLFxuICAgICAgICAgICAgICBwcmV2aW91c0NhbWVyYVN0YXRlID0gY2FtZXJhLmdldFByZXZpb3VzU3RhdGUoKSB8fCB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYW1lcmEuYW5pbWF0ZSh7XG4gICAgICAgICAgICAgIHg6IGNhbWVyYVN0YXRlLnggKyB0aGlzLnNldHRpbmdzLmluZXJ0aWFSYXRpbyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICAgICAgeTogY2FtZXJhU3RhdGUueSArIHRoaXMuc2V0dGluZ3MuaW5lcnRpYVJhdGlvICogKGNhbWVyYVN0YXRlLnkgLSBwcmV2aW91c0NhbWVyYVN0YXRlLnkpXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLnNldHRpbmdzLmluZXJ0aWFEdXJhdGlvbixcbiAgICAgICAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY091dFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYXNNb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuaXNNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLnRvdWNoTW9kZSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaHVwXCIsIGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKSk7XG5cbiAgICAgIC8vIFdoZW4gdGhlIGxhc3QgdG91Y2ggZW5kcyBhbmQgdGhlcmUgaGFzbid0IGJlZW4gdG9vIG11Y2ggbW92ZW1lbnQsIHRyaWdnZXIgYSBcInRhcFwiIG9yIFwiZG91YmxldGFwXCIgZXZlbnQ6XG4gICAgICBpZiAoIWUudG91Y2hlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZ2V0UG9zaXRpb24odGhpcy5sYXN0VG91Y2hlc1swXSwgdGhpcy5jb250YWluZXIpO1xuICAgICAgICB2YXIgZG93blBvc2l0aW9uID0gdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnNbMF07XG4gICAgICAgIHZhciBkU3F1YXJlID0gTWF0aC5wb3cocG9zaXRpb24ueCAtIGRvd25Qb3NpdGlvbi54LCAyKSArIE1hdGgucG93KHBvc2l0aW9uLnkgLSBkb3duUG9zaXRpb24ueSwgMik7XG4gICAgICAgIGlmICghZS50b3VjaGVzLmxlbmd0aCAmJiBkU3F1YXJlIDwgTWF0aC5wb3codGhpcy5zZXR0aW5ncy50YXBNb3ZlVG9sZXJhbmNlLCAyKSkge1xuICAgICAgICAgIC8vIE9ubHkgdHJpZ2dlciBcImRvdWJsZXRhcFwiIHdoZW4gdGhlIGxhc3QgdGFwIGlzIHJlY2VudCBlbm91Z2g6XG4gICAgICAgICAgaWYgKHRoaXMubGFzdFRhcCAmJiBEYXRlLm5vdygpIC0gdGhpcy5sYXN0VGFwLnRpbWUgPCB0aGlzLnNldHRpbmdzLmRvdWJsZUNsaWNrVGltZW91dCkge1xuICAgICAgICAgICAgdmFyIHRvdWNoQ29vcmRzID0gZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5sYXN0VG91Y2hlcywgdGhpcy5jb250YWluZXIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZG91YmxldGFwXCIsIHRvdWNoQ29vcmRzKTtcbiAgICAgICAgICAgIHRoaXMubGFzdFRhcCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXRvdWNoQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICB2YXIgX2NhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgICAgICAgIHZhciBuZXdSYXRpbyA9IF9jYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKF9jYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAvIHRoaXMuc2V0dGluZ3MuZG91YmxlQ2xpY2tab29taW5nUmF0aW8pO1xuICAgICAgICAgICAgICBfY2FtZXJhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRWaWV3cG9ydFpvb21lZFN0YXRlKHBvc2l0aW9uLCBuZXdSYXRpbyksIHtcbiAgICAgICAgICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogdGhpcy5zZXR0aW5ncy5kb3VibGVDbGlja1pvb21pbmdEdXJhdGlvblxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRWxzZSwgdHJpZ2dlciBhIG5vcm1hbCBcInRhcFwiIGV2ZW50OlxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIF90b3VjaENvb3JkcyA9IGdldFRvdWNoQ29vcmRzKGUsIHRoaXMubGFzdFRvdWNoZXMsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInRhcFwiLCBfdG91Y2hDb29yZHMpO1xuICAgICAgICAgICAgdGhpcy5sYXN0VGFwID0ge1xuICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgICBwb3NpdGlvbjogX3RvdWNoQ29vcmRzLnRvdWNoZXNbMF0gfHwgX3RvdWNoQ29vcmRzLnByZXZpb3VzVG91Y2hlc1swXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zID0gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZU1vdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTW92ZShlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICF0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucy5sZW5ndGgpIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcyk7XG4gICAgICB2YXIgdG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXMubWFwKGZ1bmN0aW9uICh0b3VjaCkge1xuICAgICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIF90aGlzMy5jb250YWluZXIpO1xuICAgICAgfSk7XG4gICAgICB2YXIgbGFzdFRvdWNoZXMgPSB0aGlzLmxhc3RUb3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcyA9IHRvdWNoZXM7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdG91Y2hlc1Bvc2l0aW9ucztcbiAgICAgIHZhciB0b3VjaENvb3JkcyA9IGdldFRvdWNoQ29vcmRzKGUsIGxhc3RUb3VjaGVzLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaG1vdmVcIiwgdG91Y2hDb29yZHMpO1xuICAgICAgaWYgKHRvdWNoQ29vcmRzLnNpZ21hRGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBJZiBhIG1vdmUgd2FzIGluaXRpYXRlZCBhdCBzb21lIHBvaW50LCBhbmQgd2UgZ2V0IGJhY2sgdG8gc3RhcnQgcG9pbnQsXG4gICAgICAvLyB3ZSBzaG91bGQgc3RpbGwgY29uc2lkZXIgdGhhdCB3ZSBkaWQgbW92ZSAod2hpY2ggYWxzbyBoYXBwZW5zIGFmdGVyIGFcbiAgICAgIC8vIG11bHRpcGxlIHRvdWNoIHdoZW4gb25seSBvbmUgdG91Y2ggcmVtYWlucyBpbiB3aGljaCBjYXNlIGhhbmRsZVN0YXJ0XG4gICAgICAvLyBpcyByZWNhbGxlZCB3aXRoaW4gaGFuZGxlTGVhdmUpLlxuICAgICAgLy8gTm93LCBzb21lIG1vYmlsZSBicm93c2VycyByZXBvcnQgemVyby1kaXN0YW5jZSBtb3ZlcyBzbyB3ZSBhbHNvIGNoZWNrIHRoYXRcbiAgICAgIC8vIG9uZSBvZiB0aGUgdG91Y2hlcyBkaWQgYWN0dWFsbHkgbW92ZSBmcm9tIHRoZSBvcmlnaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLmhhc01vdmVkIHx8ICh0aGlzLmhhc01vdmVkID0gdG91Y2hlc1Bvc2l0aW9ucy5zb21lKGZ1bmN0aW9uIChwb3NpdGlvbiwgaWR4KSB7XG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gX3RoaXMzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1tpZHhdO1xuICAgICAgICByZXR1cm4gc3RhcnRQb3NpdGlvbiAmJiAocG9zaXRpb24ueCAhPT0gc3RhcnRQb3NpdGlvbi54IHx8IHBvc2l0aW9uLnkgIT09IHN0YXJ0UG9zaXRpb24ueSk7XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBtb3ZlLCBkbyBub3QgdHJpZ2dlciB0b3VjaCBtb3ZlcyBiZWhhdmlvclxuICAgICAgaWYgKCF0aGlzLmhhc01vdmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaXNNb3ZpbmcgPSB0cnVlO1xuICAgICAgaWYgKHRoaXMubW92aW5nVGltZW91dCkgY2xlYXJUaW1lb3V0KHRoaXMubW92aW5nVGltZW91dCk7XG4gICAgICB0aGlzLm1vdmluZ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgfSwgdGhpcy5zZXR0aW5ncy5kcmFnVGltZW91dCk7XG4gICAgICB2YXIgY2FtZXJhID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKTtcbiAgICAgIHZhciBzdGFydENhbWVyYVN0YXRlID0gdGhpcy5zdGFydENhbWVyYVN0YXRlO1xuICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLnJlbmRlcmVyLmdldFNldHRpbmcoXCJzdGFnZVBhZGRpbmdcIik7XG4gICAgICBzd2l0Y2ggKHRoaXMudG91Y2hNb2RlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX3RoaXMkcmVuZGVyZXIkdmlld3BvID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSksXG4gICAgICAgICAgICAgIHhTdGFydCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwby54LFxuICAgICAgICAgICAgICB5U3RhcnQgPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8ueTtcbiAgICAgICAgICAgIHZhciBfdGhpcyRyZW5kZXJlciR2aWV3cG8yID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgodG91Y2hlc1Bvc2l0aW9uc1swXSksXG4gICAgICAgICAgICAgIHggPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8yLngsXG4gICAgICAgICAgICAgIHkgPSBfdGhpcyRyZW5kZXJlciR2aWV3cG8yLnk7XG4gICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICB4OiBzdGFydENhbWVyYVN0YXRlLnggKyB4U3RhcnQgLSB4LFxuICAgICAgICAgICAgICB5OiBzdGFydENhbWVyYVN0YXRlLnkgKyB5U3RhcnQgLSB5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGVyZSBpcyB0aGUgdGhpbmtpbmcgaGVyZTpcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiAxLiBXZSBjYW4gZmluZCB0aGUgbmV3IGFuZ2xlIGFuZCByYXRpbywgYnkgY29tcGFyaW5nIHRoZSB2ZWN0b3IgZnJvbSBcInRvdWNoIG9uZVwiIHRvIFwidG91Y2ggdHdvXCIgYXQgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgKiAgICBvZiB0aGUgZCduJ2QgYW5kIG5vd1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDIuIFdlIGNhbiB1c2UgYENhbWVyYSN2aWV3cG9ydFRvR3JhcGhgIGluc2lkZSBmb3JtdWxhIHRvIHJldHJpZXZlIHRoZSBuZXcgY2FtZXJhIHBvc2l0aW9uLCB1c2luZyB0aGUgZ3JhcGhcbiAgICAgICAgICAgICAqICAgIHBvc2l0aW9uIG9mIGEgdG91Y2ggYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZCduJ2QgKHVzaW5nIGBzdGFydENhbWVyYS52aWV3cG9ydFRvR3JhcGhgKSBhbmQgdGhlIHZpZXdwb3J0XG4gICAgICAgICAgICAgKiAgICBwb3NpdGlvbiBvZiB0aGlzIHNhbWUgdG91Y2ggbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBuZXdDYW1lcmFTdGF0ZSA9IHtcbiAgICAgICAgICAgICAgeDogMC41LFxuICAgICAgICAgICAgICB5OiAwLjUsXG4gICAgICAgICAgICAgIGFuZ2xlOiAwLFxuICAgICAgICAgICAgICByYXRpbzogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBfdG91Y2hlc1Bvc2l0aW9ucyQgPSB0b3VjaGVzUG9zaXRpb25zWzBdLFxuICAgICAgICAgICAgICB4MCA9IF90b3VjaGVzUG9zaXRpb25zJC54LFxuICAgICAgICAgICAgICB5MCA9IF90b3VjaGVzUG9zaXRpb25zJC55O1xuICAgICAgICAgICAgdmFyIF90b3VjaGVzUG9zaXRpb25zJDIgPSB0b3VjaGVzUG9zaXRpb25zWzFdLFxuICAgICAgICAgICAgICB4MSA9IF90b3VjaGVzUG9zaXRpb25zJDIueCxcbiAgICAgICAgICAgICAgeTEgPSBfdG91Y2hlc1Bvc2l0aW9ucyQyLnk7XG4gICAgICAgICAgICB2YXIgYW5nbGVEaWZmID0gTWF0aC5hdGFuMih5MSAtIHkwLCB4MSAtIHgwKSAtIHRoaXMuc3RhcnRUb3VjaGVzQW5nbGU7XG4gICAgICAgICAgICB2YXIgcmF0aW9EaWZmID0gTWF0aC5oeXBvdCh5MSAtIHkwLCB4MSAtIHgwKSAvIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIDEuXG4gICAgICAgICAgICB2YXIgbmV3UmF0aW8gPSBjYW1lcmEuZ2V0Qm91bmRlZFJhdGlvKHN0YXJ0Q2FtZXJhU3RhdGUucmF0aW8gLyByYXRpb0RpZmYpO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUucmF0aW8gPSBuZXdSYXRpbztcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLmFuZ2xlID0gc3RhcnRDYW1lcmFTdGF0ZS5hbmdsZSArIGFuZ2xlRGlmZjtcblxuICAgICAgICAgICAgLy8gMi5cbiAgICAgICAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG4gICAgICAgICAgICB2YXIgdG91Y2hHcmFwaFBvc2l0aW9uID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoKHRoaXMuc3RhcnRUb3VjaGVzUG9zaXRpb25zIHx8IFtdKVswXSwge1xuICAgICAgICAgICAgICBjYW1lcmFTdGF0ZTogc3RhcnRDYW1lcmFTdGF0ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbihkaW1lbnNpb25zLndpZHRoLCBkaW1lbnNpb25zLmhlaWdodCkgLSAyICogcGFkZGluZztcbiAgICAgICAgICAgIHZhciBkeCA9IHNtYWxsZXN0RGltZW5zaW9uIC8gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgIHZhciBkeSA9IHNtYWxsZXN0RGltZW5zaW9uIC8gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSBuZXdSYXRpbyAvIHNtYWxsZXN0RGltZW5zaW9uO1xuXG4gICAgICAgICAgICAvLyBBbGlnbiB3aXRoIGNlbnRlciBvZiB0aGUgZ3JhcGg6XG4gICAgICAgICAgICB2YXIgX3ggPSB4MCAtIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGR4O1xuICAgICAgICAgICAgdmFyIF95ID0geTAgLSBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBkeTtcblxuICAgICAgICAgICAgLy8gUm90YXRlOlxuICAgICAgICAgICAgdmFyIF9yZWYgPSBbX3ggKiBNYXRoLmNvcygtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpIC0gX3kgKiBNYXRoLnNpbigtbmV3Q2FtZXJhU3RhdGUuYW5nbGUpLCBfeSAqIE1hdGguY29zKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSkgKyBfeCAqIE1hdGguc2luKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSldO1xuICAgICAgICAgICAgX3ggPSBfcmVmWzBdO1xuICAgICAgICAgICAgX3kgPSBfcmVmWzFdO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUueCA9IHRvdWNoR3JhcGhQb3NpdGlvbi54IC0gX3ggKiByYXRpbztcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnkgPSB0b3VjaEdyYXBoUG9zaXRpb24ueSArIF95ICogcmF0aW87XG4gICAgICAgICAgICBjYW1lcmEuc2V0U3RhdGUobmV3Q2FtZXJhU3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgdGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xuICAgIH1cbiAgfV0pO1xufShDYXB0b3IpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMocikge1xuICBpZiAoQXJyYXkuaXNBcnJheShyKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KHIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KHIpIHtcbiAgaWYgKFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBudWxsICE9IHJbU3ltYm9sLml0ZXJhdG9yXSB8fCBudWxsICE9IHJbXCJAQGl0ZXJhdG9yXCJdKSByZXR1cm4gQXJyYXkuZnJvbShyKTtcbn1cblxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UociwgZSkge1xuICBpZiAobnVsbCA9PSByKSByZXR1cm4ge307XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIG4gaW4gcikgaWYgKHt9Lmhhc093blByb3BlcnR5LmNhbGwociwgbikpIHtcbiAgICBpZiAoLTEgIT09IGUuaW5kZXhPZihuKSkgY29udGludWU7XG4gICAgdFtuXSA9IHJbbl07XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhlLCB0KSB7XG4gIGlmIChudWxsID09IGUpIHJldHVybiB7fTtcbiAgdmFyIG8sXG4gICAgcixcbiAgICBpID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UoZSwgdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIGZvciAociA9IDA7IHIgPCBuLmxlbmd0aDsgcisrKSBvID0gbltyXSwgLTEgPT09IHQuaW5kZXhPZihvKSAmJiB7fS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUsIG8pICYmIChpW29dID0gZVtvXSk7XG4gIH1cbiAgcmV0dXJuIGk7XG59XG5cbi8qKlxuICogU2lnbWEuanMgTGFiZWxzIEhldXJpc3RpY3NcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIE1pc2NlbGxhbmVvdXMgaGV1cmlzdGljcyByZWxhdGVkIHRvIGxhYmVsIGRpc3BsYXkuXG4gKiBAbW9kdWxlXG4gKi9cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2luZ2xlIGNhbmRpZGF0ZSBmb3IgdGhlIGxhYmVsIGdyaWQgc2VsZWN0aW9uLlxuICpcbiAqIEl0IGFsc28gZGVzY3JpYmVzIGEgZGV0ZXJtaW5pc3RpYyB3YXkgdG8gY29tcGFyZSB0d28gY2FuZGlkYXRlcyB0byBhc3Nlc3NcbiAqIHdoaWNoIG9uZSBpcyBiZXR0ZXIuXG4gKi9cbnZhciBMYWJlbENhbmRpZGF0ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIExhYmVsQ2FuZGlkYXRlKGtleSwgc2l6ZSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMYWJlbENhbmRpZGF0ZSk7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKExhYmVsQ2FuZGlkYXRlLCBudWxsLCBbe1xuICAgIGtleTogXCJjb21wYXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBhcmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgLy8gRmlyc3Qgd2UgY29tcGFyZSBieSBzaXplXG4gICAgICBpZiAoZmlyc3Quc2l6ZSA+IHNlY29uZC5zaXplKSByZXR1cm4gLTE7XG4gICAgICBpZiAoZmlyc3Quc2l6ZSA8IHNlY29uZC5zaXplKSByZXR1cm4gMTtcblxuICAgICAgLy8gVGhlbiBzaW5jZSBubyB0d28gbm9kZXMgY2FuIGhhdmUgdGhlIHNhbWUga2V5LCB3ZSB1c2UgaXQgdG9cbiAgICAgIC8vIGRldGVybWluaXN0aWNhbGx5IHRpZS1icmVhayBieSBrZXlcbiAgICAgIGlmIChmaXJzdC5rZXkgPiBzZWNvbmQua2V5KSByZXR1cm4gMTtcblxuICAgICAgLy8gTk9URTogdGhpcyBjb21wYXJhdG9yIGNhbm5vdCByZXR1cm4gMFxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfV0pO1xufSgpO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAyRCBzcGF0aWFsIGdyaWQgZGl2aWRlZCBpbnRvIGNvbnN0YW50LXNpemUgY2VsbHMuXG4gKi9cbnZhciBMYWJlbEdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYWJlbEdyaWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsR3JpZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbGxTaXplXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbHVtbnNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm93c1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZWxsc1wiLCB7fSk7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhMYWJlbEdyaWQsIFt7XG4gICAga2V5OiBcInJlc2l6ZUFuZENsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZUFuZENsZWFyKGRpbWVuc2lvbnMsIGNlbGxTaXplKSB7XG4gICAgICB0aGlzLndpZHRoID0gZGltZW5zaW9ucy53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gZGltZW5zaW9ucy5oZWlnaHQ7XG4gICAgICB0aGlzLmNlbGxTaXplID0gY2VsbFNpemU7XG4gICAgICB0aGlzLmNvbHVtbnMgPSBNYXRoLmNlaWwoZGltZW5zaW9ucy53aWR0aCAvIGNlbGxTaXplKTtcbiAgICAgIHRoaXMucm93cyA9IE1hdGguY2VpbChkaW1lbnNpb25zLmhlaWdodCAvIGNlbGxTaXplKTtcbiAgICAgIHRoaXMuY2VsbHMgPSB7fTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5kZXhcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SW5kZXgocG9zKSB7XG4gICAgICB2YXIgeEluZGV4ID0gTWF0aC5mbG9vcihwb3MueCAvIHRoaXMuY2VsbFNpemUpO1xuICAgICAgdmFyIHlJbmRleCA9IE1hdGguZmxvb3IocG9zLnkgLyB0aGlzLmNlbGxTaXplKTtcbiAgICAgIHJldHVybiB5SW5kZXggKiB0aGlzLmNvbHVtbnMgKyB4SW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImFkZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGQoa2V5LCBzaXplLCBwb3MpIHtcbiAgICAgIHZhciBjYW5kaWRhdGUgPSBuZXcgTGFiZWxDYW5kaWRhdGUoa2V5LCBzaXplKTtcbiAgICAgIHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgocG9zKTtcbiAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1tpbmRleF07XG4gICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgY2VsbCA9IFtdO1xuICAgICAgICB0aGlzLmNlbGxzW2luZGV4XSA9IGNlbGw7XG4gICAgICB9XG4gICAgICBjZWxsLnB1c2goY2FuZGlkYXRlKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwib3JnYW5pemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb3JnYW5pemUoKSB7XG4gICAgICBmb3IgKHZhciBrIGluIHRoaXMuY2VsbHMpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2tdO1xuICAgICAgICBjZWxsLnNvcnQoTGFiZWxDYW5kaWRhdGUuY29tcGFyZSk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhYmVsc1RvRGlzcGxheVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYWJlbHNUb0Rpc3BsYXkocmF0aW8sIGRlbnNpdHkpIHtcbiAgICAgIC8vIFRPRE86IHdvcmsgb24gdmlzaWJsZSBub2RlcyB0byBvcHRpbWl6ZT8gXiAtPiB0aHJlc2hvbGQgb3V0c2lkZSBzbyB0aGF0IG1lbW9pemF0aW9uIHdvcmtzP1xuICAgICAgLy8gVE9ETzogYWRqdXN0IHRocmVzaG9sZCBsb3dlciwgYnV0IGluY3JlYXNlIGNlbGxzIGEgYml0P1xuICAgICAgLy8gVE9ETzogaHVudCBmb3IgZ2VvbSBpc3N1ZSBpbiBkaXNndWlzZVxuICAgICAgLy8gVE9ETzogbWVtb2l6ZSB3aGlsZSByYXRpbyBkb2VzIG5vdCBtb3ZlLiBtZXRob2QgdG8gZm9yY2UgcmVjb21wdXRlXG4gICAgICB2YXIgY2VsbEFyZWEgPSB0aGlzLmNlbGxTaXplICogdGhpcy5jZWxsU2l6ZTtcbiAgICAgIHZhciBzY2FsZWRDZWxsQXJlYSA9IGNlbGxBcmVhIC8gcmF0aW8gLyByYXRpbztcbiAgICAgIHZhciBzY2FsZWREZW5zaXR5ID0gc2NhbGVkQ2VsbEFyZWEgKiBkZW5zaXR5IC8gY2VsbEFyZWE7XG4gICAgICB2YXIgbGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCA9IE1hdGguY2VpbChzY2FsZWREZW5zaXR5KTtcbiAgICAgIHZhciBsYWJlbHMgPSBbXTtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5jZWxscykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNba107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTWF0aC5taW4obGFiZWxzVG9EaXNwbGF5UGVyQ2VsbCwgY2VsbC5sZW5ndGgpOyBpKyspIHtcbiAgICAgICAgICBsYWJlbHMucHVzaChjZWxsW2ldLmtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKlxuICogTGFiZWwgaGV1cmlzdGljIHNlbGVjdGluZyBlZGdlIGxhYmVscyB0byBkaXNwbGF5LCBiYXNlZCBvbiBkaXNwbGF5ZWQgbm9kZVxuICogbGFiZWxzXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSBwYXJhbXMgICAgICAgICAgICAgICAgIC0gUGFyYW1ldGVyczpcbiAqIEBwYXJhbSAge1NldH0gICAgICBkaXNwbGF5ZWROb2RlTGFiZWxzICAtIEN1cnJlbnRseSBkaXNwbGF5ZWQgbm9kZSBsYWJlbHMuXG4gKiBAcGFyYW0gIHtTZXR9ICAgICAgaGlnaGxpZ2h0ZWROb2RlcyAgICAgLSBIaWdobGlnaHRlZCBub2Rlcy5cbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAgICAgICAgICAgICAtIFRoZSByZW5kZXJlZCBncmFwaC5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBob3ZlcmVkTm9kZSAgICAgICAgICAtIEhvdmVyZWQgbm9kZSAob3B0aW9uYWwpXG4gKiBAcmV0dXJuIHtBcnJheX0gICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgc2VsZWN0ZWQgbGFiZWxzLlxuICovXG5mdW5jdGlvbiBlZGdlTGFiZWxzVG9EaXNwbGF5RnJvbU5vZGVzKHBhcmFtcykge1xuICB2YXIgZ3JhcGggPSBwYXJhbXMuZ3JhcGgsXG4gICAgaG92ZXJlZE5vZGUgPSBwYXJhbXMuaG92ZXJlZE5vZGUsXG4gICAgaGlnaGxpZ2h0ZWROb2RlcyA9IHBhcmFtcy5oaWdobGlnaHRlZE5vZGVzLFxuICAgIGRpc3BsYXllZE5vZGVMYWJlbHMgPSBwYXJhbXMuZGlzcGxheWVkTm9kZUxhYmVscztcbiAgdmFyIHdvcnRoeUVkZ2VzID0gW107XG5cbiAgLy8gVE9ETzogdGhlIGNvZGUgYmVsb3cgY2FuIGJlIG9wdGltaXplZCB1c2luZyAjLmZvckVhY2ggYW5kIGJhdGNoaW5nIHRoZSBjb2RlIHBlciBhZGpcblxuICAvLyBXZSBzaG91bGQgZGlzcGxheSBhbiBlZGdlJ3MgbGFiZWwgaWY6XG4gIC8vICAgLSBBbnkgb2YgaXRzIGV4dHJlbWl0aWVzIGlzIGhpZ2hsaWdodGVkIG9yIGhvdmVyZWRcbiAgLy8gICAtIEJvdGggb2YgaXRzIGV4dHJlbWl0aWVzIGhhcyBpdHMgbGFiZWwgc2hvd25cbiAgZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UsIF8sIHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gaG92ZXJlZE5vZGUgfHwgdGFyZ2V0ID09PSBob3ZlcmVkTm9kZSB8fCBoaWdobGlnaHRlZE5vZGVzLmhhcyhzb3VyY2UpIHx8IGhpZ2hsaWdodGVkTm9kZXMuaGFzKHRhcmdldCkgfHwgZGlzcGxheWVkTm9kZUxhYmVscy5oYXMoc291cmNlKSAmJiBkaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyh0YXJnZXQpKSB7XG4gICAgICB3b3J0aHlFZGdlcy5wdXNoKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB3b3J0aHlFZGdlcztcbn1cblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBYX0xBQkVMX01BUkdJTiA9IDE1MDtcbnZhciBZX0xBQkVMX01BUkdJTiA9IDUwO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbXBvcnRhbnQgZnVuY3Rpb25zLlxuICovXG5mdW5jdGlvbiBhcHBseU5vZGVEZWZhdWx0cyhzZXR0aW5ncywga2V5LCBkYXRhKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcInhcIikgfHwgIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJ5XCIpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSB2YWxpZCBwb3NpdGlvbiAoeCwgeSkgZm9yIG5vZGUgXFxcIlwiLmNvbmNhdChrZXksIFwiXFxcIi4gQWxsIHlvdXIgbm9kZXMgbXVzdCBoYXZlIGEgbnVtYmVyIFxcXCJ4XFxcIiBhbmQgXFxcInlcXFwiLiBNYXliZSB5b3VyIGZvcmdvdCB0byBhcHBseSBhIGxheW91dCBvciB5b3VyIFxcXCJub2RlUmVkdWNlclxcXCIgaXMgbm90IHJldHVybmluZyB0aGUgY29ycmVjdCBkYXRhP1wiKSk7XG4gIGlmICghZGF0YS5jb2xvcikgZGF0YS5jb2xvciA9IHNldHRpbmdzLmRlZmF1bHROb2RlQ29sb3I7XG4gIGlmICghZGF0YS5sYWJlbCAmJiBkYXRhLmxhYmVsICE9PSBcIlwiKSBkYXRhLmxhYmVsID0gbnVsbDtcbiAgaWYgKGRhdGEubGFiZWwgIT09IHVuZGVmaW5lZCAmJiBkYXRhLmxhYmVsICE9PSBudWxsKSBkYXRhLmxhYmVsID0gXCJcIiArIGRhdGEubGFiZWw7ZWxzZSBkYXRhLmxhYmVsID0gbnVsbDtcbiAgaWYgKCFkYXRhLnNpemUpIGRhdGEuc2l6ZSA9IDI7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImhpZGRlblwiKSkgZGF0YS5oaWRkZW4gPSBmYWxzZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlnaGxpZ2h0ZWRcIikpIGRhdGEuaGlnaGxpZ2h0ZWQgPSBmYWxzZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiZm9yY2VMYWJlbFwiKSkgZGF0YS5mb3JjZUxhYmVsID0gZmFsc2U7XG4gIGlmICghZGF0YS50eXBlIHx8IGRhdGEudHlwZSA9PT0gXCJcIikgZGF0YS50eXBlID0gc2V0dGluZ3MuZGVmYXVsdE5vZGVUeXBlO1xuICBpZiAoIWRhdGEuekluZGV4KSBkYXRhLnpJbmRleCA9IDA7XG4gIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gYXBwbHlFZGdlRGVmYXVsdHMoc2V0dGluZ3MsIF9rZXksIGRhdGEpIHtcbiAgaWYgKCFkYXRhLmNvbG9yKSBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdEVkZ2VDb2xvcjtcbiAgaWYgKCFkYXRhLmxhYmVsKSBkYXRhLmxhYmVsID0gXCJcIjtcbiAgaWYgKCFkYXRhLnNpemUpIGRhdGEuc2l6ZSA9IDAuNTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlkZGVuXCIpKSBkYXRhLmhpZGRlbiA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJmb3JjZUxhYmVsXCIpKSBkYXRhLmZvcmNlTGFiZWwgPSBmYWxzZTtcbiAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSBcIlwiKSBkYXRhLnR5cGUgPSBzZXR0aW5ncy5kZWZhdWx0RWRnZVR5cGU7XG4gIGlmICghZGF0YS56SW5kZXgpIGRhdGEuekluZGV4ID0gMDtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTWFpbiBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7R3JhcGh9ICAgICAgIGdyYXBoICAgICAtIEdyYXBoIHRvIHJlbmRlci5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGNvbnRhaW5lciAtIERPTSBjb250YWluZXIgaW4gd2hpY2ggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtvYmplY3R9ICAgICAgc2V0dGluZ3MgIC0gT3B0aW9uYWwgc2V0dGluZ3MuXG4gKi9cbnZhciBTaWdtYSQxID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfVHlwZWRFdmVudEVtaXR0ZXIpIHtcbiAgZnVuY3Rpb24gU2lnbWEoZ3JhcGgsIGNvbnRhaW5lcikge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgc2V0dGluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTaWdtYSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFNpZ21hKTtcblxuICAgIC8vIFJlc29sdmluZyBzZXR0aW5nc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlbGVtZW50c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImNhbnZhc0NvbnRleHRzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwid2ViR0xDb250ZXh0c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpY2tpbmdMYXllcnNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwidGV4dHVyZXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJmcmFtZUJ1ZmZlcnNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJhY3RpdmVMaXN0ZW5lcnNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJsYWJlbEdyaWRcIiwgbmV3IExhYmVsR3JpZCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZURhdGFDYWNoZVwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VEYXRhQ2FjaGVcIiwge30pO1xuICAgIC8vIEluZGljZXMgdG8ga2VlcCB0cmFjayBvZiB0aGUgaW5kZXggb2YgdGhlIGl0ZW0gaW5zaWRlIHByb2dyYW1zXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVQcm9ncmFtSW5kZXhcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlUHJvZ3JhbUluZGV4XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwibm9kZXNXaXRoRm9yY2VkTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImVkZ2VzV2l0aEZvcmNlZExhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlRXh0ZW50XCIsIHtcbiAgICAgIHg6IFswLCAxXSxcbiAgICAgIHk6IFswLCAxXVxuICAgIH0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub2RlWkV4dGVudFwiLCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJlZGdlWkV4dGVudFwiLCBbSW5maW5pdHksIC1JbmZpbml0eV0pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJtYXRyaXhcIiwgaWRlbnRpdHkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImludk1hdHJpeFwiLCBpZGVudGl0eSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY29ycmVjdGlvblJhdGlvXCIsIDEpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJjdXN0b21CQm94XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJub3JtYWxpemF0aW9uRnVuY3Rpb25cIiwgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKHtcbiAgICAgIHg6IFswLCAxXSxcbiAgICAgIHk6IFswLCAxXVxuICAgIH0pKTtcbiAgICAvLyBDYWNoZTpcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZ3JhcGhUb1ZpZXdwb3J0UmF0aW9cIiwgMSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIml0ZW1JRHNJbmRleFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVJbmRpY2VzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZUluZGljZXNcIiwge30pO1xuICAgIC8vIFN0YXJ0aW5nIGRpbWVuc2lvbnMgYW5kIHBpeGVsIHJhdGlvXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIndpZHRoXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJoZWlnaHRcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcInBpeGVsUmF0aW9cIiwgZ2V0UGl4ZWxSYXRpbygpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicGlja2luZ0Rvd25TaXppbmdSYXRpb1wiLCAyICogX3RoaXMucGl4ZWxSYXRpbyk7XG4gICAgLy8gR3JhcGggU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZGlzcGxheWVkTm9kZUxhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJkaXNwbGF5ZWRFZGdlTGFiZWxzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhpZ2hsaWdodGVkTm9kZXNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiaG92ZXJlZE5vZGVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcImhvdmVyZWRFZGdlXCIsIG51bGwpO1xuICAgIC8vIEludGVybmFsIHN0YXRlc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJyZW5kZXJGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwicmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfdGhpcywgXCJuZWVkVG9Qcm9jZXNzXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiY2hlY2tFZGdlc0V2ZW50c0ZyYW1lXCIsIG51bGwpO1xuICAgIC8vIFByb2dyYW1zXG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVQcm9ncmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF90aGlzLCBcIm5vZGVIb3ZlclByb2dyYW1zXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX3RoaXMsIFwiZWRnZVByb2dyYW1zXCIsIHt9KTtcbiAgICBfdGhpcy5zZXR0aW5ncyA9IHJlc29sdmVTZXR0aW5ncyhzZXR0aW5ncyk7XG5cbiAgICAvLyBWYWxpZGF0aW5nXG4gICAgdmFsaWRhdGVTZXR0aW5ncyhfdGhpcy5zZXR0aW5ncyk7XG4gICAgdmFsaWRhdGVHcmFwaChncmFwaCk7XG4gICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY29udGFpbmVyIHNob3VsZCBiZSBhbiBodG1sIGVsZW1lbnQuXCIpO1xuXG4gICAgLy8gUHJvcGVydGllc1xuICAgIF90aGlzLmdyYXBoID0gZ3JhcGg7XG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgLy8gSW5pdGlhbGl6aW5nIGNvbnRleHRzXG4gICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwiZWRnZXNcIiwge1xuICAgICAgcGlja2luZzogc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50c1xuICAgIH0pO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJlZGdlTGFiZWxzXCIpO1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcIm5vZGVzXCIsIHtcbiAgICAgIHBpY2tpbmc6IHRydWVcbiAgICB9KTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwibGFiZWxzXCIpO1xuICAgIF90aGlzLmNyZWF0ZUNhbnZhc0NvbnRleHQoXCJob3ZlcnNcIik7XG4gICAgX3RoaXMuY3JlYXRlV2ViR0xDb250ZXh0KFwiaG92ZXJOb2Rlc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwibW91c2VcIiwge1xuICAgICAgc3R5bGU6IHtcbiAgICAgICAgdG91Y2hBY3Rpb246IFwibm9uZVwiLFxuICAgICAgICB1c2VyU2VsZWN0OiBcIm5vbmVcIlxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gSW5pdGlhbCByZXNpemVcbiAgICBfdGhpcy5yZXNpemUoKTtcblxuICAgIC8vIExvYWRpbmcgcHJvZ3JhbXNcbiAgICBmb3IgKHZhciB0eXBlIGluIF90aGlzLnNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgX3RoaXMucmVnaXN0ZXJOb2RlUHJvZ3JhbSh0eXBlLCBfdGhpcy5zZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbdHlwZV0sIF90aGlzLnNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW3R5cGVdKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX3R5cGUgaW4gX3RoaXMuc2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICBfdGhpcy5yZWdpc3RlckVkZ2VQcm9ncmFtKF90eXBlLCBfdGhpcy5zZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbX3R5cGVdKTtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXppbmcgdGhlIGNhbWVyYVxuICAgIF90aGlzLmNhbWVyYSA9IG5ldyBDYW1lcmEoKTtcblxuICAgIC8vIEJpbmRpbmcgY2FtZXJhIGV2ZW50c1xuICAgIF90aGlzLmJpbmRDYW1lcmFIYW5kbGVycygpO1xuXG4gICAgLy8gSW5pdGlhbGl6aW5nIGNhcHRvcnNcbiAgICBfdGhpcy5tb3VzZUNhcHRvciA9IG5ldyBNb3VzZUNhcHRvcihfdGhpcy5lbGVtZW50cy5tb3VzZSwgX3RoaXMpO1xuICAgIF90aGlzLm1vdXNlQ2FwdG9yLnNldFNldHRpbmdzKF90aGlzLnNldHRpbmdzKTtcbiAgICBfdGhpcy50b3VjaENhcHRvciA9IG5ldyBUb3VjaENhcHRvcihfdGhpcy5lbGVtZW50cy5tb3VzZSwgX3RoaXMpO1xuICAgIF90aGlzLnRvdWNoQ2FwdG9yLnNldFNldHRpbmdzKF90aGlzLnNldHRpbmdzKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnQgaGFuZGxlcnNcbiAgICBfdGhpcy5iaW5kRXZlbnRIYW5kbGVycygpO1xuXG4gICAgLy8gQmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgIF90aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGV2ZW50dWFsIHNldHRpbmdzLXJlbGF0ZWQgdGhpbmdzXG4gICAgX3RoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUoKTtcblxuICAgIC8vIFByb2Nlc3NpbmcgZGF0YSBmb3IgdGhlIGZpcnN0IHRpbWUgJiByZW5kZXJcbiAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEludGVybmFsIG1ldGhvZHMuXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byByZWdpc3RlciBhIG5vZGUgcHJvZ3JhbVxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgICAgICBrZXkgICAgICAgICAgICAgIC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIG5vZGVzIFwidHlwZVwiIHZhbHVlcy5cbiAgICogQHBhcmFtICB7Tm9kZVByb2dyYW1UeXBlfSAgTm9kZVByb2dyYW1DbGFzcyAtIEEgbm9kZXMgcHJvZ3JhbSBjbGFzcy5cbiAgICogQHBhcmFtICB7Tm9kZVByb2dyYW1UeXBlP30gTm9kZUhvdmVyUHJvZ3JhbSAtIEEgbm9kZXMgcHJvZ3JhbSBjbGFzcyB0byByZW5kZXIgaG92ZXJlZCBub2RlcyAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICovXG4gIF9pbmhlcml0cyhTaWdtYSwgX1R5cGVkRXZlbnRFbWl0dGVyKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTaWdtYSwgW3tcbiAgICBrZXk6IFwicmVnaXN0ZXJOb2RlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdpc3Rlck5vZGVQcm9ncmFtKGtleSwgTm9kZVByb2dyYW1DbGFzcywgTm9kZUhvdmVyUHJvZ3JhbSkge1xuICAgICAgaWYgKHRoaXMubm9kZVByb2dyYW1zW2tleV0pIHRoaXMubm9kZVByb2dyYW1zW2tleV0ua2lsbCgpO1xuICAgICAgaWYgKHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSkgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1trZXldLmtpbGwoKTtcbiAgICAgIHRoaXMubm9kZVByb2dyYW1zW2tleV0gPSBuZXcgTm9kZVByb2dyYW1DbGFzcyh0aGlzLndlYkdMQ29udGV4dHMubm9kZXMsIHRoaXMuZnJhbWVCdWZmZXJzLm5vZGVzLCB0aGlzKTtcbiAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSA9IG5ldyAoTm9kZUhvdmVyUHJvZ3JhbSB8fCBOb2RlUHJvZ3JhbUNsYXNzKSh0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2RlcywgbnVsbCwgdGhpcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIHJlZ2lzdGVyIGFuIGVkZ2UgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSAgICAgICAgICBrZXkgICAgICAgICAgICAgIC0gVGhlIHByb2dyYW0ncyBrZXksIG1hdGNoaW5nIHRoZSByZWxhdGVkIGVkZ2VzIFwidHlwZVwiIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0gIHtFZGdlUHJvZ3JhbVR5cGV9IEVkZ2VQcm9ncmFtQ2xhc3MgLSBBbiBlZGdlcyBwcm9ncmFtIGNsYXNzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlZ2lzdGVyRWRnZVByb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVnaXN0ZXJFZGdlUHJvZ3JhbShrZXksIEVkZ2VQcm9ncmFtQ2xhc3MpIHtcbiAgICAgIGlmICh0aGlzLmVkZ2VQcm9ncmFtc1trZXldKSB0aGlzLmVkZ2VQcm9ncmFtc1trZXldLmtpbGwoKTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1zW2tleV0gPSBuZXcgRWRnZVByb2dyYW1DbGFzcyh0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMsIHRoaXMuZnJhbWVCdWZmZXJzLmVkZ2VzLCB0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gdW5yZWdpc3RlciBhIG5vZGUgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgbm9kZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVucmVnaXN0ZXJOb2RlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyTm9kZVByb2dyYW0oa2V5KSB7XG4gICAgICBpZiAodGhpcy5ub2RlUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkbm9kZVByb2dyYW1zID0gdGhpcy5ub2RlUHJvZ3JhbXMsXG4gICAgICAgICAgcHJvZ3JhbSA9IF90aGlzJG5vZGVQcm9ncmFtc1trZXldLFxuICAgICAgICAgIHByb2dyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJG5vZGVQcm9ncmFtcywgW2tleV0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICAgIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB0aGlzLm5vZGVQcm9ncmFtcyA9IHByb2dyYW1zO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkbm9kZUhvdmVyUHJvZ3JhID0gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcyxcbiAgICAgICAgICBfcHJvZ3JhbSA9IF90aGlzJG5vZGVIb3ZlclByb2dyYVtrZXldLFxuICAgICAgICAgIF9wcm9ncmFtcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfdGhpcyRub2RlSG92ZXJQcm9ncmEsIFtrZXldLm1hcChfdG9Qcm9wZXJ0eUtleSkpO1xuICAgICAgICBfcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zID0gX3Byb2dyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byB1bnJlZ2lzdGVyIGFuIGVkZ2UgcHJvZ3JhbVxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgcHJvZ3JhbSdzIGtleSwgbWF0Y2hpbmcgdGhlIHJlbGF0ZWQgZWRnZXMgXCJ0eXBlXCIgdmFsdWVzLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVucmVnaXN0ZXJFZGdlUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnJlZ2lzdGVyRWRnZVByb2dyYW0oa2V5KSB7XG4gICAgICBpZiAodGhpcy5lZGdlUHJvZ3JhbXNba2V5XSkge1xuICAgICAgICB2YXIgX3RoaXMkZWRnZVByb2dyYW1zID0gdGhpcy5lZGdlUHJvZ3JhbXMsXG4gICAgICAgICAgcHJvZ3JhbSA9IF90aGlzJGVkZ2VQcm9ncmFtc1trZXldLFxuICAgICAgICAgIHByb2dyYW1zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF90aGlzJGVkZ2VQcm9ncmFtcywgW2tleV0ubWFwKF90b1Byb3BlcnR5S2V5KSk7XG4gICAgICAgIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtcyA9IHByb2dyYW1zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIChyZSliaW5kaW5nIFdlYkdMIHRleHR1cmUgKGZvciBwaWNraW5nKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlc2V0V2ViR0xUZXh0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0V2ViR0xUZXh0dXJlKGlkKSB7XG4gICAgICB2YXIgZ2wgPSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgdmFyIGZyYW1lQnVmZmVyID0gdGhpcy5mcmFtZUJ1ZmZlcnNbaWRdO1xuICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tpZF07XG4gICAgICBpZiAoY3VycmVudFRleHR1cmUpIGdsLmRlbGV0ZVRleHR1cmUoY3VycmVudFRleHR1cmUpO1xuICAgICAgdmFyIHBpY2tpbmdUZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBwaWNraW5nVGV4dHVyZSk7XG4gICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgcGlja2luZ1RleHR1cmUsIDApO1xuICAgICAgdGhpcy50ZXh0dXJlc1tpZF0gPSBwaWNraW5nVGV4dHVyZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGNhbWVyYSBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRDYW1lcmFIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQ2FtZXJhSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMyLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5jYW1lcmEub24oXCJ1cGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdW5iaW5kaW5nIGNhbWVyYSBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZENhbWVyYUhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuYmluZENhbWVyYUhhbmRsZXJzKCkge1xuICAgICAgdGhpcy5jYW1lcmEucmVtb3ZlTGlzdGVuZXIoXCJ1cGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNhbWVyYSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCByZXR1cm5zIHRoZSBjbG9zZXN0IG5vZGUgdG8gYSBnaXZlbiBwb3NpdGlvbi5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXROb2RlQXRQb3NpdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlQXRQb3NpdGlvbihwb3NpdGlvbikge1xuICAgICAgdmFyIHggPSBwb3NpdGlvbi54LFxuICAgICAgICB5ID0gcG9zaXRpb24ueTtcbiAgICAgIHZhciBjb2xvciA9IGdldFBpeGVsQ29sb3IodGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLCB0aGlzLmZyYW1lQnVmZmVycy5ub2RlcywgeCwgeSwgdGhpcy5waXhlbFJhdGlvLCB0aGlzLnBpY2tpbmdEb3duU2l6aW5nUmF0aW8pO1xuICAgICAgdmFyIGluZGV4ID0gY29sb3JUb0luZGV4LmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KGNvbG9yKSk7XG4gICAgICB2YXIgaXRlbUF0ID0gdGhpcy5pdGVtSURzSW5kZXhbaW5kZXhdO1xuICAgICAgcmV0dXJuIGl0ZW1BdCAmJiBpdGVtQXQudHlwZSA9PT0gXCJub2RlXCIgPyBpdGVtQXQuaWQgOiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBiaW5kaW5nIGV2ZW50IGhhbmRsZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEV2ZW50SGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEV2ZW50SGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIC8vIEhhbmRsaW5nIHdpbmRvdyByZXNpemVcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gbmVlZCB0byBjYWxsIGEgcmVmcmVzaCB0byByZWJ1aWxkIHRoZSBsYWJlbGdyaWRcbiAgICAgICAgX3RoaXMzLnNjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJlc2l6ZSk7XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIG1vdmVcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG5vZGVUb0hvdmVyID0gX3RoaXMzLmdldE5vZGVBdFBvc2l0aW9uKGV2ZW50KTtcbiAgICAgICAgaWYgKG5vZGVUb0hvdmVyICYmIF90aGlzMy5ob3ZlcmVkTm9kZSAhPT0gbm9kZVRvSG92ZXIgJiYgIV90aGlzMy5ub2RlRGF0YUNhY2hlW25vZGVUb0hvdmVyXS5oaWRkZW4pIHtcbiAgICAgICAgICAvLyBIYW5kbGluZyBwYXNzaW5nIGZyb20gb25lIG5vZGUgdG8gdGhlIG90aGVyIGRpcmVjdGx5XG4gICAgICAgICAgaWYgKF90aGlzMy5ob3ZlcmVkTm9kZSkgX3RoaXMzLmVtaXQoXCJsZWF2ZU5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBfdGhpczMuaG92ZXJlZE5vZGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLmhvdmVyZWROb2RlID0gbm9kZVRvSG92ZXI7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoXCJlbnRlck5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBub2RlVG9Ib3ZlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2hlY2tpbmcgaWYgdGhlIGhvdmVyZWQgbm9kZSBpcyBzdGlsbCBob3ZlcmVkXG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBpZiAoX3RoaXMzLmdldE5vZGVBdFBvc2l0aW9uKGV2ZW50KSAhPT0gX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ob3ZlcmVkTm9kZTtcbiAgICAgICAgICAgIF90aGlzMy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvSG92ZXIgPSBfdGhpczMuaG92ZXJlZE5vZGUgPyBudWxsIDogX3RoaXMzLmdldEVkZ2VBdFBvaW50KGJhc2VFdmVudC5ldmVudC54LCBiYXNlRXZlbnQuZXZlbnQueSk7XG4gICAgICAgICAgaWYgKGVkZ2VUb0hvdmVyICE9PSBfdGhpczMuaG92ZXJlZEVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczMuaG92ZXJlZEVkZ2UpIF90aGlzMy5lbWl0KFwibGVhdmVFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBfdGhpczMuaG92ZXJlZEVkZ2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChlZGdlVG9Ib3ZlcikgX3RoaXMzLmVtaXQoXCJlbnRlckVkZ2VcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGVkZ2VUb0hvdmVyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpczMuaG92ZXJlZEVkZ2UgPSBlZGdlVG9Ib3ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIG1vdmUgb3ZlciBib2R5IChvbmx5IHRvIGRpc3BhdGNoIHRoZSBwcm9wZXIgZXZlbnQpOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICBfdGhpczMuZW1pdChcIm1vdmVCb2R5XCIsIHtcbiAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgbGVhdmUgc3RhZ2U6XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVMZWF2ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZU5vZGVcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBfdGhpczMuaG92ZXJlZE5vZGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfdGhpczMuc2V0dGluZ3MuZW5hYmxlRWRnZUV2ZW50cyAmJiBfdGhpczMuaG92ZXJlZEVkZ2UpIHtcbiAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlRWRnZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIGVkZ2U6IF90aGlzMy5ob3ZlcmVkRWRnZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLmVtaXQoXCJsZWF2ZVN0YWdlXCIsIF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIGVudGVyIHN0YWdlOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRW50ZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjbGVhbk1vdXNlQ29vcmRzKGUpO1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMzLmVtaXQoXCJlbnRlclN0YWdlXCIsIF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIGNsaWNrXG4gICAgICB2YXIgY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lciA9IGZ1bmN0aW9uIGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBldmVudCA9IGNsZWFuTW91c2VDb29yZHMoZSk7XG4gICAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICAgIGV2ZW50LnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHZhciBub2RlQXRQb3NpdGlvbiA9IF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihldmVudCk7XG4gICAgICAgICAgaWYgKG5vZGVBdFBvc2l0aW9uKSByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIk5vZGVcIiksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogbm9kZUF0UG9zaXRpb25cbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzKSB7XG4gICAgICAgICAgICB2YXIgZWRnZSA9IF90aGlzMy5nZXRFZGdlQXRQb2ludChldmVudC54LCBldmVudC55KTtcbiAgICAgICAgICAgIGlmIChlZGdlKSByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIkVkZ2VcIiksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiU3RhZ2VcIiksIGJhc2VFdmVudCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlQ2xpY2sgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwiY2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSaWdodENsaWNrID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcInJpZ2h0Q2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJkb3VibGVDbGlja1wiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVdoZWVsID0gY3JlYXRlSW50ZXJhY3Rpb25MaXN0ZW5lcihcIndoZWVsXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93biA9IGNyZWF0ZUludGVyYWN0aW9uTGlzdGVuZXIoXCJkb3duXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXAgPSBjcmVhdGVJbnRlcmFjdGlvbkxpc3RlbmVyKFwidXBcIik7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbW92ZWJvZHlcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJyaWdodENsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJpZ2h0Q2xpY2spO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImRvdWJsZUNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJ3aGVlbFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVXaGVlbCk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24pO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNldXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXApO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbGVhdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTGVhdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlZW50ZXJcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRW50ZXIpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRvdWNoZG93blwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3duKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaGRvd25cIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZSk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2h1cFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVVcCk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwidG91Y2htb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5vbihcInRhcFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVDbGljayk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLm9uKFwiZG91YmxldGFwXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMudG91Y2hDYXB0b3Iub24oXCJ0b3VjaG1vdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTW92ZUJvZHkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGJpbmRpbmcgZ3JhcGggaGFuZGxlcnNcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRHcmFwaEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRHcmFwaEhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgdmFyIExBWU9VVF9JTVBBQ1RJTkdfRklFTERTID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpJbmRleFwiLCBcInR5cGVcIl0pO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIF9lJGhpbnRzO1xuICAgICAgICB2YXIgdXBkYXRlZEZpZWxkcyA9IChfZSRoaW50cyA9IGUuaGludHMpID09PSBudWxsIHx8IF9lJGhpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZSRoaW50cy5hdHRyaWJ1dGVzO1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIGFsbCBub2Rlc1xuICAgICAgICBfdGhpczQuZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnVwZGF0ZU5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGlmIGNvb3JkLCB0eXBlIG9yIHpJbmRleCBoYXZlIGNoYW5nZWQsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSByZW5kZXJcbiAgICAgICAgLy8gKHpJbmRleCBmb3IgdGhlIHByb2dyYW1JbmRleClcbiAgICAgICAgdmFyIGxheW91dENoYW5nZWQgPSAhdXBkYXRlZEZpZWxkcyB8fCB1cGRhdGVkRmllbGRzLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gTEFZT1VUX0lNUEFDVElOR19GSUVMRFMuaGFzKGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgbm9kZXM6IGdyYXBoLm5vZGVzKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiAhbGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2UkaGludHMyO1xuICAgICAgICB2YXIgdXBkYXRlZEZpZWxkcyA9IChfZSRoaW50czIgPSBlLmhpbnRzKSA9PT0gbnVsbCB8fCBfZSRoaW50czIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJGhpbnRzMi5hdHRyaWJ1dGVzO1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIGFsbCBlZGdlc1xuICAgICAgICBfdGhpczQuZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0LnVwZGF0ZUVkZ2UoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbGF5b3V0Q2hhbmdlZCA9IHVwZGF0ZWRGaWVsZHMgJiYgW1wiekluZGV4XCIsIFwidHlwZVwiXS5zb21lKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRGaWVsZHMgPT09IG51bGwgfHwgdXBkYXRlZEZpZWxkcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXBkYXRlZEZpZWxkcy5pbmNsdWRlcyhmKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIGVkZ2VzOiBncmFwaC5lZGdlcygpXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogIWxheW91dENoYW5nZWQsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBhZGQgbm9kZSwgd2UgYWRkIHRoZSBub2RlIGluIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZW5kZXJcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBub2RlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIG5vZGVcbiAgICAgICAgX3RoaXM0LmFkZE5vZGUobm9kZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogZmFsc2UsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiB1cGRhdGUgbm9kZSwgd2UgdXBkYXRlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZW5kZXJcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZU5vZGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBub2RlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogW25vZGVdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBza2lwSW5kZXhhdGlvbjogZmFsc2UsXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBkcm9wIG5vZGUsIHdlIHJlbW92ZSB0aGUgbm9kZSBmcm9tIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgbm9kZVxuICAgICAgICBfdGhpczQucmVtb3ZlTm9kZShub2RlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGV2ZXJ5dGhpbmdcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gYWRkIGVkZ2UsIHdlIHJlbW92ZSB0aGUgZWRnZSBmcm9tIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGRFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5hZGRFZGdlKGVkZ2UpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IFtlZGdlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiB1cGRhdGUgZWRnZSwgd2UgdXBkYXRlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlcGFpbnQgZm9yIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIGVkZ2VzOiBbZWRnZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGRyb3AgZWRnZSwgd2UgcmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BFZGdlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgZWRnZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBlZGdlXG4gICAgICAgIF90aGlzNC5yZW1vdmVFZGdlKGVkZ2UpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgYWxsIGVkZ2VzXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGNsZWFyIGVkZ2VzLCB3ZSBjbGVhciB0aGUgZWRnZSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyB3ZSBjbGVhciB0aGUgZWRnZSBkYXRhIHN0cnVjdHVyZXNcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZVN0YXRlKCk7XG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGwgZWRnZXNcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gZ3JhcGggY2xlYXIsIHdlIGNsZWFyIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBjbGVhciBncmFwaCBzdGF0ZVxuICAgICAgICBfdGhpczQuY2xlYXJFZGdlU3RhdGUoKTtcbiAgICAgICAgX3RoaXM0LmNsZWFyTm9kZVN0YXRlKCk7XG5cbiAgICAgICAgLy8gY2xlYXIgZ3JhcGggaW5kaWNlc1xuICAgICAgICBfdGhpczQuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICBfdGhpczQuY2xlYXJOb2RlSW5kaWNlcygpO1xuXG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGxcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGdyYXBoLm9uKFwibm9kZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcIm5vZGVEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VzQ2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJjbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gdW5iaW5kIGhhbmRsZXJzIGZyb20gdGhlIGdyYXBoLlxuICAgICAqXG4gICAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVuYmluZEdyYXBoSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kR3JhcGhIYW5kbGVycygpIHtcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGROb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZU5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlc0NsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJFZGdlc0dyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiY2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckdyYXBoVXBkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgbG9va2luZyBmb3IgYW4gZWRnZSBjb2xsaWRpbmcgd2l0aCBhIGdpdmVuIHBvaW50IGF0ICh4LCB5KS4gUmV0dXJuc1xuICAgICAqIHRoZSBrZXkgb2YgdGhlIGVkZ2UgaWYgYW55LCBvciBudWxsIGVsc2UuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RWRnZUF0UG9pbnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZUF0UG9pbnQoeCwgeSkge1xuICAgICAgdmFyIGNvbG9yID0gZ2V0UGl4ZWxDb2xvcih0aGlzLndlYkdMQ29udGV4dHMuZWRnZXMsIHRoaXMuZnJhbWVCdWZmZXJzLmVkZ2VzLCB4LCB5LCB0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGlja2luZ0Rvd25TaXppbmdSYXRpbyk7XG4gICAgICB2YXIgaW5kZXggPSBjb2xvclRvSW5kZXguYXBwbHkodm9pZCAwLCBfdG9Db25zdW1hYmxlQXJyYXkoY29sb3IpKTtcbiAgICAgIHZhciBpdGVtQXQgPSB0aGlzLml0ZW1JRHNJbmRleFtpbmRleF07XG4gICAgICByZXR1cm4gaXRlbUF0ICYmIGl0ZW1BdC50eXBlID09PSBcImVkZ2VcIiA/IGl0ZW1BdC5pZCA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcHJvY2VzcyB0aGUgd2hvbGUgZ3JhcGgncyBkYXRhLlxuICAgICAqICAtIGV4dGVudFxuICAgICAqICAtIG5vcm1hbGl6YXRpb25GdW5jdGlvblxuICAgICAqICAtIGNvbXB1dGUgbm9kZSdzIGNvb3JkaW5hdGVcbiAgICAgKiAgLSBsYWJlbGdyaWRcbiAgICAgKiAgLSBwcm9ncmFtIGRhdGEgYWxsb2NhdGlvblxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcygpIHtcbiAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlUHJvY2Vzc1wiKTtcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICB2YXIgc2V0dGluZ3MgPSB0aGlzLnNldHRpbmdzO1xuICAgICAgdmFyIGRpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKTtcblxuICAgICAgLy9cbiAgICAgIC8vIE5PREVTXG4gICAgICAvL1xuICAgICAgdGhpcy5ub2RlRXh0ZW50ID0gZ3JhcGhFeHRlbnQodGhpcy5ncmFwaCk7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MuYXV0b1Jlc2NhbGUpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gZGltZW5zaW9ucy53aWR0aCxcbiAgICAgICAgICBoZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgdmFyIF90aGlzJG5vZGVFeHRlbnQgPSB0aGlzLm5vZGVFeHRlbnQsXG4gICAgICAgICAgeCA9IF90aGlzJG5vZGVFeHRlbnQueCxcbiAgICAgICAgICB5ID0gX3RoaXMkbm9kZUV4dGVudC55O1xuICAgICAgICB0aGlzLm5vZGVFeHRlbnQgPSB7XG4gICAgICAgICAgeDogWyh4WzBdICsgeFsxXSkgLyAyIC0gd2lkdGggLyAyLCAoeFswXSArIHhbMV0pIC8gMiArIHdpZHRoIC8gMl0sXG4gICAgICAgICAgeTogWyh5WzBdICsgeVsxXSkgLyAyIC0gaGVpZ2h0IC8gMiwgKHlbMF0gKyB5WzFdKSAvIDIgKyBoZWlnaHQgLyAyXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24odGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudCk7XG5cbiAgICAgIC8vIE5PVEU6IGl0IGlzIGltcG9ydGFudCB0byBjb21wdXRlIHRoaXMgbWF0cml4IGFmdGVyIGNvbXB1dGluZyB0aGUgbm9kZSdzIGV4dGVudFxuICAgICAgLy8gYmVjYXVzZSAjLmdldEdyYXBoRGltZW5zaW9ucyByZWxpZXMgb24gaXRcbiAgICAgIHZhciBudWxsQ2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgdmFyIG51bGxDYW1lcmFNYXRyaXggPSBtYXRyaXhGcm9tQ2FtZXJhKG51bGxDYW1lcmEuZ2V0U3RhdGUoKSwgZGltZW5zaW9ucywgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgdGhpcy5nZXRTdGFnZVBhZGRpbmcoKSk7XG4gICAgICAvLyBSZXNldHRpbmcgdGhlIGxhYmVsIGdyaWRcbiAgICAgIC8vIFRPRE86IGl0J3MgcHJvYmFibHkgYmV0dGVyIHRvIGRvIHRoaXMgZXhwbGljaXRseSBvciBvbiByZXNpemVzIGZvciBsYXlvdXQgYW5kIGFuaW1zXG4gICAgICB0aGlzLmxhYmVsR3JpZC5yZXNpemVBbmRDbGVhcihkaW1lbnNpb25zLCBzZXR0aW5ncy5sYWJlbEdyaWRDZWxsU2l6ZSk7XG4gICAgICB2YXIgbm9kZXNQZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdmFyIG5vZGVJbmRpY2VzID0ge307XG4gICAgICB2YXIgZWRnZUluZGljZXMgPSB7fTtcbiAgICAgIHZhciBpdGVtSURzSW5kZXggPSB7fTtcbiAgICAgIHZhciBpbmNySUQgPSAxO1xuICAgICAgdmFyIG5vZGVzID0gZ3JhcGgubm9kZXMoKTtcblxuICAgICAgLy8gRG8gc29tZSBpbmRleGF0aW9uIG9uIHRoZSB3aG9sZSBncmFwaFxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG5cbiAgICAgICAgLy8gR2V0IGluaXRpYWwgY29vcmRpbmF0ZXNcbiAgICAgICAgdmFyIGF0dHJzID0gZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZXMobm9kZSk7XG4gICAgICAgIGRhdGEueCA9IGF0dHJzLng7XG4gICAgICAgIGRhdGEueSA9IGF0dHJzLnk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmFwcGx5VG8oZGF0YSk7XG5cbiAgICAgICAgLy8gbGFiZWxncmlkXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YS5sYWJlbCA9PT0gXCJzdHJpbmdcIiAmJiAhZGF0YS5oaWRkZW4pIHRoaXMubGFiZWxHcmlkLmFkZChub2RlLCBkYXRhLnNpemUsIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEsIHtcbiAgICAgICAgICBtYXRyaXg6IG51bGxDYW1lcmFNYXRyaXhcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIC8vIHVwZGF0ZSBjb3VudCBwZXIgcHJvZ3JhbVxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW2RhdGEudHlwZV0gPSAobm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICAgIHRoaXMubGFiZWxHcmlkLm9yZ2FuaXplKCk7XG5cbiAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVQcm9ncmFtcykge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcy5ub2RlUHJvZ3JhbXMsIHR5cGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQodHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0ucmVhbGxvY2F0ZShub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApO1xuICAgICAgICAvLyBXZSByZXNldCB0aGF0IGNvdW50IGhlcmUsIHNvIHRoYXQgd2UgY2FuIHJldXNlIGl0IHdoaWxlIGNhbGxpbmcgdGhlIFByb2dyYW0jcHJvY2VzcyBtZXRob2RzOlxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gMDtcbiAgICAgIH1cblxuICAgICAgLy8gT3JkZXIgbm9kZXMgYnkgekluZGV4IGJlZm9yZSB0byBhZGQgdGhlbSB0byBwcm9ncmFtXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXggJiYgdGhpcy5ub2RlWkV4dGVudFswXSAhPT0gdGhpcy5ub2RlWkV4dGVudFsxXSkgbm9kZXMgPSB6SW5kZXhPcmRlcmluZyh0aGlzLm5vZGVaRXh0ZW50LCBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gX3RoaXM1Lm5vZGVEYXRhQ2FjaGVbbm9kZV0uekluZGV4O1xuICAgICAgfSwgbm9kZXMpO1xuXG4gICAgICAvLyBBZGQgZGF0YSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IG5vZGVzLmxlbmd0aDsgX2kgPCBfbDsgX2krKykge1xuICAgICAgICB2YXIgX25vZGUgPSBub2Rlc1tfaV07XG4gICAgICAgIG5vZGVJbmRpY2VzW19ub2RlXSA9IGluY3JJRDtcbiAgICAgICAgaXRlbUlEc0luZGV4W25vZGVJbmRpY2VzW19ub2RlXV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJub2RlXCIsXG4gICAgICAgICAgaWQ6IF9ub2RlXG4gICAgICAgIH07XG4gICAgICAgIGluY3JJRCsrO1xuICAgICAgICB2YXIgX2RhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbX25vZGVdO1xuICAgICAgICB0aGlzLmFkZE5vZGVUb1Byb2dyYW0oX25vZGUsIG5vZGVJbmRpY2VzW19ub2RlXSwgbm9kZXNQZXJQcm9ncmFtc1tfZGF0YS50eXBlXSsrKTtcbiAgICAgIH1cblxuICAgICAgLy9cbiAgICAgIC8vIEVER0VTXG4gICAgICAvL1xuXG4gICAgICB2YXIgZWRnZXNQZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdmFyIGVkZ2VzID0gZ3JhcGguZWRnZXMoKTtcblxuICAgICAgLy8gQWxsb2NhdGUgbWVtb3J5IHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciBfaTIgPSAwLCBfbDIgPSBlZGdlcy5sZW5ndGg7IF9pMiA8IF9sMjsgX2kyKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTJdO1xuICAgICAgICB2YXIgX2RhdGEyID0gdGhpcy5lZGdlRGF0YUNhY2hlW2VkZ2VdO1xuICAgICAgICBlZGdlc1BlclByb2dyYW1zW19kYXRhMi50eXBlXSA9IChlZGdlc1BlclByb2dyYW1zW19kYXRhMi50eXBlXSB8fCAwKSArIDE7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVyIGVkZ2VzIGJ5IHpJbmRleCBiZWZvcmUgdG8gYWRkIHRoZW0gdG8gcHJvZ3JhbVxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4ICYmIHRoaXMuZWRnZVpFeHRlbnRbMF0gIT09IHRoaXMuZWRnZVpFeHRlbnRbMV0pIGVkZ2VzID0gekluZGV4T3JkZXJpbmcodGhpcy5lZGdlWkV4dGVudCwgZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5lZGdlRGF0YUNhY2hlW2VkZ2VdLnpJbmRleDtcbiAgICAgIH0sIGVkZ2VzKTtcbiAgICAgIGZvciAodmFyIF90eXBlMiBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodGhpcy5lZGdlUHJvZ3JhbXMsIF90eXBlMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBlZGdlIHR5cGUgXFxcIlwiLmNvbmNhdChfdHlwZTIsIFwiXFxcIiFcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRnZVByb2dyYW1zW190eXBlMl0ucmVhbGxvY2F0ZShlZGdlc1BlclByb2dyYW1zW190eXBlMl0gfHwgMCk7XG4gICAgICAgIC8vIFdlIHJlc2V0IHRoYXQgY291bnQgaGVyZSwgc28gdGhhdCB3ZSBjYW4gcmV1c2UgaXQgd2hpbGUgY2FsbGluZyB0aGUgUHJvZ3JhbSNwcm9jZXNzIG1ldGhvZHM6XG4gICAgICAgIGVkZ2VzUGVyUHJvZ3JhbXNbX3R5cGUyXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBkYXRhIHRvIHByb2dyYW1zXG4gICAgICBmb3IgKHZhciBfaTMgPSAwLCBfbDMgPSBlZGdlcy5sZW5ndGg7IF9pMyA8IF9sMzsgX2kzKyspIHtcbiAgICAgICAgdmFyIF9lZGdlID0gZWRnZXNbX2kzXTtcbiAgICAgICAgZWRnZUluZGljZXNbX2VkZ2VdID0gaW5jcklEO1xuICAgICAgICBpdGVtSURzSW5kZXhbZWRnZUluZGljZXNbX2VkZ2VdXSA9IHtcbiAgICAgICAgICB0eXBlOiBcImVkZ2VcIixcbiAgICAgICAgICBpZDogX2VkZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaW5jcklEKys7XG4gICAgICAgIHZhciBfZGF0YTMgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbX2VkZ2VdO1xuICAgICAgICB0aGlzLmFkZEVkZ2VUb1Byb2dyYW0oX2VkZ2UsIGVkZ2VJbmRpY2VzW19lZGdlXSwgZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTMudHlwZV0rKyk7XG4gICAgICB9XG4gICAgICB0aGlzLml0ZW1JRHNJbmRleCA9IGl0ZW1JRHNJbmRleDtcbiAgICAgIHRoaXMubm9kZUluZGljZXMgPSBub2RlSW5kaWNlcztcbiAgICAgIHRoaXMuZWRnZUluZGljZXMgPSBlZGdlSW5kaWNlcztcbiAgICAgIHRoaXMuZW1pdChcImFmdGVyUHJvY2Vzc1wiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0aGF0IGJhY2twb3J0cyBwb3RlbnRpYWwgc2V0dGluZ3MgdXBkYXRlcyB3aGVyZSBpdCdzIG5lZWRlZC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVNldHRpbmdzVXBkYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVNldHRpbmdzVXBkYXRlKG9sZFNldHRpbmdzKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3M7XG4gICAgICB0aGlzLmNhbWVyYS5taW5SYXRpbyA9IHNldHRpbmdzLm1pbkNhbWVyYVJhdGlvO1xuICAgICAgdGhpcy5jYW1lcmEubWF4UmF0aW8gPSBzZXR0aW5ncy5tYXhDYW1lcmFSYXRpbztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRab29taW5nID0gc2V0dGluZ3MuZW5hYmxlQ2FtZXJhWm9vbWluZztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRQYW5uaW5nID0gc2V0dGluZ3MuZW5hYmxlQ2FtZXJhUGFubmluZztcbiAgICAgIHRoaXMuY2FtZXJhLmVuYWJsZWRSb3RhdGlvbiA9IHNldHRpbmdzLmVuYWJsZUNhbWVyYVJvdGF0aW9uO1xuICAgICAgaWYgKHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMpIHtcbiAgICAgICAgdGhpcy5jYW1lcmEuY2xlYW4gPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM2LmNsZWFuQ2FtZXJhU3RhdGUoc3RhdGUsIHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMgJiYgX3R5cGVvZihzZXR0aW5ncy5jYW1lcmFQYW5Cb3VuZGFyaWVzKSA9PT0gXCJvYmplY3RcIiA/IHNldHRpbmdzLmNhbWVyYVBhbkJvdW5kYXJpZXMgOiB7fSk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNhbWVyYS5jbGVhbiA9IG51bGw7XG4gICAgICB9XG4gICAgICB0aGlzLmNhbWVyYS5zZXRTdGF0ZSh0aGlzLmNhbWVyYS52YWxpZGF0ZVN0YXRlKHRoaXMuY2FtZXJhLmdldFN0YXRlKCkpKTtcbiAgICAgIGlmIChvbGRTZXR0aW5ncykge1xuICAgICAgICAvLyBDaGVjayBlZGdlIHByb2dyYW1zOlxuICAgICAgICBpZiAob2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzICE9PSBzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciB0eXBlIGluIHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgICAgICAgaWYgKHNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1t0eXBlXSAhPT0gb2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzW3R5cGVdKSB7XG4gICAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJFZGdlUHJvZ3JhbSh0eXBlLCBzZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbdHlwZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTMgaW4gb2xkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlc1tfdHlwZTNdKSB0aGlzLnVucmVnaXN0ZXJFZGdlUHJvZ3JhbShfdHlwZTMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNrIG5vZGUgcHJvZ3JhbXM6XG4gICAgICAgIGlmIChvbGRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMgIT09IHNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3NlcyB8fCBvbGRTZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3NlcyAhPT0gc2V0dGluZ3Mubm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXMpIHtcbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTQgaW4gc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNF0gIT09IG9sZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTRdIHx8IHNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0gIT09IG9sZFNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0pIHtcbiAgICAgICAgICAgICAgdGhpcy5yZWdpc3Rlck5vZGVQcm9ncmFtKF90eXBlNCwgc2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzW190eXBlNF0sIHNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzW190eXBlNF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHZhciBfdHlwZTUgaW4gb2xkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlc1tfdHlwZTVdKSB0aGlzLnVucmVnaXN0ZXJOb2RlUHJvZ3JhbShfdHlwZTUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBVcGRhdGUgY2FwdG9ycyBzZXR0aW5nczpcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iuc2V0U2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLnRvdWNoQ2FwdG9yLnNldFNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFuQ2FtZXJhU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYW5DYW1lcmFTdGF0ZShzdGF0ZSkge1xuICAgICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9LFxuICAgICAgICBfcmVmJHRvbGVyYW5jZSA9IF9yZWYudG9sZXJhbmNlLFxuICAgICAgICB0b2xlcmFuY2UgPSBfcmVmJHRvbGVyYW5jZSA9PT0gdm9pZCAwID8gMCA6IF9yZWYkdG9sZXJhbmNlLFxuICAgICAgICBib3VuZGFyaWVzID0gX3JlZi5ib3VuZGFyaWVzO1xuICAgICAgdmFyIG5ld1N0YXRlID0gX29iamVjdFNwcmVhZDIoe30sIHN0YXRlKTtcblxuICAgICAgLy8gRXh0cmFjdCBuZWNlc3NhcnkgcHJvcGVydGllc1xuICAgICAgdmFyIF9yZWYyID0gYm91bmRhcmllcyB8fCB0aGlzLm5vZGVFeHRlbnQsXG4gICAgICAgIF9yZWYyJHggPSBfc2xpY2VkVG9BcnJheShfcmVmMi54LCAyKSxcbiAgICAgICAgeE1pbkdyYXBoID0gX3JlZjIkeFswXSxcbiAgICAgICAgeE1heEdyYXBoID0gX3JlZjIkeFsxXSxcbiAgICAgICAgX3JlZjIkeSA9IF9zbGljZWRUb0FycmF5KF9yZWYyLnksIDIpLFxuICAgICAgICB5TWluR3JhcGggPSBfcmVmMiR5WzBdLFxuICAgICAgICB5TWF4R3JhcGggPSBfcmVmMiR5WzFdO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gdGhlIGZvdXIgY29ybmVycyBvZiB0aGUgZ3JhcGggcmVjdGFuZ2xlIHVzaW5nIHRoZSBwcm92aWRlZCBjYW1lcmEgc3RhdGVcbiAgICAgIHZhciBjb3JuZXJzID0gW3RoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1pbkdyYXBoLFxuICAgICAgICB5OiB5TWluR3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KSwgdGhpcy5ncmFwaFRvVmlld3BvcnQoe1xuICAgICAgICB4OiB4TWF4R3JhcGgsXG4gICAgICAgIHk6IHlNaW5HcmFwaFxuICAgICAgfSwge1xuICAgICAgICBjYW1lcmFTdGF0ZTogc3RhdGVcbiAgICAgIH0pLCB0aGlzLmdyYXBoVG9WaWV3cG9ydCh7XG4gICAgICAgIHg6IHhNaW5HcmFwaCxcbiAgICAgICAgeTogeU1heEdyYXBoXG4gICAgICB9LCB7XG4gICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgfSksIHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KHtcbiAgICAgICAgeDogeE1heEdyYXBoLFxuICAgICAgICB5OiB5TWF4R3JhcGhcbiAgICAgIH0sIHtcbiAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICB9KV07XG5cbiAgICAgIC8vIExvb2sgZm9yIG5ldyBleHRlbnRzLCBiYXNlZCBvbiB0aGVzZSBmb3VyIGNvcm5lcnNcbiAgICAgIHZhciB4TWluID0gSW5maW5pdHksXG4gICAgICAgIHhNYXggPSAtSW5maW5pdHksXG4gICAgICAgIHlNaW4gPSBJbmZpbml0eSxcbiAgICAgICAgeU1heCA9IC1JbmZpbml0eTtcbiAgICAgIGNvcm5lcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZjMpIHtcbiAgICAgICAgdmFyIHggPSBfcmVmMy54LFxuICAgICAgICAgIHkgPSBfcmVmMy55O1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgeCk7XG4gICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCB4KTtcbiAgICAgICAgeU1pbiA9IE1hdGgubWluKHlNaW4sIHkpO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgeSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGVhY2ggZGltZW5zaW9uLCBjb25zdHJhaW50IHRoZSBzbWFsbGVyIGVsZW1lbnQgKGNhbWVyYSBvciBncmFwaCkgdG8gZml0IGluIHRoZSBsYXJnZXIgb25lOlxuICAgICAgdmFyIGdyYXBoV2lkdGggPSB4TWF4IC0geE1pbjtcbiAgICAgIHZhciBncmFwaEhlaWdodCA9IHlNYXggLSB5TWluO1xuICAgICAgdmFyIF90aGlzJGdldERpbWVuc2lvbnMgPSB0aGlzLmdldERpbWVuc2lvbnMoKSxcbiAgICAgICAgd2lkdGggPSBfdGhpcyRnZXREaW1lbnNpb25zLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfdGhpcyRnZXREaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIHZhciBkeCA9IDA7XG4gICAgICB2YXIgZHkgPSAwO1xuICAgICAgaWYgKGdyYXBoV2lkdGggPj0gd2lkdGgpIHtcbiAgICAgICAgaWYgKHhNYXggPCB3aWR0aCAtIHRvbGVyYW5jZSkgZHggPSB4TWF4IC0gKHdpZHRoIC0gdG9sZXJhbmNlKTtlbHNlIGlmICh4TWluID4gdG9sZXJhbmNlKSBkeCA9IHhNaW4gLSB0b2xlcmFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeE1heCA+IHdpZHRoICsgdG9sZXJhbmNlKSBkeCA9IHhNYXggLSAod2lkdGggKyB0b2xlcmFuY2UpO2Vsc2UgaWYgKHhNaW4gPCAtdG9sZXJhbmNlKSBkeCA9IHhNaW4gKyB0b2xlcmFuY2U7XG4gICAgICB9XG4gICAgICBpZiAoZ3JhcGhIZWlnaHQgPj0gaGVpZ2h0KSB7XG4gICAgICAgIGlmICh5TWF4IDwgaGVpZ2h0IC0gdG9sZXJhbmNlKSBkeSA9IHlNYXggLSAoaGVpZ2h0IC0gdG9sZXJhbmNlKTtlbHNlIGlmICh5TWluID4gdG9sZXJhbmNlKSBkeSA9IHlNaW4gLSB0b2xlcmFuY2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoeU1heCA+IGhlaWdodCArIHRvbGVyYW5jZSkgZHkgPSB5TWF4IC0gKGhlaWdodCArIHRvbGVyYW5jZSk7ZWxzZSBpZiAoeU1pbiA8IC10b2xlcmFuY2UpIGR5ID0geU1pbiArIHRvbGVyYW5jZTtcbiAgICAgIH1cbiAgICAgIGlmIChkeCB8fCBkeSkge1xuICAgICAgICAvLyBUcmFuc2Zvcm0gW2R4LCBkeV0gZnJvbSB2aWV3cG9ydCB0byBncmFwaCAodXNpbmcgdHdvIGRpZmZlcmVudCBwb2ludCB0byB0cmFuc2Zvcm0gdGhhdCB2ZWN0b3IpOlxuICAgICAgICB2YXIgb3JpZ2luID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB7XG4gICAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXRlXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZGVsdGEgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogZHgsXG4gICAgICAgICAgeTogZHlcbiAgICAgICAgfSwge1xuICAgICAgICAgIGNhbWVyYVN0YXRlOiBzdGF0ZVxuICAgICAgICB9KTtcbiAgICAgICAgZHggPSBkZWx0YS54IC0gb3JpZ2luLng7XG4gICAgICAgIGR5ID0gZGVsdGEueSAtIG9yaWdpbi55O1xuICAgICAgICBuZXdTdGF0ZS54ICs9IGR4O1xuICAgICAgICBuZXdTdGF0ZS55ICs9IGR5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld1N0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciBsYWJlbHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLnJlbmRlckxhYmVscykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpO1xuXG4gICAgICAvLyBTZWxlY3RpbmcgbGFiZWxzIHRvIGRyYXdcbiAgICAgIHZhciBsYWJlbHNUb0Rpc3BsYXkgPSB0aGlzLmxhYmVsR3JpZC5nZXRMYWJlbHNUb0Rpc3BsYXkoY2FtZXJhU3RhdGUucmF0aW8sIHRoaXMuc2V0dGluZ3MubGFiZWxEZW5zaXR5KTtcbiAgICAgIGV4dGVuZChsYWJlbHNUb0Rpc3BsYXksIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzKTtcbiAgICAgIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyA9IG5ldyBTZXQoKTtcblxuICAgICAgLy8gRHJhd2luZyBsYWJlbHNcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5sYWJlbHM7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGxhYmVsc1RvRGlzcGxheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSBsYWJlbHNUb0Rpc3BsYXlbaV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuXG4gICAgICAgIC8vIElmIHRoZSBub2RlIHdhcyBhbHJlYWR5IGRyYXduIChsaWtlIGlmIGl0IGlzIGVsaWdpYmxlIEFORCBoYXNcbiAgICAgICAgLy8gYGZvcmNlTGFiZWxgKSwgd2UgZG9uJ3Qgd2FudCB0byBkcmF3IGl0IGFnYWluXG4gICAgICAgIC8vIE5PVEU6IHdlIGNhbiBkbyBiZXR0ZXIgcHJvYmFibHlcbiAgICAgICAgaWYgKHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscy5oYXMobm9kZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElmIHRoZSBub2RlIGlzIGhpZGRlbiwgd2UgZG9uJ3QgbmVlZCB0byBkaXNwbGF5IGl0cyBsYWJlbCBvYnZpb3VzbHlcbiAgICAgICAgaWYgKGRhdGEuaGlkZGVuKSBjb250aW51ZTtcbiAgICAgICAgdmFyIF90aGlzJGZyYW1lZEdyYXBoVG9WaSA9IHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEpLFxuICAgICAgICAgIHggPSBfdGhpcyRmcmFtZWRHcmFwaFRvVmkueCxcbiAgICAgICAgICB5ID0gX3RoaXMkZnJhbWVkR3JhcGhUb1ZpLnk7XG5cbiAgICAgICAgLy8gTk9URTogd2UgY2FuIGNhY2hlIHRoZSBsYWJlbHMgd2UgbmVlZCB0byByZW5kZXIgdW50aWwgdGhlIGNhbWVyYSdzIHJhdGlvIGNoYW5nZXNcbiAgICAgICAgdmFyIHNpemUgPSB0aGlzLnNjYWxlU2l6ZShkYXRhLnNpemUpO1xuXG4gICAgICAgIC8vIElzIG5vZGUgYmlnIGVub3VnaD9cbiAgICAgICAgaWYgKCFkYXRhLmZvcmNlTGFiZWwgJiYgc2l6ZSA8IHRoaXMuc2V0dGluZ3MubGFiZWxSZW5kZXJlZFNpemVUaHJlc2hvbGQpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElzIG5vZGUgYWN0dWFsbHkgb24gc2NyZWVuICh3aXRoIHNvbWUgbWFyZ2luKVxuICAgICAgICAvLyBOT1RFOiB3ZSB1c2VkIHRvIHJlbHkgb24gdGhlIHF1YWR0cmVlIGZvciB0aGlzLCBidXQgdGhlIGNvb3JkaW5hdGVzXG4gICAgICAgIC8vIGNvbnZlcnNpb24gbWFrZSBpdCB1bnJlbGlhYmxlIGFuZCBhdCB0aGF0IHBvaW50IHdlIGFscmVhZHkgY29udmVydGVkXG4gICAgICAgIC8vIHRvIHZpZXdwb3J0IGNvb3JkaW5hdGVzIGFuZCBzaW5jZSB0aGUgbGFiZWwgZ3JpZCBhbHJlYWR5IGN1bGxzIHRoZVxuICAgICAgICAvLyBudW1iZXIgb2YgcG90ZW50aWFsIGxhYmVscyB0byBkaXNwbGF5IHRoaXMgbG9va3MgbGlrZSBhIGdvb2RcbiAgICAgICAgLy8gcGVyZm9ybWFuY2UgY29tcHJvbWlzZS5cbiAgICAgICAgLy8gTk9URTogbGFiZWxHcmlkLmdldExhYmVsc1RvRGlzcGxheSBjb3VsZCBwcm9iYWJseSBvcHRpbWl6ZSBieSBub3RcbiAgICAgICAgLy8gY29uc2lkZXJpbmcgY2VsbHMgb2J2aW91c2x5IG91dHNpZGUgb2YgdGhlIHJhbmdlIG9mIHRoZSBjdXJyZW50XG4gICAgICAgIC8vIHZpZXcgcmVjdGFuZ2xlLlxuICAgICAgICBpZiAoeCA8IC1YX0xBQkVMX01BUkdJTiB8fCB4ID4gdGhpcy53aWR0aCArIFhfTEFCRUxfTUFSR0lOIHx8IHkgPCAtWV9MQUJFTF9NQVJHSU4gfHwgeSA+IHRoaXMuaGVpZ2h0ICsgWV9MQUJFTF9NQVJHSU4pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEJlY2F1c2UgZGlzcGxheWVkIGVkZ2UgbGFiZWxzIGRlcGVuZCBkaXJlY3RseSBvbiBhY3R1YWxseSByZW5kZXJlZCBub2RlXG4gICAgICAgIC8vIGxhYmVscywgd2UgbmVlZCB0byBvbmx5IGFkZCB0byB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgbm9kZXMgd2hvc2UgbGFiZWxcbiAgICAgICAgLy8gaXMgcmVuZGVyZWQuXG4gICAgICAgIC8vIFRoaXMgbWFrZXMgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzIGRlcGVuZCBvbiB2aWV3cG9ydCwgd2hpY2ggbWlnaHQgYmVjb21lXG4gICAgICAgIC8vIGFuIGlzc3VlIG9uY2Ugd2Ugc3RhcnQgbWVtb2l6aW5nIGdldExhYmVsc1RvRGlzcGxheS5cbiAgICAgICAgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLmFkZChub2RlKTtcbiAgICAgICAgdmFyIGRlZmF1bHREcmF3Tm9kZUxhYmVsID0gdGhpcy5zZXR0aW5ncy5kZWZhdWx0RHJhd05vZGVMYWJlbDtcbiAgICAgICAgdmFyIG5vZGVQcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdMYWJlbCA9IChub2RlUHJvZ3JhbSA9PT0gbnVsbCB8fCBub2RlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2dyYW0uZHJhd0xhYmVsKSB8fCBkZWZhdWx0RHJhd05vZGVMYWJlbDtcbiAgICAgICAgZHJhd0xhYmVsKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IG5vZGVcbiAgICAgICAgfSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIGVkZ2UgbGFiZWxzLCBiYXNlZCBvbiB3aGljaCBub2RlIGxhYmVscyB3ZXJlXG4gICAgICogcmVuZGVyZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJFZGdlTGFiZWxzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckVkZ2VMYWJlbHMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmVuZGVyRWRnZUxhYmVscykgcmV0dXJuIHRoaXM7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMuZWRnZUxhYmVscztcblxuICAgICAgLy8gQ2xlYXJpbmdcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHZhciBlZGdlTGFiZWxzVG9EaXNwbGF5ID0gZWRnZUxhYmVsc1RvRGlzcGxheUZyb21Ob2Rlcyh7XG4gICAgICAgIGdyYXBoOiB0aGlzLmdyYXBoLFxuICAgICAgICBob3ZlcmVkTm9kZTogdGhpcy5ob3ZlcmVkTm9kZSxcbiAgICAgICAgZGlzcGxheWVkTm9kZUxhYmVsczogdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLFxuICAgICAgICBoaWdobGlnaHRlZE5vZGVzOiB0aGlzLmhpZ2hsaWdodGVkTm9kZXNcbiAgICAgIH0pO1xuICAgICAgZXh0ZW5kKGVkZ2VMYWJlbHNUb0Rpc3BsYXksIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzKTtcbiAgICAgIHZhciBkaXNwbGF5ZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGVkZ2VMYWJlbHNUb0Rpc3BsYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZUxhYmVsc1RvRGlzcGxheVtpXSxcbiAgICAgICAgICBleHRyZW1pdGllcyA9IHRoaXMuZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSksXG4gICAgICAgICAgc291cmNlRGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1swXV0sXG4gICAgICAgICAgdGFyZ2V0RGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1sxXV0sXG4gICAgICAgICAgZWRnZURhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG5cbiAgICAgICAgLy8gSWYgdGhlIGVkZ2Ugd2FzIGFscmVhZHkgZHJhd24gKGxpa2UgaWYgaXQgaXMgZWxpZ2libGUgQU5EIGhhc1xuICAgICAgICAvLyBgZm9yY2VMYWJlbGApLCB3ZSBkb24ndCB3YW50IHRvIGRyYXcgaXQgYWdhaW5cbiAgICAgICAgaWYgKGRpc3BsYXllZExhYmVscy5oYXMoZWRnZSkpIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIElmIHRoZSBlZGdlIGlzIGhpZGRlbiB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgaXRzIGxhYmVsXG4gICAgICAgIC8vIE5PVEU6IHRoZSB0ZXN0IG9uIHNvdXJjZURhdGEgJiB0YXJnZXREYXRhIGlzIHByb2JhYmx5IHBhcmFub2lkIGF0IHRoaXMgcG9pbnQ/XG4gICAgICAgIGlmIChlZGdlRGF0YS5oaWRkZW4gfHwgc291cmNlRGF0YS5oaWRkZW4gfHwgdGFyZ2V0RGF0YS5oaWRkZW4pIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGVmYXVsdERyYXdFZGdlTGFiZWwgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHREcmF3RWRnZUxhYmVsO1xuICAgICAgICB2YXIgZWRnZVByb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1tlZGdlRGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdMYWJlbCA9IChlZGdlUHJvZ3JhbSA9PT0gbnVsbCB8fCBlZGdlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRnZVByb2dyYW0uZHJhd0xhYmVsKSB8fCBkZWZhdWx0RHJhd0VkZ2VMYWJlbDtcbiAgICAgICAgZHJhd0xhYmVsKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGVkZ2VcbiAgICAgICAgfSwgZWRnZURhdGEpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVTaXplKGVkZ2VEYXRhLnNpemUpXG4gICAgICAgIH0pLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBleHRyZW1pdGllc1swXVxuICAgICAgICB9LCBzb3VyY2VEYXRhKSwgdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoc291cmNlRGF0YSkpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHRoaXMuc2NhbGVTaXplKHNvdXJjZURhdGEuc2l6ZSlcbiAgICAgICAgfSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGV4dHJlbWl0aWVzWzFdXG4gICAgICAgIH0sIHRhcmdldERhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydCh0YXJnZXREYXRhKSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUodGFyZ2V0RGF0YS5zaXplKVxuICAgICAgICB9KSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIGRpc3BsYXllZExhYmVscy5hZGQoZWRnZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmRpc3BsYXllZEVkZ2VMYWJlbHMgPSBkaXNwbGF5ZWRMYWJlbHM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIgdGhlIGhpZ2hsaWdodGVkIG5vZGVzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVySGlnaGxpZ2h0ZWROb2Rlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJIaWdobGlnaHRlZE5vZGVzKCkge1xuICAgICAgdmFyIF90aGlzNyA9IHRoaXM7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMuY2FudmFzQ29udGV4dHMuaG92ZXJzO1xuXG4gICAgICAvLyBDbGVhcmluZ1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgICAvLyBSZW5kZXJpbmdcbiAgICAgIHZhciByZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIobm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICB2YXIgX3RoaXM3JGZyYW1lZEdyYXBoVG9WID0gX3RoaXM3LmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhKSxcbiAgICAgICAgICB4ID0gX3RoaXM3JGZyYW1lZEdyYXBoVG9WLngsXG4gICAgICAgICAgeSA9IF90aGlzNyRmcmFtZWRHcmFwaFRvVi55O1xuICAgICAgICB2YXIgc2l6ZSA9IF90aGlzNy5zY2FsZVNpemUoZGF0YS5zaXplKTtcbiAgICAgICAgdmFyIGRlZmF1bHREcmF3Tm9kZUhvdmVyID0gX3RoaXM3LnNldHRpbmdzLmRlZmF1bHREcmF3Tm9kZUhvdmVyO1xuICAgICAgICB2YXIgbm9kZVByb2dyYW0gPSBfdGhpczcubm9kZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICAgIHZhciBkcmF3SG92ZXIgPSAobm9kZVByb2dyYW0gPT09IG51bGwgfHwgbm9kZVByb2dyYW0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVQcm9ncmFtLmRyYXdIb3ZlcikgfHwgZGVmYXVsdERyYXdOb2RlSG92ZXI7XG4gICAgICAgIGRyYXdIb3Zlcihjb250ZXh0LCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7XG4gICAgICAgICAga2V5OiBub2RlXG4gICAgICAgIH0sIGRhdGEpLCB7fSwge1xuICAgICAgICAgIHNpemU6IHNpemUsXG4gICAgICAgICAgeDogeCxcbiAgICAgICAgICB5OiB5XG4gICAgICAgIH0pLCBfdGhpczcuc2V0dGluZ3MpO1xuICAgICAgfTtcbiAgICAgIHZhciBub2Rlc1RvUmVuZGVyID0gW107XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSAmJiAhdGhpcy5ub2RlRGF0YUNhY2hlW3RoaXMuaG92ZXJlZE5vZGVdLmhpZGRlbikge1xuICAgICAgICBub2Rlc1RvUmVuZGVyLnB1c2godGhpcy5ob3ZlcmVkTm9kZSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAvLyBUaGUgaG92ZXJlZCBub2RlIGhhcyBhbHJlYWR5IGJlZW4gaGlnaGxpZ2h0ZWRcbiAgICAgICAgaWYgKG5vZGUgIT09IF90aGlzNy5ob3ZlcmVkTm9kZSkgbm9kZXNUb1JlbmRlci5wdXNoKG5vZGUpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIERyYXcgbGFiZWxzOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiByZW5kZXIobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRHJhdyBXZWJHTCBub2RlcyBvbiB0b3Agb2YgdGhlIGxhYmVsczpcbiAgICAgIHZhciBub2Rlc1BlclByb2dyYW1zID0ge307XG5cbiAgICAgIC8vIDEuIENvdW50IG5vZGVzIHBlciB0eXBlOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciB0eXBlID0gX3RoaXM3Lm5vZGVEYXRhQ2FjaGVbbm9kZV0udHlwZTtcbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1t0eXBlXSA9IChub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApICsgMTtcbiAgICAgIH0pO1xuICAgICAgLy8gMi4gQWxsb2NhdGUgZm9yIGVhY2ggdHlwZSBmb3IgdGhlIHByb3BlciBudW1iZXIgb2Ygbm9kZXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zW3R5cGVdLnJlYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgLy8gQWxzbyByZXNldCBjb3VudCwgdG8gdXNlIHdoZW4gcmVuZGVyaW5nOlxuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIDMuIFByb2Nlc3MgYWxsIG5vZGVzIHRvIHJlbmRlcjpcbiAgICAgIG5vZGVzVG9SZW5kZXIuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZGF0YSA9IF90aGlzNy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuICAgICAgICBfdGhpczcubm9kZUhvdmVyUHJvZ3JhbXNbZGF0YS50eXBlXS5wcm9jZXNzKDAsIG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSsrLCBkYXRhKTtcbiAgICAgIH0pO1xuICAgICAgLy8gNC4gQ2xlYXIgaG92ZXJlZCBub2RlcyBsYXllcjpcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLmNsZWFyKHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgLy8gNS4gUmVuZGVyOlxuICAgICAgdmFyIHJlbmRlclBhcmFtcyA9IHRoaXMuZ2V0UmVuZGVyUGFyYW1zKCk7XG4gICAgICBmb3IgKHZhciBfdHlwZTYgaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbX3R5cGU2XTtcbiAgICAgICAgcHJvZ3JhbS5yZW5kZXIocmVuZGVyUGFyYW1zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIGhvdmVyIHJlbmRlci5cbiAgICAgKlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM4ID0gdGhpcztcbiAgICAgIGlmICh0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSB8fCB0aGlzLnJlbmRlckZyYW1lKSByZXR1cm47XG4gICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFJlc2V0dGluZyBzdGF0ZVxuICAgICAgICBfdGhpczgucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gbnVsbDtcblxuICAgICAgICAvLyBSZW5kZXJpbmdcbiAgICAgICAgX3RoaXM4LnJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKTtcbiAgICAgICAgX3RoaXM4LnJlbmRlckVkZ2VMYWJlbHMoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIHRoaXMuZW1pdChcImJlZm9yZVJlbmRlclwiKTtcbiAgICAgIHZhciBleGl0UmVuZGVyID0gZnVuY3Rpb24gZXhpdFJlbmRlcigpIHtcbiAgICAgICAgX3RoaXM5LmVtaXQoXCJhZnRlclJlbmRlclwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzOTtcbiAgICAgIH07XG5cbiAgICAgIC8vIElmIGEgcmVuZGVyIHdhcyBzY2hlZHVsZWQsIHdlIGNhbmNlbCBpdFxuICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIHJlc2l6ZVxuICAgICAgdGhpcy5yZXNpemUoKTtcblxuICAgICAgLy8gRG8gd2UgbmVlZCB0byByZXByb2Nlc3MgZGF0YT9cbiAgICAgIGlmICh0aGlzLm5lZWRUb1Byb2Nlc3MpIHRoaXMucHJvY2VzcygpO1xuICAgICAgdGhpcy5uZWVkVG9Qcm9jZXNzID0gZmFsc2U7XG5cbiAgICAgIC8vIENsZWFyaW5nIHRoZSBjYW52YXNlc1xuICAgICAgdGhpcy5jbGVhcigpO1xuXG4gICAgICAvLyBQcmVwYXJlIHRoZSB0ZXh0dXJlc1xuICAgICAgdGhpcy5waWNraW5nTGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgIHJldHVybiBfdGhpczkucmVzZXRXZWJHTFRleHR1cmUobGF5ZXIpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIElmIHdlIGhhdmUgbm8gbm9kZXMgd2UgY2FuIHN0b3AgcmlnaHQgdGhlcmVcbiAgICAgIGlmICghdGhpcy5ncmFwaC5vcmRlcikgcmV0dXJuIGV4aXRSZW5kZXIoKTtcblxuICAgICAgLy8gVE9ETzogaW1wcm92ZSB0aGlzIGhldXJpc3RpYyBvciBtb3ZlIHRvIHRoZSBjYXB0b3IgaXRzZWxmP1xuICAgICAgLy8gVE9ETzogZGVhbCB3aXRoIHRoZSB0b3VjaCBjYXB0b3IgaGVyZSBhcyB3ZWxsXG4gICAgICB2YXIgbW91c2VDYXB0b3IgPSB0aGlzLm1vdXNlQ2FwdG9yO1xuICAgICAgdmFyIG1vdmluZyA9IHRoaXMuY2FtZXJhLmlzQW5pbWF0ZWQoKSB8fCBtb3VzZUNhcHRvci5pc01vdmluZyB8fCBtb3VzZUNhcHRvci5kcmFnZ2VkRXZlbnRzIHx8IG1vdXNlQ2FwdG9yLmN1cnJlbnRXaGVlbERpcmVjdGlvbjtcblxuICAgICAgLy8gVGhlbiB3ZSBuZWVkIHRvIGV4dHJhY3QgYSBtYXRyaXggZnJvbSB0aGUgY2FtZXJhXG4gICAgICB2YXIgY2FtZXJhU3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpO1xuICAgICAgdmFyIHZpZXdwb3J0RGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgdmFyIGdyYXBoRGltZW5zaW9ucyA9IHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCk7XG4gICAgICB2YXIgcGFkZGluZyA9IHRoaXMuZ2V0U3RhZ2VQYWRkaW5nKCk7XG4gICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeEZyb21DYW1lcmEoY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nKTtcbiAgICAgIHRoaXMuaW52TWF0cml4ID0gbWF0cml4RnJvbUNhbWVyYShjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMsIHBhZGRpbmcsIHRydWUpO1xuICAgICAgdGhpcy5jb3JyZWN0aW9uUmF0aW8gPSBnZXRNYXRyaXhJbXBhY3QodGhpcy5tYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyA9IHRoaXMuZ2V0R3JhcGhUb1ZpZXdwb3J0UmF0aW8oKTtcblxuICAgICAgLy8gW2phY29teWFsXVxuICAgICAgLy8gVGhpcyBjb21tZW50IGlzIHJlbGF0ZWQgdG8gdGhlIG9uZSBhYm92ZSB0aGUgYGdldE1hdHJpeEltcGFjdGAgZGVmaW5pdGlvbjpcbiAgICAgIC8vIC0gYHRoaXMuY29ycmVjdGlvblJhdGlvYCBpcyBzb21laG93IG5vdCBjb21wbGV0ZWx5IGV4cGxhaW5lZFxuICAgICAgLy8gLSBgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpb2AgaXMgdGhlIHJhdGlvIG9mIGEgZGlzdGFuY2UgaW4gdGhlIHZpZXdwb3J0IGRpdmlkZWQgYnkgdGhlIHNhbWUgZGlzdGFuY2UgaW4gdGhlXG4gICAgICAvLyAgIGdyYXBoXG4gICAgICAvLyAtIGB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5yYXRpb2AgaXMgYmFzaWNhbGx5IGBNYXRoLm1heChncmFwaERYLCBncmFwaERZKWBcbiAgICAgIC8vIEFuZCBub3csIEkgb2JzZXJ2ZSB0aGF0IGlmIEkgbXVsdGlwbHkgdGhlc2UgdGhyZWUgcmF0aW9zLCBJIGhhdmUgc29tZXRoaW5nIGNvbnN0YW50LCB3aGljaCB2YWx1ZSByZW1haW5zIDIsIGV2ZW5cbiAgICAgIC8vIHdoZW4gSSBjaGFuZ2UgdGhlIGdyYXBoLCB0aGUgdmlld3BvcnQgb3IgdGhlIGNhbWVyYS4gSXQgbWlnaHQgYmUgdXNlZnVsIGxhdGVyLCBzbyBJIHByZWZlciB0byBsZXQgdGhpcyBjb21tZW50OlxuICAgICAgLy8gY29uc29sZS5sb2codGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyAqIHRoaXMuY29ycmVjdGlvblJhdGlvICogdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24ucmF0aW8gKiAyKTtcblxuICAgICAgdmFyIHBhcmFtcyA9IHRoaXMuZ2V0UmVuZGVyUGFyYW1zKCk7XG5cbiAgICAgIC8vIERyYXdpbmcgbm9kZXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1t0eXBlXTtcbiAgICAgICAgcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgIH1cblxuICAgICAgLy8gRHJhd2luZyBlZGdlc1xuICAgICAgaWYgKCF0aGlzLnNldHRpbmdzLmhpZGVFZGdlc09uTW92ZSB8fCAhbW92aW5nKSB7XG4gICAgICAgIGZvciAodmFyIF90eXBlNyBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICAgIHZhciBfcHJvZ3JhbTIgPSB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTddO1xuICAgICAgICAgIF9wcm9ncmFtMi5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgZGlzcGxheSBsYWJlbHMgb24gbW92ZSBwZXIgc2V0dGluZ1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuaGlkZUxhYmVsc09uTW92ZSAmJiBtb3ZpbmcpIHJldHVybiBleGl0UmVuZGVyKCk7XG4gICAgICB0aGlzLnJlbmRlckxhYmVscygpO1xuICAgICAgdGhpcy5yZW5kZXJFZGdlTGFiZWxzKCk7XG4gICAgICB0aGlzLnJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKTtcbiAgICAgIHJldHVybiBleGl0UmVuZGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgbm9kZSBpbiB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGUoa2V5KSB7XG4gICAgICAvLyBOb2RlIGRpc3BsYXkgZGF0YSByZXNvbHV0aW9uOlxuICAgICAgLy8gIDEuIEZpcnN0IHdlIGdldCB0aGUgbm9kZSdzIGF0dHJpYnV0ZXNcbiAgICAgIC8vICAyLiBXZSBvcHRpb25hbGx5IHJlZHVjZSB0aGVtIHVzaW5nIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgLy8gICAgIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdG90YWwgb2JqZWN0IGFuZCB3b24ndCBiZSBtZXJnZWRcbiAgICAgIC8vICAzLiBXZSBhcHBseSBvdXIgZGVmYXVsdHMsIHdoaWxlIHJ1bm5pbmcgc29tZSB2aXRhbCBjaGVja3NcbiAgICAgIC8vICA0LiBXZSBhcHBseSB0aGUgbm9ybWFsaXphdGlvbiBmdW5jdGlvblxuICAgICAgLy8gV2Ugc2hhbGxvdyBjb3B5IG5vZGUgZGF0YSB0byBhdm9pZCBkYW5nZXJvdXMgYmVoYXZpb3JzIGZyb20gcmVkdWNlcnNcbiAgICAgIHZhciBhdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ncmFwaC5nZXROb2RlQXR0cmlidXRlcyhrZXkpKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLm5vZGVSZWR1Y2VyKSBhdHRyID0gdGhpcy5zZXR0aW5ncy5ub2RlUmVkdWNlcihrZXksIGF0dHIpO1xuICAgICAgdmFyIGRhdGEgPSBhcHBseU5vZGVEZWZhdWx0cyh0aGlzLnNldHRpbmdzLCBrZXksIGF0dHIpO1xuICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlW2tleV0gPSBkYXRhO1xuXG4gICAgICAvLyBMYWJlbDpcbiAgICAgIC8vIFdlIGRlbGV0ZSBhbmQgYWRkIGlmIG5lZWRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIGZyb21cbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICAgIGlmIChkYXRhLmZvcmNlTGFiZWwgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVscy5hZGQoa2V5KTtcblxuICAgICAgLy8gSGlnaGxpZ2h0ZWQ6XG4gICAgICAvLyBXZSByZW1vdmUgYW5kIHJlIGFkZCBpZiBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCBmcm9tXG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuaGlnaGxpZ2h0ZWQgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLmhpZ2hsaWdodGVkTm9kZXMuYWRkKGtleSk7XG5cbiAgICAgIC8vIHpJbmRleFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA8IHRoaXMubm9kZVpFeHRlbnRbMF0pIHRoaXMubm9kZVpFeHRlbnRbMF0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4ID4gdGhpcy5ub2RlWkV4dGVudFsxXSkgdGhpcy5ub2RlWkV4dGVudFsxXSA9IGRhdGEuekluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhIG5vZGUgdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlTm9kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVOb2RlKGtleSkge1xuICAgICAgdGhpcy5hZGROb2RlKGtleSk7XG5cbiAgICAgIC8vIFJlLWFwcGx5IG5vcm1hbGl6YXRpb24gb24gdGhlIG5vZGVcbiAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5hcHBseVRvKGRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIG5vZGUgZnJvbSB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbW92ZU5vZGUoa2V5KSB7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBub2RlIGNhY2hlXG4gICAgICBkZWxldGUgdGhpcy5ub2RlRGF0YUNhY2hlW2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBub2RlIHByb2dyYW0gaW5kZXhcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVQcm9ncmFtSW5kZXhba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGhpZ2xpZ2h0ZWQgbm9kZXNcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaG92ZXJlZFxuICAgICAgaWYgKHRoaXMuaG92ZXJlZE5vZGUgPT09IGtleSkgdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBmb3JjZWQgbGFiZWxcbiAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIGFuIGVkZ2UgaW50byB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGRFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEVkZ2Uoa2V5KSB7XG4gICAgICAvLyBFZGdlIGRpc3BsYXkgZGF0YSByZXNvbHV0aW9uOlxuICAgICAgLy8gIDEuIEZpcnN0IHdlIGdldCB0aGUgZWRnZSdzIGF0dHJpYnV0ZXNcbiAgICAgIC8vICAyLiBXZSBvcHRpb25hbGx5IHJlZHVjZSB0aGVtIHVzaW5nIHRoZSBmdW5jdGlvbiBwcm92aWRlZCBieSB0aGUgdXNlclxuICAgICAgLy8gIDMuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdG90YWwgb2JqZWN0IGFuZCB3b24ndCBiZSBtZXJnZWRcbiAgICAgIC8vICA0LiBXZSBhcHBseSBvdXIgZGVmYXVsdHMsIHdoaWxlIHJ1bm5pbmcgc29tZSB2aXRhbCBjaGVja3NcbiAgICAgIC8vIFdlIHNoYWxsb3cgY29weSBlZGdlIGRhdGEgdG8gYXZvaWQgZGFuZ2Vyb3VzIGJlaGF2aW9ycyBmcm9tIHJlZHVjZXJzXG4gICAgICB2YXIgYXR0ciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ3JhcGguZ2V0RWRnZUF0dHJpYnV0ZXMoa2V5KSk7XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5lZGdlUmVkdWNlcikgYXR0ciA9IHRoaXMuc2V0dGluZ3MuZWRnZVJlZHVjZXIoa2V5LCBhdHRyKTtcbiAgICAgIHZhciBkYXRhID0gYXBwbHlFZGdlRGVmYXVsdHModGhpcy5zZXR0aW5ncywga2V5LCBhdHRyKTtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZVtrZXldID0gZGF0YTtcblxuICAgICAgLy8gRm9yY2VkIGxhYmVsXG4gICAgICAvLyB3ZSBmaWx0ZXIgYW5kIHJlIHB1c2ggaWYgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgZnJvbVxuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLmVkZ2VzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuZm9yY2VMYWJlbCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzLmFkZChrZXkpO1xuXG4gICAgICAvLyBDaGVjayB6SW5kZXhcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCkge1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPCB0aGlzLmVkZ2VaRXh0ZW50WzBdKSB0aGlzLmVkZ2VaRXh0ZW50WzBdID0gZGF0YS56SW5kZXg7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA+IHRoaXMuZWRnZVpFeHRlbnRbMV0pIHRoaXMuZWRnZVpFeHRlbnRbMV0gPSBkYXRhLnpJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgYW4gZWRnZSBpbiB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgZWRnZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVFZGdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUVkZ2Uoa2V5KSB7XG4gICAgICB0aGlzLmFkZEVkZ2Uoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gZWRnZSBmcm9tIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRWRnZShrZXkpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGVkZ2UgY2FjaGVcbiAgICAgIGRlbGV0ZSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIHByb2dyYW1JZCBpbmRleFxuICAgICAgZGVsZXRlIHRoaXMuZWRnZVByb2dyYW1JbmRleFtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaG92ZXJlZFxuICAgICAgaWYgKHRoaXMuaG92ZXJlZEVkZ2UgPT09IGtleSkgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBmb3JjZWQgbGFiZWxcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGluZGljZXMgcmVsYXRlZCB0byBub2Rlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyTm9kZUluZGljZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJOb2RlSW5kaWNlcygpIHtcbiAgICAgIC8vIExhYmVsR3JpZCAmIG5vZGVFeHRlbnQgYXJlIG9ubHkgbWFuYWdlL3BvcHVsYXRlZCBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgdGhpcy5sYWJlbEdyaWQgPSBuZXcgTGFiZWxHcmlkKCk7XG4gICAgICB0aGlzLm5vZGVFeHRlbnQgPSB7XG4gICAgICAgIHg6IFswLCAxXSxcbiAgICAgICAgeTogWzAsIDFdXG4gICAgICB9O1xuICAgICAgdGhpcy5ub2RlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXggPSB7fTtcbiAgICAgIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ub2RlWkV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcyByZWxhdGVkIHRvIGVkZ2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJFZGdlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckVkZ2VJbmRpY2VzKCkge1xuICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXggPSB7fTtcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5lZGdlWkV4dGVudCA9IFtJbmZpbml0eSwgLUluZmluaXR5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFySW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckluZGljZXMoKSB7XG4gICAgICB0aGlzLmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgIHRoaXMuY2xlYXJOb2RlSW5kaWNlcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncmFwaCBzdGF0ZSByZWxhdGVkIHRvIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJOb2RlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJOb2RlU3RhdGUoKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGggc3RhdGUgcmVsYXRlZCB0byBlZGdlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyRWRnZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRWRnZVN0YXRlKCkge1xuICAgICAgdGhpcy5kaXNwbGF5ZWRFZGdlTGFiZWxzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoIHN0YXRlLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhclN0YXRlKCkge1xuICAgICAgdGhpcy5jbGVhckVkZ2VTdGF0ZSgpO1xuICAgICAgdGhpcy5jbGVhck5vZGVTdGF0ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgbm9kZSBkYXRhIHRvIGl0cyBwcm9ncmFtLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIG5vZGUncyBncmFwaG9sb2d5IElEXG4gICAgICogQHBhcmFtIGZpbmdlcnByaW50IEEgZmluZ2VycHJpbnQgdXNlZCB0byBpZGVudGl0eSB0aGUgbm9kZSB3aXRoIHBpY2tpbmdcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIGluZGV4IHdoZXJlIHRvIHBsYWNlIHRoZSBub2RlIGluIHRoZSBwcm9ncmFtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkTm9kZVRvUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGROb2RlVG9Qcm9ncmFtKG5vZGUsIGZpbmdlcnByaW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICB2YXIgbm9kZVByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgaWYgKCFub2RlUHJvZ3JhbSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3Igbm9kZSB0eXBlIFxcXCJcIi5jb25jYXQoZGF0YS50eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgIG5vZGVQcm9ncmFtLnByb2Nlc3MoZmluZ2VycHJpbnQsIHBvc2l0aW9uLCBkYXRhKTtcbiAgICAgIC8vIFNhdmluZyBwcm9ncmFtIGluZGV4XG4gICAgICB0aGlzLm5vZGVQcm9ncmFtSW5kZXhbbm9kZV0gPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGVkZ2UgZGF0YSB0byBpdHMgcHJvZ3JhbS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBlZGdlIFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqIEBwYXJhbSBmaW5nZXJwcmludCBBIGZpbmdlcnByaW50IHVzZWQgdG8gaWRlbnRpdHkgdGhlIGVkZ2Ugd2l0aCBwaWNraW5nXG4gICAgICogQHBhcmFtIHBvc2l0aW9uIFRoZSBpbmRleCB3aGVyZSB0byBwbGFjZSB0aGUgZWRnZSBpbiB0aGUgcHJvZ3JhbVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VUb1Byb2dyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZVRvUHJvZ3JhbShlZGdlLCBmaW5nZXJwcmludCwgcG9zaXRpb24pIHtcbiAgICAgIHZhciBkYXRhID0gdGhpcy5lZGdlRGF0YUNhY2hlW2VkZ2VdO1xuICAgICAgdmFyIGVkZ2VQcm9ncmFtID0gdGhpcy5lZGdlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgIGlmICghZWRnZVByb2dyYW0pIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIGVkZ2UgdHlwZSBcXFwiXCIuY29uY2F0KGRhdGEudHlwZSwgXCJcXFwiIVwiKSk7XG4gICAgICB2YXIgZXh0cmVtaXRpZXMgPSB0aGlzLmdyYXBoLmV4dHJlbWl0aWVzKGVkZ2UpLFxuICAgICAgICBzb3VyY2VEYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzBdXSxcbiAgICAgICAgdGFyZ2V0RGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtleHRyZW1pdGllc1sxXV07XG4gICAgICBlZGdlUHJvZ3JhbS5wcm9jZXNzKGZpbmdlcnByaW50LCBwb3NpdGlvbiwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSk7XG4gICAgICAvLyBTYXZpbmcgcHJvZ3JhbSBpbmRleFxuICAgICAgdGhpcy5lZGdlUHJvZ3JhbUluZGV4W2VkZ2VdID0gcG9zaXRpb247XG4gICAgfVxuXG4gICAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICogUHVibGljIEFQSS5cbiAgICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gZ2V0IHRoZSByZW5kZXIgcGFyYW1zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UmVuZGVyUGFyYW1zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFJlbmRlclBhcmFtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZW5kZXJQYXJhbXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4LFxuICAgICAgICBpbnZNYXRyaXg6IHRoaXMuaW52TWF0cml4LFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICB6b29tUmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICBjYW1lcmFBbmdsZTogdGhpcy5jYW1lcmEuYW5nbGUsXG4gICAgICAgIHNpemVSYXRpbzogMSAvIHRoaXMuc2NhbGVTaXplKCksXG4gICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgIGRvd25TaXppbmdSYXRpbzogdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvLFxuICAgICAgICBtaW5FZGdlVGhpY2tuZXNzOiB0aGlzLnNldHRpbmdzLm1pbkVkZ2VUaGlja25lc3MsXG4gICAgICAgIGFudGlBbGlhc2luZ0ZlYXRoZXI6IHRoaXMuc2V0dGluZ3MuYW50aUFsaWFzaW5nRmVhdGhlclxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIHJldHJpZXZlIHRoZSBhY3R1YWwgc3RhZ2UgcGFkZGluZyB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge251bWJlcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGFnZVBhZGRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U3RhZ2VQYWRkaW5nKCkge1xuICAgICAgdmFyIF90aGlzJHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgc3RhZ2VQYWRkaW5nID0gX3RoaXMkc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxuICAgICAgICBhdXRvUmVzY2FsZSA9IF90aGlzJHNldHRpbmdzLmF1dG9SZXNjYWxlO1xuICAgICAgcmV0dXJuIGF1dG9SZXNjYWxlID8gc3RhZ2VQYWRkaW5nIHx8IDAgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgbGF5ZXIgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIENvbnRleHQncyBpZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIC0gVGhlIEhUTUwgdGFnIHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUxheWVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUxheWVyKGlkLCB0YWcpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2lkXSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGEgbGF5ZXIgbmFtZWQgXFxcIlwiLmNvbmNhdChpZCwgXCJcXFwiIGFscmVhZHkgZXhpc3RzXCIpKTtcbiAgICAgIHZhciBlbGVtZW50ID0gY3JlYXRlRWxlbWVudCh0YWcsIHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgfSwge1xuICAgICAgICBcImNsYXNzXCI6IFwic2lnbWEtXCIuY29uY2F0KGlkKVxuICAgICAgfSk7XG4gICAgICBpZiAob3B0aW9ucy5zdHlsZSkgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBvcHRpb25zLnN0eWxlKTtcbiAgICAgIHRoaXMuZWxlbWVudHNbaWRdID0gZWxlbWVudDtcbiAgICAgIGlmIChcImJlZm9yZUxheWVyXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmJlZm9yZUxheWVyKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbb3B0aW9ucy5iZWZvcmVMYXllcl0uYmVmb3JlKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmIChcImFmdGVyTGF5ZXJcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuYWZ0ZXJMYXllcikge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW29wdGlvbnMuYWZ0ZXJMYXllcl0uYWZ0ZXIoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBDb250ZXh0J3MgaWQuXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVDYW52YXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FudmFzKGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYXllcihpZCwgXCJjYW52YXNcIiwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBjYW52YXMgY29udGV4dCBhbmQgYWRkIHRoZSByZWxldmFudCBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAgb3B0aW9uc1xuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dChpZCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKGlkLCBvcHRpb25zKTtcbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHNbaWRdID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIFdlYkdMIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnQgRE9NXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBpZCAgICAgIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAge29iamVjdD99IG9wdGlvbnMgLSAjZ2V0Q29udGV4dCBwYXJhbXMgdG8gb3ZlcnJpZGUgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1dlYkdMUmVuZGVyaW5nQ29udGV4dH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVXZWJHTENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlV2ViR0xDb250ZXh0KGlkKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgY2FudmFzID0gKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYW52YXMpIHx8IHRoaXMuY3JlYXRlQ2FudmFzKGlkLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmhpZGRlbikgY2FudmFzLnJlbW92ZSgpO1xuICAgICAgdmFyIGNvbnRleHRPcHRpb25zID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zKTtcbiAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICAvLyBGaXJzdCB3ZSB0cnkgd2ViZ2wyIGZvciBhbiBlYXN5IHBlcmZvcm1hbmNlIGJvb3N0XG4gICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbDJcIiwgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAvLyBFbHNlIHdlIGZhbGwgYmFjayB0byB3ZWJnbFxuICAgICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCJ3ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG5cbiAgICAgIC8vIEVkZ2UsIEkgYW0gbG9va2luZyByaWdodCBhdCB5b3UuLi5cbiAgICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiZXhwZXJpbWVudGFsLXdlYmdsXCIsIGNvbnRleHRPcHRpb25zKTtcbiAgICAgIHZhciBnbCA9IGNvbnRleHQ7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHNbaWRdID0gZ2w7XG5cbiAgICAgIC8vIEJsZW5kaW5nOlxuICAgICAgZ2wuYmxlbmRGdW5jKGdsLk9ORSwgZ2wuT05FX01JTlVTX1NSQ19BTFBIQSk7XG5cbiAgICAgIC8vIFByZXBhcmUgZnJhbWUgYnVmZmVyIGZvciBwaWNraW5nIGxheWVyczpcbiAgICAgIGlmIChvcHRpb25zLnBpY2tpbmcpIHtcbiAgICAgICAgdGhpcy5waWNraW5nTGF5ZXJzLmFkZChpZCk7XG4gICAgICAgIHZhciBuZXdGcmFtZUJ1ZmZlciA9IGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7XG4gICAgICAgIGlmICghbmV3RnJhbWVCdWZmZXIpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjYW5ub3QgY3JlYXRlIGEgbmV3IGZyYW1lIGJ1ZmZlciBmb3IgbGF5ZXIgXCIuY29uY2F0KGlkKSk7XG4gICAgICAgIHRoaXMuZnJhbWVCdWZmZXJzW2lkXSA9IG5ld0ZyYW1lQnVmZmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZ1bmN0aW9uIHVzZWQgdG8gcHJvcGVybHkga2lsbCBhIGxheWVyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAtIExheWVyIGlkLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImtpbGxMYXllclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsTGF5ZXIoaWQpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpZF07XG4gICAgICBpZiAoIWVsZW1lbnQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjYW5ub3Qga2lsbCBsYXllciBcIi5jb25jYXQoaWQsIFwiLCB3aGljaCBkb2VzIG5vdCBleGlzdFwiKSk7XG4gICAgICBpZiAodGhpcy53ZWJHTENvbnRleHRzW2lkXSkge1xuICAgICAgICB2YXIgX2dsJGdldEV4dGVuc2lvbjtcbiAgICAgICAgdmFyIGdsID0gdGhpcy53ZWJHTENvbnRleHRzW2lkXTtcbiAgICAgICAgKF9nbCRnZXRFeHRlbnNpb24gPSBnbC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIikpID09PSBudWxsIHx8IF9nbCRnZXRFeHRlbnNpb24gPT09IHZvaWQgMCB8fCBfZ2wkZ2V0RXh0ZW5zaW9uLmxvc2VDb250ZXh0KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmNhbnZhc0NvbnRleHRzW2lkXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5jYW52YXNDb250ZXh0c1tpZF07XG4gICAgICB9XG5cbiAgICAgIC8vIERlbGV0ZSBsYXllciBlbGVtZW50XG4gICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgZGVsZXRlIHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDYW1lcmF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbWVyYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtDYW1lcmF9IGNhbWVyYSAtIE5ldyBjYW1lcmEuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhbWVyYShjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgdGhpcy5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250YWluZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHJlbmRlcmVyJ3MgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgcmVuZGVyZXIncyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0dyYXBofVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdyYXBoKGdyYXBoKSB7XG4gICAgICBpZiAoZ3JhcGggPT09IHRoaXMuZ3JhcGgpIHJldHVybjtcblxuICAgICAgLy8gQ2hlY2sgaG92ZXJlZE5vZGUgYW5kIGhvdmVyZWRFZGdlXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSAmJiAhZ3JhcGguaGFzTm9kZSh0aGlzLmhvdmVyZWROb2RlKSkgdGhpcy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSAmJiAhZ3JhcGguaGFzRWRnZSh0aGlzLmhvdmVyZWRFZGdlKSkgdGhpcy5ob3ZlcmVkRWRnZSA9IG51bGw7XG5cbiAgICAgIC8vIFVuYmluZGluZyBoYW5kbGVycyBvbiB0aGUgY3VycmVudCBncmFwaFxuICAgICAgdGhpcy51bmJpbmRHcmFwaEhhbmRsZXJzKCk7XG4gICAgICBpZiAodGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUgIT09IG51bGwpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5jaGVja0VkZ2VzRXZlbnRzRnJhbWUpO1xuICAgICAgICB0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEluc3RhbGxpbmcgbmV3IGdyYXBoXG4gICAgICB0aGlzLmdyYXBoID0gZ3JhcGg7XG5cbiAgICAgIC8vIEJpbmRpbmcgbmV3IGhhbmRsZXJzXG4gICAgICB0aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlLXJlbmRlcmluZyBub3cgdG8gYXZvaWQgZGlzY3JlcGFuY2llcyBmcm9tIG5vdyB0byBuZXh0IGZyYW1lXG4gICAgICB0aGlzLnJlZnJlc2goKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBtb3VzZSBjYXB0b3IuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtNb3VzZUNhcHRvcn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRNb3VzZUNhcHRvclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNb3VzZUNhcHRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vdXNlQ2FwdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHRvdWNoIGNhcHRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1RvdWNoQ2FwdG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRvdWNoQ2FwdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFRvdWNoQ2FwdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG91Y2hDYXB0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY3VycmVudCByZW5kZXJlcidzIGRpbWVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuaGVpZ2h0XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGN1cnJlbnQgZ3JhcGgncyBkaW1lbnNpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybiB7RGltZW5zaW9uc31cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaERpbWVuc2lvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R3JhcGhEaW1lbnNpb25zKCkge1xuICAgICAgdmFyIGV4dGVudCA9IHRoaXMuY3VzdG9tQkJveCB8fCB0aGlzLm5vZGVFeHRlbnQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogZXh0ZW50LnhbMV0gLSBleHRlbnQueFswXSB8fCAxLFxuICAgICAgICBoZWlnaHQ6IGV4dGVudC55WzFdIC0gZXh0ZW50LnlbMF0gfHwgMVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBub2RlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcbiAgICAgKiBhbmQgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIG5vZGVSZWR1Y2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgICAqIEByZXR1cm4ge05vZGVEaXNwbGF5RGF0YSB8IHVuZGVmaW5lZH0gQSBjb3B5IG9mIHRoZSBkZXNpcmVkIG5vZGUncyBhdHRyaWJ1dGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlRGlzcGxheURhdGEoa2V5KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZURhdGFDYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIG5vZGUgPyBPYmplY3QuYXNzaWduKHt9LCBub2RlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBlZGdlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIGVkZ2VSZWR1Y2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgZWRnZSdzIGtleS5cbiAgICAgKiBAcmV0dXJuIHtFZGdlRGlzcGxheURhdGEgfCB1bmRlZmluZWR9IEEgY29weSBvZiB0aGUgZGVzaXJlZCBlZGdlJ3MgYXR0cmlidXRlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlRGlzcGxheURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXlEYXRhKGtleSkge1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBlZGdlID8gT2JqZWN0LmFzc2lnbih7fSwgZWRnZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBub2RlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBub2RlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBlZGdlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBlZGdlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyBhIGNvcHkgb2YgdGhlIHNldHRpbmdzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTZXR0aW5nc30gQSBjb3B5IG9mIHRoZSBzZXR0aW5ncyBjb2xsZWN0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmdzKCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBhIGdpdmVuIHNldHRpbmcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgc2V0dGluZyBrZXkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlIGF0dGFjaGVkIHRvIHRoaXMgc2V0dGluZyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgKiBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHthbnl9ICAgIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmcoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIG9sZFZhbHVlcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3Nba2V5XSA9IHZhbHVlO1xuICAgICAgdmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUob2xkVmFsdWVzKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXBkYXRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkgdXNpbmcgdGhlIHByb3ZpZGVkIGZ1bmN0aW9uLlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGUgYSBuZXcgcmVuZGVyIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAga2V5ICAgICAtIFRoZSBzZXR0aW5nIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBUaGUgdXBkYXRlIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU2V0dGluZyhrZXksIHVwZGF0ZXIpIHtcbiAgICAgIHRoaXMuc2V0U2V0dGluZyhrZXksIHVwZGF0ZXIodGhpcy5zZXR0aW5nc1trZXldKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyBtdWx0aXBsZSBzZXR0aW5ncyBhdCBvbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7UGFydGlhbDxTZXR0aW5ncz59IHNldHRpbmdzIC0gVGhlIHNldHRpbmdzIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTZXR0aW5ncyhzZXR0aW5ncykge1xuICAgICAgdmFyIG9sZFZhbHVlcyA9IF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgdGhpcy5zZXR0aW5ncyksIHNldHRpbmdzKTtcbiAgICAgIHZhbGlkYXRlU2V0dGluZ3ModGhpcy5zZXR0aW5ncyk7XG4gICAgICB0aGlzLmhhbmRsZVNldHRpbmdzVXBkYXRlKG9sZFZhbHVlcyk7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVmcmVzaCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVzaXplIHRoZSByZW5kZXJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2Jvb2xlYW59IGZvcmNlIC0gSWYgdHJ1ZSwgdGhlbiByZXNpemUgaXMgcHJvY2Vzc2VkIGV2ZW4gaWYgc2l6ZSBpcyB1bmNoYW5nZWQgKG9wdGlvbmFsKS5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplKGZvcmNlKSB7XG4gICAgICB2YXIgcHJldmlvdXNXaWR0aCA9IHRoaXMud2lkdGgsXG4gICAgICAgIHByZXZpb3VzSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICB0aGlzLndpZHRoID0gdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IHRoaXMuY29udGFpbmVyLm9mZnNldEhlaWdodDtcbiAgICAgIHRoaXMucGl4ZWxSYXRpbyA9IGdldFBpeGVsUmF0aW8oKTtcbiAgICAgIGlmICh0aGlzLndpZHRoID09PSAwKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmFsbG93SW52YWxpZENvbnRhaW5lcikgdGhpcy53aWR0aCA9IDE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29udGFpbmVyIGhhcyBubyB3aWR0aC4gWW91IGNhbiBzZXQgdGhlIGFsbG93SW52YWxpZENvbnRhaW5lciBzZXR0aW5nIHRvIHRydWUgdG8gc3RvcCBzZWVpbmcgdGhpcyBlcnJvci5cIik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oZWlnaHQgPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dJbnZhbGlkQ29udGFpbmVyKSB0aGlzLmhlaWdodCA9IDE7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogQ29udGFpbmVyIGhhcyBubyBoZWlnaHQuIFlvdSBjYW4gc2V0IHRoZSBhbGxvd0ludmFsaWRDb250YWluZXIgc2V0dGluZyB0byB0cnVlIHRvIHN0b3Agc2VlaW5nIHRoaXMgZXJyb3IuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBub3RoaW5nIGhhcyBjaGFuZ2VkLCB3ZSBjYW4gc3RvcCByaWdodCBoZXJlXG4gICAgICBpZiAoIWZvcmNlICYmIHByZXZpb3VzV2lkdGggPT09IHRoaXMud2lkdGggJiYgcHJldmlvdXNIZWlnaHQgPT09IHRoaXMuaGVpZ2h0KSByZXR1cm4gdGhpcztcblxuICAgICAgLy8gU2l6aW5nIGRvbSBlbGVtZW50c1xuICAgICAgZm9yICh2YXIgaWQgaW4gdGhpcy5lbGVtZW50cykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuZWxlbWVudHNbaWRdO1xuICAgICAgICBlbGVtZW50LnN0eWxlLndpZHRoID0gdGhpcy53aWR0aCArIFwicHhcIjtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0aGlzLmhlaWdodCArIFwicHhcIjtcbiAgICAgIH1cblxuICAgICAgLy8gU2l6aW5nIGNhbnZhcyBjb250ZXh0c1xuICAgICAgZm9yICh2YXIgX2lkIGluIHRoaXMuY2FudmFzQ29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWRdLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZF0uc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgaWYgKHRoaXMucGl4ZWxSYXRpbyAhPT0gMSkgdGhpcy5jYW52YXNDb250ZXh0c1tfaWRdLnNjYWxlKHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waXhlbFJhdGlvKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2l6aW5nIFdlYkdMIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBfaWQyIGluIHRoaXMud2ViR0xDb250ZXh0cykge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZDJdLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB0aGlzLmVsZW1lbnRzW19pZDJdLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIHZhciBnbCA9IHRoaXMud2ViR0xDb250ZXh0c1tfaWQyXTtcbiAgICAgICAgZ2wudmlld3BvcnQoMCwgMCwgdGhpcy53aWR0aCAqIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8pO1xuXG4gICAgICAgIC8vIENsZWFyIHBpY2tpbmcgdGV4dHVyZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMucGlja2luZ0xheWVycy5oYXMoX2lkMikpIHtcbiAgICAgICAgICB2YXIgY3VycmVudFRleHR1cmUgPSB0aGlzLnRleHR1cmVzW19pZDJdO1xuICAgICAgICAgIGlmIChjdXJyZW50VGV4dHVyZSkgZ2wuZGVsZXRlVGV4dHVyZShjdXJyZW50VGV4dHVyZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChcInJlc2l6ZVwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNsZWFyIGFsbCB0aGUgY2FudmFzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgIHRoaXMuZW1pdChcImJlZm9yZUNsZWFyXCIpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcy5iaW5kRnJhbWVidWZmZXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkZSQU1FQlVGRkVSLCBudWxsKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcy5jbGVhcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMuaG92ZXJOb2Rlcy5jbGVhcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzLmxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5ob3ZlcnMuY2xlYXJSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMuZWRnZUxhYmVscy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5lbWl0KFwiYWZ0ZXJDbGVhclwiKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlZnJlc2gsIGkuZS4gZm9yY2UgdGhlIHJlbmRlcmVyIHRvIHJlcHJvY2VzcyBncmFwaFxuICAgICAqIGRhdGEgYW5kIHJlbmRlciwgYnV0IGtlZXAgdGhlIHN0YXRlLlxuICAgICAqIC0gaWYgYSBwYXJ0aWFsR3JhcGggaXMgcHJvdmlkZWQsIHdlIG9ubHkgcmVwcm9jZXNzIHRob3NlIG5vZGVzICYgZWRnZXMuXG4gICAgICogLSBpZiBzY2hlZHVsZSBpcyBUUlVFLCB3ZSBzY2hlZHVsZSBhIHJlbmRlciBpbnN0ZWFkIG9mIHN5bmMgcmVuZGVyXG4gICAgICogLSBpZiBza2lwSW5kZXhhdGlvbiBpcyBUUlVFLCB0aGVuIGxhYmVsR3JpZCAmIHByb2dyYW0gaW5kZXhhdGlvbiBhcmUgc2tpcHBlZCAoY2FuIGJlIHVzZWQgaWYgeW91IGhhdmVuJ3QgbW9kaWZ5IHgsIHksIHpJbmRleCAmIHNpemUpXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlZnJlc2gob3B0cykge1xuICAgICAgdmFyIF90aGlzMTAgPSB0aGlzO1xuICAgICAgdmFyIHNraXBJbmRleGF0aW9uID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbikgIT09IHVuZGVmaW5lZCA/IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbiA6IGZhbHNlO1xuICAgICAgdmFyIHNjaGVkdWxlID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zY2hlZHVsZSkgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NoZWR1bGUgOiBmYWxzZTtcbiAgICAgIHZhciBmdWxsUmVmcmVzaCA9ICFvcHRzIHx8ICFvcHRzLnBhcnRpYWxHcmFwaDtcbiAgICAgIGlmIChmdWxsUmVmcmVzaCkge1xuICAgICAgICAvLyBSZS1pbmRleCBncmFwaCBkYXRhXG4gICAgICAgIHRoaXMuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICB0aGlzLmNsZWFyTm9kZUluZGljZXMoKTtcbiAgICAgICAgdGhpcy5ncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczEwLmFkZE5vZGUobm9kZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmdyYXBoLmZvckVhY2hFZGdlKGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMTAuYWRkRWRnZShlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX29wdHMkcGFydGlhbEdyYXBoLCBfb3B0cyRwYXJ0aWFsR3JhcGgyO1xuICAgICAgICB2YXIgbm9kZXMgPSAoKF9vcHRzJHBhcnRpYWxHcmFwaCA9IG9wdHMucGFydGlhbEdyYXBoKSA9PT0gbnVsbCB8fCBfb3B0cyRwYXJ0aWFsR3JhcGggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHBhcnRpYWxHcmFwaC5ub2RlcykgfHwgW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpIHx8IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB2YXIgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgIC8vIFJlY29tcHV0ZSBub2RlJ3MgZGF0YSAoaWUuIGFwcGx5IHJlZHVjZXIpXG4gICAgICAgICAgdGhpcy51cGRhdGVOb2RlKG5vZGUpO1xuICAgICAgICAgIC8vIEFkZCBub2RlIHRvIHRoZSBwcm9ncmFtIGlmIGxheW91dCBpcyB1bmNoYW5nZWQuXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZG9uZSBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgIGlmIChza2lwSW5kZXhhdGlvbikge1xuICAgICAgICAgICAgdmFyIHByb2dyYW1JbmRleCA9IHRoaXMubm9kZVByb2dyYW1JbmRleFtub2RlXTtcbiAgICAgICAgICAgIGlmIChwcm9ncmFtSW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IG5vZGUgXFxcIlwiLmNvbmNhdChub2RlLCBcIlxcXCIgY2FuJ3QgYmUgcmVwYWludFwiKSk7XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVUb1Byb2dyYW0obm9kZSwgdGhpcy5ub2RlSW5kaWNlc1tub2RlXSwgcHJvZ3JhbUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVkZ2VzID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwIHx8IChfb3B0cyRwYXJ0aWFsR3JhcGgyID0gb3B0cy5wYXJ0aWFsR3JhcGgpID09PSBudWxsIHx8IF9vcHRzJHBhcnRpYWxHcmFwaDIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9vcHRzJHBhcnRpYWxHcmFwaDIuZWRnZXMpIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBfaTQgPSAwLCBfbDQgPSBlZGdlcy5sZW5ndGg7IF9pNCA8IF9sNDsgX2k0KyspIHtcbiAgICAgICAgICB2YXIgZWRnZSA9IGVkZ2VzW19pNF07XG4gICAgICAgICAgLy8gUmVjb21wdXRlIGVkZ2UncyBkYXRhIChpZS4gYXBwbHkgcmVkdWNlcilcbiAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2UoZWRnZSk7XG4gICAgICAgICAgLy8gQWRkIGVkZ2UgdG8gdGhlIHByb2dyYW1cbiAgICAgICAgICAvLyBvdGhlcndpc2UgaXQgd2lsbCBiZSBkb25lIGluIHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICAgICAgaWYgKHNraXBJbmRleGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgX3Byb2dyYW1JbmRleCA9IHRoaXMuZWRnZVByb2dyYW1JbmRleFtlZGdlXTtcbiAgICAgICAgICAgIGlmIChfcHJvZ3JhbUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBlZGdlIFxcXCJcIi5jb25jYXQoZWRnZSwgXCJcXFwiIGNhbid0IGJlIHJlcGFpbnRcIikpO1xuICAgICAgICAgICAgdGhpcy5hZGRFZGdlVG9Qcm9ncmFtKGVkZ2UsIHRoaXMuZWRnZUluZGljZXNbZWRnZV0sIF9wcm9ncmFtSW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEbyB3ZSBuZWVkIHRvIGNhbGwgdGhlIHByb2Nlc3MgZnVuY3Rpb24gP1xuICAgICAgaWYgKGZ1bGxSZWZyZXNoIHx8ICFza2lwSW5kZXhhdGlvbikgdGhpcy5uZWVkVG9Qcm9jZXNzID0gdHJ1ZTtcbiAgICAgIGlmIChzY2hlZHVsZSkgdGhpcy5zY2hlZHVsZVJlbmRlcigpO2Vsc2UgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgcmVuZGVyIGF0IHRoZSBuZXh0IGF2YWlsYWJsZSBmcmFtZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgc2FmZWx5IGNhbGxlZCBvbiBhIHNhbWUgZnJhbWUgYmVjYXVzZSBpdCBiYXNpY2FsbHlcbiAgICAgKiBkZWJvdW5jZXMgcmVmcmVzaCB0byB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlUmVuZGVyKCkge1xuICAgICAgdmFyIF90aGlzMTEgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLnJlbmRlckZyYW1lKSB7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzMTEucmVuZGVyKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gc2NoZWR1bGUgYSByZWZyZXNoIChpLmUuIGZ1bGx5IHJlcHJvY2VzcyBncmFwaCBkYXRhIGFuZCByZW5kZXIpXG4gICAgICogYXQgdGhlIG5leHQgYXZhaWxhYmxlIGZyYW1lLlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBzYWZlbHkgY2FsbGVkIG9uIGEgc2FtZSBmcmFtZSBiZWNhdXNlIGl0IGJhc2ljYWxseVxuICAgICAqIGRlYm91bmNlcyByZWZyZXNoIHRvIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVSZWZyZXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlUmVmcmVzaChvcHRzKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWZyZXNoKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBvcHRzKSwge30sIHtcbiAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byAodW4pem9vbSwgd2hpbGUgcHJlc2VydmluZyB0aGUgcG9zaXRpb24gb2YgYSB2aWV3cG9ydCBwb2ludC5cbiAgICAgKiBVc2VkIGZvciBpbnN0YW5jZSB0byB6b29tIFwib24gdGhlIG1vdXNlIGN1cnNvclwiLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZpZXdwb3J0VGFyZ2V0XG4gICAgICogQHBhcmFtIG5ld1JhdGlvXG4gICAgICogQHJldHVybiB7Q2FtZXJhU3RhdGV9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vmlld3BvcnRab29tZWRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRWaWV3cG9ydFpvb21lZFN0YXRlKHZpZXdwb3J0VGFyZ2V0LCBuZXdSYXRpbykge1xuICAgICAgdmFyIF90aGlzJGNhbWVyYSRnZXRTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCksXG4gICAgICAgIHJhdGlvID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLnJhdGlvLFxuICAgICAgICBhbmdsZSA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS5hbmdsZSxcbiAgICAgICAgeCA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS54LFxuICAgICAgICB5ID0gX3RoaXMkY2FtZXJhJGdldFN0YXRlLnk7XG4gICAgICB2YXIgX3RoaXMkc2V0dGluZ3MyID0gdGhpcy5zZXR0aW5ncyxcbiAgICAgICAgbWluQ2FtZXJhUmF0aW8gPSBfdGhpcyRzZXR0aW5nczIubWluQ2FtZXJhUmF0aW8sXG4gICAgICAgIG1heENhbWVyYVJhdGlvID0gX3RoaXMkc2V0dGluZ3MyLm1heENhbWVyYVJhdGlvO1xuICAgICAgaWYgKHR5cGVvZiBtYXhDYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIikgbmV3UmF0aW8gPSBNYXRoLm1pbihuZXdSYXRpbywgbWF4Q2FtZXJhUmF0aW8pO1xuICAgICAgaWYgKHR5cGVvZiBtaW5DYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIikgbmV3UmF0aW8gPSBNYXRoLm1heChuZXdSYXRpbywgbWluQ2FtZXJhUmF0aW8pO1xuICAgICAgdmFyIHJhdGlvRGlmZiA9IG5ld1JhdGlvIC8gcmF0aW87XG4gICAgICB2YXIgY2VudGVyID0ge1xuICAgICAgICB4OiB0aGlzLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoTW91c2VQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHZpZXdwb3J0VGFyZ2V0KTtcbiAgICAgIHZhciBncmFwaENlbnRlclBvc2l0aW9uID0gdGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgoY2VudGVyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgeDogKGdyYXBoTW91c2VQb3NpdGlvbi54IC0gZ3JhcGhDZW50ZXJQb3NpdGlvbi54KSAqICgxIC0gcmF0aW9EaWZmKSArIHgsXG4gICAgICAgIHk6IChncmFwaE1vdXNlUG9zaXRpb24ueSAtIGdyYXBoQ2VudGVyUG9zaXRpb24ueSkgKiAoMSAtIHJhdGlvRGlmZikgKyB5LFxuICAgICAgICByYXRpbzogbmV3UmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgYWJzdHJhY3QgcmVjdGFuZ2xlIGNvbnRhaW5pbmcgdGhlIGdyYXBoIGFjY29yZGluZ1xuICAgICAqIHRvIHRoZSBjYW1lcmEncyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgdmlldydzIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2aWV3UmVjdGFuZ2xlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdSZWN0YW5nbGUoKSB7XG4gICAgICB2YXIgcDEgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwXG4gICAgICAgIH0pLFxuICAgICAgICBwMiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiB0aGlzLndpZHRoLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfSksXG4gICAgICAgIGggPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiB0aGlzLmhlaWdodFxuICAgICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHgxOiBwMS54LFxuICAgICAgICB5MTogcDEueSxcbiAgICAgICAgeDI6IHAyLngsXG4gICAgICAgIHkyOiBwMi55LFxuICAgICAgICBoZWlnaHQ6IHAyLnkgLSBoLnlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSBmcmFtZWQgZ3JhcGggc3lzdGVtIHRvIHRoZSB2aWV3cG9ydCBzeXN0ZW0uIEl0IGFsbG93c1xuICAgICAqIG92ZXJyaWRpbmcgYW55dGhpbmcgdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgdHJhbnNsYXRpb24gbWF0cml4LCBvciBldmVuIHRoZSBtYXRyaXggaXRzZWxmLlxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBpZiBvdmVycmlkaW5nIGRpbWVuc2lvbnMsIHBhZGRpbmcgb3IgY2FtZXJhU3RhdGUsIGFzIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgbWF0cml4IGlzIG5vdCB0aGUgbGlnaHRlc3RcbiAgICAgKiBvZiBjb21wdXRhdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJhbWVkR3JhcGhUb1ZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyYW1lZEdyYXBoVG9WaWV3cG9ydChjb29yZGluYXRlcykge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZWNvbXB1dGVNYXRyaXggPSAhIW92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8ICEhb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8ICEhb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zO1xuICAgICAgdmFyIG1hdHJpeCA9IG92ZXJyaWRlLm1hdHJpeCA/IG92ZXJyaWRlLm1hdHJpeCA6IHJlY29tcHV0ZU1hdHJpeCA/IG1hdHJpeEZyb21DYW1lcmEob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFN0YWdlUGFkZGluZygpKSA6IHRoaXMubWF0cml4O1xuICAgICAgdmFyIHZpZXdwb3J0UG9zID0gbXVsdGlwbHlWZWMyKG1hdHJpeCwgY29vcmRpbmF0ZXMpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogKDEgKyB2aWV3cG9ydFBvcy54KSAqIHRoaXMud2lkdGggLyAyLFxuICAgICAgICB5OiAoMSAtIHZpZXdwb3J0UG9zLnkpICogdGhpcy5oZWlnaHQgLyAyXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgdmlld3BvcnQgc3lzdGVtIHRvIHRoZSBmcmFtZWQgZ3JhcGggc3lzdGVtLiBJdCBhbGxvd3NcbiAgICAgKiBvdmVycmlkaW5nIGFueXRoaW5nIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCwgb3IgZXZlbiB0aGUgbWF0cml4IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgaWYgb3ZlcnJpZGluZyBkaW1lbnNpb25zLCBwYWRkaW5nIG9yIGNhbWVyYVN0YXRlLCBhcyB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG1hdHJpeCBpcyBub3QgdGhlIGxpZ2h0ZXN0XG4gICAgICogb2YgY29tcHV0YXRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZpZXdwb3J0VG9GcmFtZWRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3cG9ydFRvRnJhbWVkR3JhcGgoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcmVjb21wdXRlTWF0cml4ID0gISFvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCAhIW92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCAhb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zO1xuICAgICAgdmFyIGludk1hdHJpeCA9IG92ZXJyaWRlLm1hdHJpeCA/IG92ZXJyaWRlLm1hdHJpeCA6IHJlY29tcHV0ZU1hdHJpeCA/IG1hdHJpeEZyb21DYW1lcmEob3ZlcnJpZGUuY2FtZXJhU3RhdGUgfHwgdGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSwgb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8IHRoaXMuZ2V0RGltZW5zaW9ucygpLCBvdmVycmlkZS5ncmFwaERpbWVuc2lvbnMgfHwgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUucGFkZGluZyB8fCB0aGlzLmdldFN0YWdlUGFkZGluZygpLCB0cnVlKSA6IHRoaXMuaW52TWF0cml4O1xuICAgICAgdmFyIHJlcyA9IG11bHRpcGx5VmVjMihpbnZNYXRyaXgsIHtcbiAgICAgICAgeDogY29vcmRpbmF0ZXMueCAvIHRoaXMud2lkdGggKiAyIC0gMSxcbiAgICAgICAgeTogMSAtIGNvb3JkaW5hdGVzLnkgLyB0aGlzLmhlaWdodCAqIDJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTmFOKHJlcy54KSkgcmVzLnggPSAwO1xuICAgICAgaWYgKGlzTmFOKHJlcy55KSkgcmVzLnkgPSAwO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlXG4gICAgICogc3RhZ2UpIHRvIHRoZSBncmFwaCBzeXN0ZW0gKHRoZSByZWZlcmVuY2Ugc3lzdGVtIG9mIGRhdGEgYXMgdGhleSBhcmUgaW4gdGhlIGdpdmVuIGdyYXBoIGluc3RhbmNlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIHZpZXdwb3J0UG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRUb0dyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0VG9HcmFwaCh2aWV3cG9ydFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmludmVyc2UodGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgodmlld3BvcnRQb2ludCwgb3ZlcnJpZGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIGdyYXBoIHN5c3RlbSAodGhlIHJlZmVyZW5jZSBzeXN0ZW0gb2YgZGF0YSBhcyB0aGV5IGFyZSBpblxuICAgICAqIHRoZSBnaXZlbiBncmFwaCBpbnN0YW5jZSkgdG8gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlIHN0YWdlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIGdyYXBoUG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhcGhUb1ZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXBoVG9WaWV3cG9ydChncmFwaFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uKGdyYXBoUG9pbnQpLCBvdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZGlzdGFuY2UgbXVsdGlwbGllciBiZXR3ZWVuIHRoZSBncmFwaCBzeXN0ZW0gYW5kIHRoZVxuICAgICAqIHZpZXdwb3J0IHN5c3RlbS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFRvVmlld3BvcnRSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaFRvVmlld3BvcnRSYXRpbygpIHtcbiAgICAgIHZhciBncmFwaFAxID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoUDIgPSB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgZ3JhcGhEID0gTWF0aC5zcXJ0KE1hdGgucG93KGdyYXBoUDEueCAtIGdyYXBoUDIueCwgMikgKyBNYXRoLnBvdyhncmFwaFAxLnkgLSBncmFwaFAyLnksIDIpKTtcbiAgICAgIHZhciB2aWV3cG9ydFAxID0gdGhpcy5ncmFwaFRvVmlld3BvcnQoZ3JhcGhQMSk7XG4gICAgICB2YXIgdmlld3BvcnRQMiA9IHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KGdyYXBoUDIpO1xuICAgICAgdmFyIHZpZXdwb3J0RCA9IE1hdGguc3FydChNYXRoLnBvdyh2aWV3cG9ydFAxLnggLSB2aWV3cG9ydFAyLngsIDIpICsgTWF0aC5wb3codmlld3BvcnRQMS55IC0gdmlld3BvcnRQMi55LCAyKSk7XG4gICAgICByZXR1cm4gdmlld3BvcnREIC8gZ3JhcGhEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7eyB4OiBFeHRlbnQsIHk6IEV4dGVudCB9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVFeHRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBjdXN0b20gYm91bmRpbmcgYm94LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt7IHg6IEV4dGVudCwgeTogRXh0ZW50IH0gfCBudWxsfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEN1c3RvbUJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VzdG9tQkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJCb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94IHdpdGggYSBjdXN0b20gb25lLiBHaXZlIGBudWxsYCBhcyB0aGUgYXJndW1lbnQgdG8gc3RvcCBvdmVycmlkaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VzdG9tQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21CQm94KGN1c3RvbUJCb3gpIHtcbiAgICAgIHRoaXMuY3VzdG9tQkJveCA9IGN1c3RvbUJCb3g7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzaHV0IHRoZSBjb250YWluZXIgJiByZWxlYXNlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvLyBFbWl0dGluZyBcImtpbGxcIiBldmVudHMgc28gdGhhdCBwbHVnaW5zIGFuZCBzdWNoIGNhbiBjbGVhbnVwXG4gICAgICB0aGlzLmVtaXQoXCJraWxsXCIpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgZXZlbnRzXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgY2FtZXJhIGhhbmRsZXJzXG4gICAgICB0aGlzLnVuYmluZENhbWVyYUhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBET00gZXZlbnRzICYgY2FwdG9yc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iua2lsbCgpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5raWxsKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBncmFwaCBoYW5kbGVyc1xuICAgICAgdGhpcy51bmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBjYWNoZSAmIHN0YXRlXG4gICAgICB0aGlzLmNsZWFySW5kaWNlcygpO1xuICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzLmNsZWFyKCk7XG5cbiAgICAgIC8vIENsZWFyaW5nIGZyYW1lc1xuICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXN0cm95aW5nIGNhbnZhc2VzXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAgIC8vIEtpbGwgcHJvZ3JhbXM6XG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zW3R5cGVdLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF90eXBlOCBpbiB0aGlzLm5vZGVIb3ZlclByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbX3R5cGU4XS5raWxsKCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBfdHlwZTkgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5lZGdlUHJvZ3JhbXNbX3R5cGU5XS5raWxsKCk7XG4gICAgICB9XG4gICAgICB0aGlzLm5vZGVQcm9ncmFtcyA9IHt9O1xuICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtcyA9IHt9O1xuICAgICAgdGhpcy5lZGdlUHJvZ3JhbXMgPSB7fTtcblxuICAgICAgLy8gS2lsbCBhbGwgY2FudmFzL1dlYkdMIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMua2lsbExheWVyKGlkKTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVzdHJveWluZyByZW1haW5pbmcgY29sbGVjdGlvbnNcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMgPSB7fTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cyA9IHt9O1xuICAgICAgdGhpcy5lbGVtZW50cyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjYWxlIHRoZSBnaXZlbiBzaXplIGFjY29yZGluZyB0byB0aGUgY2FtZXJhJ3MgcmF0aW8sIGkuZS5cbiAgICAgKiB6b29taW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyP30gc2l6ZSAtICAgICAgICBUaGUgc2l6ZSB0byBzY2FsZSAobm9kZSBzaXplLCBlZGdlIHRoaWNrbmVzcyBldGMuKS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXI/fSBjYW1lcmFSYXRpbyAtIEEgY2FtZXJhIHJhdGlvIChkZWZhdWx0cyB0byB0aGUgYWN0dWFsIGNhbWVyYSByYXRpbykuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgLSBUaGUgc2NhbGVkIHNpemUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlU2l6ZSgpIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgdmFyIGNhbWVyYVJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmNhbWVyYS5yYXRpbztcbiAgICAgIHJldHVybiBzaXplIC8gdGhpcy5zZXR0aW5ncy56b29tVG9TaXplUmF0aW9GdW5jdGlvbihjYW1lcmFSYXRpbykgKiAodGhpcy5nZXRTZXR0aW5nKFwiaXRlbVNpemVzUmVmZXJlbmNlXCIpID09PSBcInBvc2l0aW9uc1wiID8gY2FtZXJhUmF0aW8gKiB0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvIDogMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgdXNlZCBjYW52YXNlcy5cbiAgICAgKiBBdCB0aGUgbW9tZW50LCB0aGUgaW5zdGFudGlhdGVkIGNhbnZhc2VzIGFyZSB0aGUgZm9sbG93aW5nLCBhbmQgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIG9yZGVyIGluIHRoZSBET006XG4gICAgICogLSBgZWRnZXNgXG4gICAgICogLSBgbm9kZXNgXG4gICAgICogLSBgZWRnZUxhYmVsc2BcbiAgICAgKiAtIGBsYWJlbHNgXG4gICAgICogLSBgaG92ZXJzYFxuICAgICAqIC0gYGhvdmVyTm9kZXNgXG4gICAgICogLSBgbW91c2VgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQbGFpbk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD59IC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FudmFzZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FudmFzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FudmFzZXMoKSB7XG4gICAgICB2YXIgcmVzID0ge307XG4gICAgICBmb3IgKHZhciBsYXllciBpbiB0aGlzLmVsZW1lbnRzKSBpZiAodGhpcy5lbGVtZW50c1tsYXllcl0gaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkgcmVzW2xheWVyXSA9IHRoaXMuZWxlbWVudHNbbGF5ZXJdO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gIH1dKTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIFNpZ21hLmpzIExpYnJhcnkgRW5kcG9pbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlicmFyeSBlbmRwb2ludC5cbiAqIEBtb2R1bGVcbiAqL1xudmFyIFNpZ21hID0gU2lnbWEkMTtcblxuZXhwb3J0IHsgQ2FtZXJhLCBNb3VzZUNhcHRvciwgU2lnbWEkMSBhcyBTaWdtYSwgVG91Y2hDYXB0b3IsIFNpZ21hIGFzIGRlZmF1bHQgfTtcbiIsImltcG9ydCB7IGYgYXMgTm9kZVByb2dyYW0sIEQgYXMgREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TLCBfIGFzIF9vYmplY3RTcHJlYWQyLCBGIGFzIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMywgZyBhcyBFZGdlUHJvZ3JhbSwgaCBhcyBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtLCBpIGFzIGNyZWF0ZUVkZ2VBcnJvd0hlYWRQcm9ncmFtIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmRleC0yMzZjNjJhZC5lc20uanMnO1xuZXhwb3J0IHsgayBhcyBBYnN0cmFjdEVkZ2VQcm9ncmFtLCBBIGFzIEFic3RyYWN0Tm9kZVByb2dyYW0sIGwgYXMgQWJzdHJhY3RQcm9ncmFtLCBEIGFzIERFRkFVTFRfRURHRV9BUlJPV19IRUFEX1BST0dSQU1fT1BUSU9OUywgcCBhcyBERUZBVUxUX0VER0VfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMsIG0gYXMgRWRnZUFycm93SGVhZFByb2dyYW0sIEUgYXMgRWRnZUFycm93UHJvZ3JhbSwgbiBhcyBFZGdlQ2xhbXBlZFByb2dyYW0sIGcgYXMgRWRnZVByb2dyYW0sIGUgYXMgRWRnZVJlY3RhbmdsZVByb2dyYW0sIE4gYXMgTm9kZUNpcmNsZVByb2dyYW0sIGYgYXMgTm9kZVByb2dyYW0sIFAgYXMgUHJvZ3JhbSwgaSBhcyBjcmVhdGVFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgcSBhcyBjcmVhdGVFZGdlQXJyb3dQcm9ncmFtLCBvIGFzIGNyZWF0ZUVkZ2VDbGFtcGVkUHJvZ3JhbSwgaCBhcyBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtLCBqIGFzIGNyZWF0ZU5vZGVDb21wb3VuZFByb2dyYW0sIGMgYXMgZHJhd0Rpc2NOb2RlSG92ZXIsIGIgYXMgZHJhd0Rpc2NOb2RlTGFiZWwsIGQgYXMgZHJhd1N0cmFpZ2h0RWRnZUxhYmVsLCByIGFzIGdldEF0dHJpYnV0ZUl0ZW1zQ291bnQsIHMgYXMgZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQsIHcgYXMga2lsbFByb2dyYW0sIHUgYXMgbG9hZEZyYWdtZW50U2hhZGVyLCB2IGFzIGxvYWRQcm9ncmFtLCB0IGFzIGxvYWRWZXJ0ZXhTaGFkZXIsIHggYXMgbnVtYmVyVG9HTFNMRmxvYXQgfSBmcm9tICcuLi8uLi9kaXN0L2luZGV4LTIzNmM2MmFkLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9pbmhlcml0cywgYSBhcyBfY3JlYXRlQ2xhc3MsIGIgYXMgX2NsYXNzQ2FsbENoZWNrLCBjIGFzIF9jYWxsU3VwZXIgfSBmcm9tICcuLi8uLi9kaXN0L2luaGVyaXRzLWQxYTFlMjliLmVzbS5qcyc7XG5pbXBvcnQgeyBmIGFzIGZsb2F0Q29sb3IgfSBmcm9tICcuLi8uLi9kaXN0L2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ2ID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9ib3JkZXI7XFxuXFxuY29uc3QgZmxvYXQgcmFkaXVzID0gMC41O1xcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTtcXG4gIGZsb2F0IGRpc3QgPSByYWRpdXMgLSBsZW5ndGgobSk7XFxuXFxuICAvLyBObyBhbnRpYWxpYXNpbmcgZm9yIHBpY2tpbmcgbW9kZTpcXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIGlmIChkaXN0ID4gdl9ib3JkZXIpXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuICBlbHNlXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRyYW5zcGFyZW50O1xcblxcbiAgI2Vsc2VcXG4gIGZsb2F0IHQgPSAwLjA7XFxuICBpZiAoZGlzdCA+IHZfYm9yZGVyKVxcbiAgICB0ID0gMS4wO1xcbiAgZWxzZSBpZiAoZGlzdCA+IDAuMClcXG4gICAgdCA9IGRpc3QgLyB2X2JvcmRlcjtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh0cmFuc3BhcmVudCwgdl9jb2xvciwgdCk7XFxuICAjZW5kaWZcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQ2O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ1ID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuXFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X2JvcmRlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5LFxcbiAgICAwLFxcbiAgICAxXFxuICApO1xcblxcbiAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XFxuICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcXG4gIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxcbiAgZ2xfUG9pbnRTaXplID0gYV9zaXplIC8gdV9zaXplUmF0aW8gKiB1X3BpeGVsUmF0aW8gKiAyLjA7XFxuXFxuICB2X2JvcmRlciA9ICgwLjUgLyBhX3NpemUpICogdV9zaXplUmF0aW87XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMyA9IFNIQURFUl9TT1VSQ0UkNTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFJDMgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMy5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCQzID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMuRkxPQVQ7XG52YXIgVU5JRk9STVMkMyA9IFtcInVfc2l6ZVJhdGlvXCIsIFwidV9waXhlbFJhdGlvXCIsIFwidV9tYXRyaXhcIl07XG52YXIgTm9kZVBvaW50UHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVQcm9ncmFtKSB7XG4gIGZ1bmN0aW9uIE5vZGVQb2ludFByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVQb2ludFByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE5vZGVQb2ludFByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2luaGVyaXRzKE5vZGVQb2ludFByb2dyYW0sIF9Ob2RlUHJvZ3JhbSk7XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoTm9kZVBvaW50UHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDEsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQzLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlBPSU5UUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDMsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfc2l6ZVwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShub2RlSW5kZXgsIHN0YXJ0SW5kZXgsIGRhdGEpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS54O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEueTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnNpemU7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBub2RlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKF9yZWYsIF9yZWYyKSB7XG4gICAgICB2YXIgc2l6ZVJhdGlvID0gX3JlZi5zaXplUmF0aW8sXG4gICAgICAgIHBpeGVsUmF0aW8gPSBfcmVmLnBpeGVsUmF0aW8sXG4gICAgICAgIG1hdHJpeCA9IF9yZWYubWF0cml4O1xuICAgICAgdmFyIGdsID0gX3JlZjIuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmMi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9waXhlbFJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sXG4gICAgICAgIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeDtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3BpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBzaXplUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIG1hdHJpeCk7XG4gICAgfVxuICB9XSk7XG59KE5vZGVQcm9ncmFtKTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkNCA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfbm9ybWFsQ29lZjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uU3RhcnQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbkVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9wb3NpdGlvbkNvZWY7XFxuYXR0cmlidXRlIGZsb2F0IGFfc291cmNlUmFkaXVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3RhcmdldFJhZGl1cztcXG5hdHRyaWJ1dGUgZmxvYXQgYV9zb3VyY2VSYWRpdXNDb2VmO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3RhcmdldFJhZGl1c0NvZWY7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9taW5FZGdlVGhpY2tuZXNzO1xcbnVuaWZvcm0gZmxvYXQgdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9mZWF0aGVyO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcbnZhcnlpbmcgZmxvYXQgdl9mZWF0aGVyO1xcblxcbmNvbnN0IGZsb2F0IGJpYXMgPSAyNTUuMCAvIDI1NC4wO1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IG1pblRoaWNrbmVzcyA9IHVfbWluRWRnZVRoaWNrbmVzcztcXG5cXG4gIHZlYzIgbm9ybWFsID0gYV9ub3JtYWwgKiBhX25vcm1hbENvZWY7XFxuICB2ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvblN0YXJ0ICogKDEuMCAtIGFfcG9zaXRpb25Db2VmKSArIGFfcG9zaXRpb25FbmQgKiBhX3Bvc2l0aW9uQ29lZjtcXG5cXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0b1xcbiAgLy8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3MgaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zaXplUmF0aW8pO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgLy8gSGVyZSwgd2UgbW92ZSB0aGUgcG9pbnQgdG8gbGVhdmUgc3BhY2UgZm9yIHRoZSBhcnJvdyBoZWFkczpcXG4gIC8vIFNvdXJjZSBhcnJvdyBoZWFkXFxuICBmbG9hdCBzb3VyY2VSYWRpdXMgPSBhX3NvdXJjZVJhZGl1cyAqIGFfc291cmNlUmFkaXVzQ29lZjtcXG4gIGZsb2F0IHNvdXJjZURpcmVjdGlvbiA9IHNpZ24oc291cmNlUmFkaXVzKTtcXG4gIGZsb2F0IHdlYkdMU291cmNlUmFkaXVzID0gc291cmNlRGlyZWN0aW9uICogc291cmNlUmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMU291cmNlQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gKiAyLjA7XFxuICB2ZWMyIHNvdXJjZUNvbXBlbnNhdGlvblZlY3RvciA9XFxuICAgIHZlYzIoLXNvdXJjZURpcmVjdGlvbiAqIHVuaXROb3JtYWwueSwgc291cmNlRGlyZWN0aW9uICogdW5pdE5vcm1hbC54KVxcbiAgICAqICh3ZWJHTFNvdXJjZVJhZGl1cyArIHdlYkdMU291cmNlQXJyb3dIZWFkTGVuZ3RoKTtcXG4gICAgXFxuICAvLyBUYXJnZXQgYXJyb3cgaGVhZFxcbiAgZmxvYXQgdGFyZ2V0UmFkaXVzID0gYV90YXJnZXRSYWRpdXMgKiBhX3RhcmdldFJhZGl1c0NvZWY7XFxuICBmbG9hdCB0YXJnZXREaXJlY3Rpb24gPSBzaWduKHRhcmdldFJhZGl1cyk7XFxuICBmbG9hdCB3ZWJHTFRhcmdldFJhZGl1cyA9IHRhcmdldERpcmVjdGlvbiAqIHRhcmdldFJhZGl1cyAqIDIuMCAqIHVfY29ycmVjdGlvblJhdGlvIC8gdV9zaXplUmF0aW87XFxuICBmbG9hdCB3ZWJHTFRhcmdldEFycm93SGVhZExlbmd0aCA9IHdlYkdMVGhpY2tuZXNzICogdV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvICogMi4wO1xcbiAgdmVjMiB0YXJnZXRDb21wZW5zYXRpb25WZWN0b3IgPVxcbiAgdmVjMigtdGFyZ2V0RGlyZWN0aW9uICogdW5pdE5vcm1hbC55LCB0YXJnZXREaXJlY3Rpb24gKiB1bml0Tm9ybWFsLngpXFxuICAgICogKHdlYkdMVGFyZ2V0UmFkaXVzICsgd2ViR0xUYXJnZXRBcnJvd0hlYWRMZW5ndGgpO1xcblxcbiAgLy8gSGVyZSBpcyB0aGUgcHJvcGVyIHBvc2l0aW9uIG9mIHRoZSB2ZXJ0ZXhcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzICsgc291cmNlQ29tcGVuc2F0aW9uVmVjdG9yICsgdGFyZ2V0Q29tcGVuc2F0aW9uVmVjdG9yLCAxKSkueHksIDAsIDEpO1xcblxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfem9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcblxcbiAgdl9mZWF0aGVyID0gdV9mZWF0aGVyICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3pvb21SYXRpbyAvIHVfcGl4ZWxSYXRpbyAqIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQ0O1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMiA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDIgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMi5GTE9BVDtcbnZhciBVTklGT1JNUyQyID0gW1widV9tYXRyaXhcIiwgXCJ1X3pvb21SYXRpb1wiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIiwgXCJ1X3BpeGVsUmF0aW9cIiwgXCJ1X2ZlYXRoZXJcIiwgXCJ1X21pbkVkZ2VUaGlja25lc3NcIiwgXCJ1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW9cIl07XG52YXIgREVGQVVMVF9FREdFX0RPVUJMRV9DTEFNUEVEX1BST0dSQU1fT1BUSU9OUyA9IHtcbiAgbGVuZ3RoVG9UaGlja25lc3NSYXRpbzogREVGQVVMVF9FREdFX0FSUk9XX0hFQURfUFJPR1JBTV9PUFRJT05TLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW9cbn07XG5mdW5jdGlvbiBjcmVhdGVFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfRURHRV9ET1VCTEVfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMpLCBpbnB1dE9wdGlvbnMgfHwge30pO1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgICBmdW5jdGlvbiBFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW0oKSB7XG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZURvdWJsZUNsYW1wZWRQcm9ncmFtKTtcbiAgICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VEb3VibGVDbGFtcGVkUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgX2luaGVyaXRzKEVkZ2VEb3VibGVDbGFtcGVkUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VEb3VibGVDbGFtcGVkUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBWRVJUSUNFUzogNixcbiAgICAgICAgICBWRVJURVhfU0hBREVSX1NPVVJDRTogVkVSVEVYX1NIQURFUl9TT1VSQ0UkMixcbiAgICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDMsXG4gICAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyQyLFxuICAgICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25TdGFydFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25FbmRcIixcbiAgICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX25vcm1hbFwiLFxuICAgICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDIsXG4gICAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQyLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV9zb3VyY2VSYWRpdXNcIixcbiAgICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX3RhcmdldFJhZGl1c1wiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAgIC8vIElmIDEsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uRW5kXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfc291cmNlUmFkaXVzQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfdGFyZ2V0UmFkaXVzQ29lZlwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9EQVRBOiBbWzAsIDEsIC0xLCAwXSwgWzAsIC0xLCAxLCAwXSwgWzEsIDEsIDAsIDFdLCBbMSwgMSwgMCwgMV0sIFswLCAtMSwgMSwgMF0sIFsxLCAtMSwgMCwgLTFdXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICAgIHZhciBzb3VyY2VSYWRpdXMgPSBzb3VyY2VEYXRhLnNpemUgfHwgMTtcbiAgICAgICAgdmFyIHRhcmdldFJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICAgIHZhciBuMSA9IDA7XG4gICAgICAgIHZhciBuMiA9IDA7XG4gICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG4yO1xuICAgICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBzb3VyY2VSYWRpdXM7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB0YXJnZXRSYWRpdXM7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgICB1X3pvb21SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV96b29tUmF0aW8sXG4gICAgICAgICAgdV9mZWF0aGVyID0gdW5pZm9ybUxvY2F0aW9ucy51X2ZlYXRoZXIsXG4gICAgICAgICAgdV9waXhlbFJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3BpeGVsUmF0aW8sXG4gICAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcyxcbiAgICAgICAgICB1X2xlbmd0aFRvVGhpY2tuZXNzUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfbGVuZ3RoVG9UaGlja25lc3NSYXRpbztcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV96b29tUmF0aW8sIHBhcmFtcy56b29tUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9waXhlbFJhdGlvLCBwYXJhbXMucGl4ZWxSYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2ZlYXRoZXIsIHBhcmFtcy5hbnRpQWxpYXNpbmdGZWF0aGVyKTtcbiAgICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9sZW5ndGhUb1RoaWNrbmVzc1JhdGlvLCBvcHRpb25zLmxlbmd0aFRvVGhpY2tuZXNzUmF0aW8pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgfShFZGdlUHJvZ3JhbSk7XG59XG52YXIgRWRnZURvdWJsZUNsYW1wZWRQcm9ncmFtID0gY3JlYXRlRWRnZURvdWJsZUNsYW1wZWRQcm9ncmFtKCk7XG52YXIgRWRnZURvdWJsZUNsYW1wZWRQcm9ncmFtJDEgPSBFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW07XG5cbmZ1bmN0aW9uIGNyZWF0ZUVkZ2VEb3VibGVBcnJvd1Byb2dyYW0oaW5wdXRPcHRpb25zKSB7XG4gIHJldHVybiBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKFtjcmVhdGVFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW0oaW5wdXRPcHRpb25zKSwgY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oaW5wdXRPcHRpb25zKSwgY3JlYXRlRWRnZUFycm93SGVhZFByb2dyYW0oX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGlucHV0T3B0aW9ucyksIHt9LCB7XG4gICAgZXh0cmVtaXR5OiBcInNvdXJjZVwiXG4gIH0pKV0pO1xufVxudmFyIEVkZ2VEb3VibGVBcnJvd1Byb2dyYW0gPSBjcmVhdGVFZGdlRG91YmxlQXJyb3dQcm9ncmFtKCk7XG52YXIgRWRnZURvdWJsZUFycm93UHJvZ3JhbSQxID0gRWRnZURvdWJsZUFycm93UHJvZ3JhbTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkMyA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQzO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQyID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KFxcbiAgICAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSxcXG4gICAgMCxcXG4gICAgMVxcbiAgKTtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQyO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDEgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMS5GTE9BVDtcbnZhciBVTklGT1JNUyQxID0gW1widV9tYXRyaXhcIl07XG52YXIgRWRnZUxpbmVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgZnVuY3Rpb24gRWRnZUxpbmVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlTGluZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VMaW5lUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRWRnZUxpbmVQcm9ncmFtLCBfRWRnZVByb2dyYW0pO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEVkZ2VMaW5lUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDIsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQxLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LkxJTkVTLFxuICAgICAgICBVTklGT1JNUzogVU5JRk9STVMkMSxcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25cIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcblxuICAgICAgLy8gRmlyc3QgcG9pbnRcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG5cbiAgICAgIC8vIFNlY29uZCBwb2ludFxuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeDtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICB9XG4gIH1dKTtcbn0oRWRnZVByb2dyYW0pO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQxID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRSQxO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfbm9ybWFsQ29lZjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uU3RhcnQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbkVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9wb3NpdGlvbkNvZWY7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBtaW5UaGlja25lc3MgPSAxLjc7XFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBub3JtYWwgPSBhX25vcm1hbCAqIGFfbm9ybWFsQ29lZjtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uU3RhcnQgKiAoMS4wIC0gYV9wb3NpdGlvbkNvZWYpICsgYV9wb3NpdGlvbkVuZCAqIGFfcG9zaXRpb25Db2VmO1xcblxcbiAgLy8gVGhlIG9ubHkgZGlmZmVyZW50IGhlcmUgd2l0aCBlZGdlLnZlcnQuZ2xzbCBpcyB0aGF0IHdlIG5lZWQgdG8gaGFuZGxlIG51bGxcXG4gIC8vIGlucHV0IG5vcm1hbCB2ZWN0b3IuIEFwYXJ0IGZyb20gdGhhdCwgeW91IGNhbiByZWFkIGVkZ2UudmVydC5nbHNsIG1vcmUgaW5mb1xcbiAgLy8gb24gaG93IGl0IHdvcmtzOlxcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKG5vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuICBpZiAobm9ybWFsTGVuZ3RoIDw9IDAuMCkgdW5pdE5vcm1hbCA9IG5vcm1hbDtcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG5cXG4gIGdsX1Bvc2l0aW9uID0gdmVjNCgodV9tYXRyaXggKiB2ZWMzKHBvc2l0aW9uICsgdW5pdE5vcm1hbCAqIHdlYkdMVGhpY2tuZXNzLCAxKSkueHksIDAsIDEpO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRTtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleC5GTE9BVDtcbnZhciBVTklGT1JNUyA9IFtcInVfbWF0cml4XCIsIFwidV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfbWluRWRnZVRoaWNrbmVzc1wiXTtcbnZhciBFZGdlVHJpYW5nbGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgZnVuY3Rpb24gRWRnZVRyaWFuZ2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZVRyaWFuZ2xlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfaW5oZXJpdHMoRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFZGdlVHJpYW5nbGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogMyxcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFLFxuICAgICAgICBNRVRIT0Q6IFdlYkdMUmVuZGVyaW5nQ29udGV4dC5UUklBTkdMRVMsXG4gICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyxcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25TdGFydFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkVuZFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFtcbiAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAvLyBJZiAxLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvbkVuZFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxDb2VmXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfREFUQTogW1swLCAxXSwgWzAsIC0xXSwgWzEsIDBdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIHZhciBuMSA9IDA7XG4gICAgICB2YXIgbjIgPSAwO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICBuMiA9IGR4ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcblxuICAgICAgLy8gRmlyc3QgcG9pbnRcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZikge1xuICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgIHZhciB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X21pbkVkZ2VUaGlja25lc3MgPSB1bmlmb3JtTG9jYXRpb25zLnVfbWluRWRnZVRoaWNrbmVzcztcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfbWluRWRnZVRoaWNrbmVzcywgcGFyYW1zLm1pbkVkZ2VUaGlja25lc3MpO1xuICAgIH1cbiAgfV0pO1xufShFZGdlUHJvZ3JhbSk7XG5cbmV4cG9ydCB7IERFRkFVTFRfRURHRV9ET1VCTEVfQ0xBTVBFRF9QUk9HUkFNX09QVElPTlMsIEVkZ2VEb3VibGVBcnJvd1Byb2dyYW0kMSBhcyBFZGdlRG91YmxlQXJyb3dQcm9ncmFtLCBFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW0kMSBhcyBFZGdlRG91YmxlQ2xhbXBlZFByb2dyYW0sIEVkZ2VMaW5lUHJvZ3JhbSwgRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgTm9kZVBvaW50UHJvZ3JhbSwgY3JlYXRlRWRnZURvdWJsZUFycm93UHJvZ3JhbSwgY3JlYXRlRWRnZURvdWJsZUNsYW1wZWRQcm9ncmFtIH07XG4iLCJpbXBvcnQgeyBkIGFzIGRyYXdTdHJhaWdodEVkZ2VMYWJlbCwgYiBhcyBkcmF3RGlzY05vZGVMYWJlbCwgYyBhcyBkcmF3RGlzY05vZGVIb3ZlciwgTiBhcyBOb2RlQ2lyY2xlUHJvZ3JhbSwgRSBhcyBFZGdlQXJyb3dQcm9ncmFtLCBlIGFzIEVkZ2VSZWN0YW5nbGVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmRleC0yMzZjNjJhZC5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuLi8uLi9kaXN0L2RhdGEtMTFkZjcxMjQuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9pbmhlcml0cy1kMWExZTI5Yi5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuXG4vKipcbiAqIFNpZ21hLmpzIFNldHRpbmdzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlzdCBvZiBzZXR0aW5ncyBhbmQgc29tZSBoYW5keSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBTaWdtYS5qcyBzZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxudmFyIERFRkFVTFRfU0VUVElOR1MgPSB7XG4gIC8vIFBlcmZvcm1hbmNlXG4gIGhpZGVFZGdlc09uTW92ZTogZmFsc2UsXG4gIGhpZGVMYWJlbHNPbk1vdmU6IGZhbHNlLFxuICByZW5kZXJMYWJlbHM6IHRydWUsXG4gIHJlbmRlckVkZ2VMYWJlbHM6IGZhbHNlLFxuICBlbmFibGVFZGdlRXZlbnRzOiBmYWxzZSxcbiAgLy8gQ29tcG9uZW50IHJlbmRlcmluZ1xuICBkZWZhdWx0Tm9kZUNvbG9yOiBcIiM5OTlcIixcbiAgZGVmYXVsdE5vZGVUeXBlOiBcImNpcmNsZVwiLFxuICBkZWZhdWx0RWRnZUNvbG9yOiBcIiNjY2NcIixcbiAgZGVmYXVsdEVkZ2VUeXBlOiBcImxpbmVcIixcbiAgbGFiZWxGb250OiBcIkFyaWFsXCIsXG4gIGxhYmVsU2l6ZTogMTQsXG4gIGxhYmVsV2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsYWJlbENvbG9yOiB7XG4gICAgY29sb3I6IFwiIzAwMFwiXG4gIH0sXG4gIGVkZ2VMYWJlbEZvbnQ6IFwiQXJpYWxcIixcbiAgZWRnZUxhYmVsU2l6ZTogMTQsXG4gIGVkZ2VMYWJlbFdlaWdodDogXCJub3JtYWxcIixcbiAgZWRnZUxhYmVsQ29sb3I6IHtcbiAgICBhdHRyaWJ1dGU6IFwiY29sb3JcIlxuICB9LFxuICBzdGFnZVBhZGRpbmc6IDMwLFxuICBkZWZhdWx0RHJhd0VkZ2VMYWJlbDogZHJhd1N0cmFpZ2h0RWRnZUxhYmVsLFxuICBkZWZhdWx0RHJhd05vZGVMYWJlbDogZHJhd0Rpc2NOb2RlTGFiZWwsXG4gIGRlZmF1bHREcmF3Tm9kZUhvdmVyOiBkcmF3RGlzY05vZGVIb3ZlcixcbiAgbWluRWRnZVRoaWNrbmVzczogMS43LFxuICBhbnRpQWxpYXNpbmdGZWF0aGVyOiAxLFxuICAvLyBNb3VzZSBhbmQgdG91Y2ggc2V0dGluZ3NcbiAgZHJhZ1RpbWVvdXQ6IDEwMCxcbiAgZHJhZ2dlZEV2ZW50c1RvbGVyYW5jZTogMyxcbiAgaW5lcnRpYUR1cmF0aW9uOiAyMDAsXG4gIGluZXJ0aWFSYXRpbzogMyxcbiAgem9vbUR1cmF0aW9uOiAyNTAsXG4gIHpvb21pbmdSYXRpbzogMS43LFxuICBkb3VibGVDbGlja1RpbWVvdXQ6IDMwMCxcbiAgZG91YmxlQ2xpY2tab29taW5nUmF0aW86IDIuMixcbiAgZG91YmxlQ2xpY2tab29taW5nRHVyYXRpb246IDIwMCxcbiAgdGFwTW92ZVRvbGVyYW5jZTogMTAsXG4gIC8vIFNpemUgYW5kIHNjYWxpbmdcbiAgem9vbVRvU2l6ZVJhdGlvRnVuY3Rpb246IE1hdGguc3FydCxcbiAgaXRlbVNpemVzUmVmZXJlbmNlOiBcInNjcmVlblwiLFxuICBhdXRvUmVzY2FsZTogdHJ1ZSxcbiAgYXV0b0NlbnRlcjogdHJ1ZSxcbiAgLy8gTGFiZWxzXG4gIGxhYmVsRGVuc2l0eTogMSxcbiAgbGFiZWxHcmlkQ2VsbFNpemU6IDEwMCxcbiAgbGFiZWxSZW5kZXJlZFNpemVUaHJlc2hvbGQ6IDYsXG4gIC8vIFJlZHVjZXJzXG4gIG5vZGVSZWR1Y2VyOiBudWxsLFxuICBlZGdlUmVkdWNlcjogbnVsbCxcbiAgLy8gRmVhdHVyZXNcbiAgekluZGV4OiBmYWxzZSxcbiAgbWluQ2FtZXJhUmF0aW86IG51bGwsXG4gIG1heENhbWVyYVJhdGlvOiBudWxsLFxuICBlbmFibGVDYW1lcmFab29taW5nOiB0cnVlLFxuICBlbmFibGVDYW1lcmFQYW5uaW5nOiB0cnVlLFxuICBlbmFibGVDYW1lcmFSb3RhdGlvbjogdHJ1ZSxcbiAgY2FtZXJhUGFuQm91bmRhcmllczogbnVsbCxcbiAgLy8gTGlmZWN5Y2xlXG4gIGFsbG93SW52YWxpZENvbnRhaW5lcjogZmFsc2UsXG4gIC8vIFByb2dyYW0gY2xhc3Nlc1xuICBub2RlUHJvZ3JhbUNsYXNzZXM6IHt9LFxuICBub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlczoge30sXG4gIGVkZ2VQcm9ncmFtQ2xhc3Nlczoge31cbn07XG52YXIgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUyA9IHtcbiAgY2lyY2xlOiBOb2RlQ2lyY2xlUHJvZ3JhbVxufTtcbnZhciBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTID0ge1xuICBhcnJvdzogRWRnZUFycm93UHJvZ3JhbSxcbiAgbGluZTogRWRnZVJlY3RhbmdsZVByb2dyYW1cbn07XG5mdW5jdGlvbiB2YWxpZGF0ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ3MubGFiZWxEZW5zaXR5ICE9PSBcIm51bWJlclwiIHx8IHNldHRpbmdzLmxhYmVsRGVuc2l0eSA8IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXR0aW5nczogaW52YWxpZCBgbGFiZWxEZW5zaXR5YC4gRXhwZWN0aW5nIGEgcG9zaXRpdmUgbnVtYmVyLlwiKTtcbiAgfVxuICB2YXIgbWluQ2FtZXJhUmF0aW8gPSBzZXR0aW5ncy5taW5DYW1lcmFSYXRpbyxcbiAgICBtYXhDYW1lcmFSYXRpbyA9IHNldHRpbmdzLm1heENhbWVyYVJhdGlvO1xuICBpZiAodHlwZW9mIG1pbkNhbWVyYVJhdGlvID09PSBcIm51bWJlclwiICYmIHR5cGVvZiBtYXhDYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIiAmJiBtYXhDYW1lcmFSYXRpbyA8IG1pbkNhbWVyYVJhdGlvKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgY2FtZXJhIHJhdGlvIGJvdW5kYXJpZXMuIEV4cGVjdGluZyBgbWF4Q2FtZXJhUmF0aW9gIHRvIGJlIGdyZWF0ZXIgdGhhbiBgbWluQ2FtZXJhUmF0aW9gLlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIHZhciByZXNvbHZlZFNldHRpbmdzID0gYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBzZXR0aW5ncyk7XG4gIHJlc29sdmVkU2V0dGluZ3Mubm9kZVByb2dyYW1DbGFzc2VzID0gYXNzaWduKHt9LCBERUZBVUxUX05PREVfUFJPR1JBTV9DTEFTU0VTLCByZXNvbHZlZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcyk7XG4gIHJlc29sdmVkU2V0dGluZ3MuZWRnZVByb2dyYW1DbGFzc2VzID0gYXNzaWduKHt9LCBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTLCByZXNvbHZlZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcyk7XG4gIHJldHVybiByZXNvbHZlZFNldHRpbmdzO1xufVxuXG5leHBvcnQgeyBERUZBVUxUX0VER0VfUFJPR1JBTV9DTEFTU0VTLCBERUZBVUxUX05PREVfUFJPR1JBTV9DTEFTU0VTLCBERUZBVUxUX1NFVFRJTkdTLCByZXNvbHZlU2V0dGluZ3MsIHZhbGlkYXRlU2V0dGluZ3MgfTtcbiIsImltcG9ydCB7IF8gYXMgX2luaGVyaXRzLCBhIGFzIF9jcmVhdGVDbGFzcywgYiBhcyBfY2xhc3NDYWxsQ2hlY2ssIGMgYXMgX2NhbGxTdXBlciB9IGZyb20gJy4uLy4uL2Rpc3QvaW5oZXJpdHMtZDFhMWUyOWIuZXNtLmpzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5cbi8qKlxuICogVXRpbCB0eXBlIHRvIHJlcHJlc2VudCBtYXBzIG9mIHR5cGVkIGVsZW1lbnRzLCBidXQgaW1wbGVtZW50ZWQgd2l0aFxuICogSmF2YVNjcmlwdCBvYmplY3RzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIFJldHVybnMgYSB0eXBlIHNpbWlsYXIgdG8gVCwgYnV0IHdpdGggdGhlIEsgc2V0IG9mIHByb3BlcnRpZXMgb2YgdGhlIHR5cGVcbiAqIFQgKnJlcXVpcmVkKiwgYW5kIHRoZSByZXN0IG9wdGlvbmFsLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuXG4vKipcbiAqIFJldHVybnMgYSB0eXBlIHNpbWlsYXIgdG8gUGFydGlhbDxUPiwgYnV0IHdpdGggYXQgbGVhc3Qgb25lIGtleSBzZXQuXG4gKi9cblxuLyoqXG4gKiBDdXN0b20gZXZlbnQgZW1pdHRlciB0eXBlcy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcblxudmFyIFR5cGVkRXZlbnRFbWl0dGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIGZ1bmN0aW9uIFR5cGVkRXZlbnRFbWl0dGVyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHlwZWRFdmVudEVtaXR0ZXIpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUeXBlZEV2ZW50RW1pdHRlcik7XG4gICAgX3RoaXMucmF3RW1pdHRlciA9IF90aGlzO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfaW5oZXJpdHMoVHlwZWRFdmVudEVtaXR0ZXIsIF9yZWYpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFR5cGVkRXZlbnRFbWl0dGVyKTtcbn0oRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuXG4vKipcbiAqIEV4cG9ydCB2YXJpb3VzIG90aGVyIHR5cGVzOlxuICovXG5cbmV4cG9ydCB7IFR5cGVkRXZlbnRFbWl0dGVyIH07XG4iLCJleHBvcnQgeyBBIGFzIEFOSU1BVEVfREVGQVVMVFMsIGggYXMgYW5pbWF0ZU5vZGVzLCBiIGFzIGNyZWF0ZUVsZW1lbnQsIGMgYXMgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uLCBvIGFzIGN1YmljSW4sIHIgYXMgY3ViaWNJbk91dCwgcCBhcyBjdWJpY091dCwgZSBhcyBlYXNpbmdzLCBqIGFzIGdldENvcnJlY3Rpb25SYXRpbywgYSBhcyBnZXRNYXRyaXhJbXBhY3QsIGQgYXMgZ2V0UGl4ZWxSYXRpbywgZyBhcyBncmFwaEV4dGVudCwgaSBhcyBpZGVudGl0eSwgbCBhcyBsaW5lYXIsIG0gYXMgbWF0cml4RnJvbUNhbWVyYSwgdyBhcyBtdWx0aXBseSwgZiBhcyBtdWx0aXBseVZlYzIsIHEgYXMgcXVhZHJhdGljSW4sIG4gYXMgcXVhZHJhdGljSW5PdXQsIGsgYXMgcXVhZHJhdGljT3V0LCB0IGFzIHJvdGF0ZSwgcyBhcyBzY2FsZSwgdSBhcyB0cmFuc2xhdGUsIHYgYXMgdmFsaWRhdGVHcmFwaCwgeiBhcyB6SW5kZXhPcmRlcmluZyB9IGZyb20gJy4uLy4uL2Rpc3Qvbm9ybWFsaXphdGlvbi1iZTQ0NTUxOC5lc20uanMnO1xuZXhwb3J0IHsgSCBhcyBIVE1MX0NPTE9SUywgZCBhcyBjb2xvclRvQXJyYXksIGMgYXMgY29sb3JUb0luZGV4LCBlIGFzIGV4dHJhY3RQaXhlbCwgZiBhcyBmbG9hdENvbG9yLCBnIGFzIGdldFBpeGVsQ29sb3IsIGkgYXMgaW5kZXhUb0NvbG9yLCBwIGFzIHBhcnNlQ29sb3IsIHIgYXMgcmdiYVRvRmxvYXQgfSBmcm9tICcuLi8uLi9kaXN0L2NvbG9ycy1iZWIwNmViMi5lc20uanMnO1xuZXhwb3J0IHsgYSBhcyBhc3NpZ24sIGIgYXMgYXNzaWduRGVlcCwgZSBhcyBleHRlbmQsIGkgYXMgaXNQbGFpbk9iamVjdCB9IGZyb20gJy4uLy4uL2Rpc3QvZGF0YS0xMWRmNzEyNC5lc20uanMnO1xuaW1wb3J0ICdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJztcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gKG1vZHVsZSkgPT4ge1xuXHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cblx0XHQoKSA9PiAobW9kdWxlWydkZWZhdWx0J10pIDpcblx0XHQoKSA9PiAobW9kdWxlKTtcblx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG5cdHJldHVybiBnZXR0ZXI7XG59OyIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgU2lnbWEgZnJvbSAnc2lnbWEnO1xyXG5pbXBvcnQgZ3JhcGhvbG9neSBmcm9tICdncmFwaG9sb2d5JztcclxuaW1wb3J0IFBhcGEgZnJvbSAncGFwYXBhcnNlJztcclxuaW1wb3J0IEVkZ2VDdXJ2ZVByb2dyYW0gZnJvbSBcIkBzaWdtYS9lZGdlLWN1cnZlXCI7XHJcbmltcG9ydCBGb3JjZVN1cGVydmlzb3IgZnJvbSBcImdyYXBob2xvZ3ktbGF5b3V0LWZvcmNlL3dvcmtlclwiO1xyXG5cclxuXHJcbndpbmRvdy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJIZWxsb1wiKTtcclxuXHJcbiAgICAvLyBSZXRyaWV2ZSBzb21lIHVzZWZ1bCBET00gZWxlbWVudHM6XHJcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInNpZ21hLWNvbnRhaW5lclwiKTtcclxuICAgIFxyXG4gICAgLy8gSW5pdGlhbGl6ZSB0aGUgZ3JhcGggaW5zdGFuY2VcclxuICAgIGNvbnN0IGdyYXBoID0gbmV3IGdyYXBob2xvZ3kuR3JhcGgoKTtcclxuXHJcbiAgICAvLyBUeXBlIGFuZCBkZWNsYXJlIGludGVybmFsIHN0YXRlOlxyXG4gICAgLyoqXHJcbiAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTdGF0ZVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSBob3ZlcmVkTm9kZVxyXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmc9fSBzZWxlY3RlZE5vZGVcclxuICAgICAqIEBwcm9wZXJ0eSB7U2V0PHN0cmluZz49fSBzdWdnZXN0aW9uc1xyXG4gICAgICogQHByb3BlcnR5IHtTZXQ8c3RyaW5nPj19IGhvdmVyZWROZWlnaGJvcnNcclxuICAgICAqL1xyXG4gICAgLyoqIEB0eXBlIHtTdGF0ZX0gKi9cclxuICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgbGV0IHJvd1NpemUgPSB7fTtcclxuXHJcbiAgICB2YXIgcmVzdWx0cyA9IFBhcGEucGFyc2UoXCIuL2pvbl9zYW1wbGVfZGF0YS5jc3ZcIiwge1xyXG4gICAgICAgIGRvd25sb2FkOiB0cnVlLFxyXG4gICAgICAgIGhlYWRlcjogdHJ1ZSxcclxuICAgICAgICBza2lwRW1wdHlMaW5lczogdHJ1ZSxcclxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKHJlc3VsdHMpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJDU1YgRGF0YSBQYXJzZWQ6XCIsIHJlc3VsdHMuZGF0YSk7XHJcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHBhcnNlZCBkYXRhIGhlcmVcclxuICAgICAgICAgICAgLy8gRm9yIGV4YW1wbGUsIHlvdSBjYW4gY3JlYXRlIG5vZGVzIGFuZCBlZGdlcyBiYXNlZCBvbiB0aGUgQ1NWIGRhdGFcclxuICAgICAgICAgICAgY29uc3QgZ3JhcGggPSBuZXcgZ3JhcGhvbG9neS5HcmFwaCgpO1xyXG5cclxuICAgICAgICAgICAgLy8gUHJlcHJvY2VzcyBub2RlcyBhbmQgZWRnZXMgZnJvbSB0aGUgQ1NWIGRhdGE6XHJcbiAgICAgICAgICAgIC8vIE1ha2UgdGhlIG5vZGVzIGJpZ2dlciBiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGVkZ2VzXHJcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVRhcmdldENvdW50ID0ge307XHJcbiAgICAgICAgICAgIHJlc3VsdHMuZGF0YS5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAocm93LnNvdXJjZSAmJiByb3cudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VUYXJnZXRDb3VudFtyb3cuc291cmNlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VUYXJnZXRDb3VudFtyb3cuc291cmNlXSA9IDEwO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VUYXJnZXRDb3VudFtyb3cuc291cmNlXSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIHJlc3VsdHMuZGF0YS5mb3JFYWNoKHJvdyA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWdyYXBoLmhhc05vZGUocm93LnNvdXJjZSkpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguYWRkTm9kZShyb3cuc291cmNlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiByb3cuc291cmNlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBNYXRoLnJhbmRvbSgpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplOiBzb3VyY2VUYXJnZXRDb3VudFtyb3cuc291cmNlXSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3I6IFwiYmx1ZVwiXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgcmVzdWx0cy5kYXRhLmZvckVhY2gocm93ID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChyb3cuc291cmNlICYmIHJvdy50YXJnZXQgJiYgZ3JhcGguaGFzTm9kZSAocm93LnNvdXJjZSkgJiYgZ3JhcGguaGFzTm9kZShyb3cudGFyZ2V0KSAmJiAhZ3JhcGguaGFzRWRnZShyb3cuc291cmNlLCByb3cudGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLmFkZEVkZ2Uocm93LnNvdXJjZSwgcm93LnRhcmdldCwgeyBcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogMiwgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsOiByb3cubGFiZWwsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnZlZDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yY2VMYWJlbDogdHJ1ZVxyXG4gICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgc3ByaW5nIGxheW91dCBhbmQgc3RhcnQgaXRcclxuICAgICAgICAgICAgY29uc3QgbGF5b3V0ID0gbmV3IEZvcmNlU3VwZXJ2aXNvcihncmFwaCwgeyBcclxuICAgICAgICAgICAgICAgIGlzTm9kZUZpeGVkOiAoXywgYXR0cikgPT4gYXR0ci5oaWdobGlnaHRlZCxcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWRnZVdlaWdodEluZmx1ZW5jZTogMC41LFxyXG4gICAgICAgICAgICAgICAgICAgIG1heEl0ZXJhdGlvbnM6IDUwLFxyXG4gICAgICAgICAgICAgICAgICAgIGF0dHJhY3Rpb246IDAuMDAwMDEsXHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgbGF5b3V0LnN0YXJ0KCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJbnN0YW50aWF0ZSBzaWdtYTpcclxuICAgICAgICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgU2lnbWEoZ3JhcGgsIGNvbnRhaW5lciwge1xyXG4gICAgICAgICAgICAgICAgYWxsb3dJbnZhbGlkQ29udGFpbmVyOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyRWRnZUxhYmVsczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGRlZmF1bHRFZGdlVHlwZTogXCJjdXJ2ZVwiLFxyXG4gICAgICAgICAgICAgICAgZWRnZVByb2dyYW1DbGFzc2VzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VydmU6IEVkZ2VDdXJ2ZVByb2dyYW1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gU3RhdGUgZm9yIGRyYWcnbidkcm9wXHJcbiAgICAgICAgICAgIGxldCBkcmFnZ2VkTm9kZSA9IG51bGw7XHJcbiAgICAgICAgICAgIGxldCBpc0RyYWdnaW5nID0gZmFsc2U7XHJcblxyXG4gICAgICAgICAgICAvLyBCaW5kIGdyYXBoIGludGVyYWN0aW9uczpcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJlbnRlck5vZGVcIiwgKHsgbm9kZSB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaXNEcmFnZ2luZykgcmV0dXJuOyAvLyBJZ25vcmUgaWYgZHJhZ2dpbmdcclxuICAgICAgICAgICAgICAgIHNldEhvdmVyZWROb2RlKG5vZGUpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJsZWF2ZU5vZGVcIiwgKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHJldHVybjsgLy8gSWdub3JlIGlmIGRyYWdnaW5nXHJcbiAgICAgICAgICAgICAgICBzZXRIb3ZlcmVkTm9kZSh1bmRlZmluZWQpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIFJlbmRlciBub2RlcyBhY2NvcmRpbmdseSB0byB0aGUgaW50ZXJuYWwgc3RhdGU6XHJcbiAgICAgICAgICAgIC8vIDEuIElmIGEgbm9kZSBpcyBzZWxlY3RlZCwgaXQgaXMgaGlnaGxpZ2h0ZWRcclxuICAgICAgICAgICAgLy8gMi4gSWYgdGhlcmUgaXMgcXVlcnksIGFsbCBub24tbWF0Y2hpbmcgbm9kZXMgYXJlIGdyZXllZFxyXG4gICAgICAgICAgICAvLyAzLiBJZiB0aGVyZSBpcyBhIGhvdmVyZWQgbm9kZSwgYWxsIG5vbi1uZWlnaGJvciBub2RlcyBhcmUgZ3JleWVkXHJcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNldHRpbmcoXCJub2RlUmVkdWNlclwiLCAobm9kZSwgZGF0YSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0geyAuLi5kYXRhIH07XHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmICghZ3JhcGguaGFzTm9kZShub2RlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGhpZGRlbjogdHJ1ZSB9O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmhvdmVyZWROZWlnaGJvcnMgJiYgIXN0YXRlLmhvdmVyZWROZWlnaGJvcnMuaGFzKG5vZGUpICYmIHN0YXRlLmhvdmVyZWROb2RlICE9PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmxhYmVsID0gXCJcIjtcclxuICAgICAgICAgICAgICAgICAgICByZXMuY29sb3IgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc2VsZWN0ZWROb2RlID09PSBub2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmhpZ2hsaWdodGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdGUuc3VnZ2VzdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdGUuc3VnZ2VzdGlvbnMuaGFzKG5vZGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5mb3JjZUxhYmVsID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMubGFiZWwgPSBcIlwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuY29sb3IgPSBcIiNmNmY2ZjZcIjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBSZW5kZXIgZWRnZXMgYWNjb3JkaW5nbHkgdG8gdGhlIGludGVybmFsIHN0YXRlOlxyXG4gICAgICAgICAgICAvLyAxLiBJZiBhIG5vZGUgaXMgaG92ZXJlZCwgdGhlIGVkZ2UgaXMgaGlkZGVuIGlmIGl0IGlzIG5vdCBjb25uZWN0ZWQgdG8gdGhlXHJcbiAgICAgICAgICAgIC8vICAgIG5vZGVcclxuICAgICAgICAgICAgLy8gMi4gSWYgdGhlcmUgaXMgYSBxdWVyeSwgdGhlIGVkZ2UgaXMgb25seSB2aXNpYmxlIGlmIGl0IGNvbm5lY3RzIHR3b1xyXG4gICAgICAgICAgICAvLyAgICBzdWdnZXN0aW9uc1xyXG4gICAgICAgICAgICByZW5kZXJlci5zZXRTZXR0aW5nKFwiZWRnZVJlZHVjZXJcIiwgKGVkZ2UsIGRhdGEpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IHsgLi4uZGF0YSB9O1xyXG5cclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlcmVkTm9kZSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFncmFwaC5leHRyZW1pdGllcyhlZGdlKS5ldmVyeSgobikgPT4gbiA9PT0gc3RhdGUuaG92ZXJlZE5vZGUgfHwgZ3JhcGguYXJlTmVpZ2hib3JzKG4sIHN0YXRlLmhvdmVyZWROb2RlKSlcclxuICAgICAgICAgICAgICAgICkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlcy5oaWRkZW4gPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zdWdnZXN0aW9ucyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICghc3RhdGUuc3VnZ2VzdGlvbnMuaGFzKGdyYXBoLnNvdXJjZShlZGdlKSkgfHwgIXN0YXRlLnN1Z2dlc3Rpb25zLmhhcyhncmFwaC50YXJnZXQoZWRnZSkpKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzLmhpZGRlbiA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICByZW5kZXJlci5vbihcImNsaWNrTm9kZVwiLCAoeyBub2RlIH0pID0+IHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBub2RlIGF0dHJpYnV0ZXNcclxuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhub2RlKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBzdW1tYXJ5IEhUTUwgKGN1c3RvbWl6ZSBhcyBuZWVkZWQpXHJcbiAgICAgICAgICAgICAgICBjb25zdCBodG1sID0gYFxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Tm9kZTo8L3N0cm9uZz4gJHtub2RlfTxicj5cclxuICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPkxhYmVsOjwvc3Ryb25nPiAke2RhdGEubGFiZWx9PGJyPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+U2l6ZTo8L3N0cm9uZz4gJHtkYXRhLnNpemV9PGJyPlxyXG4gICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+Q29sb3I6PC9zdHJvbmc+ICR7ZGF0YS5jb2xvcn1cclxuICAgICAgICAgICAgICAgIGA7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhbmQgdXBkYXRlIHRoZSBwYW5lbFxyXG4gICAgICAgICAgICAgICAgY29uc3QgcGFuZWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImluZm8tcGFuZWxcIik7XHJcbiAgICAgICAgICAgICAgICBwYW5lbC5pbm5lckhUTUwgPSBodG1sO1xyXG4gICAgICAgICAgICAgICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICAvLyBPcHRpb25hbDogSGlkZSB0aGUgcGFuZWwgd2hlbiBjbGlja2luZyBlbHNld2hlcmVcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJjbGlja1N0YWdlXCIsICgpID0+IHtcclxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiaW5mby1wYW5lbFwiKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgICAvL1xyXG4gICAgICAgICAgICAvLyBEcmFnJ24nZHJvcCBmZWF0dXJlXHJcbiAgICAgICAgICAgIC8vIH5+fn5+fn5+fn5+fn5+fn5+fn5cclxuICAgICAgICAgICAgLy9cclxuXHJcbiAgICAgICAgICAgIC8vIE9uIG1vdXNlIGRvd24gb24gYSBub2RlXHJcbiAgICAgICAgICAgIC8vICAtIHdlIGVuYWJsZSB0aGUgZHJhZyBtb2RlXHJcbiAgICAgICAgICAgIC8vICAtIHNhdmUgaW4gdGhlIGRyYWdnZWQgbm9kZSBpbiB0aGUgc3RhdGVcclxuICAgICAgICAgICAgLy8gIC0gaGlnaGxpZ2h0IHRoZSBub2RlXHJcbiAgICAgICAgICAgIC8vICAtIGRpc2FibGUgdGhlIGNhbWVyYSBzbyBpdHMgc3RhdGUgaXMgbm90IHVwZGF0ZWRcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJkb3duTm9kZVwiLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaXNEcmFnZ2luZyA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICBkcmFnZ2VkTm9kZSA9IGUubm9kZTtcclxuICAgICAgICAgICAgICAgIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUoZHJhZ2dlZE5vZGUsIFwiaGlnaGxpZ2h0ZWRcIiwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXJlbmRlcmVyLmdldEN1c3RvbUJCb3goKSkgcmVuZGVyZXIuc2V0Q3VzdG9tQkJveChyZW5kZXJlci5nZXRCQm94KCkpO1xyXG4gICAgICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgICAgIC8vIE9uIG1vdXNlIG1vdmUsIGlmIHRoZSBkcmFnIG1vZGUgaXMgZW5hYmxlZCwgd2UgY2hhbmdlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZE5vZGVcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJtb3ZlQm9keVwiLCAoeyBldmVudCB9KSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRHJhZ2dpbmcgfHwgIWRyYWdnZWROb2RlKSByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gR2V0IG5ldyBwb3NpdGlvbiBvZiBub2RlXHJcbiAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSByZW5kZXJlci52aWV3cG9ydFRvR3JhcGgoZXZlbnQpO1xyXG5cclxuICAgICAgICAgICAgICAgIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUoZHJhZ2dlZE5vZGUsIFwieFwiLCBwb3MueCk7XHJcbiAgICAgICAgICAgICAgICBncmFwaC5zZXROb2RlQXR0cmlidXRlKGRyYWdnZWROb2RlLCBcInlcIiwgcG9zLnkpO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgc2lnbWEgdG8gbW92ZSBjYW1lcmE6XHJcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XHJcbiAgICAgICAgICAgICAgICBldmVudC5vcmlnaW5hbC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICAgICAgZXZlbnQub3JpZ2luYWwuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgICAgLy8gT24gbW91c2UgdXAsIHdlIHJlc2V0IHRoZSBkcmFnZ2luZyBtb2RlXHJcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZVVwID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgaWYgKGRyYWdnZWROb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGgucmVtb3ZlTm9kZUF0dHJpYnV0ZShkcmFnZ2VkTm9kZSwgXCJoaWdobGlnaHRlZFwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIGRyYWdnZWROb2RlID0gbnVsbDtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmVuZGVyZXIub24oXCJ1cE5vZGVcIiwgaGFuZGxlVXApO1xyXG4gICAgICAgICAgICByZW5kZXJlci5vbihcInVwU3RhZ2VcIiwgaGFuZGxlVXApO1xyXG5cclxuICAgICAgICAgICAgZnVuY3Rpb24gc2V0SG92ZXJlZE5vZGUobm9kZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlcmVkTm9kZSA9IG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaG92ZXJlZE5laWdoYm9ycyA9IG5ldyBTZXQoZ3JhcGgubmVpZ2hib3JzKG5vZGUpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlcmVkTm9kZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5ob3ZlcmVkTmVpZ2hib3JzID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIC8vIFJlZnJlc2ggcmVuZGVyaW5nXHJcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZWZyZXNoKHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB0b3VjaCB0aGUgZ3JhcGggZGF0YSBzbyB3ZSBjYW4gc2tpcCBpdHMgcmVpbmRleGF0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcEluZGV4YXRpb246IHRydWUsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChlcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgcGFyc2luZyBDU1Y6XCIsIGVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxuXHJcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9